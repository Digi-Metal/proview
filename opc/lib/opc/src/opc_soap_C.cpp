/* opc_soap_C.cpp
   Generated by gSOAP 2.7.9d from opc_msg.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "opc_soap_H.h"

SOAP_SOURCE_STAMP("@(#) opc_soap_C.cpp ver 2.7.9d 2007-02-26 14:18:39 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__browseFilter:
		return soap_in_ns1__browseFilter(soap, NULL, NULL, "ns1:browseFilter");
	case SOAP_TYPE_ns1__limitBits:
		return soap_in_ns1__limitBits(soap, NULL, NULL, "ns1:limitBits");
	case SOAP_TYPE_ns1__qualityBits:
		return soap_in_ns1__qualityBits(soap, NULL, NULL, "ns1:qualityBits");
	case SOAP_TYPE_ns1__interfaceVersion:
		return soap_in_ns1__interfaceVersion(soap, NULL, NULL, "ns1:interfaceVersion");
	case SOAP_TYPE_ns1__serverState:
		return soap_in_ns1__serverState(soap, NULL, NULL, "ns1:serverState");
	case SOAP_TYPE_ns1__PropertyReplyList:
		return soap_in_ns1__PropertyReplyList(soap, NULL, NULL, "ns1:PropertyReplyList");
	case SOAP_TYPE_ns1__ItemIdentifier:
		return soap_in_ns1__ItemIdentifier(soap, NULL, NULL, "ns1:ItemIdentifier");
	case SOAP_TYPE_ns1__ItemProperty:
		return soap_in_ns1__ItemProperty(soap, NULL, NULL, "ns1:ItemProperty");
	case SOAP_TYPE_ns1__BrowseElement:
		return soap_in_ns1__BrowseElement(soap, NULL, NULL, "ns1:BrowseElement");
	case SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList:
		return soap_in_ns1__SubscribePolledRefreshReplyItemList(soap, NULL, NULL, "ns1:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_ns1__SubscribeItemValue:
		return soap_in_ns1__SubscribeItemValue(soap, NULL, NULL, "ns1:SubscribeItemValue");
	case SOAP_TYPE_ns1__SubscribeReplyItemList:
		return soap_in_ns1__SubscribeReplyItemList(soap, NULL, NULL, "ns1:SubscribeReplyItemList");
	case SOAP_TYPE_ns1__SubscribeRequestItem:
		return soap_in_ns1__SubscribeRequestItem(soap, NULL, NULL, "ns1:SubscribeRequestItem");
	case SOAP_TYPE_ns1__SubscribeRequestItemList:
		return soap_in_ns1__SubscribeRequestItemList(soap, NULL, NULL, "ns1:SubscribeRequestItemList");
	case SOAP_TYPE_ns1__WriteRequestItemList:
		return soap_in_ns1__WriteRequestItemList(soap, NULL, NULL, "ns1:WriteRequestItemList");
	case SOAP_TYPE_ns1__ArrayOfShort:
		return soap_in_ns1__ArrayOfShort(soap, NULL, NULL, "ns1:ArrayOfShort");
	case SOAP_TYPE_ns1__ArrayOfByte:
		return soap_in_ns1__ArrayOfByte(soap, NULL, NULL, "ns1:ArrayOfByte");
	case SOAP_TYPE_ns1__ArrayOfDecimal:
		return soap_in_ns1__ArrayOfDecimal(soap, NULL, NULL, "ns1:ArrayOfDecimal");
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		return soap_in_ns1__ArrayOfAnyType(soap, NULL, NULL, "ns1:ArrayOfAnyType");
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		return soap_in_ns1__ArrayOfDateTime(soap, NULL, NULL, "ns1:ArrayOfDateTime");
	case SOAP_TYPE_ns1__ArrayOfString:
		return soap_in_ns1__ArrayOfString(soap, NULL, NULL, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__ArrayOfBoolean:
		return soap_in_ns1__ArrayOfBoolean(soap, NULL, NULL, "ns1:ArrayOfBoolean");
	case SOAP_TYPE_ns1__ArrayOfUnsignedShort:
		return soap_in_ns1__ArrayOfUnsignedShort(soap, NULL, NULL, "ns1:ArrayOfUnsignedShort");
	case SOAP_TYPE_ns1__ArrayOfDouble:
		return soap_in_ns1__ArrayOfDouble(soap, NULL, NULL, "ns1:ArrayOfDouble");
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		return soap_in_ns1__ArrayOfUnsignedLong(soap, NULL, NULL, "ns1:ArrayOfUnsignedLong");
	case SOAP_TYPE_ns1__ArrayOfLong:
		return soap_in_ns1__ArrayOfLong(soap, NULL, NULL, "ns1:ArrayOfLong");
	case SOAP_TYPE_ns1__ArrayOfUnsignedInt:
		return soap_in_ns1__ArrayOfUnsignedInt(soap, NULL, NULL, "ns1:ArrayOfUnsignedInt");
	case SOAP_TYPE_ns1__ArrayOfInt:
		return soap_in_ns1__ArrayOfInt(soap, NULL, NULL, "ns1:ArrayOfInt");
	case SOAP_TYPE_ns1__ArrayOfFloat:
		return soap_in_ns1__ArrayOfFloat(soap, NULL, NULL, "ns1:ArrayOfFloat");
	case SOAP_TYPE_ns1__OPCError:
		return soap_in_ns1__OPCError(soap, NULL, NULL, "ns1:OPCError");
	case SOAP_TYPE_ns1__OPCQuality:
		return soap_in_ns1__OPCQuality(soap, NULL, NULL, "ns1:OPCQuality");
	case SOAP_TYPE_ns1__ItemValue:
		return soap_in_ns1__ItemValue(soap, NULL, NULL, "ns1:ItemValue");
	case SOAP_TYPE_ns1__ReplyItemList:
		return soap_in_ns1__ReplyItemList(soap, NULL, NULL, "ns1:ReplyItemList");
	case SOAP_TYPE_ns1__ReadRequestItem:
		return soap_in_ns1__ReadRequestItem(soap, NULL, NULL, "ns1:ReadRequestItem");
	case SOAP_TYPE_ns1__ReadRequestItemList:
		return soap_in_ns1__ReadRequestItemList(soap, NULL, NULL, "ns1:ReadRequestItemList");
	case SOAP_TYPE_ns1__RequestOptions:
		return soap_in_ns1__RequestOptions(soap, NULL, NULL, "ns1:RequestOptions");
	case SOAP_TYPE_ns1__ServerStatus:
		return soap_in_ns1__ServerStatus(soap, NULL, NULL, "ns1:ServerStatus");
	case SOAP_TYPE_ns1__ReplyBase:
		return soap_in_ns1__ReplyBase(soap, NULL, NULL, "ns1:ReplyBase");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__GetPropertiesResponse:
		return soap_in_PointerTo_ns1__GetPropertiesResponse(soap, NULL, NULL, "ns1:GetPropertiesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProperties:
		return soap_in_PointerTo_ns1__GetProperties(soap, NULL, NULL, "ns1:GetProperties");
	case SOAP_TYPE_PointerTo_ns1__BrowseResponse:
		return soap_in_PointerTo_ns1__BrowseResponse(soap, NULL, NULL, "ns1:BrowseResponse");
	case SOAP_TYPE_PointerTo_ns1__Browse:
		return soap_in_PointerTo_ns1__Browse(soap, NULL, NULL, "ns1:Browse");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionCancelResponse:
		return soap_in_PointerTo_ns1__SubscriptionCancelResponse(soap, NULL, NULL, "ns1:SubscriptionCancelResponse");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionCancel:
		return soap_in_PointerTo_ns1__SubscriptionCancel(soap, NULL, NULL, "ns1:SubscriptionCancel");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefreshResponse:
		return soap_in_PointerTo_ns1__SubscriptionPolledRefreshResponse(soap, NULL, NULL, "ns1:SubscriptionPolledRefreshResponse");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefresh:
		return soap_in_PointerTo_ns1__SubscriptionPolledRefresh(soap, NULL, NULL, "ns1:SubscriptionPolledRefresh");
	case SOAP_TYPE_PointerTo_ns1__SubscribeResponse:
		return soap_in_PointerTo_ns1__SubscribeResponse(soap, NULL, NULL, "ns1:SubscribeResponse");
	case SOAP_TYPE_PointerTo_ns1__Subscribe:
		return soap_in_PointerTo_ns1__Subscribe(soap, NULL, NULL, "ns1:Subscribe");
	case SOAP_TYPE_PointerTo_ns1__WriteResponse:
		return soap_in_PointerTo_ns1__WriteResponse(soap, NULL, NULL, "ns1:WriteResponse");
	case SOAP_TYPE_PointerTo_ns1__Write:
		return soap_in_PointerTo_ns1__Write(soap, NULL, NULL, "ns1:Write");
	case SOAP_TYPE_PointerTo_ns1__ReadResponse:
		return soap_in_PointerTo_ns1__ReadResponse(soap, NULL, NULL, "ns1:ReadResponse");
	case SOAP_TYPE_PointerTo_ns1__Read:
		return soap_in_PointerTo_ns1__Read(soap, NULL, NULL, "ns1:Read");
	case SOAP_TYPE_PointerTo_ns1__GetStatusResponse:
		return soap_in_PointerTo_ns1__GetStatusResponse(soap, NULL, NULL, "ns1:GetStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStatus:
		return soap_in_PointerTo_ns1__GetStatus(soap, NULL, NULL, "ns1:GetStatus");
	case SOAP_TYPE_PointerTons1__PropertyReplyList:
		return soap_in_PointerTons1__PropertyReplyList(soap, NULL, NULL, "ns1:PropertyReplyList");
	case SOAP_TYPE_PointerTons1__ItemIdentifier:
		return soap_in_PointerTons1__ItemIdentifier(soap, NULL, NULL, "ns1:ItemIdentifier");
	case SOAP_TYPE_PointerTons1__BrowseElement:
		return soap_in_PointerTons1__BrowseElement(soap, NULL, NULL, "ns1:BrowseElement");
	case SOAP_TYPE_PointerTons1__browseFilter:
		return soap_in_PointerTons1__browseFilter(soap, NULL, NULL, "ns1:browseFilter");
	case SOAP_TYPE_PointerTons1__SubscribePolledRefreshReplyItemList:
		return soap_in_PointerTons1__SubscribePolledRefreshReplyItemList(soap, NULL, NULL, "ns1:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_PointerTons1__SubscribeReplyItemList:
		return soap_in_PointerTons1__SubscribeReplyItemList(soap, NULL, NULL, "ns1:SubscribeReplyItemList");
	case SOAP_TYPE_PointerTons1__SubscribeRequestItemList:
		return soap_in_PointerTons1__SubscribeRequestItemList(soap, NULL, NULL, "ns1:SubscribeRequestItemList");
	case SOAP_TYPE_PointerTons1__WriteRequestItemList:
		return soap_in_PointerTons1__WriteRequestItemList(soap, NULL, NULL, "ns1:WriteRequestItemList");
	case SOAP_TYPE_PointerTons1__OPCError:
		return soap_in_PointerTons1__OPCError(soap, NULL, NULL, "ns1:OPCError");
	case SOAP_TYPE_PointerTons1__ReplyItemList:
		return soap_in_PointerTons1__ReplyItemList(soap, NULL, NULL, "ns1:ReplyItemList");
	case SOAP_TYPE_PointerTons1__ReadRequestItemList:
		return soap_in_PointerTons1__ReadRequestItemList(soap, NULL, NULL, "ns1:ReadRequestItemList");
	case SOAP_TYPE_PointerTons1__RequestOptions:
		return soap_in_PointerTons1__RequestOptions(soap, NULL, NULL, "ns1:RequestOptions");
	case SOAP_TYPE_PointerTons1__ServerStatus:
		return soap_in_PointerTons1__ServerStatus(soap, NULL, NULL, "ns1:ServerStatus");
	case SOAP_TYPE_PointerTons1__ReplyBase:
		return soap_in_PointerTons1__ReplyBase(soap, NULL, NULL, "ns1:ReplyBase");
	case SOAP_TYPE_PointerTons1__ItemProperty:
		return soap_in_PointerTons1__ItemProperty(soap, NULL, NULL, "ns1:ItemProperty");
	case SOAP_TYPE_PointerTons1__SubscribeItemValue:
		return soap_in_PointerTons1__SubscribeItemValue(soap, NULL, NULL, "ns1:SubscribeItemValue");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerTons1__SubscribeRequestItem:
		return soap_in_PointerTons1__SubscribeRequestItem(soap, NULL, NULL, "ns1:SubscribeRequestItem");
	case SOAP_TYPE_PointerTounsignedShort:
		return soap_in_PointerTounsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_PointerTons1__limitBits:
		return soap_in_PointerTons1__limitBits(soap, NULL, NULL, "ns1:limitBits");
	case SOAP_TYPE_PointerTons1__qualityBits:
		return soap_in_PointerTons1__qualityBits(soap, NULL, NULL, "ns1:qualityBits");
	case SOAP_TYPE_PointerTons1__OPCQuality:
		return soap_in_PointerTons1__OPCQuality(soap, NULL, NULL, "ns1:OPCQuality");
	case SOAP_TYPE_PointerTons1__ItemValue:
		return soap_in_PointerTons1__ItemValue(soap, NULL, NULL, "ns1:ItemValue");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTons1__ReadRequestItem:
		return soap_in_PointerTons1__ReadRequestItem(soap, NULL, NULL, "ns1:ReadRequestItem");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:browseFilter"))
		{	*type = SOAP_TYPE_ns1__browseFilter;
			return soap_in_ns1__browseFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:limitBits"))
		{	*type = SOAP_TYPE_ns1__limitBits;
			return soap_in_ns1__limitBits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:qualityBits"))
		{	*type = SOAP_TYPE_ns1__qualityBits;
			return soap_in_ns1__qualityBits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:interfaceVersion"))
		{	*type = SOAP_TYPE_ns1__interfaceVersion;
			return soap_in_ns1__interfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:serverState"))
		{	*type = SOAP_TYPE_ns1__serverState;
			return soap_in_ns1__serverState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PropertyReplyList"))
		{	*type = SOAP_TYPE_ns1__PropertyReplyList;
			return soap_in_ns1__PropertyReplyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemIdentifier"))
		{	*type = SOAP_TYPE_ns1__ItemIdentifier;
			return soap_in_ns1__ItemIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemProperty"))
		{	*type = SOAP_TYPE_ns1__ItemProperty;
			return soap_in_ns1__ItemProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BrowseElement"))
		{	*type = SOAP_TYPE_ns1__BrowseElement;
			return soap_in_ns1__BrowseElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribePolledRefreshReplyItemList"))
		{	*type = SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList;
			return soap_in_ns1__SubscribePolledRefreshReplyItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeItemValue"))
		{	*type = SOAP_TYPE_ns1__SubscribeItemValue;
			return soap_in_ns1__SubscribeItemValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeReplyItemList"))
		{	*type = SOAP_TYPE_ns1__SubscribeReplyItemList;
			return soap_in_ns1__SubscribeReplyItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeRequestItem"))
		{	*type = SOAP_TYPE_ns1__SubscribeRequestItem;
			return soap_in_ns1__SubscribeRequestItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeRequestItemList"))
		{	*type = SOAP_TYPE_ns1__SubscribeRequestItemList;
			return soap_in_ns1__SubscribeRequestItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteRequestItemList"))
		{	*type = SOAP_TYPE_ns1__WriteRequestItemList;
			return soap_in_ns1__WriteRequestItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfShort"))
		{	*type = SOAP_TYPE_ns1__ArrayOfShort;
			return soap_in_ns1__ArrayOfShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfByte"))
		{	*type = SOAP_TYPE_ns1__ArrayOfByte;
			return soap_in_ns1__ArrayOfByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDecimal"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDecimal;
			return soap_in_ns1__ArrayOfDecimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfAnyType"))
		{	*type = SOAP_TYPE_ns1__ArrayOfAnyType;
			return soap_in_ns1__ArrayOfAnyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDateTime"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDateTime;
			return soap_in_ns1__ArrayOfDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfString"))
		{	*type = SOAP_TYPE_ns1__ArrayOfString;
			return soap_in_ns1__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfBoolean"))
		{	*type = SOAP_TYPE_ns1__ArrayOfBoolean;
			return soap_in_ns1__ArrayOfBoolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfUnsignedShort"))
		{	*type = SOAP_TYPE_ns1__ArrayOfUnsignedShort;
			return soap_in_ns1__ArrayOfUnsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfDouble"))
		{	*type = SOAP_TYPE_ns1__ArrayOfDouble;
			return soap_in_ns1__ArrayOfDouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfUnsignedLong"))
		{	*type = SOAP_TYPE_ns1__ArrayOfUnsignedLong;
			return soap_in_ns1__ArrayOfUnsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfLong"))
		{	*type = SOAP_TYPE_ns1__ArrayOfLong;
			return soap_in_ns1__ArrayOfLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfUnsignedInt"))
		{	*type = SOAP_TYPE_ns1__ArrayOfUnsignedInt;
			return soap_in_ns1__ArrayOfUnsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfInt"))
		{	*type = SOAP_TYPE_ns1__ArrayOfInt;
			return soap_in_ns1__ArrayOfInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfFloat"))
		{	*type = SOAP_TYPE_ns1__ArrayOfFloat;
			return soap_in_ns1__ArrayOfFloat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OPCError"))
		{	*type = SOAP_TYPE_ns1__OPCError;
			return soap_in_ns1__OPCError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OPCQuality"))
		{	*type = SOAP_TYPE_ns1__OPCQuality;
			return soap_in_ns1__OPCQuality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ItemValue"))
		{	*type = SOAP_TYPE_ns1__ItemValue;
			return soap_in_ns1__ItemValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReplyItemList"))
		{	*type = SOAP_TYPE_ns1__ReplyItemList;
			return soap_in_ns1__ReplyItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReadRequestItem"))
		{	*type = SOAP_TYPE_ns1__ReadRequestItem;
			return soap_in_ns1__ReadRequestItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReadRequestItemList"))
		{	*type = SOAP_TYPE_ns1__ReadRequestItemList;
			return soap_in_ns1__ReadRequestItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RequestOptions"))
		{	*type = SOAP_TYPE_ns1__RequestOptions;
			return soap_in_ns1__RequestOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerStatus"))
		{	*type = SOAP_TYPE_ns1__ServerStatus;
			return soap_in_ns1__ServerStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReplyBase"))
		{	*type = SOAP_TYPE_ns1__ReplyBase;
			return soap_in_ns1__ReplyBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetPropertiesResponse"))
		{	*type = SOAP_TYPE__ns1__GetPropertiesResponse;
			return soap_in__ns1__GetPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetProperties"))
		{	*type = SOAP_TYPE__ns1__GetProperties;
			return soap_in__ns1__GetProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BrowseResponse"))
		{	*type = SOAP_TYPE__ns1__BrowseResponse;
			return soap_in__ns1__BrowseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Browse"))
		{	*type = SOAP_TYPE__ns1__Browse;
			return soap_in__ns1__Browse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscriptionCancelResponse"))
		{	*type = SOAP_TYPE__ns1__SubscriptionCancelResponse;
			return soap_in__ns1__SubscriptionCancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscriptionCancel"))
		{	*type = SOAP_TYPE__ns1__SubscriptionCancel;
			return soap_in__ns1__SubscriptionCancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscriptionPolledRefreshResponse"))
		{	*type = SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse;
			return soap_in__ns1__SubscriptionPolledRefreshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscriptionPolledRefresh"))
		{	*type = SOAP_TYPE__ns1__SubscriptionPolledRefresh;
			return soap_in__ns1__SubscriptionPolledRefresh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SubscribeResponse"))
		{	*type = SOAP_TYPE__ns1__SubscribeResponse;
			return soap_in__ns1__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Subscribe"))
		{	*type = SOAP_TYPE__ns1__Subscribe;
			return soap_in__ns1__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WriteResponse"))
		{	*type = SOAP_TYPE__ns1__WriteResponse;
			return soap_in__ns1__WriteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Write"))
		{	*type = SOAP_TYPE__ns1__Write;
			return soap_in__ns1__Write(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ReadResponse"))
		{	*type = SOAP_TYPE__ns1__ReadResponse;
			return soap_in__ns1__ReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Read"))
		{	*type = SOAP_TYPE__ns1__Read;
			return soap_in__ns1__Read(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStatusResponse"))
		{	*type = SOAP_TYPE__ns1__GetStatusResponse;
			return soap_in__ns1__GetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStatus"))
		{	*type = SOAP_TYPE__ns1__GetStatus;
			return soap_in__ns1__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__browseFilter:
		return soap_out_ns1__browseFilter(soap, tag, id, (const enum ns1__browseFilter *)ptr, "ns1:browseFilter");
	case SOAP_TYPE_ns1__limitBits:
		return soap_out_ns1__limitBits(soap, tag, id, (const enum ns1__limitBits *)ptr, "ns1:limitBits");
	case SOAP_TYPE_ns1__qualityBits:
		return soap_out_ns1__qualityBits(soap, tag, id, (const enum ns1__qualityBits *)ptr, "ns1:qualityBits");
	case SOAP_TYPE_ns1__interfaceVersion:
		return soap_out_ns1__interfaceVersion(soap, tag, id, (const enum ns1__interfaceVersion *)ptr, "ns1:interfaceVersion");
	case SOAP_TYPE_ns1__serverState:
		return soap_out_ns1__serverState(soap, tag, id, (const enum ns1__serverState *)ptr, "ns1:serverState");
	case SOAP_TYPE__ns1__GetPropertiesResponse:
		return ((_ns1__GetPropertiesResponse *)ptr)->soap_out(soap, "ns1:GetPropertiesResponse", id, NULL);
	case SOAP_TYPE__ns1__GetProperties:
		return ((_ns1__GetProperties *)ptr)->soap_out(soap, "ns1:GetProperties", id, NULL);
	case SOAP_TYPE__ns1__BrowseResponse:
		return ((_ns1__BrowseResponse *)ptr)->soap_out(soap, "ns1:BrowseResponse", id, NULL);
	case SOAP_TYPE__ns1__Browse:
		return ((_ns1__Browse *)ptr)->soap_out(soap, "ns1:Browse", id, NULL);
	case SOAP_TYPE__ns1__SubscriptionCancelResponse:
		return ((_ns1__SubscriptionCancelResponse *)ptr)->soap_out(soap, "ns1:SubscriptionCancelResponse", id, NULL);
	case SOAP_TYPE__ns1__SubscriptionCancel:
		return ((_ns1__SubscriptionCancel *)ptr)->soap_out(soap, "ns1:SubscriptionCancel", id, NULL);
	case SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse:
		return ((_ns1__SubscriptionPolledRefreshResponse *)ptr)->soap_out(soap, "ns1:SubscriptionPolledRefreshResponse", id, NULL);
	case SOAP_TYPE__ns1__SubscriptionPolledRefresh:
		return ((_ns1__SubscriptionPolledRefresh *)ptr)->soap_out(soap, "ns1:SubscriptionPolledRefresh", id, NULL);
	case SOAP_TYPE__ns1__SubscribeResponse:
		return ((_ns1__SubscribeResponse *)ptr)->soap_out(soap, "ns1:SubscribeResponse", id, NULL);
	case SOAP_TYPE__ns1__Subscribe:
		return ((_ns1__Subscribe *)ptr)->soap_out(soap, "ns1:Subscribe", id, NULL);
	case SOAP_TYPE__ns1__WriteResponse:
		return ((_ns1__WriteResponse *)ptr)->soap_out(soap, "ns1:WriteResponse", id, NULL);
	case SOAP_TYPE__ns1__Write:
		return ((_ns1__Write *)ptr)->soap_out(soap, "ns1:Write", id, NULL);
	case SOAP_TYPE__ns1__ReadResponse:
		return ((_ns1__ReadResponse *)ptr)->soap_out(soap, "ns1:ReadResponse", id, NULL);
	case SOAP_TYPE__ns1__Read:
		return ((_ns1__Read *)ptr)->soap_out(soap, "ns1:Read", id, NULL);
	case SOAP_TYPE__ns1__GetStatusResponse:
		return ((_ns1__GetStatusResponse *)ptr)->soap_out(soap, "ns1:GetStatusResponse", id, NULL);
	case SOAP_TYPE__ns1__GetStatus:
		return ((_ns1__GetStatus *)ptr)->soap_out(soap, "ns1:GetStatus", id, NULL);
	case SOAP_TYPE_ns1__PropertyReplyList:
		return ((ns1__PropertyReplyList *)ptr)->soap_out(soap, tag, id, "ns1:PropertyReplyList");
	case SOAP_TYPE_ns1__ItemIdentifier:
		return ((ns1__ItemIdentifier *)ptr)->soap_out(soap, tag, id, "ns1:ItemIdentifier");
	case SOAP_TYPE_ns1__ItemProperty:
		return ((ns1__ItemProperty *)ptr)->soap_out(soap, tag, id, "ns1:ItemProperty");
	case SOAP_TYPE_ns1__BrowseElement:
		return ((ns1__BrowseElement *)ptr)->soap_out(soap, tag, id, "ns1:BrowseElement");
	case SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList:
		return ((ns1__SubscribePolledRefreshReplyItemList *)ptr)->soap_out(soap, tag, id, "ns1:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_ns1__SubscribeItemValue:
		return ((ns1__SubscribeItemValue *)ptr)->soap_out(soap, tag, id, "ns1:SubscribeItemValue");
	case SOAP_TYPE_ns1__SubscribeReplyItemList:
		return ((ns1__SubscribeReplyItemList *)ptr)->soap_out(soap, tag, id, "ns1:SubscribeReplyItemList");
	case SOAP_TYPE_ns1__SubscribeRequestItem:
		return ((ns1__SubscribeRequestItem *)ptr)->soap_out(soap, tag, id, "ns1:SubscribeRequestItem");
	case SOAP_TYPE_ns1__SubscribeRequestItemList:
		return ((ns1__SubscribeRequestItemList *)ptr)->soap_out(soap, tag, id, "ns1:SubscribeRequestItemList");
	case SOAP_TYPE_ns1__WriteRequestItemList:
		return ((ns1__WriteRequestItemList *)ptr)->soap_out(soap, tag, id, "ns1:WriteRequestItemList");
	case SOAP_TYPE_ns1__ArrayOfShort:
		return ((ns1__ArrayOfShort *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfShort");
	case SOAP_TYPE_ns1__ArrayOfByte:
		return ((ns1__ArrayOfByte *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfByte");
	case SOAP_TYPE_ns1__ArrayOfDecimal:
		return ((ns1__ArrayOfDecimal *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDecimal");
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		return ((ns1__ArrayOfAnyType *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfAnyType");
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		return ((ns1__ArrayOfDateTime *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDateTime");
	case SOAP_TYPE_ns1__ArrayOfString:
		return ((ns1__ArrayOfString *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfString");
	case SOAP_TYPE_ns1__ArrayOfBoolean:
		return ((ns1__ArrayOfBoolean *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfBoolean");
	case SOAP_TYPE_ns1__ArrayOfUnsignedShort:
		return ((ns1__ArrayOfUnsignedShort *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfUnsignedShort");
	case SOAP_TYPE_ns1__ArrayOfDouble:
		return ((ns1__ArrayOfDouble *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfDouble");
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		return ((ns1__ArrayOfUnsignedLong *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfUnsignedLong");
	case SOAP_TYPE_ns1__ArrayOfLong:
		return ((ns1__ArrayOfLong *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfLong");
	case SOAP_TYPE_ns1__ArrayOfUnsignedInt:
		return ((ns1__ArrayOfUnsignedInt *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfUnsignedInt");
	case SOAP_TYPE_ns1__ArrayOfInt:
		return ((ns1__ArrayOfInt *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfInt");
	case SOAP_TYPE_ns1__ArrayOfFloat:
		return ((ns1__ArrayOfFloat *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfFloat");
	case SOAP_TYPE_ns1__OPCError:
		return ((ns1__OPCError *)ptr)->soap_out(soap, tag, id, "ns1:OPCError");
	case SOAP_TYPE_ns1__OPCQuality:
		return ((ns1__OPCQuality *)ptr)->soap_out(soap, tag, id, "ns1:OPCQuality");
	case SOAP_TYPE_ns1__ItemValue:
		return ((ns1__ItemValue *)ptr)->soap_out(soap, tag, id, "ns1:ItemValue");
	case SOAP_TYPE_ns1__ReplyItemList:
		return ((ns1__ReplyItemList *)ptr)->soap_out(soap, tag, id, "ns1:ReplyItemList");
	case SOAP_TYPE_ns1__ReadRequestItem:
		return ((ns1__ReadRequestItem *)ptr)->soap_out(soap, tag, id, "ns1:ReadRequestItem");
	case SOAP_TYPE_ns1__ReadRequestItemList:
		return ((ns1__ReadRequestItemList *)ptr)->soap_out(soap, tag, id, "ns1:ReadRequestItemList");
	case SOAP_TYPE_ns1__RequestOptions:
		return ((ns1__RequestOptions *)ptr)->soap_out(soap, tag, id, "ns1:RequestOptions");
	case SOAP_TYPE_ns1__ServerStatus:
		return ((ns1__ServerStatus *)ptr)->soap_out(soap, tag, id, "ns1:ServerStatus");
	case SOAP_TYPE_ns1__ReplyBase:
		return ((ns1__ReplyBase *)ptr)->soap_out(soap, tag, id, "ns1:ReplyBase");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns1__GetPropertiesResponse:
		return soap_out_PointerTo_ns1__GetPropertiesResponse(soap, tag, id, (_ns1__GetPropertiesResponse *const*)ptr, "ns1:GetPropertiesResponse");
	case SOAP_TYPE_PointerTo_ns1__GetProperties:
		return soap_out_PointerTo_ns1__GetProperties(soap, tag, id, (_ns1__GetProperties *const*)ptr, "ns1:GetProperties");
	case SOAP_TYPE_PointerTo_ns1__BrowseResponse:
		return soap_out_PointerTo_ns1__BrowseResponse(soap, tag, id, (_ns1__BrowseResponse *const*)ptr, "ns1:BrowseResponse");
	case SOAP_TYPE_PointerTo_ns1__Browse:
		return soap_out_PointerTo_ns1__Browse(soap, tag, id, (_ns1__Browse *const*)ptr, "ns1:Browse");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionCancelResponse:
		return soap_out_PointerTo_ns1__SubscriptionCancelResponse(soap, tag, id, (_ns1__SubscriptionCancelResponse *const*)ptr, "ns1:SubscriptionCancelResponse");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionCancel:
		return soap_out_PointerTo_ns1__SubscriptionCancel(soap, tag, id, (_ns1__SubscriptionCancel *const*)ptr, "ns1:SubscriptionCancel");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefreshResponse:
		return soap_out_PointerTo_ns1__SubscriptionPolledRefreshResponse(soap, tag, id, (_ns1__SubscriptionPolledRefreshResponse *const*)ptr, "ns1:SubscriptionPolledRefreshResponse");
	case SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefresh:
		return soap_out_PointerTo_ns1__SubscriptionPolledRefresh(soap, tag, id, (_ns1__SubscriptionPolledRefresh *const*)ptr, "ns1:SubscriptionPolledRefresh");
	case SOAP_TYPE_PointerTo_ns1__SubscribeResponse:
		return soap_out_PointerTo_ns1__SubscribeResponse(soap, tag, id, (_ns1__SubscribeResponse *const*)ptr, "ns1:SubscribeResponse");
	case SOAP_TYPE_PointerTo_ns1__Subscribe:
		return soap_out_PointerTo_ns1__Subscribe(soap, tag, id, (_ns1__Subscribe *const*)ptr, "ns1:Subscribe");
	case SOAP_TYPE_PointerTo_ns1__WriteResponse:
		return soap_out_PointerTo_ns1__WriteResponse(soap, tag, id, (_ns1__WriteResponse *const*)ptr, "ns1:WriteResponse");
	case SOAP_TYPE_PointerTo_ns1__Write:
		return soap_out_PointerTo_ns1__Write(soap, tag, id, (_ns1__Write *const*)ptr, "ns1:Write");
	case SOAP_TYPE_PointerTo_ns1__ReadResponse:
		return soap_out_PointerTo_ns1__ReadResponse(soap, tag, id, (_ns1__ReadResponse *const*)ptr, "ns1:ReadResponse");
	case SOAP_TYPE_PointerTo_ns1__Read:
		return soap_out_PointerTo_ns1__Read(soap, tag, id, (_ns1__Read *const*)ptr, "ns1:Read");
	case SOAP_TYPE_PointerTo_ns1__GetStatusResponse:
		return soap_out_PointerTo_ns1__GetStatusResponse(soap, tag, id, (_ns1__GetStatusResponse *const*)ptr, "ns1:GetStatusResponse");
	case SOAP_TYPE_PointerTo_ns1__GetStatus:
		return soap_out_PointerTo_ns1__GetStatus(soap, tag, id, (_ns1__GetStatus *const*)ptr, "ns1:GetStatus");
	case SOAP_TYPE_PointerTons1__PropertyReplyList:
		return soap_out_PointerTons1__PropertyReplyList(soap, tag, id, (ns1__PropertyReplyList *const*)ptr, "ns1:PropertyReplyList");
	case SOAP_TYPE_PointerTons1__ItemIdentifier:
		return soap_out_PointerTons1__ItemIdentifier(soap, tag, id, (ns1__ItemIdentifier *const*)ptr, "ns1:ItemIdentifier");
	case SOAP_TYPE_PointerTons1__BrowseElement:
		return soap_out_PointerTons1__BrowseElement(soap, tag, id, (ns1__BrowseElement *const*)ptr, "ns1:BrowseElement");
	case SOAP_TYPE_PointerTons1__browseFilter:
		return soap_out_PointerTons1__browseFilter(soap, tag, id, (enum ns1__browseFilter *const*)ptr, "ns1:browseFilter");
	case SOAP_TYPE_PointerTons1__SubscribePolledRefreshReplyItemList:
		return soap_out_PointerTons1__SubscribePolledRefreshReplyItemList(soap, tag, id, (ns1__SubscribePolledRefreshReplyItemList *const*)ptr, "ns1:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_PointerTons1__SubscribeReplyItemList:
		return soap_out_PointerTons1__SubscribeReplyItemList(soap, tag, id, (ns1__SubscribeReplyItemList *const*)ptr, "ns1:SubscribeReplyItemList");
	case SOAP_TYPE_PointerTons1__SubscribeRequestItemList:
		return soap_out_PointerTons1__SubscribeRequestItemList(soap, tag, id, (ns1__SubscribeRequestItemList *const*)ptr, "ns1:SubscribeRequestItemList");
	case SOAP_TYPE_PointerTons1__WriteRequestItemList:
		return soap_out_PointerTons1__WriteRequestItemList(soap, tag, id, (ns1__WriteRequestItemList *const*)ptr, "ns1:WriteRequestItemList");
	case SOAP_TYPE_PointerTons1__OPCError:
		return soap_out_PointerTons1__OPCError(soap, tag, id, (ns1__OPCError *const*)ptr, "ns1:OPCError");
	case SOAP_TYPE_PointerTons1__ReplyItemList:
		return soap_out_PointerTons1__ReplyItemList(soap, tag, id, (ns1__ReplyItemList *const*)ptr, "ns1:ReplyItemList");
	case SOAP_TYPE_PointerTons1__ReadRequestItemList:
		return soap_out_PointerTons1__ReadRequestItemList(soap, tag, id, (ns1__ReadRequestItemList *const*)ptr, "ns1:ReadRequestItemList");
	case SOAP_TYPE_PointerTons1__RequestOptions:
		return soap_out_PointerTons1__RequestOptions(soap, tag, id, (ns1__RequestOptions *const*)ptr, "ns1:RequestOptions");
	case SOAP_TYPE_PointerTons1__ServerStatus:
		return soap_out_PointerTons1__ServerStatus(soap, tag, id, (ns1__ServerStatus *const*)ptr, "ns1:ServerStatus");
	case SOAP_TYPE_PointerTons1__ReplyBase:
		return soap_out_PointerTons1__ReplyBase(soap, tag, id, (ns1__ReplyBase *const*)ptr, "ns1:ReplyBase");
	case SOAP_TYPE_PointerTons1__ItemProperty:
		return soap_out_PointerTons1__ItemProperty(soap, tag, id, (ns1__ItemProperty *const*)ptr, "ns1:ItemProperty");
	case SOAP_TYPE_PointerTons1__SubscribeItemValue:
		return soap_out_PointerTons1__SubscribeItemValue(soap, tag, id, (ns1__SubscribeItemValue *const*)ptr, "ns1:SubscribeItemValue");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTons1__SubscribeRequestItem:
		return soap_out_PointerTons1__SubscribeRequestItem(soap, tag, id, (ns1__SubscribeRequestItem *const*)ptr, "ns1:SubscribeRequestItem");
	case SOAP_TYPE_PointerTounsignedShort:
		return soap_out_PointerTounsignedShort(soap, tag, id, (unsigned short *const*)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_PointerTons1__limitBits:
		return soap_out_PointerTons1__limitBits(soap, tag, id, (enum ns1__limitBits *const*)ptr, "ns1:limitBits");
	case SOAP_TYPE_PointerTons1__qualityBits:
		return soap_out_PointerTons1__qualityBits(soap, tag, id, (enum ns1__qualityBits *const*)ptr, "ns1:qualityBits");
	case SOAP_TYPE_PointerTons1__OPCQuality:
		return soap_out_PointerTons1__OPCQuality(soap, tag, id, (ns1__OPCQuality *const*)ptr, "ns1:OPCQuality");
	case SOAP_TYPE_PointerTons1__ItemValue:
		return soap_out_PointerTons1__ItemValue(soap, tag, id, (ns1__ItemValue *const*)ptr, "ns1:ItemValue");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTons1__ReadRequestItem:
		return soap_out_PointerTons1__ReadRequestItem(soap, tag, id, (ns1__ReadRequestItem *const*)ptr, "ns1:ReadRequestItem");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetPropertiesResponse:
		((_ns1__GetPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetProperties:
		((_ns1__GetProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BrowseResponse:
		((_ns1__BrowseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Browse:
		((_ns1__Browse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubscriptionCancelResponse:
		((_ns1__SubscriptionCancelResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubscriptionCancel:
		((_ns1__SubscriptionCancel *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse:
		((_ns1__SubscriptionPolledRefreshResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubscriptionPolledRefresh:
		((_ns1__SubscriptionPolledRefresh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SubscribeResponse:
		((_ns1__SubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Subscribe:
		((_ns1__Subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WriteResponse:
		((_ns1__WriteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Write:
		((_ns1__Write *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ReadResponse:
		((_ns1__ReadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Read:
		((_ns1__Read *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStatusResponse:
		((_ns1__GetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStatus:
		((_ns1__GetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PropertyReplyList:
		((ns1__PropertyReplyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ItemIdentifier:
		((ns1__ItemIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ItemProperty:
		((ns1__ItemProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BrowseElement:
		((ns1__BrowseElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList:
		((ns1__SubscribePolledRefreshReplyItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubscribeItemValue:
		((ns1__SubscribeItemValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubscribeReplyItemList:
		((ns1__SubscribeReplyItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubscribeRequestItem:
		((ns1__SubscribeRequestItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SubscribeRequestItemList:
		((ns1__SubscribeRequestItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__WriteRequestItemList:
		((ns1__WriteRequestItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfShort:
		((ns1__ArrayOfShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfByte:
		((ns1__ArrayOfByte *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDecimal:
		((ns1__ArrayOfDecimal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		((ns1__ArrayOfAnyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		((ns1__ArrayOfDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		((ns1__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfBoolean:
		((ns1__ArrayOfBoolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedShort:
		((ns1__ArrayOfUnsignedShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfDouble:
		((ns1__ArrayOfDouble *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		((ns1__ArrayOfUnsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfLong:
		((ns1__ArrayOfLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedInt:
		((ns1__ArrayOfUnsignedInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfInt:
		((ns1__ArrayOfInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfFloat:
		((ns1__ArrayOfFloat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OPCError:
		((ns1__OPCError *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OPCQuality:
		((ns1__OPCQuality *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ItemValue:
		((ns1__ItemValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReplyItemList:
		((ns1__ReplyItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReadRequestItem:
		((ns1__ReadRequestItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReadRequestItemList:
		((ns1__ReadRequestItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RequestOptions:
		((ns1__RequestOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ServerStatus:
		((ns1__ServerStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ReplyBase:
		((ns1__ReplyBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns1__GetProperties:
		soap_serialize___ns1__GetProperties(soap, (const struct __ns1__GetProperties *)ptr);
		break;
	case SOAP_TYPE___ns1__Browse:
		soap_serialize___ns1__Browse(soap, (const struct __ns1__Browse *)ptr);
		break;
	case SOAP_TYPE___ns1__SubscriptionCancel:
		soap_serialize___ns1__SubscriptionCancel(soap, (const struct __ns1__SubscriptionCancel *)ptr);
		break;
	case SOAP_TYPE___ns1__SubscriptionPolledRefresh:
		soap_serialize___ns1__SubscriptionPolledRefresh(soap, (const struct __ns1__SubscriptionPolledRefresh *)ptr);
		break;
	case SOAP_TYPE___ns1__Subscribe:
		soap_serialize___ns1__Subscribe(soap, (const struct __ns1__Subscribe *)ptr);
		break;
	case SOAP_TYPE___ns1__Write:
		soap_serialize___ns1__Write(soap, (const struct __ns1__Write *)ptr);
		break;
	case SOAP_TYPE___ns1__Read:
		soap_serialize___ns1__Read(soap, (const struct __ns1__Read *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStatus:
		soap_serialize___ns1__GetStatus(soap, (const struct __ns1__GetStatus *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPropertiesResponse:
		soap_serialize_PointerTo_ns1__GetPropertiesResponse(soap, (_ns1__GetPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetProperties:
		soap_serialize_PointerTo_ns1__GetProperties(soap, (_ns1__GetProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BrowseResponse:
		soap_serialize_PointerTo_ns1__BrowseResponse(soap, (_ns1__BrowseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Browse:
		soap_serialize_PointerTo_ns1__Browse(soap, (_ns1__Browse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubscriptionCancelResponse:
		soap_serialize_PointerTo_ns1__SubscriptionCancelResponse(soap, (_ns1__SubscriptionCancelResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubscriptionCancel:
		soap_serialize_PointerTo_ns1__SubscriptionCancel(soap, (_ns1__SubscriptionCancel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefreshResponse:
		soap_serialize_PointerTo_ns1__SubscriptionPolledRefreshResponse(soap, (_ns1__SubscriptionPolledRefreshResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefresh:
		soap_serialize_PointerTo_ns1__SubscriptionPolledRefresh(soap, (_ns1__SubscriptionPolledRefresh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SubscribeResponse:
		soap_serialize_PointerTo_ns1__SubscribeResponse(soap, (_ns1__SubscribeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Subscribe:
		soap_serialize_PointerTo_ns1__Subscribe(soap, (_ns1__Subscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WriteResponse:
		soap_serialize_PointerTo_ns1__WriteResponse(soap, (_ns1__WriteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Write:
		soap_serialize_PointerTo_ns1__Write(soap, (_ns1__Write *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ReadResponse:
		soap_serialize_PointerTo_ns1__ReadResponse(soap, (_ns1__ReadResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Read:
		soap_serialize_PointerTo_ns1__Read(soap, (_ns1__Read *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStatusResponse:
		soap_serialize_PointerTo_ns1__GetStatusResponse(soap, (_ns1__GetStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStatus:
		soap_serialize_PointerTo_ns1__GetStatus(soap, (_ns1__GetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PropertyReplyList:
		soap_serialize_PointerTons1__PropertyReplyList(soap, (ns1__PropertyReplyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemIdentifier:
		soap_serialize_PointerTons1__ItemIdentifier(soap, (ns1__ItemIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BrowseElement:
		soap_serialize_PointerTons1__BrowseElement(soap, (ns1__BrowseElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__browseFilter:
		soap_serialize_PointerTons1__browseFilter(soap, (enum ns1__browseFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubscribePolledRefreshReplyItemList:
		soap_serialize_PointerTons1__SubscribePolledRefreshReplyItemList(soap, (ns1__SubscribePolledRefreshReplyItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubscribeReplyItemList:
		soap_serialize_PointerTons1__SubscribeReplyItemList(soap, (ns1__SubscribeReplyItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubscribeRequestItemList:
		soap_serialize_PointerTons1__SubscribeRequestItemList(soap, (ns1__SubscribeRequestItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__WriteRequestItemList:
		soap_serialize_PointerTons1__WriteRequestItemList(soap, (ns1__WriteRequestItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OPCError:
		soap_serialize_PointerTons1__OPCError(soap, (ns1__OPCError *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReplyItemList:
		soap_serialize_PointerTons1__ReplyItemList(soap, (ns1__ReplyItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReadRequestItemList:
		soap_serialize_PointerTons1__ReadRequestItemList(soap, (ns1__ReadRequestItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RequestOptions:
		soap_serialize_PointerTons1__RequestOptions(soap, (ns1__RequestOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ServerStatus:
		soap_serialize_PointerTons1__ServerStatus(soap, (ns1__ServerStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReplyBase:
		soap_serialize_PointerTons1__ReplyBase(soap, (ns1__ReplyBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemProperty:
		soap_serialize_PointerTons1__ItemProperty(soap, (ns1__ItemProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubscribeItemValue:
		soap_serialize_PointerTons1__SubscribeItemValue(soap, (ns1__SubscribeItemValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SubscribeRequestItem:
		soap_serialize_PointerTons1__SubscribeRequestItem(soap, (ns1__SubscribeRequestItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedShort:
		soap_serialize_PointerTounsignedShort(soap, (unsigned short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__limitBits:
		soap_serialize_PointerTons1__limitBits(soap, (enum ns1__limitBits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__qualityBits:
		soap_serialize_PointerTons1__qualityBits(soap, (enum ns1__qualityBits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OPCQuality:
		soap_serialize_PointerTons1__OPCQuality(soap, (ns1__OPCQuality *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ItemValue:
		soap_serialize_PointerTons1__ItemValue(soap, (ns1__ItemValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ReadRequestItem:
		soap_serialize_PointerTons1__ReadRequestItem(soap, (ns1__ReadRequestItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReplyBase:
		return (void*)soap_instantiate_ns1__ReplyBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ServerStatus:
		return (void*)soap_instantiate_ns1__ServerStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RequestOptions:
		return (void*)soap_instantiate_ns1__RequestOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReadRequestItemList:
		return (void*)soap_instantiate_ns1__ReadRequestItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReadRequestItem:
		return (void*)soap_instantiate_ns1__ReadRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ReplyItemList:
		return (void*)soap_instantiate_ns1__ReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemValue:
		return (void*)soap_instantiate_ns1__ItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OPCQuality:
		return (void*)soap_instantiate_ns1__OPCQuality(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OPCError:
		return (void*)soap_instantiate_ns1__OPCError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfFloat:
		return (void*)soap_instantiate_ns1__ArrayOfFloat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfInt:
		return (void*)soap_instantiate_ns1__ArrayOfInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfUnsignedInt:
		return (void*)soap_instantiate_ns1__ArrayOfUnsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfLong:
		return (void*)soap_instantiate_ns1__ArrayOfLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		return (void*)soap_instantiate_ns1__ArrayOfUnsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDouble:
		return (void*)soap_instantiate_ns1__ArrayOfDouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfUnsignedShort:
		return (void*)soap_instantiate_ns1__ArrayOfUnsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfBoolean:
		return (void*)soap_instantiate_ns1__ArrayOfBoolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfString:
		return (void*)soap_instantiate_ns1__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		return (void*)soap_instantiate_ns1__ArrayOfDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		return (void*)soap_instantiate_ns1__ArrayOfAnyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfDecimal:
		return (void*)soap_instantiate_ns1__ArrayOfDecimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfByte:
		return (void*)soap_instantiate_ns1__ArrayOfByte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfShort:
		return (void*)soap_instantiate_ns1__ArrayOfShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__WriteRequestItemList:
		return (void*)soap_instantiate_ns1__WriteRequestItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribeRequestItemList:
		return (void*)soap_instantiate_ns1__SubscribeRequestItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribeRequestItem:
		return (void*)soap_instantiate_ns1__SubscribeRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribeReplyItemList:
		return (void*)soap_instantiate_ns1__SubscribeReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribeItemValue:
		return (void*)soap_instantiate_ns1__SubscribeItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList:
		return (void*)soap_instantiate_ns1__SubscribePolledRefreshReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BrowseElement:
		return (void*)soap_instantiate_ns1__BrowseElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemProperty:
		return (void*)soap_instantiate_ns1__ItemProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ItemIdentifier:
		return (void*)soap_instantiate_ns1__ItemIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PropertyReplyList:
		return (void*)soap_instantiate_ns1__PropertyReplyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStatus:
		return (void*)soap_instantiate__ns1__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStatusResponse:
		return (void*)soap_instantiate__ns1__GetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Read:
		return (void*)soap_instantiate__ns1__Read(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ReadResponse:
		return (void*)soap_instantiate__ns1__ReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Write:
		return (void*)soap_instantiate__ns1__Write(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WriteResponse:
		return (void*)soap_instantiate__ns1__WriteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Subscribe:
		return (void*)soap_instantiate__ns1__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubscribeResponse:
		return (void*)soap_instantiate__ns1__SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubscriptionPolledRefresh:
		return (void*)soap_instantiate__ns1__SubscriptionPolledRefresh(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse:
		return (void*)soap_instantiate__ns1__SubscriptionPolledRefreshResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubscriptionCancel:
		return (void*)soap_instantiate__ns1__SubscriptionCancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SubscriptionCancelResponse:
		return (void*)soap_instantiate__ns1__SubscriptionCancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Browse:
		return (void*)soap_instantiate__ns1__Browse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BrowseResponse:
		return (void*)soap_instantiate__ns1__BrowseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetProperties:
		return (void*)soap_instantiate__ns1__GetProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPropertiesResponse:
		return (void*)soap_instantiate__ns1__GetPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStatus:
		return (void*)soap_instantiate___ns1__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Read:
		return (void*)soap_instantiate___ns1__Read(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Write:
		return (void*)soap_instantiate___ns1__Write(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Subscribe:
		return (void*)soap_instantiate___ns1__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SubscriptionPolledRefresh:
		return (void*)soap_instantiate___ns1__SubscriptionPolledRefresh(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SubscriptionCancel:
		return (void*)soap_instantiate___ns1__SubscriptionCancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Browse:
		return (void*)soap_instantiate___ns1__Browse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetProperties:
		return (void*)soap_instantiate___ns1__GetProperties(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PropertyReplyList:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemIdentifier:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BrowseElement:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__BrowseElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OPCError:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__OPCError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemProperty:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ItemProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeItemValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeRequestItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfshort:
		return (void*)soap_instantiate_std__vectorTemplateOfshort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfbyte:
		return (void*)soap_instantiate_std__vectorTemplateOfbyte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftime:
		return (void*)soap_instantiate_std__vectorTemplateOftime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfbool:
		return (void*)soap_instantiate_std__vectorTemplateOfbool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		return (void*)soap_instantiate_std__vectorTemplateOfdouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedLONG64(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		return (void*)soap_instantiate_std__vectorTemplateOfLONG64(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOffloat:
		return (void*)soap_instantiate_std__vectorTemplateOffloat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReadRequestItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__interfaceVersion:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__interfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ReplyBase:
		if (p->size < 0)
			delete (ns1__ReplyBase*)p->ptr;
		else
			delete[] (ns1__ReplyBase*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ServerStatus:
		if (p->size < 0)
			delete (ns1__ServerStatus*)p->ptr;
		else
			delete[] (ns1__ServerStatus*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RequestOptions:
		if (p->size < 0)
			delete (ns1__RequestOptions*)p->ptr;
		else
			delete[] (ns1__RequestOptions*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ReadRequestItemList:
		if (p->size < 0)
			delete (ns1__ReadRequestItemList*)p->ptr;
		else
			delete[] (ns1__ReadRequestItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ReadRequestItem:
		if (p->size < 0)
			delete (ns1__ReadRequestItem*)p->ptr;
		else
			delete[] (ns1__ReadRequestItem*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ReplyItemList:
		if (p->size < 0)
			delete (ns1__ReplyItemList*)p->ptr;
		else
			delete[] (ns1__ReplyItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemValue:
		if (p->size < 0)
			delete (ns1__ItemValue*)p->ptr;
		else
			delete[] (ns1__ItemValue*)p->ptr;
		break;
	case SOAP_TYPE_ns1__OPCQuality:
		if (p->size < 0)
			delete (ns1__OPCQuality*)p->ptr;
		else
			delete[] (ns1__OPCQuality*)p->ptr;
		break;
	case SOAP_TYPE_ns1__OPCError:
		if (p->size < 0)
			delete (ns1__OPCError*)p->ptr;
		else
			delete[] (ns1__OPCError*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfFloat:
		if (p->size < 0)
			delete (ns1__ArrayOfFloat*)p->ptr;
		else
			delete[] (ns1__ArrayOfFloat*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfInt:
		if (p->size < 0)
			delete (ns1__ArrayOfInt*)p->ptr;
		else
			delete[] (ns1__ArrayOfInt*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedInt:
		if (p->size < 0)
			delete (ns1__ArrayOfUnsignedInt*)p->ptr;
		else
			delete[] (ns1__ArrayOfUnsignedInt*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfLong:
		if (p->size < 0)
			delete (ns1__ArrayOfLong*)p->ptr;
		else
			delete[] (ns1__ArrayOfLong*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedLong:
		if (p->size < 0)
			delete (ns1__ArrayOfUnsignedLong*)p->ptr;
		else
			delete[] (ns1__ArrayOfUnsignedLong*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfDouble:
		if (p->size < 0)
			delete (ns1__ArrayOfDouble*)p->ptr;
		else
			delete[] (ns1__ArrayOfDouble*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfUnsignedShort:
		if (p->size < 0)
			delete (ns1__ArrayOfUnsignedShort*)p->ptr;
		else
			delete[] (ns1__ArrayOfUnsignedShort*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfBoolean:
		if (p->size < 0)
			delete (ns1__ArrayOfBoolean*)p->ptr;
		else
			delete[] (ns1__ArrayOfBoolean*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfString:
		if (p->size < 0)
			delete (ns1__ArrayOfString*)p->ptr;
		else
			delete[] (ns1__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfDateTime:
		if (p->size < 0)
			delete (ns1__ArrayOfDateTime*)p->ptr;
		else
			delete[] (ns1__ArrayOfDateTime*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfAnyType:
		if (p->size < 0)
			delete (ns1__ArrayOfAnyType*)p->ptr;
		else
			delete[] (ns1__ArrayOfAnyType*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfDecimal:
		if (p->size < 0)
			delete (ns1__ArrayOfDecimal*)p->ptr;
		else
			delete[] (ns1__ArrayOfDecimal*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfByte:
		if (p->size < 0)
			delete (ns1__ArrayOfByte*)p->ptr;
		else
			delete[] (ns1__ArrayOfByte*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ArrayOfShort:
		if (p->size < 0)
			delete (ns1__ArrayOfShort*)p->ptr;
		else
			delete[] (ns1__ArrayOfShort*)p->ptr;
		break;
	case SOAP_TYPE_ns1__WriteRequestItemList:
		if (p->size < 0)
			delete (ns1__WriteRequestItemList*)p->ptr;
		else
			delete[] (ns1__WriteRequestItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SubscribeRequestItemList:
		if (p->size < 0)
			delete (ns1__SubscribeRequestItemList*)p->ptr;
		else
			delete[] (ns1__SubscribeRequestItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SubscribeRequestItem:
		if (p->size < 0)
			delete (ns1__SubscribeRequestItem*)p->ptr;
		else
			delete[] (ns1__SubscribeRequestItem*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SubscribeReplyItemList:
		if (p->size < 0)
			delete (ns1__SubscribeReplyItemList*)p->ptr;
		else
			delete[] (ns1__SubscribeReplyItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SubscribeItemValue:
		if (p->size < 0)
			delete (ns1__SubscribeItemValue*)p->ptr;
		else
			delete[] (ns1__SubscribeItemValue*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList:
		if (p->size < 0)
			delete (ns1__SubscribePolledRefreshReplyItemList*)p->ptr;
		else
			delete[] (ns1__SubscribePolledRefreshReplyItemList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BrowseElement:
		if (p->size < 0)
			delete (ns1__BrowseElement*)p->ptr;
		else
			delete[] (ns1__BrowseElement*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemProperty:
		if (p->size < 0)
			delete (ns1__ItemProperty*)p->ptr;
		else
			delete[] (ns1__ItemProperty*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ItemIdentifier:
		if (p->size < 0)
			delete (ns1__ItemIdentifier*)p->ptr;
		else
			delete[] (ns1__ItemIdentifier*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PropertyReplyList:
		if (p->size < 0)
			delete (ns1__PropertyReplyList*)p->ptr;
		else
			delete[] (ns1__PropertyReplyList*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetStatus:
		if (p->size < 0)
			delete (_ns1__GetStatus*)p->ptr;
		else
			delete[] (_ns1__GetStatus*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetStatusResponse:
		if (p->size < 0)
			delete (_ns1__GetStatusResponse*)p->ptr;
		else
			delete[] (_ns1__GetStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__Read:
		if (p->size < 0)
			delete (_ns1__Read*)p->ptr;
		else
			delete[] (_ns1__Read*)p->ptr;
		break;
	case SOAP_TYPE__ns1__ReadResponse:
		if (p->size < 0)
			delete (_ns1__ReadResponse*)p->ptr;
		else
			delete[] (_ns1__ReadResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__Write:
		if (p->size < 0)
			delete (_ns1__Write*)p->ptr;
		else
			delete[] (_ns1__Write*)p->ptr;
		break;
	case SOAP_TYPE__ns1__WriteResponse:
		if (p->size < 0)
			delete (_ns1__WriteResponse*)p->ptr;
		else
			delete[] (_ns1__WriteResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__Subscribe:
		if (p->size < 0)
			delete (_ns1__Subscribe*)p->ptr;
		else
			delete[] (_ns1__Subscribe*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SubscribeResponse:
		if (p->size < 0)
			delete (_ns1__SubscribeResponse*)p->ptr;
		else
			delete[] (_ns1__SubscribeResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SubscriptionPolledRefresh:
		if (p->size < 0)
			delete (_ns1__SubscriptionPolledRefresh*)p->ptr;
		else
			delete[] (_ns1__SubscriptionPolledRefresh*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse:
		if (p->size < 0)
			delete (_ns1__SubscriptionPolledRefreshResponse*)p->ptr;
		else
			delete[] (_ns1__SubscriptionPolledRefreshResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SubscriptionCancel:
		if (p->size < 0)
			delete (_ns1__SubscriptionCancel*)p->ptr;
		else
			delete[] (_ns1__SubscriptionCancel*)p->ptr;
		break;
	case SOAP_TYPE__ns1__SubscriptionCancelResponse:
		if (p->size < 0)
			delete (_ns1__SubscriptionCancelResponse*)p->ptr;
		else
			delete[] (_ns1__SubscriptionCancelResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__Browse:
		if (p->size < 0)
			delete (_ns1__Browse*)p->ptr;
		else
			delete[] (_ns1__Browse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__BrowseResponse:
		if (p->size < 0)
			delete (_ns1__BrowseResponse*)p->ptr;
		else
			delete[] (_ns1__BrowseResponse*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetProperties:
		if (p->size < 0)
			delete (_ns1__GetProperties*)p->ptr;
		else
			delete[] (_ns1__GetProperties*)p->ptr;
		break;
	case SOAP_TYPE__ns1__GetPropertiesResponse:
		if (p->size < 0)
			delete (_ns1__GetPropertiesResponse*)p->ptr;
		else
			delete[] (_ns1__GetPropertiesResponse*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetStatus:
		if (p->size < 0)
			delete (struct __ns1__GetStatus*)p->ptr;
		else
			delete[] (struct __ns1__GetStatus*)p->ptr;
		break;
	case SOAP_TYPE___ns1__Read:
		if (p->size < 0)
			delete (struct __ns1__Read*)p->ptr;
		else
			delete[] (struct __ns1__Read*)p->ptr;
		break;
	case SOAP_TYPE___ns1__Write:
		if (p->size < 0)
			delete (struct __ns1__Write*)p->ptr;
		else
			delete[] (struct __ns1__Write*)p->ptr;
		break;
	case SOAP_TYPE___ns1__Subscribe:
		if (p->size < 0)
			delete (struct __ns1__Subscribe*)p->ptr;
		else
			delete[] (struct __ns1__Subscribe*)p->ptr;
		break;
	case SOAP_TYPE___ns1__SubscriptionPolledRefresh:
		if (p->size < 0)
			delete (struct __ns1__SubscriptionPolledRefresh*)p->ptr;
		else
			delete[] (struct __ns1__SubscriptionPolledRefresh*)p->ptr;
		break;
	case SOAP_TYPE___ns1__SubscriptionCancel:
		if (p->size < 0)
			delete (struct __ns1__SubscriptionCancel*)p->ptr;
		else
			delete[] (struct __ns1__SubscriptionCancel*)p->ptr;
		break;
	case SOAP_TYPE___ns1__Browse:
		if (p->size < 0)
			delete (struct __ns1__Browse*)p->ptr;
		else
			delete[] (struct __ns1__Browse*)p->ptr;
		break;
	case SOAP_TYPE___ns1__GetProperties:
		if (p->size < 0)
			delete (struct __ns1__GetProperties*)p->ptr;
		else
			delete[] (struct __ns1__GetProperties*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PropertyReplyList:
		if (p->size < 0)
			delete (std::vector<ns1__PropertyReplyList * >*)p->ptr;
		else
			delete[] (std::vector<ns1__PropertyReplyList * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemIdentifier:
		if (p->size < 0)
			delete (std::vector<ns1__ItemIdentifier * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ItemIdentifier * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BrowseElement:
		if (p->size < 0)
			delete (std::vector<ns1__BrowseElement * >*)p->ptr;
		else
			delete[] (std::vector<ns1__BrowseElement * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList:
		if (p->size < 0)
			delete (std::vector<ns1__SubscribePolledRefreshReplyItemList * >*)p->ptr;
		else
			delete[] (std::vector<ns1__SubscribePolledRefreshReplyItemList * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OPCError:
		if (p->size < 0)
			delete (std::vector<ns1__OPCError * >*)p->ptr;
		else
			delete[] (std::vector<ns1__OPCError * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemProperty:
		if (p->size < 0)
			delete (std::vector<ns1__ItemProperty * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ItemProperty * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeItemValue:
		if (p->size < 0)
			delete (std::vector<ns1__SubscribeItemValue * >*)p->ptr;
		else
			delete[] (std::vector<ns1__SubscribeItemValue * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeRequestItem:
		if (p->size < 0)
			delete (std::vector<ns1__SubscribeRequestItem * >*)p->ptr;
		else
			delete[] (std::vector<ns1__SubscribeRequestItem * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfshort:
		if (p->size < 0)
			delete (std::vector<short >*)p->ptr;
		else
			delete[] (std::vector<short >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbyte:
		if (p->size < 0)
			delete (std::vector<char >*)p->ptr;
		else
			delete[] (std::vector<char >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOftime:
		if (p->size < 0)
			delete (std::vector<time_t >*)p->ptr;
		else
			delete[] (std::vector<time_t >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbool:
		if (p->size < 0)
			delete (std::vector<bool >*)p->ptr;
		else
			delete[] (std::vector<bool >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
		if (p->size < 0)
			delete (std::vector<unsigned short >*)p->ptr;
		else
			delete[] (std::vector<unsigned short >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		if (p->size < 0)
			delete (std::vector<double >*)p->ptr;
		else
			delete[] (std::vector<double >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
		if (p->size < 0)
			delete (std::vector<ULONG64 >*)p->ptr;
		else
			delete[] (std::vector<ULONG64 >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		if (p->size < 0)
			delete (std::vector<LONG64 >*)p->ptr;
		else
			delete[] (std::vector<LONG64 >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		if (p->size < 0)
			delete (std::vector<unsigned int >*)p->ptr;
		else
			delete[] (std::vector<unsigned int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOffloat:
		if (p->size < 0)
			delete (std::vector<float >*)p->ptr;
		else
			delete[] (std::vector<float >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemValue:
		if (p->size < 0)
			delete (std::vector<ns1__ItemValue * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ItemValue * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReadRequestItem:
		if (p->size < 0)
			delete (std::vector<ns1__ReadRequestItem * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ReadRequestItem * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__interfaceVersion:
		if (p->size < 0)
			delete (std::vector<enum ns1__interfaceVersion >*)p->ptr;
		else
			delete[] (std::vector<enum ns1__interfaceVersion >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__PropertyReplyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__PropertyReplyList * >*)p)[len] = *(ns1__PropertyReplyList **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ItemIdentifier * >*)p)[len] = *(ns1__ItemIdentifier **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__BrowseElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__BrowseElement * >*)p)[len] = *(ns1__BrowseElement **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SubscribePolledRefreshReplyItemList * >*)p)[len] = *(ns1__SubscribePolledRefreshReplyItemList **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__OPCError:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__OPCError * >*)p)[len] = *(ns1__OPCError **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemProperty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ItemProperty * >*)p)[len] = *(ns1__ItemProperty **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeItemValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SubscribeItemValue * >*)p)[len] = *(ns1__SubscribeItemValue **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeRequestItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__SubscribeRequestItem * >*)p)[len] = *(ns1__SubscribeRequestItem **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfshort:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<short >*)p)[len] = *(short *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbyte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char >*)p)[len] = *(char *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOftime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<time_t >*)p)[len] = *(time_t *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbool:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bool >*)p)[len] = *(bool *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<unsigned short >*)p)[len] = *(unsigned short *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<double >*)p)[len] = *(double *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ULONG64 >*)p)[len] = *(ULONG64 *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<LONG64 >*)p)[len] = *(LONG64 *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<unsigned int >*)p)[len] = *(unsigned int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOffloat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<float >*)p)[len] = *(float *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ItemValue * >*)p)[len] = *(ns1__ItemValue **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReadRequestItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ReadRequestItem * >*)p)[len] = *(ns1__ReadRequestItem **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__interfaceVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns1__interfaceVersion >*)p)[len] = *(enum ns1__interfaceVersion *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__browseFilter(struct soap *soap, enum ns1__browseFilter *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__browseFilter
	*a = SOAP_DEFAULT_ns1__browseFilter;
#else
	*a = (enum ns1__browseFilter)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__browseFilter(struct soap *soap, const enum ns1__browseFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__browseFilter);
	if (soap_out_ns1__browseFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__browseFilter[] =
{	{ (long)ns1__browseFilter__all, "all" },
	{ (long)ns1__browseFilter__branch, "branch" },
	{ (long)ns1__browseFilter__item, "item" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__browseFilter2s(struct soap *soap, enum ns1__browseFilter n)
{	const char *s = soap_code_str(soap_codes_ns1__browseFilter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__browseFilter(struct soap *soap, const char *tag, int id, const enum ns1__browseFilter *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__browseFilter), type);
	soap_send(soap, soap_ns1__browseFilter2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__browseFilter * SOAP_FMAC4 soap_get_ns1__browseFilter(struct soap *soap, enum ns1__browseFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__browseFilter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__browseFilter(struct soap *soap, const char *s, enum ns1__browseFilter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__browseFilter, s);
	if (map)
		*a = (enum ns1__browseFilter)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__browseFilter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__browseFilter * SOAP_FMAC4 soap_in_ns1__browseFilter(struct soap *soap, const char *tag, enum ns1__browseFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__browseFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__browseFilter, sizeof(enum ns1__browseFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__browseFilter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__browseFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__browseFilter, 0, sizeof(enum ns1__browseFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__limitBits(struct soap *soap, enum ns1__limitBits *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__limitBits
	*a = SOAP_DEFAULT_ns1__limitBits;
#else
	*a = (enum ns1__limitBits)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__limitBits(struct soap *soap, const enum ns1__limitBits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__limitBits);
	if (soap_out_ns1__limitBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__limitBits[] =
{	{ (long)ns1__limitBits__none, "none" },
	{ (long)ns1__limitBits__low, "low" },
	{ (long)ns1__limitBits__high, "high" },
	{ (long)ns1__limitBits__constant, "constant" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__limitBits2s(struct soap *soap, enum ns1__limitBits n)
{	const char *s = soap_code_str(soap_codes_ns1__limitBits, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__limitBits(struct soap *soap, const char *tag, int id, const enum ns1__limitBits *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__limitBits), type);
	soap_send(soap, soap_ns1__limitBits2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__limitBits * SOAP_FMAC4 soap_get_ns1__limitBits(struct soap *soap, enum ns1__limitBits *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__limitBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__limitBits(struct soap *soap, const char *s, enum ns1__limitBits *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__limitBits, s);
	if (map)
		*a = (enum ns1__limitBits)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__limitBits)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__limitBits * SOAP_FMAC4 soap_in_ns1__limitBits(struct soap *soap, const char *tag, enum ns1__limitBits *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__limitBits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__limitBits, sizeof(enum ns1__limitBits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__limitBits(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__limitBits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__limitBits, 0, sizeof(enum ns1__limitBits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__qualityBits(struct soap *soap, enum ns1__qualityBits *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__qualityBits
	*a = SOAP_DEFAULT_ns1__qualityBits;
#else
	*a = (enum ns1__qualityBits)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__qualityBits(struct soap *soap, const enum ns1__qualityBits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__qualityBits);
	if (soap_out_ns1__qualityBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__qualityBits[] =
{	{ (long)ns1__qualityBits__bad, "bad" },
	{ (long)ns1__qualityBits__badConfigurationError, "badConfigurationError" },
	{ (long)ns1__qualityBits__badNotConnected, "badNotConnected" },
	{ (long)ns1__qualityBits__badDeviceFailure, "badDeviceFailure" },
	{ (long)ns1__qualityBits__badSensorFailure, "badSensorFailure" },
	{ (long)ns1__qualityBits__badLastKnownValue, "badLastKnownValue" },
	{ (long)ns1__qualityBits__badCommFailure, "badCommFailure" },
	{ (long)ns1__qualityBits__badOutOfService, "badOutOfService" },
	{ (long)ns1__qualityBits__badWaitingForInitialData, "badWaitingForInitialData" },
	{ (long)ns1__qualityBits__uncertain, "uncertain" },
	{ (long)ns1__qualityBits__uncertainLastUsableValue, "uncertainLastUsableValue" },
	{ (long)ns1__qualityBits__uncertainSensorNotAccurate, "uncertainSensorNotAccurate" },
	{ (long)ns1__qualityBits__uncertainEUExceeded, "uncertainEUExceeded" },
	{ (long)ns1__qualityBits__uncertainSubNormal, "uncertainSubNormal" },
	{ (long)ns1__qualityBits__good, "good" },
	{ (long)ns1__qualityBits__goodLocalOverride, "goodLocalOverride" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__qualityBits2s(struct soap *soap, enum ns1__qualityBits n)
{	const char *s = soap_code_str(soap_codes_ns1__qualityBits, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__qualityBits(struct soap *soap, const char *tag, int id, const enum ns1__qualityBits *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__qualityBits), type);
	soap_send(soap, soap_ns1__qualityBits2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__qualityBits * SOAP_FMAC4 soap_get_ns1__qualityBits(struct soap *soap, enum ns1__qualityBits *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__qualityBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__qualityBits(struct soap *soap, const char *s, enum ns1__qualityBits *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__qualityBits, s);
	if (map)
		*a = (enum ns1__qualityBits)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 15)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__qualityBits)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__qualityBits * SOAP_FMAC4 soap_in_ns1__qualityBits(struct soap *soap, const char *tag, enum ns1__qualityBits *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__qualityBits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__qualityBits, sizeof(enum ns1__qualityBits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__qualityBits(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__qualityBits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__qualityBits, 0, sizeof(enum ns1__qualityBits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__interfaceVersion(struct soap *soap, enum ns1__interfaceVersion *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__interfaceVersion
	*a = SOAP_DEFAULT_ns1__interfaceVersion;
#else
	*a = (enum ns1__interfaceVersion)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__interfaceVersion(struct soap *soap, const enum ns1__interfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__interfaceVersion);
	if (soap_out_ns1__interfaceVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__interfaceVersion[] =
{	{ (long)ns1__interfaceVersion__XML_USCOREDA_USCOREVersion_USCORE1_USCORE0, "XML_DA_Version_1_0" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__interfaceVersion2s(struct soap *soap, enum ns1__interfaceVersion n)
{	const char *s = soap_code_str(soap_codes_ns1__interfaceVersion, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__interfaceVersion(struct soap *soap, const char *tag, int id, const enum ns1__interfaceVersion *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__interfaceVersion), type);
	soap_send(soap, soap_ns1__interfaceVersion2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__interfaceVersion * SOAP_FMAC4 soap_get_ns1__interfaceVersion(struct soap *soap, enum ns1__interfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__interfaceVersion(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__interfaceVersion(struct soap *soap, const char *s, enum ns1__interfaceVersion *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__interfaceVersion, s);
	if (map)
		*a = (enum ns1__interfaceVersion)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__interfaceVersion)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__interfaceVersion * SOAP_FMAC4 soap_in_ns1__interfaceVersion(struct soap *soap, const char *tag, enum ns1__interfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__interfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__interfaceVersion, sizeof(enum ns1__interfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__interfaceVersion(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__interfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__interfaceVersion, 0, sizeof(enum ns1__interfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__serverState(struct soap *soap, enum ns1__serverState *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__serverState
	*a = SOAP_DEFAULT_ns1__serverState;
#else
	*a = (enum ns1__serverState)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__serverState(struct soap *soap, const enum ns1__serverState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__serverState);
	if (soap_out_ns1__serverState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__serverState[] =
{	{ (long)ns1__serverState__running, "running" },
	{ (long)ns1__serverState__failed, "failed" },
	{ (long)ns1__serverState__noConfig, "noConfig" },
	{ (long)ns1__serverState__suspended, "suspended" },
	{ (long)ns1__serverState__test, "test" },
	{ (long)ns1__serverState__commFault, "commFault" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__serverState2s(struct soap *soap, enum ns1__serverState n)
{	const char *s = soap_code_str(soap_codes_ns1__serverState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__serverState(struct soap *soap, const char *tag, int id, const enum ns1__serverState *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__serverState), type);
	soap_send(soap, soap_ns1__serverState2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__serverState * SOAP_FMAC4 soap_get_ns1__serverState(struct soap *soap, enum ns1__serverState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__serverState(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__serverState(struct soap *soap, const char *s, enum ns1__serverState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__serverState, s);
	if (map)
		*a = (enum ns1__serverState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__serverState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__serverState * SOAP_FMAC4 soap_in_ns1__serverState(struct soap *soap, const char *tag, enum ns1__serverState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__serverState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__serverState, sizeof(enum ns1__serverState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__serverState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__serverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__serverState, 0, sizeof(enum ns1__serverState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns1__GetPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__GetPropertiesResponse*)this)->GetPropertiesResult = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, &((_ns1__GetPropertiesResponse*)this)->PropertyLists);
	soap_default_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__GetPropertiesResponse*)this)->Errors);
	/* transient soap skipped */
}

void _ns1__GetPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__GetPropertiesResponse*)this)->GetPropertiesResult);
	soap_serialize_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, &((_ns1__GetPropertiesResponse*)this)->PropertyLists);
	soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__GetPropertiesResponse*)this)->Errors);
	/* transient soap skipped */
}

int _ns1__GetPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPropertiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPropertiesResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPropertiesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPropertiesResponse), type);
	if (a->GetPropertiesResult)
		soap_element_result(soap, "ns1:GetPropertiesResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:GetPropertiesResult", -1, &(((_ns1__GetPropertiesResponse*)a)->GetPropertiesResult), "");
	soap_out_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, "ns1:PropertyLists", -1, &(((_ns1__GetPropertiesResponse*)a)->PropertyLists), "");
	soap_out_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", -1, &(((_ns1__GetPropertiesResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__GetPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPropertiesResponse * SOAP_FMAC4 soap_get__ns1__GetPropertiesResponse(struct soap *soap, _ns1__GetPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPropertiesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__GetPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPropertiesResponse * SOAP_FMAC4 soap_in__ns1__GetPropertiesResponse(struct soap *soap, const char *tag, _ns1__GetPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPropertiesResponse, sizeof(_ns1__GetPropertiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPropertiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPropertiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetPropertiesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPropertiesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:GetPropertiesResult", &(((_ns1__GetPropertiesResponse*)a)->GetPropertiesResult), "ns1:ReplyBase"))
				{	soap_flag_GetPropertiesResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, "ns1:PropertyLists", &(((_ns1__GetPropertiesResponse*)a)->PropertyLists), "ns1:PropertyReplyList"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", &(((_ns1__GetPropertiesResponse*)a)->Errors), "ns1:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPropertiesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPropertiesResponse, 0, sizeof(_ns1__GetPropertiesResponse), 0, soap_copy__ns1__GetPropertiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__GetPropertiesResponse * SOAP_FMAC6 soap_new__ns1__GetPropertiesResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__GetPropertiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__GetPropertiesResponse(struct soap *soap, _ns1__GetPropertiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__GetPropertiesResponse * SOAP_FMAC4 soap_instantiate__ns1__GetPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPropertiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPropertiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetPropertiesResponse;
		if (size)
			*size = sizeof(_ns1__GetPropertiesResponse);
		((_ns1__GetPropertiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetPropertiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetPropertiesResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetPropertiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetPropertiesResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPropertiesResponse %p -> %p\n", q, p));
	*(_ns1__GetPropertiesResponse*)p = *(_ns1__GetPropertiesResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__GetProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, &((_ns1__GetProperties*)this)->ItemIDs);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &((_ns1__GetProperties*)this)->PropertyNames);
	((_ns1__GetProperties*)this)->LocaleID = NULL;
	((_ns1__GetProperties*)this)->ClientRequestHandle = NULL;
	((_ns1__GetProperties*)this)->ItemPath = NULL;
	((_ns1__GetProperties*)this)->ReturnAllProperties = NULL;
	((_ns1__GetProperties*)this)->ReturnPropertyValues = NULL;
	((_ns1__GetProperties*)this)->ReturnErrorText = NULL;
	/* transient soap skipped */
}

void _ns1__GetProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, &((_ns1__GetProperties*)this)->ItemIDs);
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &((_ns1__GetProperties*)this)->PropertyNames);
	/* transient soap skipped */
}

int _ns1__GetProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetProperties);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetProperties(struct soap *soap, const char *tag, int id, const _ns1__GetProperties *a, const char *type)
{
	if (((_ns1__GetProperties *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((_ns1__GetProperties *)a)->LocaleID->c_str());
	if (((_ns1__GetProperties *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_ns1__GetProperties *)a)->ClientRequestHandle->c_str());
	if (((_ns1__GetProperties *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((_ns1__GetProperties *)a)->ItemPath->c_str());
	if (((_ns1__GetProperties *)a)->ReturnAllProperties)
		soap_set_attr(soap, "ReturnAllProperties", soap_bool2s(soap, *((_ns1__GetProperties *)a)->ReturnAllProperties));
	if (((_ns1__GetProperties *)a)->ReturnPropertyValues)
		soap_set_attr(soap, "ReturnPropertyValues", soap_bool2s(soap, *((_ns1__GetProperties *)a)->ReturnPropertyValues));
	if (((_ns1__GetProperties *)a)->ReturnErrorText)
		soap_set_attr(soap, "ReturnErrorText", soap_bool2s(soap, *((_ns1__GetProperties *)a)->ReturnErrorText));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetProperties), type);
	soap_out_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, "ns1:ItemIDs", -1, &(((_ns1__GetProperties*)a)->ItemIDs), "");
	soap_out_std__vectorTemplateOfxsd__QName(soap, "ns1:PropertyNames", -1, &(((_ns1__GetProperties*)a)->PropertyNames), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__GetProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetProperties(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetProperties * SOAP_FMAC4 soap_get__ns1__GetProperties(struct soap *soap, _ns1__GetProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__GetProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetProperties(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetProperties * SOAP_FMAC4 soap_in__ns1__GetProperties(struct soap *soap, const char *tag, _ns1__GetProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetProperties, sizeof(_ns1__GetProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetProperties *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((_ns1__GetProperties *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__GetProperties *)a)->LocaleID = soap_new_std__string(soap, -1);
			((_ns1__GetProperties *)a)->LocaleID->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_ns1__GetProperties *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__GetProperties *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_ns1__GetProperties *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((_ns1__GetProperties *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__GetProperties *)a)->ItemPath = soap_new_std__string(soap, -1);
			((_ns1__GetProperties *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnAllProperties", 0);
		if (t)
		{	if (!(((_ns1__GetProperties *)a)->ReturnAllProperties = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__GetProperties *)a)->ReturnAllProperties))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnPropertyValues", 0);
		if (t)
		{	if (!(((_ns1__GetProperties *)a)->ReturnPropertyValues = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__GetProperties *)a)->ReturnPropertyValues))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnErrorText", 0);
		if (t)
		{	if (!(((_ns1__GetProperties *)a)->ReturnErrorText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__GetProperties *)a)->ReturnErrorText))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, "ns1:ItemIDs", &(((_ns1__GetProperties*)a)->ItemIDs), "ns1:ItemIdentifier"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns1:PropertyNames", &(((_ns1__GetProperties*)a)->PropertyNames), "xsd:QName"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetProperties, 0, sizeof(_ns1__GetProperties), 0, soap_copy__ns1__GetProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__GetProperties * SOAP_FMAC6 soap_new__ns1__GetProperties(struct soap *soap, int n)
{	return soap_instantiate__ns1__GetProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__GetProperties(struct soap *soap, _ns1__GetProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__GetProperties * SOAP_FMAC4 soap_instantiate__ns1__GetProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetProperties;
		if (size)
			*size = sizeof(_ns1__GetProperties);
		((_ns1__GetProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetProperties);
		for (int i = 0; i < n; i++)
			((_ns1__GetProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetProperties*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetProperties %p -> %p\n", q, p));
	*(_ns1__GetProperties*)p = *(_ns1__GetProperties*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__BrowseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__BrowseResponse*)this)->BrowseResult = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__BrowseElement(soap, &((_ns1__BrowseResponse*)this)->Elements);
	soap_default_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__BrowseResponse*)this)->Errors);
	((_ns1__BrowseResponse*)this)->ContinuationPoint = NULL;
	((_ns1__BrowseResponse*)this)->MoreElements = NULL;
	/* transient soap skipped */
}

void _ns1__BrowseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__BrowseResponse*)this)->BrowseResult);
	soap_serialize_std__vectorTemplateOfPointerTons1__BrowseElement(soap, &((_ns1__BrowseResponse*)this)->Elements);
	soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__BrowseResponse*)this)->Errors);
	/* transient soap skipped */
}

int _ns1__BrowseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__BrowseResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__BrowseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BrowseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BrowseResponse(struct soap *soap, const char *tag, int id, const _ns1__BrowseResponse *a, const char *type)
{
	if (((_ns1__BrowseResponse *)a)->ContinuationPoint)
		soap_set_attr(soap, "ContinuationPoint", ((_ns1__BrowseResponse *)a)->ContinuationPoint->c_str());
	if (((_ns1__BrowseResponse *)a)->MoreElements)
		soap_set_attr(soap, "MoreElements", soap_bool2s(soap, *((_ns1__BrowseResponse *)a)->MoreElements));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BrowseResponse), type);
	if (a->BrowseResult)
		soap_element_result(soap, "ns1:BrowseResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:BrowseResult", -1, &(((_ns1__BrowseResponse*)a)->BrowseResult), "");
	soap_out_std__vectorTemplateOfPointerTons1__BrowseElement(soap, "ns1:Elements", -1, &(((_ns1__BrowseResponse*)a)->Elements), "");
	soap_out_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", -1, &(((_ns1__BrowseResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__BrowseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BrowseResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BrowseResponse * SOAP_FMAC4 soap_get__ns1__BrowseResponse(struct soap *soap, _ns1__BrowseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BrowseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__BrowseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BrowseResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BrowseResponse * SOAP_FMAC4 soap_in__ns1__BrowseResponse(struct soap *soap, const char *tag, _ns1__BrowseResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BrowseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BrowseResponse, sizeof(_ns1__BrowseResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__BrowseResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__BrowseResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ContinuationPoint", 0);
		if (t)
		{	if (!(((_ns1__BrowseResponse *)a)->ContinuationPoint = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__BrowseResponse *)a)->ContinuationPoint = soap_new_std__string(soap, -1);
			((_ns1__BrowseResponse *)a)->ContinuationPoint->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MoreElements", 0);
		if (t)
		{	if (!(((_ns1__BrowseResponse *)a)->MoreElements = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__BrowseResponse *)a)->MoreElements))
		return NULL;
		}
	}
	short soap_flag_BrowseResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BrowseResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:BrowseResult", &(((_ns1__BrowseResponse*)a)->BrowseResult), "ns1:ReplyBase"))
				{	soap_flag_BrowseResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__BrowseElement(soap, "ns1:Elements", &(((_ns1__BrowseResponse*)a)->Elements), "ns1:BrowseElement"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", &(((_ns1__BrowseResponse*)a)->Errors), "ns1:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:BrowseResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__BrowseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BrowseResponse, 0, sizeof(_ns1__BrowseResponse), 0, soap_copy__ns1__BrowseResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__BrowseResponse * SOAP_FMAC6 soap_new__ns1__BrowseResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__BrowseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__BrowseResponse(struct soap *soap, _ns1__BrowseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__BrowseResponse * SOAP_FMAC4 soap_instantiate__ns1__BrowseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BrowseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__BrowseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__BrowseResponse;
		if (size)
			*size = sizeof(_ns1__BrowseResponse);
		((_ns1__BrowseResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__BrowseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__BrowseResponse);
		for (int i = 0; i < n; i++)
			((_ns1__BrowseResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__BrowseResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__BrowseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__BrowseResponse %p -> %p\n", q, p));
	*(_ns1__BrowseResponse*)p = *(_ns1__BrowseResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__Browse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &((_ns1__Browse*)this)->PropertyNames);
	((_ns1__Browse*)this)->LocaleID = NULL;
	((_ns1__Browse*)this)->ClientRequestHandle = NULL;
	((_ns1__Browse*)this)->ItemPath = NULL;
	((_ns1__Browse*)this)->ItemName = NULL;
	((_ns1__Browse*)this)->ContinuationPoint = NULL;
	((_ns1__Browse*)this)->MaxElementsReturned = NULL;
	((_ns1__Browse*)this)->BrowseFilter = NULL;
	((_ns1__Browse*)this)->ElementNameFilter = NULL;
	((_ns1__Browse*)this)->VendorFilter = NULL;
	((_ns1__Browse*)this)->ReturnAllProperties = NULL;
	((_ns1__Browse*)this)->ReturnPropertyValues = NULL;
	((_ns1__Browse*)this)->ReturnErrorText = NULL;
	/* transient soap skipped */
}

void _ns1__Browse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &((_ns1__Browse*)this)->PropertyNames);
	/* transient soap skipped */
}

int _ns1__Browse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Browse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__Browse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Browse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Browse(struct soap *soap, const char *tag, int id, const _ns1__Browse *a, const char *type)
{
	if (((_ns1__Browse *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((_ns1__Browse *)a)->LocaleID->c_str());
	if (((_ns1__Browse *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_ns1__Browse *)a)->ClientRequestHandle->c_str());
	if (((_ns1__Browse *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((_ns1__Browse *)a)->ItemPath->c_str());
	if (((_ns1__Browse *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((_ns1__Browse *)a)->ItemName->c_str());
	if (((_ns1__Browse *)a)->ContinuationPoint)
		soap_set_attr(soap, "ContinuationPoint", ((_ns1__Browse *)a)->ContinuationPoint->c_str());
	if (((_ns1__Browse *)a)->MaxElementsReturned)
		soap_set_attr(soap, "MaxElementsReturned", soap_int2s(soap, *((_ns1__Browse *)a)->MaxElementsReturned));
	if (((_ns1__Browse *)a)->BrowseFilter)
		soap_set_attr(soap, "BrowseFilter", soap_ns1__browseFilter2s(soap, *((_ns1__Browse *)a)->BrowseFilter));
	if (((_ns1__Browse *)a)->ElementNameFilter)
		soap_set_attr(soap, "ElementNameFilter", ((_ns1__Browse *)a)->ElementNameFilter->c_str());
	if (((_ns1__Browse *)a)->VendorFilter)
		soap_set_attr(soap, "VendorFilter", ((_ns1__Browse *)a)->VendorFilter->c_str());
	if (((_ns1__Browse *)a)->ReturnAllProperties)
		soap_set_attr(soap, "ReturnAllProperties", soap_bool2s(soap, *((_ns1__Browse *)a)->ReturnAllProperties));
	if (((_ns1__Browse *)a)->ReturnPropertyValues)
		soap_set_attr(soap, "ReturnPropertyValues", soap_bool2s(soap, *((_ns1__Browse *)a)->ReturnPropertyValues));
	if (((_ns1__Browse *)a)->ReturnErrorText)
		soap_set_attr(soap, "ReturnErrorText", soap_bool2s(soap, *((_ns1__Browse *)a)->ReturnErrorText));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Browse), type);
	soap_out_std__vectorTemplateOfxsd__QName(soap, "ns1:PropertyNames", -1, &(((_ns1__Browse*)a)->PropertyNames), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__Browse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Browse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Browse * SOAP_FMAC4 soap_get__ns1__Browse(struct soap *soap, _ns1__Browse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Browse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__Browse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Browse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Browse * SOAP_FMAC4 soap_in__ns1__Browse(struct soap *soap, const char *tag, _ns1__Browse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Browse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Browse, sizeof(_ns1__Browse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Browse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Browse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->LocaleID = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->LocaleID->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->ItemPath = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->ItemName = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ContinuationPoint", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ContinuationPoint = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->ContinuationPoint = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->ContinuationPoint->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MaxElementsReturned", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->MaxElementsReturned = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((_ns1__Browse *)a)->MaxElementsReturned))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "BrowseFilter", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->BrowseFilter = (enum ns1__browseFilter *)soap_malloc(soap, sizeof(enum ns1__browseFilter))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2ns1__browseFilter(soap, t, ((_ns1__Browse *)a)->BrowseFilter))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ElementNameFilter", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ElementNameFilter = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->ElementNameFilter = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->ElementNameFilter->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "VendorFilter", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->VendorFilter = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__Browse *)a)->VendorFilter = soap_new_std__string(soap, -1);
			((_ns1__Browse *)a)->VendorFilter->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnAllProperties", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ReturnAllProperties = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__Browse *)a)->ReturnAllProperties))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnPropertyValues", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ReturnPropertyValues = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__Browse *)a)->ReturnPropertyValues))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnErrorText", 0);
		if (t)
		{	if (!(((_ns1__Browse *)a)->ReturnErrorText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__Browse *)a)->ReturnErrorText))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "ns1:PropertyNames", &(((_ns1__Browse*)a)->PropertyNames), "xsd:QName"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Browse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Browse, 0, sizeof(_ns1__Browse), 0, soap_copy__ns1__Browse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__Browse * SOAP_FMAC6 soap_new__ns1__Browse(struct soap *soap, int n)
{	return soap_instantiate__ns1__Browse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__Browse(struct soap *soap, _ns1__Browse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__Browse * SOAP_FMAC4 soap_instantiate__ns1__Browse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Browse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Browse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__Browse;
		if (size)
			*size = sizeof(_ns1__Browse);
		((_ns1__Browse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__Browse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__Browse);
		for (int i = 0; i < n; i++)
			((_ns1__Browse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__Browse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Browse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Browse %p -> %p\n", q, p));
	*(_ns1__Browse*)p = *(_ns1__Browse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__SubscriptionCancelResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__SubscriptionCancelResponse*)this)->ClientRequestHandle = NULL;
	/* transient soap skipped */
}

void _ns1__SubscriptionCancelResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SubscriptionCancelResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubscriptionCancelResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SubscriptionCancelResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubscriptionCancelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubscriptionCancelResponse(struct soap *soap, const char *tag, int id, const _ns1__SubscriptionCancelResponse *a, const char *type)
{
	if (((_ns1__SubscriptionCancelResponse *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_ns1__SubscriptionCancelResponse *)a)->ClientRequestHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubscriptionCancelResponse), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__SubscriptionCancelResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubscriptionCancelResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubscriptionCancelResponse * SOAP_FMAC4 soap_get__ns1__SubscriptionCancelResponse(struct soap *soap, _ns1__SubscriptionCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubscriptionCancelResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__SubscriptionCancelResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubscriptionCancelResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubscriptionCancelResponse * SOAP_FMAC4 soap_in__ns1__SubscriptionCancelResponse(struct soap *soap, const char *tag, _ns1__SubscriptionCancelResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubscriptionCancelResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubscriptionCancelResponse, sizeof(_ns1__SubscriptionCancelResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubscriptionCancelResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubscriptionCancelResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionCancelResponse *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__SubscriptionCancelResponse *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_ns1__SubscriptionCancelResponse *)a)->ClientRequestHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubscriptionCancelResponse, 0, sizeof(_ns1__SubscriptionCancelResponse), 0, soap_copy__ns1__SubscriptionCancelResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__SubscriptionCancelResponse * SOAP_FMAC6 soap_new__ns1__SubscriptionCancelResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__SubscriptionCancelResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__SubscriptionCancelResponse(struct soap *soap, _ns1__SubscriptionCancelResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__SubscriptionCancelResponse * SOAP_FMAC4 soap_instantiate__ns1__SubscriptionCancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubscriptionCancelResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubscriptionCancelResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SubscriptionCancelResponse;
		if (size)
			*size = sizeof(_ns1__SubscriptionCancelResponse);
		((_ns1__SubscriptionCancelResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SubscriptionCancelResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubscriptionCancelResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SubscriptionCancelResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubscriptionCancelResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubscriptionCancelResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubscriptionCancelResponse %p -> %p\n", q, p));
	*(_ns1__SubscriptionCancelResponse*)p = *(_ns1__SubscriptionCancelResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__SubscriptionCancel::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__SubscriptionCancel*)this)->ServerSubHandle = NULL;
	((_ns1__SubscriptionCancel*)this)->ClientRequestHandle = NULL;
	/* transient soap skipped */
}

void _ns1__SubscriptionCancel::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__SubscriptionCancel::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubscriptionCancel);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SubscriptionCancel::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubscriptionCancel(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubscriptionCancel(struct soap *soap, const char *tag, int id, const _ns1__SubscriptionCancel *a, const char *type)
{
	if (((_ns1__SubscriptionCancel *)a)->ServerSubHandle)
		soap_set_attr(soap, "ServerSubHandle", ((_ns1__SubscriptionCancel *)a)->ServerSubHandle->c_str());
	if (((_ns1__SubscriptionCancel *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_ns1__SubscriptionCancel *)a)->ClientRequestHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubscriptionCancel), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__SubscriptionCancel::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubscriptionCancel(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubscriptionCancel * SOAP_FMAC4 soap_get__ns1__SubscriptionCancel(struct soap *soap, _ns1__SubscriptionCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubscriptionCancel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__SubscriptionCancel::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubscriptionCancel(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubscriptionCancel * SOAP_FMAC4 soap_in__ns1__SubscriptionCancel(struct soap *soap, const char *tag, _ns1__SubscriptionCancel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubscriptionCancel *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubscriptionCancel, sizeof(_ns1__SubscriptionCancel), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubscriptionCancel)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubscriptionCancel *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ServerSubHandle", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionCancel *)a)->ServerSubHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__SubscriptionCancel *)a)->ServerSubHandle = soap_new_std__string(soap, -1);
			((_ns1__SubscriptionCancel *)a)->ServerSubHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionCancel *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__SubscriptionCancel *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_ns1__SubscriptionCancel *)a)->ClientRequestHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionCancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubscriptionCancel, 0, sizeof(_ns1__SubscriptionCancel), 0, soap_copy__ns1__SubscriptionCancel);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__SubscriptionCancel * SOAP_FMAC6 soap_new__ns1__SubscriptionCancel(struct soap *soap, int n)
{	return soap_instantiate__ns1__SubscriptionCancel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__SubscriptionCancel(struct soap *soap, _ns1__SubscriptionCancel *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__SubscriptionCancel * SOAP_FMAC4 soap_instantiate__ns1__SubscriptionCancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubscriptionCancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubscriptionCancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SubscriptionCancel;
		if (size)
			*size = sizeof(_ns1__SubscriptionCancel);
		((_ns1__SubscriptionCancel*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SubscriptionCancel[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubscriptionCancel);
		for (int i = 0; i < n; i++)
			((_ns1__SubscriptionCancel*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubscriptionCancel*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubscriptionCancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubscriptionCancel %p -> %p\n", q, p));
	*(_ns1__SubscriptionCancel*)p = *(_ns1__SubscriptionCancel*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__SubscriptionPolledRefreshResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__SubscriptionPolledRefreshResponse*)this)->SubscriptionPolledRefreshResult = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->InvalidServerSubHandles);
	soap_default_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->RItemList);
	soap_default_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->Errors);
	((_ns1__SubscriptionPolledRefreshResponse*)this)->DataBufferOverflow = NULL;
	/* transient soap skipped */
}

void _ns1__SubscriptionPolledRefreshResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->SubscriptionPolledRefreshResult);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->InvalidServerSubHandles);
	soap_serialize_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__SubscriptionPolledRefreshResponse*)this)->Errors);
	/* transient soap skipped */
}

int _ns1__SubscriptionPolledRefreshResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SubscriptionPolledRefreshResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubscriptionPolledRefreshResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, int id, const _ns1__SubscriptionPolledRefreshResponse *a, const char *type)
{
	if (((_ns1__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow)
		soap_set_attr(soap, "DataBufferOverflow", soap_bool2s(soap, *((_ns1__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse), type);
	if (a->SubscriptionPolledRefreshResult)
		soap_element_result(soap, "ns1:SubscriptionPolledRefreshResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:SubscriptionPolledRefreshResult", -1, &(((_ns1__SubscriptionPolledRefreshResponse*)a)->SubscriptionPolledRefreshResult), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns1:InvalidServerSubHandles", -1, &(((_ns1__SubscriptionPolledRefreshResponse*)a)->InvalidServerSubHandles), "");
	soap_out_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, "ns1:RItemList", -1, &(((_ns1__SubscriptionPolledRefreshResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", -1, &(((_ns1__SubscriptionPolledRefreshResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__SubscriptionPolledRefreshResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubscriptionPolledRefreshResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefreshResponse * SOAP_FMAC4 soap_get__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, _ns1__SubscriptionPolledRefreshResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubscriptionPolledRefreshResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__SubscriptionPolledRefreshResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubscriptionPolledRefreshResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefreshResponse * SOAP_FMAC4 soap_in__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, _ns1__SubscriptionPolledRefreshResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubscriptionPolledRefreshResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse, sizeof(_ns1__SubscriptionPolledRefreshResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubscriptionPolledRefreshResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "DataBufferOverflow", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow))
		return NULL;
		}
	}
	short soap_flag_SubscriptionPolledRefreshResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionPolledRefreshResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:SubscriptionPolledRefreshResult", &(((_ns1__SubscriptionPolledRefreshResponse*)a)->SubscriptionPolledRefreshResult), "ns1:ReplyBase"))
				{	soap_flag_SubscriptionPolledRefreshResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:InvalidServerSubHandles", &(((_ns1__SubscriptionPolledRefreshResponse*)a)->InvalidServerSubHandles), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, "ns1:RItemList", &(((_ns1__SubscriptionPolledRefreshResponse*)a)->RItemList), "ns1:SubscribePolledRefreshReplyItemList"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", &(((_ns1__SubscriptionPolledRefreshResponse*)a)->Errors), "ns1:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SubscriptionPolledRefreshResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionPolledRefreshResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse, 0, sizeof(_ns1__SubscriptionPolledRefreshResponse), 0, soap_copy__ns1__SubscriptionPolledRefreshResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__SubscriptionPolledRefreshResponse * SOAP_FMAC6 soap_new__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__SubscriptionPolledRefreshResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, _ns1__SubscriptionPolledRefreshResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefreshResponse * SOAP_FMAC4 soap_instantiate__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubscriptionPolledRefreshResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SubscriptionPolledRefreshResponse;
		if (size)
			*size = sizeof(_ns1__SubscriptionPolledRefreshResponse);
		((_ns1__SubscriptionPolledRefreshResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SubscriptionPolledRefreshResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubscriptionPolledRefreshResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SubscriptionPolledRefreshResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubscriptionPolledRefreshResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubscriptionPolledRefreshResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubscriptionPolledRefreshResponse %p -> %p\n", q, p));
	*(_ns1__SubscriptionPolledRefreshResponse*)p = *(_ns1__SubscriptionPolledRefreshResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__SubscriptionPolledRefresh::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__SubscriptionPolledRefresh*)this)->Options = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((_ns1__SubscriptionPolledRefresh*)this)->ServerSubHandles);
	((_ns1__SubscriptionPolledRefresh*)this)->HoldTime = NULL;
	((_ns1__SubscriptionPolledRefresh*)this)->WaitTime = NULL;
	((_ns1__SubscriptionPolledRefresh*)this)->ReturnAllItems = NULL;
	/* transient soap skipped */
}

void _ns1__SubscriptionPolledRefresh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RequestOptions(soap, &((_ns1__SubscriptionPolledRefresh*)this)->Options);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((_ns1__SubscriptionPolledRefresh*)this)->ServerSubHandles);
	/* transient soap skipped */
}

int _ns1__SubscriptionPolledRefresh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubscriptionPolledRefresh);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SubscriptionPolledRefresh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubscriptionPolledRefresh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubscriptionPolledRefresh(struct soap *soap, const char *tag, int id, const _ns1__SubscriptionPolledRefresh *a, const char *type)
{
	if (((_ns1__SubscriptionPolledRefresh *)a)->HoldTime)
		soap_set_attr(soap, "HoldTime", soap_dateTime2s(soap, *((_ns1__SubscriptionPolledRefresh *)a)->HoldTime));
	if (((_ns1__SubscriptionPolledRefresh *)a)->WaitTime)
		soap_set_attr(soap, "WaitTime", soap_int2s(soap, *((_ns1__SubscriptionPolledRefresh *)a)->WaitTime));
	if (((_ns1__SubscriptionPolledRefresh *)a)->ReturnAllItems)
		soap_set_attr(soap, "ReturnAllItems", soap_bool2s(soap, *((_ns1__SubscriptionPolledRefresh *)a)->ReturnAllItems));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubscriptionPolledRefresh), type);
	soap_out_PointerTons1__RequestOptions(soap, "ns1:Options", -1, &(((_ns1__SubscriptionPolledRefresh*)a)->Options), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns1:ServerSubHandles", -1, &(((_ns1__SubscriptionPolledRefresh*)a)->ServerSubHandles), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__SubscriptionPolledRefresh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubscriptionPolledRefresh(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefresh * SOAP_FMAC4 soap_get__ns1__SubscriptionPolledRefresh(struct soap *soap, _ns1__SubscriptionPolledRefresh *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubscriptionPolledRefresh(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__SubscriptionPolledRefresh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubscriptionPolledRefresh(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefresh * SOAP_FMAC4 soap_in__ns1__SubscriptionPolledRefresh(struct soap *soap, const char *tag, _ns1__SubscriptionPolledRefresh *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubscriptionPolledRefresh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubscriptionPolledRefresh, sizeof(_ns1__SubscriptionPolledRefresh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubscriptionPolledRefresh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubscriptionPolledRefresh *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "HoldTime", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionPolledRefresh *)a)->HoldTime = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2dateTime(soap, t, ((_ns1__SubscriptionPolledRefresh *)a)->HoldTime))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "WaitTime", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionPolledRefresh *)a)->WaitTime = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((_ns1__SubscriptionPolledRefresh *)a)->WaitTime))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnAllItems", 0);
		if (t)
		{	if (!(((_ns1__SubscriptionPolledRefresh *)a)->ReturnAllItems = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_ns1__SubscriptionPolledRefresh *)a)->ReturnAllItems))
		return NULL;
		}
	}
	short soap_flag_Options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RequestOptions(soap, "ns1:Options", &(((_ns1__SubscriptionPolledRefresh*)a)->Options), "ns1:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:ServerSubHandles", &(((_ns1__SubscriptionPolledRefresh*)a)->ServerSubHandles), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionPolledRefresh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubscriptionPolledRefresh, 0, sizeof(_ns1__SubscriptionPolledRefresh), 0, soap_copy__ns1__SubscriptionPolledRefresh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__SubscriptionPolledRefresh * SOAP_FMAC6 soap_new__ns1__SubscriptionPolledRefresh(struct soap *soap, int n)
{	return soap_instantiate__ns1__SubscriptionPolledRefresh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__SubscriptionPolledRefresh(struct soap *soap, _ns1__SubscriptionPolledRefresh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefresh * SOAP_FMAC4 soap_instantiate__ns1__SubscriptionPolledRefresh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubscriptionPolledRefresh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubscriptionPolledRefresh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SubscriptionPolledRefresh;
		if (size)
			*size = sizeof(_ns1__SubscriptionPolledRefresh);
		((_ns1__SubscriptionPolledRefresh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SubscriptionPolledRefresh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubscriptionPolledRefresh);
		for (int i = 0; i < n; i++)
			((_ns1__SubscriptionPolledRefresh*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubscriptionPolledRefresh*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubscriptionPolledRefresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubscriptionPolledRefresh %p -> %p\n", q, p));
	*(_ns1__SubscriptionPolledRefresh*)p = *(_ns1__SubscriptionPolledRefresh*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__SubscribeResponse*)this)->SubscribeResult = NULL;
	((_ns1__SubscribeResponse*)this)->RItemList = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__SubscribeResponse*)this)->Errors);
	((_ns1__SubscribeResponse*)this)->ServerSubHandle = NULL;
	/* transient soap skipped */
}

void _ns1__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__SubscribeResponse*)this)->SubscribeResult);
	soap_serialize_PointerTons1__SubscribeReplyItemList(soap, &((_ns1__SubscribeResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__SubscribeResponse*)this)->Errors);
	/* transient soap skipped */
}

int _ns1__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__SubscribeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SubscribeResponse(struct soap *soap, const char *tag, int id, const _ns1__SubscribeResponse *a, const char *type)
{
	if (((_ns1__SubscribeResponse *)a)->ServerSubHandle)
		soap_set_attr(soap, "ServerSubHandle", ((_ns1__SubscribeResponse *)a)->ServerSubHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SubscribeResponse), type);
	if (a->SubscribeResult)
		soap_element_result(soap, "ns1:SubscribeResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:SubscribeResult", -1, &(((_ns1__SubscribeResponse*)a)->SubscribeResult), "");
	soap_out_PointerTons1__SubscribeReplyItemList(soap, "ns1:RItemList", -1, &(((_ns1__SubscribeResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", -1, &(((_ns1__SubscribeResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SubscribeResponse * SOAP_FMAC4 soap_get__ns1__SubscribeResponse(struct soap *soap, _ns1__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SubscribeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SubscribeResponse * SOAP_FMAC4 soap_in__ns1__SubscribeResponse(struct soap *soap, const char *tag, _ns1__SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SubscribeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SubscribeResponse, sizeof(_ns1__SubscribeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SubscribeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SubscribeResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ServerSubHandle", 0);
		if (t)
		{	if (!(((_ns1__SubscribeResponse *)a)->ServerSubHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__SubscribeResponse *)a)->ServerSubHandle = soap_new_std__string(soap, -1);
			((_ns1__SubscribeResponse *)a)->ServerSubHandle->assign(s);
		}
		}
	}
	short soap_flag_SubscribeResult1 = 1, soap_flag_RItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscribeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:SubscribeResult", &(((_ns1__SubscribeResponse*)a)->SubscribeResult), "ns1:ReplyBase"))
				{	soap_flag_SubscribeResult1--;
					continue;
				}
			if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SubscribeReplyItemList(soap, "ns1:RItemList", &(((_ns1__SubscribeResponse*)a)->RItemList), "ns1:SubscribeReplyItemList"))
				{	soap_flag_RItemList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", &(((_ns1__SubscribeResponse*)a)->Errors), "ns1:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SubscribeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SubscribeResponse, 0, sizeof(_ns1__SubscribeResponse), 0, soap_copy__ns1__SubscribeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__SubscribeResponse * SOAP_FMAC6 soap_new__ns1__SubscribeResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__SubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__SubscribeResponse(struct soap *soap, _ns1__SubscribeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__SubscribeResponse * SOAP_FMAC4 soap_instantiate__ns1__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__SubscribeResponse;
		if (size)
			*size = sizeof(_ns1__SubscribeResponse);
		((_ns1__SubscribeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__SubscribeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__SubscribeResponse);
		for (int i = 0; i < n; i++)
			((_ns1__SubscribeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__SubscribeResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SubscribeResponse %p -> %p\n", q, p));
	*(_ns1__SubscribeResponse*)p = *(_ns1__SubscribeResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__Subscribe*)this)->Options = NULL;
	((_ns1__Subscribe*)this)->ItemList = NULL;
	soap_default_bool(soap, &((_ns1__Subscribe*)this)->ReturnValuesOnReply);
	((_ns1__Subscribe*)this)->SubscriptionPingRate = NULL;
	/* transient soap skipped */
}

void _ns1__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RequestOptions(soap, &((_ns1__Subscribe*)this)->Options);
	soap_serialize_PointerTons1__SubscribeRequestItemList(soap, &((_ns1__Subscribe*)this)->ItemList);
	/* transient soap skipped */
}

int _ns1__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Subscribe);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Subscribe(struct soap *soap, const char *tag, int id, const _ns1__Subscribe *a, const char *type)
{
	soap_set_attr(soap, "ReturnValuesOnReply", soap_bool2s(soap, ((_ns1__Subscribe *)a)->ReturnValuesOnReply));
	if (((_ns1__Subscribe *)a)->SubscriptionPingRate)
		soap_set_attr(soap, "SubscriptionPingRate", soap_int2s(soap, *((_ns1__Subscribe *)a)->SubscriptionPingRate));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Subscribe), type);
	soap_out_PointerTons1__RequestOptions(soap, "ns1:Options", -1, &(((_ns1__Subscribe*)a)->Options), "");
	soap_out_PointerTons1__SubscribeRequestItemList(soap, "ns1:ItemList", -1, &(((_ns1__Subscribe*)a)->ItemList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Subscribe * SOAP_FMAC4 soap_get__ns1__Subscribe(struct soap *soap, _ns1__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Subscribe(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Subscribe * SOAP_FMAC4 soap_in__ns1__Subscribe(struct soap *soap, const char *tag, _ns1__Subscribe *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Subscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Subscribe, sizeof(_ns1__Subscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Subscribe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Subscribe *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "ReturnValuesOnReply", 1), &((_ns1__Subscribe *)a)->ReturnValuesOnReply))
		return NULL;
	{	const char *t = soap_attr_value(soap, "SubscriptionPingRate", 0);
		if (t)
		{	if (!(((_ns1__Subscribe *)a)->SubscriptionPingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((_ns1__Subscribe *)a)->SubscriptionPingRate))
		return NULL;
		}
	}
	short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RequestOptions(soap, "ns1:Options", &(((_ns1__Subscribe*)a)->Options), "ns1:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SubscribeRequestItemList(soap, "ns1:ItemList", &(((_ns1__Subscribe*)a)->ItemList), "ns1:SubscribeRequestItemList"))
				{	soap_flag_ItemList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Subscribe, 0, sizeof(_ns1__Subscribe), 0, soap_copy__ns1__Subscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__Subscribe * SOAP_FMAC6 soap_new__ns1__Subscribe(struct soap *soap, int n)
{	return soap_instantiate__ns1__Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__Subscribe(struct soap *soap, _ns1__Subscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__Subscribe * SOAP_FMAC4 soap_instantiate__ns1__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__Subscribe;
		if (size)
			*size = sizeof(_ns1__Subscribe);
		((_ns1__Subscribe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__Subscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__Subscribe);
		for (int i = 0; i < n; i++)
			((_ns1__Subscribe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__Subscribe*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Subscribe %p -> %p\n", q, p));
	*(_ns1__Subscribe*)p = *(_ns1__Subscribe*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__WriteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__WriteResponse*)this)->WriteResult = NULL;
	((_ns1__WriteResponse*)this)->RItemList = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__WriteResponse*)this)->Errors);
	/* transient soap skipped */
}

void _ns1__WriteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__WriteResponse*)this)->WriteResult);
	soap_serialize_PointerTons1__ReplyItemList(soap, &((_ns1__WriteResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__WriteResponse*)this)->Errors);
	/* transient soap skipped */
}

int _ns1__WriteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__WriteResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__WriteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WriteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WriteResponse(struct soap *soap, const char *tag, int id, const _ns1__WriteResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WriteResponse), type);
	if (a->WriteResult)
		soap_element_result(soap, "ns1:WriteResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:WriteResult", -1, &(((_ns1__WriteResponse*)a)->WriteResult), "");
	soap_out_PointerTons1__ReplyItemList(soap, "ns1:RItemList", -1, &(((_ns1__WriteResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", -1, &(((_ns1__WriteResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__WriteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WriteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WriteResponse * SOAP_FMAC4 soap_get__ns1__WriteResponse(struct soap *soap, _ns1__WriteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WriteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__WriteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WriteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WriteResponse * SOAP_FMAC4 soap_in__ns1__WriteResponse(struct soap *soap, const char *tag, _ns1__WriteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WriteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WriteResponse, sizeof(_ns1__WriteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__WriteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__WriteResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_WriteResult1 = 1, soap_flag_RItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WriteResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:WriteResult", &(((_ns1__WriteResponse*)a)->WriteResult), "ns1:ReplyBase"))
				{	soap_flag_WriteResult1--;
					continue;
				}
			if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyItemList(soap, "ns1:RItemList", &(((_ns1__WriteResponse*)a)->RItemList), "ns1:ReplyItemList"))
				{	soap_flag_RItemList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", &(((_ns1__WriteResponse*)a)->Errors), "ns1:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:WriteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WriteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WriteResponse, 0, sizeof(_ns1__WriteResponse), 0, soap_copy__ns1__WriteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__WriteResponse * SOAP_FMAC6 soap_new__ns1__WriteResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__WriteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__WriteResponse(struct soap *soap, _ns1__WriteResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__WriteResponse * SOAP_FMAC4 soap_instantiate__ns1__WriteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WriteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__WriteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__WriteResponse;
		if (size)
			*size = sizeof(_ns1__WriteResponse);
		((_ns1__WriteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__WriteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__WriteResponse);
		for (int i = 0; i < n; i++)
			((_ns1__WriteResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__WriteResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__WriteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__WriteResponse %p -> %p\n", q, p));
	*(_ns1__WriteResponse*)p = *(_ns1__WriteResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__Write::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__Write*)this)->Options = NULL;
	((_ns1__Write*)this)->ItemList = NULL;
	soap_default_bool(soap, &((_ns1__Write*)this)->ReturnValuesOnReply);
	/* transient soap skipped */
}

void _ns1__Write::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RequestOptions(soap, &((_ns1__Write*)this)->Options);
	soap_serialize_PointerTons1__WriteRequestItemList(soap, &((_ns1__Write*)this)->ItemList);
	/* transient soap skipped */
}

int _ns1__Write::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Write);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__Write::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Write(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Write(struct soap *soap, const char *tag, int id, const _ns1__Write *a, const char *type)
{
	soap_set_attr(soap, "ReturnValuesOnReply", soap_bool2s(soap, ((_ns1__Write *)a)->ReturnValuesOnReply));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Write), type);
	soap_out_PointerTons1__RequestOptions(soap, "ns1:Options", -1, &(((_ns1__Write*)a)->Options), "");
	soap_out_PointerTons1__WriteRequestItemList(soap, "ns1:ItemList", -1, &(((_ns1__Write*)a)->ItemList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__Write::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Write(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Write * SOAP_FMAC4 soap_get__ns1__Write(struct soap *soap, _ns1__Write *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Write(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__Write::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Write(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Write * SOAP_FMAC4 soap_in__ns1__Write(struct soap *soap, const char *tag, _ns1__Write *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Write *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Write, sizeof(_ns1__Write), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Write)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Write *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "ReturnValuesOnReply", 1), &((_ns1__Write *)a)->ReturnValuesOnReply))
		return NULL;
	short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RequestOptions(soap, "ns1:Options", &(((_ns1__Write*)a)->Options), "ns1:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__WriteRequestItemList(soap, "ns1:ItemList", &(((_ns1__Write*)a)->ItemList), "ns1:WriteRequestItemList"))
				{	soap_flag_ItemList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Write *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Write, 0, sizeof(_ns1__Write), 0, soap_copy__ns1__Write);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__Write * SOAP_FMAC6 soap_new__ns1__Write(struct soap *soap, int n)
{	return soap_instantiate__ns1__Write(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__Write(struct soap *soap, _ns1__Write *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__Write * SOAP_FMAC4 soap_instantiate__ns1__Write(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Write(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Write, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__Write;
		if (size)
			*size = sizeof(_ns1__Write);
		((_ns1__Write*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__Write[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__Write);
		for (int i = 0; i < n; i++)
			((_ns1__Write*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__Write*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Write(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Write %p -> %p\n", q, p));
	*(_ns1__Write*)p = *(_ns1__Write*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__ReadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__ReadResponse*)this)->ReadResult = NULL;
	((_ns1__ReadResponse*)this)->RItemList = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__ReadResponse*)this)->Errors);
	/* transient soap skipped */
}

void _ns1__ReadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__ReadResponse*)this)->ReadResult);
	soap_serialize_PointerTons1__ReplyItemList(soap, &((_ns1__ReadResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(soap, &((_ns1__ReadResponse*)this)->Errors);
	/* transient soap skipped */
}

int _ns1__ReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__ReadResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__ReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ReadResponse(struct soap *soap, const char *tag, int id, const _ns1__ReadResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ReadResponse), type);
	if (a->ReadResult)
		soap_element_result(soap, "ns1:ReadResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:ReadResult", -1, &(((_ns1__ReadResponse*)a)->ReadResult), "");
	soap_out_PointerTons1__ReplyItemList(soap, "ns1:RItemList", -1, &(((_ns1__ReadResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", -1, &(((_ns1__ReadResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__ReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ReadResponse * SOAP_FMAC4 soap_get__ns1__ReadResponse(struct soap *soap, _ns1__ReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__ReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ReadResponse * SOAP_FMAC4 soap_in__ns1__ReadResponse(struct soap *soap, const char *tag, _ns1__ReadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ReadResponse, sizeof(_ns1__ReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__ReadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__ReadResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ReadResult1 = 1, soap_flag_RItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReadResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:ReadResult", &(((_ns1__ReadResponse*)a)->ReadResult), "ns1:ReplyBase"))
				{	soap_flag_ReadResult1--;
					continue;
				}
			if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyItemList(soap, "ns1:RItemList", &(((_ns1__ReadResponse*)a)->RItemList), "ns1:ReplyItemList"))
				{	soap_flag_RItemList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__OPCError(soap, "ns1:Errors", &(((_ns1__ReadResponse*)a)->Errors), "ns1:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "ns1:ReadResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__ReadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ReadResponse, 0, sizeof(_ns1__ReadResponse), 0, soap_copy__ns1__ReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__ReadResponse * SOAP_FMAC6 soap_new__ns1__ReadResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__ReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__ReadResponse(struct soap *soap, _ns1__ReadResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__ReadResponse * SOAP_FMAC4 soap_instantiate__ns1__ReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__ReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__ReadResponse;
		if (size)
			*size = sizeof(_ns1__ReadResponse);
		((_ns1__ReadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__ReadResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__ReadResponse);
		for (int i = 0; i < n; i++)
			((_ns1__ReadResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__ReadResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__ReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__ReadResponse %p -> %p\n", q, p));
	*(_ns1__ReadResponse*)p = *(_ns1__ReadResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__Read::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__Read*)this)->Options = NULL;
	((_ns1__Read*)this)->ItemList = NULL;
	/* transient soap skipped */
}

void _ns1__Read::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RequestOptions(soap, &((_ns1__Read*)this)->Options);
	soap_serialize_PointerTons1__ReadRequestItemList(soap, &((_ns1__Read*)this)->ItemList);
	/* transient soap skipped */
}

int _ns1__Read::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__Read);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__Read::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Read(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Read(struct soap *soap, const char *tag, int id, const _ns1__Read *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Read), type);
	soap_out_PointerTons1__RequestOptions(soap, "ns1:Options", -1, &(((_ns1__Read*)a)->Options), "");
	soap_out_PointerTons1__ReadRequestItemList(soap, "ns1:ItemList", -1, &(((_ns1__Read*)a)->ItemList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__Read::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Read(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Read * SOAP_FMAC4 soap_get__ns1__Read(struct soap *soap, _ns1__Read *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Read(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__Read::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Read(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Read * SOAP_FMAC4 soap_in__ns1__Read(struct soap *soap, const char *tag, _ns1__Read *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Read *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Read, sizeof(_ns1__Read), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Read)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Read *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RequestOptions(soap, "ns1:Options", &(((_ns1__Read*)a)->Options), "ns1:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReadRequestItemList(soap, "ns1:ItemList", &(((_ns1__Read*)a)->ItemList), "ns1:ReadRequestItemList"))
				{	soap_flag_ItemList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Read *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Read, 0, sizeof(_ns1__Read), 0, soap_copy__ns1__Read);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__Read * SOAP_FMAC6 soap_new__ns1__Read(struct soap *soap, int n)
{	return soap_instantiate__ns1__Read(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__Read(struct soap *soap, _ns1__Read *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__Read * SOAP_FMAC4 soap_instantiate__ns1__Read(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Read(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Read, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__Read;
		if (size)
			*size = sizeof(_ns1__Read);
		((_ns1__Read*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__Read[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__Read);
		for (int i = 0; i < n; i++)
			((_ns1__Read*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__Read*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Read(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Read %p -> %p\n", q, p));
	*(_ns1__Read*)p = *(_ns1__Read*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__GetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__GetStatusResponse*)this)->GetStatusResult = NULL;
	((_ns1__GetStatusResponse*)this)->Status = NULL;
	/* transient soap skipped */
}

void _ns1__GetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ReplyBase(soap, &((_ns1__GetStatusResponse*)this)->GetStatusResult);
	soap_serialize_PointerTons1__ServerStatus(soap, &((_ns1__GetStatusResponse*)this)->Status);
	/* transient soap skipped */
}

int _ns1__GetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStatusResponse), type);
	if (a->GetStatusResult)
		soap_element_result(soap, "ns1:GetStatusResult");
	soap_out_PointerTons1__ReplyBase(soap, "ns1:GetStatusResult", -1, &(((_ns1__GetStatusResponse*)a)->GetStatusResult), "");
	soap_out_PointerTons1__ServerStatus(soap, "ns1:Status", -1, &(((_ns1__GetStatusResponse*)a)->Status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__GetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStatusResponse * SOAP_FMAC4 soap_get__ns1__GetStatusResponse(struct soap *soap, _ns1__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__GetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStatusResponse * SOAP_FMAC4 soap_in__ns1__GetStatusResponse(struct soap *soap, const char *tag, _ns1__GetStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStatusResponse, sizeof(_ns1__GetStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetStatusResult1 = 1, soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ReplyBase(soap, "ns1:GetStatusResult", &(((_ns1__GetStatusResponse*)a)->GetStatusResult), "ns1:ReplyBase"))
				{	soap_flag_GetStatusResult1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ServerStatus(soap, "ns1:Status", &(((_ns1__GetStatusResponse*)a)->Status), "ns1:ServerStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStatusResponse, 0, sizeof(_ns1__GetStatusResponse), 0, soap_copy__ns1__GetStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__GetStatusResponse * SOAP_FMAC6 soap_new__ns1__GetStatusResponse(struct soap *soap, int n)
{	return soap_instantiate__ns1__GetStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__GetStatusResponse(struct soap *soap, _ns1__GetStatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__GetStatusResponse * SOAP_FMAC4 soap_instantiate__ns1__GetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetStatusResponse;
		if (size)
			*size = sizeof(_ns1__GetStatusResponse);
		((_ns1__GetStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetStatusResponse);
		for (int i = 0; i < n; i++)
			((_ns1__GetStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetStatusResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStatusResponse %p -> %p\n", q, p));
	*(_ns1__GetStatusResponse*)p = *(_ns1__GetStatusResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _ns1__GetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_ns1__GetStatus*)this)->LocaleID = NULL;
	((_ns1__GetStatus*)this)->ClientRequestHandle = NULL;
	/* transient soap skipped */
}

void _ns1__GetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns1__GetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__GetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStatus(struct soap *soap, const char *tag, int id, const _ns1__GetStatus *a, const char *type)
{
	if (((_ns1__GetStatus *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((_ns1__GetStatus *)a)->LocaleID->c_str());
	if (((_ns1__GetStatus *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_ns1__GetStatus *)a)->ClientRequestHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStatus), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_ns1__GetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStatus * SOAP_FMAC4 soap_get__ns1__GetStatus(struct soap *soap, _ns1__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_ns1__GetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStatus * SOAP_FMAC4 soap_in__ns1__GetStatus(struct soap *soap, const char *tag, _ns1__GetStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStatus, sizeof(_ns1__GetStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetStatus *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((_ns1__GetStatus *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__GetStatus *)a)->LocaleID = soap_new_std__string(soap, -1);
			((_ns1__GetStatus *)a)->LocaleID->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_ns1__GetStatus *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_ns1__GetStatus *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_ns1__GetStatus *)a)->ClientRequestHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStatus, 0, sizeof(_ns1__GetStatus), 0, soap_copy__ns1__GetStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__GetStatus * SOAP_FMAC6 soap_new__ns1__GetStatus(struct soap *soap, int n)
{	return soap_instantiate__ns1__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__GetStatus(struct soap *soap, _ns1__GetStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__GetStatus * SOAP_FMAC4 soap_instantiate__ns1__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__GetStatus;
		if (size)
			*size = sizeof(_ns1__GetStatus);
		((_ns1__GetStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__GetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__GetStatus);
		for (int i = 0; i < n; i++)
			((_ns1__GetStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__GetStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetStatus %p -> %p\n", q, p));
	*(_ns1__GetStatus*)p = *(_ns1__GetStatus*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__PropertyReplyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ItemProperty(soap, &((ns1__PropertyReplyList*)this)->Properties);
	((ns1__PropertyReplyList*)this)->ItemPath = NULL;
	((ns1__PropertyReplyList*)this)->ItemName = NULL;
	((ns1__PropertyReplyList*)this)->ResultID = NULL;
	/* transient soap skipped */
}

void ns1__PropertyReplyList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ItemProperty(soap, &((ns1__PropertyReplyList*)this)->Properties);
	/* transient soap skipped */
}

int ns1__PropertyReplyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PropertyReplyList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PropertyReplyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PropertyReplyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PropertyReplyList(struct soap *soap, const char *tag, int id, const ns1__PropertyReplyList *a, const char *type)
{
	if (((ns1__PropertyReplyList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__PropertyReplyList *)a)->ItemPath->c_str());
	if (((ns1__PropertyReplyList *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__PropertyReplyList *)a)->ItemName->c_str());
	if (((ns1__PropertyReplyList *)a)->ResultID)
		soap_set_attr(soap, "ResultID", soap_QName2s(soap, ((ns1__PropertyReplyList *)a)->ResultID->c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PropertyReplyList), type);
	soap_out_std__vectorTemplateOfPointerTons1__ItemProperty(soap, "ns1:Properties", -1, &(((ns1__PropertyReplyList*)a)->Properties), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PropertyReplyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PropertyReplyList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PropertyReplyList * SOAP_FMAC4 soap_get_ns1__PropertyReplyList(struct soap *soap, ns1__PropertyReplyList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PropertyReplyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PropertyReplyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PropertyReplyList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PropertyReplyList * SOAP_FMAC4 soap_in_ns1__PropertyReplyList(struct soap *soap, const char *tag, ns1__PropertyReplyList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PropertyReplyList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PropertyReplyList, sizeof(ns1__PropertyReplyList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PropertyReplyList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PropertyReplyList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__PropertyReplyList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__PropertyReplyList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__PropertyReplyList *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__PropertyReplyList *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__PropertyReplyList *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__PropertyReplyList *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ResultID", 0);
		if (t)
		{	if (!(((ns1__PropertyReplyList *)a)->ResultID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__PropertyReplyList *)a)->ResultID = soap_new_std__string(soap, -1);
			((ns1__PropertyReplyList *)a)->ResultID->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ItemProperty(soap, "ns1:Properties", &(((ns1__PropertyReplyList*)a)->Properties), "ns1:ItemProperty"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PropertyReplyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PropertyReplyList, 0, sizeof(ns1__PropertyReplyList), 0, soap_copy_ns1__PropertyReplyList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PropertyReplyList * SOAP_FMAC6 soap_new_ns1__PropertyReplyList(struct soap *soap, int n)
{	return soap_instantiate_ns1__PropertyReplyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PropertyReplyList(struct soap *soap, ns1__PropertyReplyList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__PropertyReplyList * SOAP_FMAC4 soap_instantiate_ns1__PropertyReplyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PropertyReplyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PropertyReplyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PropertyReplyList;
		if (size)
			*size = sizeof(ns1__PropertyReplyList);
		((ns1__PropertyReplyList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PropertyReplyList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PropertyReplyList);
		for (int i = 0; i < n; i++)
			((ns1__PropertyReplyList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PropertyReplyList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PropertyReplyList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PropertyReplyList %p -> %p\n", q, p));
	*(ns1__PropertyReplyList*)p = *(ns1__PropertyReplyList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ItemIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ItemIdentifier*)this)->ItemPath = NULL;
	((ns1__ItemIdentifier*)this)->ItemName = NULL;
	/* transient soap skipped */
}

void ns1__ItemIdentifier::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__ItemIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ItemIdentifier);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ItemIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemIdentifier(struct soap *soap, const char *tag, int id, const ns1__ItemIdentifier *a, const char *type)
{
	if (((ns1__ItemIdentifier *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__ItemIdentifier *)a)->ItemPath->c_str());
	if (((ns1__ItemIdentifier *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__ItemIdentifier *)a)->ItemName->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemIdentifier), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemIdentifier * SOAP_FMAC4 soap_get_ns1__ItemIdentifier(struct soap *soap, ns1__ItemIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemIdentifier(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemIdentifier * SOAP_FMAC4 soap_in_ns1__ItemIdentifier(struct soap *soap, const char *tag, ns1__ItemIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ItemIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemIdentifier, sizeof(ns1__ItemIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ItemIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ItemIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__ItemIdentifier *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemIdentifier *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__ItemIdentifier *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__ItemIdentifier *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemIdentifier *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__ItemIdentifier *)a)->ItemName->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ItemIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ItemIdentifier, 0, sizeof(ns1__ItemIdentifier), 0, soap_copy_ns1__ItemIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemIdentifier * SOAP_FMAC6 soap_new_ns1__ItemIdentifier(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemIdentifier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemIdentifier(struct soap *soap, ns1__ItemIdentifier *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ItemIdentifier * SOAP_FMAC4 soap_instantiate_ns1__ItemIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemIdentifier;
		if (size)
			*size = sizeof(ns1__ItemIdentifier);
		((ns1__ItemIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemIdentifier[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ItemIdentifier);
		for (int i = 0; i < n; i++)
			((ns1__ItemIdentifier*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ItemIdentifier*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ItemIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ItemIdentifier %p -> %p\n", q, p));
	*(ns1__ItemIdentifier*)p = *(ns1__ItemIdentifier*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ItemProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ItemProperty*)this)->Value = NULL;
	soap_default_xsd__QName(soap, &((ns1__ItemProperty*)this)->Name);
	((ns1__ItemProperty*)this)->Description = NULL;
	((ns1__ItemProperty*)this)->ItemPath = NULL;
	((ns1__ItemProperty*)this)->ItemName = NULL;
	((ns1__ItemProperty*)this)->ResultID = NULL;
	/* transient soap skipped */
}

void ns1__ItemProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__ItemProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ItemProperty);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ItemProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemProperty(struct soap *soap, const char *tag, int id, const ns1__ItemProperty *a, const char *type)
{
	if (!((ns1__ItemProperty *)a)->Name.empty())
		soap_set_attr(soap, "Name", soap_QName2s(soap, ((ns1__ItemProperty *)a)->Name.c_str()));
	if (((ns1__ItemProperty *)a)->Description)
		soap_set_attr(soap, "Description", ((ns1__ItemProperty *)a)->Description->c_str());
	if (((ns1__ItemProperty *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__ItemProperty *)a)->ItemPath->c_str());
	if (((ns1__ItemProperty *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__ItemProperty *)a)->ItemName->c_str());
	if (((ns1__ItemProperty *)a)->ResultID)
		soap_set_attr(soap, "ResultID", soap_QName2s(soap, ((ns1__ItemProperty *)a)->ResultID->c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemProperty), type);
	soap_outliteral(soap, "ns1:Value", &(((ns1__ItemProperty*)a)->Value), NULL);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemProperty(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemProperty * SOAP_FMAC4 soap_get_ns1__ItemProperty(struct soap *soap, ns1__ItemProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemProperty(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemProperty * SOAP_FMAC4 soap_in_ns1__ItemProperty(struct soap *soap, const char *tag, ns1__ItemProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ItemProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemProperty, sizeof(ns1__ItemProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ItemProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ItemProperty *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s))
				return NULL;
			((ns1__ItemProperty *)a)->Name.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{	if (!(((ns1__ItemProperty *)a)->Description = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemProperty *)a)->Description = soap_new_std__string(soap, -1);
			((ns1__ItemProperty *)a)->Description->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__ItemProperty *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemProperty *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__ItemProperty *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__ItemProperty *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemProperty *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__ItemProperty *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ResultID", 0);
		if (t)
		{	if (!(((ns1__ItemProperty *)a)->ResultID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemProperty *)a)->ResultID = soap_new_std__string(soap, -1);
			((ns1__ItemProperty *)a)->ResultID->assign(s);
		}
		}
	}
	short soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:Value", &(((ns1__ItemProperty*)a)->Value)))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ItemProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ItemProperty, 0, sizeof(ns1__ItemProperty), 0, soap_copy_ns1__ItemProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemProperty * SOAP_FMAC6 soap_new_ns1__ItemProperty(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemProperty(struct soap *soap, ns1__ItemProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ItemProperty * SOAP_FMAC4 soap_instantiate_ns1__ItemProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemProperty;
		if (size)
			*size = sizeof(ns1__ItemProperty);
		((ns1__ItemProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ItemProperty);
		for (int i = 0; i < n; i++)
			((ns1__ItemProperty*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ItemProperty*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ItemProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ItemProperty %p -> %p\n", q, p));
	*(ns1__ItemProperty*)p = *(ns1__ItemProperty*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__BrowseElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ItemProperty(soap, &((ns1__BrowseElement*)this)->Properties);
	((ns1__BrowseElement*)this)->Name = NULL;
	((ns1__BrowseElement*)this)->ItemPath = NULL;
	((ns1__BrowseElement*)this)->ItemName = NULL;
	soap_default_bool(soap, &((ns1__BrowseElement*)this)->IsItem);
	soap_default_bool(soap, &((ns1__BrowseElement*)this)->HasChildren);
	/* transient soap skipped */
}

void ns1__BrowseElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ItemProperty(soap, &((ns1__BrowseElement*)this)->Properties);
	/* transient soap skipped */
}

int ns1__BrowseElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BrowseElement);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__BrowseElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BrowseElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BrowseElement(struct soap *soap, const char *tag, int id, const ns1__BrowseElement *a, const char *type)
{
	if (((ns1__BrowseElement *)a)->Name)
		soap_set_attr(soap, "Name", ((ns1__BrowseElement *)a)->Name->c_str());
	if (((ns1__BrowseElement *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__BrowseElement *)a)->ItemPath->c_str());
	if (((ns1__BrowseElement *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__BrowseElement *)a)->ItemName->c_str());
	soap_set_attr(soap, "IsItem", soap_bool2s(soap, ((ns1__BrowseElement *)a)->IsItem));
	soap_set_attr(soap, "HasChildren", soap_bool2s(soap, ((ns1__BrowseElement *)a)->HasChildren));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BrowseElement), type);
	soap_out_std__vectorTemplateOfPointerTons1__ItemProperty(soap, "ns1:Properties", -1, &(((ns1__BrowseElement*)a)->Properties), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__BrowseElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BrowseElement(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BrowseElement * SOAP_FMAC4 soap_get_ns1__BrowseElement(struct soap *soap, ns1__BrowseElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BrowseElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__BrowseElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BrowseElement(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BrowseElement * SOAP_FMAC4 soap_in_ns1__BrowseElement(struct soap *soap, const char *tag, ns1__BrowseElement *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BrowseElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BrowseElement, sizeof(ns1__BrowseElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BrowseElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BrowseElement *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{	if (!(((ns1__BrowseElement *)a)->Name = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__BrowseElement *)a)->Name = soap_new_std__string(soap, -1);
			((ns1__BrowseElement *)a)->Name->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__BrowseElement *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__BrowseElement *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__BrowseElement *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__BrowseElement *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__BrowseElement *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__BrowseElement *)a)->ItemName->assign(s);
		}
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "IsItem", 1), &((ns1__BrowseElement *)a)->IsItem))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "HasChildren", 1), &((ns1__BrowseElement *)a)->HasChildren))
		return NULL;;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ItemProperty(soap, "ns1:Properties", &(((ns1__BrowseElement*)a)->Properties), "ns1:ItemProperty"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BrowseElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BrowseElement, 0, sizeof(ns1__BrowseElement), 0, soap_copy_ns1__BrowseElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BrowseElement * SOAP_FMAC6 soap_new_ns1__BrowseElement(struct soap *soap, int n)
{	return soap_instantiate_ns1__BrowseElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BrowseElement(struct soap *soap, ns1__BrowseElement *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__BrowseElement * SOAP_FMAC4 soap_instantiate_ns1__BrowseElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BrowseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BrowseElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BrowseElement;
		if (size)
			*size = sizeof(ns1__BrowseElement);
		((ns1__BrowseElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BrowseElement[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BrowseElement);
		for (int i = 0; i < n; i++)
			((ns1__BrowseElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BrowseElement*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BrowseElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BrowseElement %p -> %p\n", q, p));
	*(ns1__BrowseElement*)p = *(ns1__BrowseElement*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SubscribePolledRefreshReplyItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ItemValue(soap, &((ns1__SubscribePolledRefreshReplyItemList*)this)->Items);
	((ns1__SubscribePolledRefreshReplyItemList*)this)->SubscriptionHandle = NULL;
	/* transient soap skipped */
}

void ns1__SubscribePolledRefreshReplyItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ItemValue(soap, &((ns1__SubscribePolledRefreshReplyItemList*)this)->Items);
	/* transient soap skipped */
}

int ns1__SubscribePolledRefreshReplyItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SubscribePolledRefreshReplyItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubscribePolledRefreshReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, int id, const ns1__SubscribePolledRefreshReplyItemList *a, const char *type)
{
	if (((ns1__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle)
		soap_set_attr(soap, "SubscriptionHandle", ((ns1__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList), type);
	soap_out_std__vectorTemplateOfPointerTons1__ItemValue(soap, "ns1:Items", -1, &(((ns1__SubscribePolledRefreshReplyItemList*)a)->Items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SubscribePolledRefreshReplyItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubscribePolledRefreshReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubscribePolledRefreshReplyItemList * SOAP_FMAC4 soap_get_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, ns1__SubscribePolledRefreshReplyItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribePolledRefreshReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SubscribePolledRefreshReplyItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubscribePolledRefreshReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubscribePolledRefreshReplyItemList * SOAP_FMAC4 soap_in_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, ns1__SubscribePolledRefreshReplyItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubscribePolledRefreshReplyItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList, sizeof(ns1__SubscribePolledRefreshReplyItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SubscribePolledRefreshReplyItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "SubscriptionHandle", 0);
		if (t)
		{	if (!(((ns1__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle = soap_new_std__string(soap, -1);
			((ns1__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ItemValue(soap, "ns1:Items", &(((ns1__SubscribePolledRefreshReplyItemList*)a)->Items), "ns1:ItemValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubscribePolledRefreshReplyItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList, 0, sizeof(ns1__SubscribePolledRefreshReplyItemList), 0, soap_copy_ns1__SubscribePolledRefreshReplyItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SubscribePolledRefreshReplyItemList * SOAP_FMAC6 soap_new_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__SubscribePolledRefreshReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, ns1__SubscribePolledRefreshReplyItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SubscribePolledRefreshReplyItemList * SOAP_FMAC4 soap_instantiate_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribePolledRefreshReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SubscribePolledRefreshReplyItemList;
		if (size)
			*size = sizeof(ns1__SubscribePolledRefreshReplyItemList);
		((ns1__SubscribePolledRefreshReplyItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SubscribePolledRefreshReplyItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SubscribePolledRefreshReplyItemList);
		for (int i = 0; i < n; i++)
			((ns1__SubscribePolledRefreshReplyItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SubscribePolledRefreshReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SubscribePolledRefreshReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SubscribePolledRefreshReplyItemList %p -> %p\n", q, p));
	*(ns1__SubscribePolledRefreshReplyItemList*)p = *(ns1__SubscribePolledRefreshReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SubscribeItemValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__SubscribeItemValue*)this)->ItemValue = NULL;
	((ns1__SubscribeItemValue*)this)->RevisedSamplingRate = NULL;
	/* transient soap skipped */
}

void ns1__SubscribeItemValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ItemValue(soap, &((ns1__SubscribeItemValue*)this)->ItemValue);
	/* transient soap skipped */
}

int ns1__SubscribeItemValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SubscribeItemValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SubscribeItemValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubscribeItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribeItemValue(struct soap *soap, const char *tag, int id, const ns1__SubscribeItemValue *a, const char *type)
{
	if (((ns1__SubscribeItemValue *)a)->RevisedSamplingRate)
		soap_set_attr(soap, "RevisedSamplingRate", soap_int2s(soap, *((ns1__SubscribeItemValue *)a)->RevisedSamplingRate));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribeItemValue), type);
	soap_out_PointerTons1__ItemValue(soap, "ns1:ItemValue", -1, &(((ns1__SubscribeItemValue*)a)->ItemValue), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SubscribeItemValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubscribeItemValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubscribeItemValue * SOAP_FMAC4 soap_get_ns1__SubscribeItemValue(struct soap *soap, ns1__SubscribeItemValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribeItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SubscribeItemValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubscribeItemValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubscribeItemValue * SOAP_FMAC4 soap_in_ns1__SubscribeItemValue(struct soap *soap, const char *tag, ns1__SubscribeItemValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubscribeItemValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribeItemValue, sizeof(ns1__SubscribeItemValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SubscribeItemValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SubscribeItemValue *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "RevisedSamplingRate", 0);
		if (t)
		{	if (!(((ns1__SubscribeItemValue *)a)->RevisedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ns1__SubscribeItemValue *)a)->RevisedSamplingRate))
		return NULL;
		}
	}
	short soap_flag_ItemValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ItemValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ItemValue(soap, "ns1:ItemValue", &(((ns1__SubscribeItemValue*)a)->ItemValue), "ns1:ItemValue"))
				{	soap_flag_ItemValue1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeItemValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribeItemValue, 0, sizeof(ns1__SubscribeItemValue), 0, soap_copy_ns1__SubscribeItemValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SubscribeItemValue * SOAP_FMAC6 soap_new_ns1__SubscribeItemValue(struct soap *soap, int n)
{	return soap_instantiate_ns1__SubscribeItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SubscribeItemValue(struct soap *soap, ns1__SubscribeItemValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SubscribeItemValue * SOAP_FMAC4 soap_instantiate_ns1__SubscribeItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribeItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SubscribeItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SubscribeItemValue;
		if (size)
			*size = sizeof(ns1__SubscribeItemValue);
		((ns1__SubscribeItemValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SubscribeItemValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SubscribeItemValue);
		for (int i = 0; i < n; i++)
			((ns1__SubscribeItemValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SubscribeItemValue*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SubscribeItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SubscribeItemValue %p -> %p\n", q, p));
	*(ns1__SubscribeItemValue*)p = *(ns1__SubscribeItemValue*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SubscribeReplyItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, &((ns1__SubscribeReplyItemList*)this)->Items);
	((ns1__SubscribeReplyItemList*)this)->RevisedSamplingRate = NULL;
	/* transient soap skipped */
}

void ns1__SubscribeReplyItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, &((ns1__SubscribeReplyItemList*)this)->Items);
	/* transient soap skipped */
}

int ns1__SubscribeReplyItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SubscribeReplyItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SubscribeReplyItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubscribeReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribeReplyItemList(struct soap *soap, const char *tag, int id, const ns1__SubscribeReplyItemList *a, const char *type)
{
	if (((ns1__SubscribeReplyItemList *)a)->RevisedSamplingRate)
		soap_set_attr(soap, "RevisedSamplingRate", soap_int2s(soap, *((ns1__SubscribeReplyItemList *)a)->RevisedSamplingRate));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribeReplyItemList), type);
	soap_out_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, "ns1:Items", -1, &(((ns1__SubscribeReplyItemList*)a)->Items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SubscribeReplyItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubscribeReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubscribeReplyItemList * SOAP_FMAC4 soap_get_ns1__SubscribeReplyItemList(struct soap *soap, ns1__SubscribeReplyItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribeReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SubscribeReplyItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubscribeReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubscribeReplyItemList * SOAP_FMAC4 soap_in_ns1__SubscribeReplyItemList(struct soap *soap, const char *tag, ns1__SubscribeReplyItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubscribeReplyItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribeReplyItemList, sizeof(ns1__SubscribeReplyItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SubscribeReplyItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SubscribeReplyItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "RevisedSamplingRate", 0);
		if (t)
		{	if (!(((ns1__SubscribeReplyItemList *)a)->RevisedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ns1__SubscribeReplyItemList *)a)->RevisedSamplingRate))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, "ns1:Items", &(((ns1__SubscribeReplyItemList*)a)->Items), "ns1:SubscribeItemValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeReplyItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribeReplyItemList, 0, sizeof(ns1__SubscribeReplyItemList), 0, soap_copy_ns1__SubscribeReplyItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SubscribeReplyItemList * SOAP_FMAC6 soap_new_ns1__SubscribeReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__SubscribeReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SubscribeReplyItemList(struct soap *soap, ns1__SubscribeReplyItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SubscribeReplyItemList * SOAP_FMAC4 soap_instantiate_ns1__SubscribeReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribeReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SubscribeReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SubscribeReplyItemList;
		if (size)
			*size = sizeof(ns1__SubscribeReplyItemList);
		((ns1__SubscribeReplyItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SubscribeReplyItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SubscribeReplyItemList);
		for (int i = 0; i < n; i++)
			((ns1__SubscribeReplyItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SubscribeReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SubscribeReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SubscribeReplyItemList %p -> %p\n", q, p));
	*(ns1__SubscribeReplyItemList*)p = *(ns1__SubscribeReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SubscribeRequestItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__SubscribeRequestItem*)this)->ItemPath = NULL;
	((ns1__SubscribeRequestItem*)this)->ReqType = NULL;
	((ns1__SubscribeRequestItem*)this)->ItemName = NULL;
	((ns1__SubscribeRequestItem*)this)->ClientItemHandle = NULL;
	((ns1__SubscribeRequestItem*)this)->Deadband = NULL;
	((ns1__SubscribeRequestItem*)this)->RequestedSamplingRate = NULL;
	((ns1__SubscribeRequestItem*)this)->EnableBuffering = NULL;
	/* transient soap skipped */
}

void ns1__SubscribeRequestItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__SubscribeRequestItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SubscribeRequestItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SubscribeRequestItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubscribeRequestItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribeRequestItem(struct soap *soap, const char *tag, int id, const ns1__SubscribeRequestItem *a, const char *type)
{
	if (((ns1__SubscribeRequestItem *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__SubscribeRequestItem *)a)->ItemPath->c_str());
	if (((ns1__SubscribeRequestItem *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((ns1__SubscribeRequestItem *)a)->ReqType->c_str()));
	if (((ns1__SubscribeRequestItem *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__SubscribeRequestItem *)a)->ItemName->c_str());
	if (((ns1__SubscribeRequestItem *)a)->ClientItemHandle)
		soap_set_attr(soap, "ClientItemHandle", ((ns1__SubscribeRequestItem *)a)->ClientItemHandle->c_str());
	if (((ns1__SubscribeRequestItem *)a)->Deadband)
		soap_set_attr(soap, "Deadband", soap_float2s(soap, *((ns1__SubscribeRequestItem *)a)->Deadband));
	if (((ns1__SubscribeRequestItem *)a)->RequestedSamplingRate)
		soap_set_attr(soap, "RequestedSamplingRate", soap_int2s(soap, *((ns1__SubscribeRequestItem *)a)->RequestedSamplingRate));
	if (((ns1__SubscribeRequestItem *)a)->EnableBuffering)
		soap_set_attr(soap, "EnableBuffering", soap_bool2s(soap, *((ns1__SubscribeRequestItem *)a)->EnableBuffering));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribeRequestItem), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SubscribeRequestItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubscribeRequestItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubscribeRequestItem * SOAP_FMAC4 soap_get_ns1__SubscribeRequestItem(struct soap *soap, ns1__SubscribeRequestItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribeRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SubscribeRequestItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubscribeRequestItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubscribeRequestItem * SOAP_FMAC4 soap_in_ns1__SubscribeRequestItem(struct soap *soap, const char *tag, ns1__SubscribeRequestItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubscribeRequestItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribeRequestItem, sizeof(ns1__SubscribeRequestItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SubscribeRequestItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SubscribeRequestItem *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribeRequestItem *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__SubscribeRequestItem *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribeRequestItem *)a)->ReqType = soap_new_std__string(soap, -1);
			((ns1__SubscribeRequestItem *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribeRequestItem *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__SubscribeRequestItem *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientItemHandle", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->ClientItemHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribeRequestItem *)a)->ClientItemHandle = soap_new_std__string(soap, -1);
			((ns1__SubscribeRequestItem *)a)->ClientItemHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "Deadband", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->Deadband = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2float(soap, t, ((ns1__SubscribeRequestItem *)a)->Deadband))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "RequestedSamplingRate", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->RequestedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ns1__SubscribeRequestItem *)a)->RequestedSamplingRate))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "EnableBuffering", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItem *)a)->EnableBuffering = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__SubscribeRequestItem *)a)->EnableBuffering))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeRequestItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribeRequestItem, 0, sizeof(ns1__SubscribeRequestItem), 0, soap_copy_ns1__SubscribeRequestItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SubscribeRequestItem * SOAP_FMAC6 soap_new_ns1__SubscribeRequestItem(struct soap *soap, int n)
{	return soap_instantiate_ns1__SubscribeRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SubscribeRequestItem(struct soap *soap, ns1__SubscribeRequestItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SubscribeRequestItem * SOAP_FMAC4 soap_instantiate_ns1__SubscribeRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribeRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SubscribeRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SubscribeRequestItem;
		if (size)
			*size = sizeof(ns1__SubscribeRequestItem);
		((ns1__SubscribeRequestItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SubscribeRequestItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SubscribeRequestItem);
		for (int i = 0; i < n; i++)
			((ns1__SubscribeRequestItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SubscribeRequestItem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SubscribeRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SubscribeRequestItem %p -> %p\n", q, p));
	*(ns1__SubscribeRequestItem*)p = *(ns1__SubscribeRequestItem*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SubscribeRequestItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, &((ns1__SubscribeRequestItemList*)this)->Items);
	((ns1__SubscribeRequestItemList*)this)->ItemPath = NULL;
	((ns1__SubscribeRequestItemList*)this)->ReqType = NULL;
	((ns1__SubscribeRequestItemList*)this)->Deadband = NULL;
	((ns1__SubscribeRequestItemList*)this)->RequestedSamplingRate = NULL;
	((ns1__SubscribeRequestItemList*)this)->EnableBuffering = NULL;
	/* transient soap skipped */
}

void ns1__SubscribeRequestItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, &((ns1__SubscribeRequestItemList*)this)->Items);
	/* transient soap skipped */
}

int ns1__SubscribeRequestItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SubscribeRequestItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SubscribeRequestItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SubscribeRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SubscribeRequestItemList(struct soap *soap, const char *tag, int id, const ns1__SubscribeRequestItemList *a, const char *type)
{
	if (((ns1__SubscribeRequestItemList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__SubscribeRequestItemList *)a)->ItemPath->c_str());
	if (((ns1__SubscribeRequestItemList *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((ns1__SubscribeRequestItemList *)a)->ReqType->c_str()));
	if (((ns1__SubscribeRequestItemList *)a)->Deadband)
		soap_set_attr(soap, "Deadband", soap_float2s(soap, *((ns1__SubscribeRequestItemList *)a)->Deadband));
	if (((ns1__SubscribeRequestItemList *)a)->RequestedSamplingRate)
		soap_set_attr(soap, "RequestedSamplingRate", soap_int2s(soap, *((ns1__SubscribeRequestItemList *)a)->RequestedSamplingRate));
	if (((ns1__SubscribeRequestItemList *)a)->EnableBuffering)
		soap_set_attr(soap, "EnableBuffering", soap_bool2s(soap, *((ns1__SubscribeRequestItemList *)a)->EnableBuffering));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SubscribeRequestItemList), type);
	soap_out_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, "ns1:Items", -1, &(((ns1__SubscribeRequestItemList*)a)->Items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SubscribeRequestItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SubscribeRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SubscribeRequestItemList * SOAP_FMAC4 soap_get_ns1__SubscribeRequestItemList(struct soap *soap, ns1__SubscribeRequestItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SubscribeRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SubscribeRequestItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SubscribeRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SubscribeRequestItemList * SOAP_FMAC4 soap_in_ns1__SubscribeRequestItemList(struct soap *soap, const char *tag, ns1__SubscribeRequestItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SubscribeRequestItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SubscribeRequestItemList, sizeof(ns1__SubscribeRequestItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SubscribeRequestItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SubscribeRequestItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItemList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribeRequestItemList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__SubscribeRequestItemList *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItemList *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__SubscribeRequestItemList *)a)->ReqType = soap_new_std__string(soap, -1);
			((ns1__SubscribeRequestItemList *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "Deadband", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItemList *)a)->Deadband = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2float(soap, t, ((ns1__SubscribeRequestItemList *)a)->Deadband))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "RequestedSamplingRate", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItemList *)a)->RequestedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ns1__SubscribeRequestItemList *)a)->RequestedSamplingRate))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "EnableBuffering", 0);
		if (t)
		{	if (!(((ns1__SubscribeRequestItemList *)a)->EnableBuffering = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__SubscribeRequestItemList *)a)->EnableBuffering))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, "ns1:Items", &(((ns1__SubscribeRequestItemList*)a)->Items), "ns1:SubscribeRequestItem"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeRequestItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SubscribeRequestItemList, 0, sizeof(ns1__SubscribeRequestItemList), 0, soap_copy_ns1__SubscribeRequestItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SubscribeRequestItemList * SOAP_FMAC6 soap_new_ns1__SubscribeRequestItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__SubscribeRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SubscribeRequestItemList(struct soap *soap, ns1__SubscribeRequestItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SubscribeRequestItemList * SOAP_FMAC4 soap_instantiate_ns1__SubscribeRequestItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SubscribeRequestItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SubscribeRequestItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SubscribeRequestItemList;
		if (size)
			*size = sizeof(ns1__SubscribeRequestItemList);
		((ns1__SubscribeRequestItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SubscribeRequestItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SubscribeRequestItemList);
		for (int i = 0; i < n; i++)
			((ns1__SubscribeRequestItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SubscribeRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SubscribeRequestItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SubscribeRequestItemList %p -> %p\n", q, p));
	*(ns1__SubscribeRequestItemList*)p = *(ns1__SubscribeRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__WriteRequestItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ItemValue(soap, &((ns1__WriteRequestItemList*)this)->Items);
	((ns1__WriteRequestItemList*)this)->ItemPath = NULL;
	/* transient soap skipped */
}

void ns1__WriteRequestItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ItemValue(soap, &((ns1__WriteRequestItemList*)this)->Items);
	/* transient soap skipped */
}

int ns1__WriteRequestItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__WriteRequestItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__WriteRequestItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__WriteRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__WriteRequestItemList(struct soap *soap, const char *tag, int id, const ns1__WriteRequestItemList *a, const char *type)
{
	if (((ns1__WriteRequestItemList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__WriteRequestItemList *)a)->ItemPath->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__WriteRequestItemList), type);
	soap_out_std__vectorTemplateOfPointerTons1__ItemValue(soap, "ns1:Items", -1, &(((ns1__WriteRequestItemList*)a)->Items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__WriteRequestItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__WriteRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__WriteRequestItemList * SOAP_FMAC4 soap_get_ns1__WriteRequestItemList(struct soap *soap, ns1__WriteRequestItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__WriteRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__WriteRequestItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__WriteRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__WriteRequestItemList * SOAP_FMAC4 soap_in_ns1__WriteRequestItemList(struct soap *soap, const char *tag, ns1__WriteRequestItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__WriteRequestItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__WriteRequestItemList, sizeof(ns1__WriteRequestItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__WriteRequestItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__WriteRequestItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__WriteRequestItemList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__WriteRequestItemList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__WriteRequestItemList *)a)->ItemPath->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ItemValue(soap, "ns1:Items", &(((ns1__WriteRequestItemList*)a)->Items), "ns1:ItemValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__WriteRequestItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__WriteRequestItemList, 0, sizeof(ns1__WriteRequestItemList), 0, soap_copy_ns1__WriteRequestItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__WriteRequestItemList * SOAP_FMAC6 soap_new_ns1__WriteRequestItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__WriteRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__WriteRequestItemList(struct soap *soap, ns1__WriteRequestItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__WriteRequestItemList * SOAP_FMAC4 soap_instantiate_ns1__WriteRequestItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__WriteRequestItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__WriteRequestItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__WriteRequestItemList;
		if (size)
			*size = sizeof(ns1__WriteRequestItemList);
		((ns1__WriteRequestItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__WriteRequestItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__WriteRequestItemList);
		for (int i = 0; i < n; i++)
			((ns1__WriteRequestItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__WriteRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__WriteRequestItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__WriteRequestItemList %p -> %p\n", q, p));
	*(ns1__WriteRequestItemList*)p = *(ns1__WriteRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfshort(soap, &((ns1__ArrayOfShort*)this)->short_);
	/* transient soap skipped */
}

void ns1__ArrayOfShort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfshort(soap, &((ns1__ArrayOfShort*)this)->short_);
	/* transient soap skipped */
}

int ns1__ArrayOfShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfShort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfShort(struct soap *soap, const char *tag, int id, const ns1__ArrayOfShort *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfShort), type);
	soap_out_std__vectorTemplateOfshort(soap, "ns1:short", -1, &(((ns1__ArrayOfShort*)a)->short_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfShort(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfShort * SOAP_FMAC4 soap_get_ns1__ArrayOfShort(struct soap *soap, ns1__ArrayOfShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfShort(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfShort * SOAP_FMAC4 soap_in_ns1__ArrayOfShort(struct soap *soap, const char *tag, ns1__ArrayOfShort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfShort, sizeof(ns1__ArrayOfShort), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfShort)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfShort *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfshort(soap, "ns1:short", &(((ns1__ArrayOfShort*)a)->short_), "xsd:short"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfShort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfShort, 0, sizeof(ns1__ArrayOfShort), 0, soap_copy_ns1__ArrayOfShort);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfShort * SOAP_FMAC6 soap_new_ns1__ArrayOfShort(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfShort(struct soap *soap, ns1__ArrayOfShort *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfShort * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfShort;
		if (size)
			*size = sizeof(ns1__ArrayOfShort);
		((ns1__ArrayOfShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfShort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfShort);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfShort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfShort %p -> %p\n", q, p));
	*(ns1__ArrayOfShort*)p = *(ns1__ArrayOfShort*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfByte::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfbyte(soap, &((ns1__ArrayOfByte*)this)->byte);
	/* transient soap skipped */
}

void ns1__ArrayOfByte::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfbyte(soap, &((ns1__ArrayOfByte*)this)->byte);
	/* transient soap skipped */
}

int ns1__ArrayOfByte::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfByte);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfByte::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfByte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfByte(struct soap *soap, const char *tag, int id, const ns1__ArrayOfByte *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfByte), type);
	soap_out_std__vectorTemplateOfbyte(soap, "ns1:byte", -1, &(((ns1__ArrayOfByte*)a)->byte), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfByte::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfByte(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfByte * SOAP_FMAC4 soap_get_ns1__ArrayOfByte(struct soap *soap, ns1__ArrayOfByte *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfByte::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfByte(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfByte * SOAP_FMAC4 soap_in_ns1__ArrayOfByte(struct soap *soap, const char *tag, ns1__ArrayOfByte *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfByte *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfByte, sizeof(ns1__ArrayOfByte), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfByte)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfByte *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfbyte(soap, "ns1:byte", &(((ns1__ArrayOfByte*)a)->byte), "xsd:byte"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfByte *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfByte, 0, sizeof(ns1__ArrayOfByte), 0, soap_copy_ns1__ArrayOfByte);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfByte * SOAP_FMAC6 soap_new_ns1__ArrayOfByte(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfByte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfByte(struct soap *soap, ns1__ArrayOfByte *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfByte * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfByte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfByte(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfByte, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfByte;
		if (size)
			*size = sizeof(ns1__ArrayOfByte);
		((ns1__ArrayOfByte*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfByte[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfByte);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfByte*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfByte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfByte(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfByte %p -> %p\n", q, p));
	*(ns1__ArrayOfByte*)p = *(ns1__ArrayOfByte*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfDecimal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__decimal(soap, &((ns1__ArrayOfDecimal*)this)->decimal);
	/* transient soap skipped */
}

void ns1__ArrayOfDecimal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__decimal(soap, &((ns1__ArrayOfDecimal*)this)->decimal);
	/* transient soap skipped */
}

int ns1__ArrayOfDecimal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDecimal);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfDecimal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDecimal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDecimal(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDecimal *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDecimal), type);
	soap_out_std__vectorTemplateOfxsd__decimal(soap, "ns1:decimal", -1, &(((ns1__ArrayOfDecimal*)a)->decimal), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfDecimal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDecimal(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDecimal * SOAP_FMAC4 soap_get_ns1__ArrayOfDecimal(struct soap *soap, ns1__ArrayOfDecimal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDecimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfDecimal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDecimal(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDecimal * SOAP_FMAC4 soap_in_ns1__ArrayOfDecimal(struct soap *soap, const char *tag, ns1__ArrayOfDecimal *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDecimal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDecimal, sizeof(ns1__ArrayOfDecimal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDecimal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDecimal *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__decimal(soap, "ns1:decimal", &(((ns1__ArrayOfDecimal*)a)->decimal), "xsd:decimal"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDecimal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDecimal, 0, sizeof(ns1__ArrayOfDecimal), 0, soap_copy_ns1__ArrayOfDecimal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfDecimal * SOAP_FMAC6 soap_new_ns1__ArrayOfDecimal(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfDecimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfDecimal(struct soap *soap, ns1__ArrayOfDecimal *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfDecimal * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfDecimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDecimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDecimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfDecimal;
		if (size)
			*size = sizeof(ns1__ArrayOfDecimal);
		((ns1__ArrayOfDecimal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfDecimal[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDecimal);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDecimal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDecimal*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDecimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDecimal %p -> %p\n", q, p));
	*(ns1__ArrayOfDecimal*)p = *(ns1__ArrayOfDecimal*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfAnyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &((ns1__ArrayOfAnyType*)this)->anyType);
	/* transient soap skipped */
}

void ns1__ArrayOfAnyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &((ns1__ArrayOfAnyType*)this)->anyType);
	/* transient soap skipped */
}

int ns1__ArrayOfAnyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfAnyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfAnyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfAnyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfAnyType(struct soap *soap, const char *tag, int id, const ns1__ArrayOfAnyType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfAnyType), type);
	soap_out_std__vectorTemplateOf_XML(soap, "ns1:anyType", -1, &(((ns1__ArrayOfAnyType*)a)->anyType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfAnyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfAnyType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfAnyType * SOAP_FMAC4 soap_get_ns1__ArrayOfAnyType(struct soap *soap, ns1__ArrayOfAnyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfAnyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfAnyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfAnyType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfAnyType * SOAP_FMAC4 soap_in_ns1__ArrayOfAnyType(struct soap *soap, const char *tag, ns1__ArrayOfAnyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfAnyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfAnyType, sizeof(ns1__ArrayOfAnyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfAnyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfAnyType *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "ns1:anyType", &(((ns1__ArrayOfAnyType*)a)->anyType), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfAnyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfAnyType, 0, sizeof(ns1__ArrayOfAnyType), 0, soap_copy_ns1__ArrayOfAnyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfAnyType * SOAP_FMAC6 soap_new_ns1__ArrayOfAnyType(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfAnyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfAnyType(struct soap *soap, ns1__ArrayOfAnyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfAnyType * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfAnyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfAnyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfAnyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfAnyType;
		if (size)
			*size = sizeof(ns1__ArrayOfAnyType);
		((ns1__ArrayOfAnyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfAnyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfAnyType);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfAnyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfAnyType*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfAnyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfAnyType %p -> %p\n", q, p));
	*(ns1__ArrayOfAnyType*)p = *(ns1__ArrayOfAnyType*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftime(soap, &((ns1__ArrayOfDateTime*)this)->dateTime);
	/* transient soap skipped */
}

void ns1__ArrayOfDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOftime(soap, &((ns1__ArrayOfDateTime*)this)->dateTime);
	/* transient soap skipped */
}

int ns1__ArrayOfDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDateTime(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDateTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDateTime), type);
	soap_out_std__vectorTemplateOftime(soap, "ns1:dateTime", -1, &(((ns1__ArrayOfDateTime*)a)->dateTime), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDateTime(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDateTime * SOAP_FMAC4 soap_get_ns1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDateTime(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDateTime * SOAP_FMAC4 soap_in_ns1__ArrayOfDateTime(struct soap *soap, const char *tag, ns1__ArrayOfDateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDateTime, sizeof(ns1__ArrayOfDateTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDateTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDateTime *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOftime(soap, "ns1:dateTime", &(((ns1__ArrayOfDateTime*)a)->dateTime), "xsd:dateTime"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDateTime, 0, sizeof(ns1__ArrayOfDateTime), 0, soap_copy_ns1__ArrayOfDateTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfDateTime * SOAP_FMAC6 soap_new_ns1__ArrayOfDateTime(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfDateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfDateTime(struct soap *soap, ns1__ArrayOfDateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfDateTime * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfDateTime;
		if (size)
			*size = sizeof(ns1__ArrayOfDateTime);
		((ns1__ArrayOfDateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfDateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDateTime);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDateTime*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDateTime %p -> %p\n", q, p));
	*(ns1__ArrayOfDateTime*)p = *(ns1__ArrayOfDateTime*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns1__ArrayOfString*)this)->string);
	/* transient soap skipped */
}

void ns1__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns1__ArrayOfString*)this)->string);
	/* transient soap skipped */
}

int ns1__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfString(struct soap *soap, const char *tag, int id, const ns1__ArrayOfString *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfString), type);
	soap_out_std__vectorTemplateOfstd__string(soap, "ns1:string", -1, &(((ns1__ArrayOfString*)a)->string), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_get_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_in_ns1__ArrayOfString(struct soap *soap, const char *tag, ns1__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfString, sizeof(ns1__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:string", &(((ns1__ArrayOfString*)a)->string), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfString, 0, sizeof(ns1__ArrayOfString), 0, soap_copy_ns1__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfString * SOAP_FMAC6 soap_new_ns1__ArrayOfString(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfString(struct soap *soap, ns1__ArrayOfString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfString * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfString;
		if (size)
			*size = sizeof(ns1__ArrayOfString);
		((ns1__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfString);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfString*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfString %p -> %p\n", q, p));
	*(ns1__ArrayOfString*)p = *(ns1__ArrayOfString*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfBoolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfbool(soap, &((ns1__ArrayOfBoolean*)this)->boolean);
	/* transient soap skipped */
}

void ns1__ArrayOfBoolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfbool(soap, &((ns1__ArrayOfBoolean*)this)->boolean);
	/* transient soap skipped */
}

int ns1__ArrayOfBoolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfBoolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfBoolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfBoolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfBoolean(struct soap *soap, const char *tag, int id, const ns1__ArrayOfBoolean *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfBoolean), type);
	soap_out_std__vectorTemplateOfbool(soap, "ns1:boolean", -1, &(((ns1__ArrayOfBoolean*)a)->boolean), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfBoolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfBoolean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfBoolean * SOAP_FMAC4 soap_get_ns1__ArrayOfBoolean(struct soap *soap, ns1__ArrayOfBoolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfBoolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfBoolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfBoolean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfBoolean * SOAP_FMAC4 soap_in_ns1__ArrayOfBoolean(struct soap *soap, const char *tag, ns1__ArrayOfBoolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfBoolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfBoolean, sizeof(ns1__ArrayOfBoolean), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfBoolean)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfBoolean *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfbool(soap, "ns1:boolean", &(((ns1__ArrayOfBoolean*)a)->boolean), "xsd:boolean"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfBoolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfBoolean, 0, sizeof(ns1__ArrayOfBoolean), 0, soap_copy_ns1__ArrayOfBoolean);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfBoolean * SOAP_FMAC6 soap_new_ns1__ArrayOfBoolean(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfBoolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfBoolean(struct soap *soap, ns1__ArrayOfBoolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfBoolean * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfBoolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfBoolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfBoolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfBoolean;
		if (size)
			*size = sizeof(ns1__ArrayOfBoolean);
		((ns1__ArrayOfBoolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfBoolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfBoolean);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfBoolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfBoolean*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfBoolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfBoolean %p -> %p\n", q, p));
	*(ns1__ArrayOfBoolean*)p = *(ns1__ArrayOfBoolean*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfUnsignedShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfunsignedShort(soap, &((ns1__ArrayOfUnsignedShort*)this)->unsignedShort);
	/* transient soap skipped */
}

void ns1__ArrayOfUnsignedShort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfunsignedShort(soap, &((ns1__ArrayOfUnsignedShort*)this)->unsignedShort);
	/* transient soap skipped */
}

int ns1__ArrayOfUnsignedShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfUnsignedShort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfUnsignedShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfUnsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfUnsignedShort(struct soap *soap, const char *tag, int id, const ns1__ArrayOfUnsignedShort *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfUnsignedShort), type);
	soap_out_std__vectorTemplateOfunsignedShort(soap, "ns1:unsignedShort", -1, &(((ns1__ArrayOfUnsignedShort*)a)->unsignedShort), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfUnsignedShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfUnsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedShort * SOAP_FMAC4 soap_get_ns1__ArrayOfUnsignedShort(struct soap *soap, ns1__ArrayOfUnsignedShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfUnsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfUnsignedShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfUnsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedShort * SOAP_FMAC4 soap_in_ns1__ArrayOfUnsignedShort(struct soap *soap, const char *tag, ns1__ArrayOfUnsignedShort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfUnsignedShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfUnsignedShort, sizeof(ns1__ArrayOfUnsignedShort), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfUnsignedShort)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfUnsignedShort *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfunsignedShort(soap, "ns1:unsignedShort", &(((ns1__ArrayOfUnsignedShort*)a)->unsignedShort), "xsd:unsignedShort"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfUnsignedShort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfUnsignedShort, 0, sizeof(ns1__ArrayOfUnsignedShort), 0, soap_copy_ns1__ArrayOfUnsignedShort);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfUnsignedShort * SOAP_FMAC6 soap_new_ns1__ArrayOfUnsignedShort(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfUnsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfUnsignedShort(struct soap *soap, ns1__ArrayOfUnsignedShort *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedShort * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfUnsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfUnsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfUnsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfUnsignedShort;
		if (size)
			*size = sizeof(ns1__ArrayOfUnsignedShort);
		((ns1__ArrayOfUnsignedShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfUnsignedShort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfUnsignedShort);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfUnsignedShort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfUnsignedShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfUnsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfUnsignedShort %p -> %p\n", q, p));
	*(ns1__ArrayOfUnsignedShort*)p = *(ns1__ArrayOfUnsignedShort*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfDouble::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &((ns1__ArrayOfDouble*)this)->double_);
	/* transient soap skipped */
}

void ns1__ArrayOfDouble::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &((ns1__ArrayOfDouble*)this)->double_);
	/* transient soap skipped */
}

int ns1__ArrayOfDouble::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfDouble);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfDouble::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfDouble(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfDouble(struct soap *soap, const char *tag, int id, const ns1__ArrayOfDouble *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfDouble), type);
	soap_out_std__vectorTemplateOfdouble(soap, "ns1:double", -1, &(((ns1__ArrayOfDouble*)a)->double_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfDouble::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfDouble(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfDouble * SOAP_FMAC4 soap_get_ns1__ArrayOfDouble(struct soap *soap, ns1__ArrayOfDouble *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfDouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfDouble::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfDouble(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfDouble * SOAP_FMAC4 soap_in_ns1__ArrayOfDouble(struct soap *soap, const char *tag, ns1__ArrayOfDouble *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfDouble *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfDouble, sizeof(ns1__ArrayOfDouble), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfDouble)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfDouble *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "ns1:double", &(((ns1__ArrayOfDouble*)a)->double_), "xsd:double"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfDouble *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfDouble, 0, sizeof(ns1__ArrayOfDouble), 0, soap_copy_ns1__ArrayOfDouble);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfDouble * SOAP_FMAC6 soap_new_ns1__ArrayOfDouble(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfDouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfDouble(struct soap *soap, ns1__ArrayOfDouble *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfDouble * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfDouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfDouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfDouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfDouble;
		if (size)
			*size = sizeof(ns1__ArrayOfDouble);
		((ns1__ArrayOfDouble*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfDouble[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfDouble);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfDouble*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfDouble*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfDouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfDouble %p -> %p\n", q, p));
	*(ns1__ArrayOfDouble*)p = *(ns1__ArrayOfDouble*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfUnsignedLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfunsignedLONG64(soap, &((ns1__ArrayOfUnsignedLong*)this)->unsignedLong);
	/* transient soap skipped */
}

void ns1__ArrayOfUnsignedLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfunsignedLONG64(soap, &((ns1__ArrayOfUnsignedLong*)this)->unsignedLong);
	/* transient soap skipped */
}

int ns1__ArrayOfUnsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfUnsignedLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfUnsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfUnsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfUnsignedLong(struct soap *soap, const char *tag, int id, const ns1__ArrayOfUnsignedLong *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfUnsignedLong), type);
	soap_out_std__vectorTemplateOfunsignedLONG64(soap, "ns1:unsignedLong", -1, &(((ns1__ArrayOfUnsignedLong*)a)->unsignedLong), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfUnsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfUnsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedLong * SOAP_FMAC4 soap_get_ns1__ArrayOfUnsignedLong(struct soap *soap, ns1__ArrayOfUnsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfUnsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfUnsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfUnsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedLong * SOAP_FMAC4 soap_in_ns1__ArrayOfUnsignedLong(struct soap *soap, const char *tag, ns1__ArrayOfUnsignedLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfUnsignedLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfUnsignedLong, sizeof(ns1__ArrayOfUnsignedLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfUnsignedLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfUnsignedLong *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfunsignedLONG64(soap, "ns1:unsignedLong", &(((ns1__ArrayOfUnsignedLong*)a)->unsignedLong), "xsd:unsignedLong"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfUnsignedLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfUnsignedLong, 0, sizeof(ns1__ArrayOfUnsignedLong), 0, soap_copy_ns1__ArrayOfUnsignedLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfUnsignedLong * SOAP_FMAC6 soap_new_ns1__ArrayOfUnsignedLong(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfUnsignedLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfUnsignedLong(struct soap *soap, ns1__ArrayOfUnsignedLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedLong * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfUnsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfUnsignedLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfUnsignedLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfUnsignedLong;
		if (size)
			*size = sizeof(ns1__ArrayOfUnsignedLong);
		((ns1__ArrayOfUnsignedLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfUnsignedLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfUnsignedLong);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfUnsignedLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfUnsignedLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfUnsignedLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfUnsignedLong %p -> %p\n", q, p));
	*(ns1__ArrayOfUnsignedLong*)p = *(ns1__ArrayOfUnsignedLong*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfLONG64(soap, &((ns1__ArrayOfLong*)this)->long_);
	/* transient soap skipped */
}

void ns1__ArrayOfLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfLONG64(soap, &((ns1__ArrayOfLong*)this)->long_);
	/* transient soap skipped */
}

int ns1__ArrayOfLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfLong(struct soap *soap, const char *tag, int id, const ns1__ArrayOfLong *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfLong), type);
	soap_out_std__vectorTemplateOfLONG64(soap, "ns1:long", -1, &(((ns1__ArrayOfLong*)a)->long_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfLong(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfLong * SOAP_FMAC4 soap_get_ns1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfLong(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfLong * SOAP_FMAC4 soap_in_ns1__ArrayOfLong(struct soap *soap, const char *tag, ns1__ArrayOfLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfLong, sizeof(ns1__ArrayOfLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfLong *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "ns1:long", &(((ns1__ArrayOfLong*)a)->long_), "xsd:long"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfLong, 0, sizeof(ns1__ArrayOfLong), 0, soap_copy_ns1__ArrayOfLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfLong * SOAP_FMAC6 soap_new_ns1__ArrayOfLong(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfLong(struct soap *soap, ns1__ArrayOfLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfLong * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfLong;
		if (size)
			*size = sizeof(ns1__ArrayOfLong);
		((ns1__ArrayOfLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfLong);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfLong %p -> %p\n", q, p));
	*(ns1__ArrayOfLong*)p = *(ns1__ArrayOfLong*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfUnsignedInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfunsignedInt(soap, &((ns1__ArrayOfUnsignedInt*)this)->unsignedInt);
	/* transient soap skipped */
}

void ns1__ArrayOfUnsignedInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfunsignedInt(soap, &((ns1__ArrayOfUnsignedInt*)this)->unsignedInt);
	/* transient soap skipped */
}

int ns1__ArrayOfUnsignedInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfUnsignedInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfUnsignedInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfUnsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfUnsignedInt(struct soap *soap, const char *tag, int id, const ns1__ArrayOfUnsignedInt *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfUnsignedInt), type);
	soap_out_std__vectorTemplateOfunsignedInt(soap, "ns1:unsignedInt", -1, &(((ns1__ArrayOfUnsignedInt*)a)->unsignedInt), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfUnsignedInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfUnsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedInt * SOAP_FMAC4 soap_get_ns1__ArrayOfUnsignedInt(struct soap *soap, ns1__ArrayOfUnsignedInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfUnsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfUnsignedInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfUnsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedInt * SOAP_FMAC4 soap_in_ns1__ArrayOfUnsignedInt(struct soap *soap, const char *tag, ns1__ArrayOfUnsignedInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfUnsignedInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfUnsignedInt, sizeof(ns1__ArrayOfUnsignedInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfUnsignedInt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfUnsignedInt *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfunsignedInt(soap, "ns1:unsignedInt", &(((ns1__ArrayOfUnsignedInt*)a)->unsignedInt), "xsd:unsignedInt"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfUnsignedInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfUnsignedInt, 0, sizeof(ns1__ArrayOfUnsignedInt), 0, soap_copy_ns1__ArrayOfUnsignedInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfUnsignedInt * SOAP_FMAC6 soap_new_ns1__ArrayOfUnsignedInt(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfUnsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfUnsignedInt(struct soap *soap, ns1__ArrayOfUnsignedInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfUnsignedInt * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfUnsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfUnsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfUnsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfUnsignedInt;
		if (size)
			*size = sizeof(ns1__ArrayOfUnsignedInt);
		((ns1__ArrayOfUnsignedInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfUnsignedInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfUnsignedInt);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfUnsignedInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfUnsignedInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfUnsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfUnsignedInt %p -> %p\n", q, p));
	*(ns1__ArrayOfUnsignedInt*)p = *(ns1__ArrayOfUnsignedInt*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &((ns1__ArrayOfInt*)this)->int_);
	/* transient soap skipped */
}

void ns1__ArrayOfInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &((ns1__ArrayOfInt*)this)->int_);
	/* transient soap skipped */
}

int ns1__ArrayOfInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfInt(struct soap *soap, const char *tag, int id, const ns1__ArrayOfInt *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfInt), type);
	soap_out_std__vectorTemplateOfint(soap, "ns1:int", -1, &(((ns1__ArrayOfInt*)a)->int_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfInt(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfInt * SOAP_FMAC4 soap_get_ns1__ArrayOfInt(struct soap *soap, ns1__ArrayOfInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfInt(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfInt * SOAP_FMAC4 soap_in_ns1__ArrayOfInt(struct soap *soap, const char *tag, ns1__ArrayOfInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfInt, sizeof(ns1__ArrayOfInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfInt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfInt *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "ns1:int", &(((ns1__ArrayOfInt*)a)->int_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfInt, 0, sizeof(ns1__ArrayOfInt), 0, soap_copy_ns1__ArrayOfInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfInt * SOAP_FMAC6 soap_new_ns1__ArrayOfInt(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfInt(struct soap *soap, ns1__ArrayOfInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfInt * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfInt;
		if (size)
			*size = sizeof(ns1__ArrayOfInt);
		((ns1__ArrayOfInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfInt);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfInt %p -> %p\n", q, p));
	*(ns1__ArrayOfInt*)p = *(ns1__ArrayOfInt*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ArrayOfFloat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOffloat(soap, &((ns1__ArrayOfFloat*)this)->float_);
	/* transient soap skipped */
}

void ns1__ArrayOfFloat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOffloat(soap, &((ns1__ArrayOfFloat*)this)->float_);
	/* transient soap skipped */
}

int ns1__ArrayOfFloat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ArrayOfFloat);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ArrayOfFloat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfFloat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfFloat(struct soap *soap, const char *tag, int id, const ns1__ArrayOfFloat *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfFloat), type);
	soap_out_std__vectorTemplateOffloat(soap, "ns1:float", -1, &(((ns1__ArrayOfFloat*)a)->float_), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ArrayOfFloat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfFloat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfFloat * SOAP_FMAC4 soap_get_ns1__ArrayOfFloat(struct soap *soap, ns1__ArrayOfFloat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfFloat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ArrayOfFloat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfFloat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfFloat * SOAP_FMAC4 soap_in_ns1__ArrayOfFloat(struct soap *soap, const char *tag, ns1__ArrayOfFloat *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfFloat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfFloat, sizeof(ns1__ArrayOfFloat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ArrayOfFloat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ArrayOfFloat *)a->soap_in(soap, tag, type);
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOffloat(soap, "ns1:float", &(((ns1__ArrayOfFloat*)a)->float_), "xsd:float"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfFloat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfFloat, 0, sizeof(ns1__ArrayOfFloat), 0, soap_copy_ns1__ArrayOfFloat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ArrayOfFloat * SOAP_FMAC6 soap_new_ns1__ArrayOfFloat(struct soap *soap, int n)
{	return soap_instantiate_ns1__ArrayOfFloat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ArrayOfFloat(struct soap *soap, ns1__ArrayOfFloat *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ArrayOfFloat * SOAP_FMAC4 soap_instantiate_ns1__ArrayOfFloat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfFloat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ArrayOfFloat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ArrayOfFloat;
		if (size)
			*size = sizeof(ns1__ArrayOfFloat);
		((ns1__ArrayOfFloat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ArrayOfFloat[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ArrayOfFloat);
		for (int i = 0; i < n; i++)
			((ns1__ArrayOfFloat*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ArrayOfFloat*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ArrayOfFloat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ArrayOfFloat %p -> %p\n", q, p));
	*(ns1__ArrayOfFloat*)p = *(ns1__ArrayOfFloat*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__OPCError::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__OPCError*)this)->Text = NULL;
	soap_default_xsd__QName(soap, &((ns1__OPCError*)this)->ID);
	/* transient soap skipped */
}

void ns1__OPCError::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__OPCError*)this)->Text);
	/* transient soap skipped */
}

int ns1__OPCError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OPCError);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__OPCError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OPCError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OPCError(struct soap *soap, const char *tag, int id, const ns1__OPCError *a, const char *type)
{
	if (!((ns1__OPCError *)a)->ID.empty())
		soap_set_attr(soap, "ID", soap_QName2s(soap, ((ns1__OPCError *)a)->ID.c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OPCError), type);
	soap_out_PointerTostd__string(soap, "ns1:Text", -1, &(((ns1__OPCError*)a)->Text), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__OPCError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OPCError(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OPCError * SOAP_FMAC4 soap_get_ns1__OPCError(struct soap *soap, ns1__OPCError *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OPCError(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__OPCError::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OPCError(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OPCError * SOAP_FMAC4 soap_in_ns1__OPCError(struct soap *soap, const char *tag, ns1__OPCError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OPCError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OPCError, sizeof(ns1__OPCError), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OPCError)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OPCError *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ID", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s))
				return NULL;
			((ns1__OPCError *)a)->ID.assign(s);
		}
	}
	short soap_flag_Text1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:Text", &(((ns1__OPCError*)a)->Text), "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OPCError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OPCError, 0, sizeof(ns1__OPCError), 0, soap_copy_ns1__OPCError);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__OPCError * SOAP_FMAC6 soap_new_ns1__OPCError(struct soap *soap, int n)
{	return soap_instantiate_ns1__OPCError(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__OPCError(struct soap *soap, ns1__OPCError *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__OPCError * SOAP_FMAC4 soap_instantiate_ns1__OPCError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OPCError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OPCError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__OPCError;
		if (size)
			*size = sizeof(ns1__OPCError);
		((ns1__OPCError*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__OPCError[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OPCError);
		for (int i = 0; i < n; i++)
			((ns1__OPCError*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OPCError*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OPCError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OPCError %p -> %p\n", q, p));
	*(ns1__OPCError*)p = *(ns1__OPCError*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__OPCQuality::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__OPCQuality*)this)->QualityField = NULL;
	((ns1__OPCQuality*)this)->LimitField = NULL;
	((ns1__OPCQuality*)this)->VendorField = NULL;
	/* transient soap skipped */
}

void ns1__OPCQuality::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__OPCQuality::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OPCQuality);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__OPCQuality::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OPCQuality(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OPCQuality(struct soap *soap, const char *tag, int id, const ns1__OPCQuality *a, const char *type)
{
	if (((ns1__OPCQuality *)a)->QualityField)
		soap_set_attr(soap, "QualityField", soap_ns1__qualityBits2s(soap, *((ns1__OPCQuality *)a)->QualityField));
	if (((ns1__OPCQuality *)a)->LimitField)
		soap_set_attr(soap, "LimitField", soap_ns1__limitBits2s(soap, *((ns1__OPCQuality *)a)->LimitField));
	if (((ns1__OPCQuality *)a)->VendorField)
		soap_set_attr(soap, "VendorField", soap_unsignedShort2s(soap, *((ns1__OPCQuality *)a)->VendorField));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OPCQuality), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__OPCQuality::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OPCQuality(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OPCQuality * SOAP_FMAC4 soap_get_ns1__OPCQuality(struct soap *soap, ns1__OPCQuality *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OPCQuality(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__OPCQuality::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OPCQuality(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OPCQuality * SOAP_FMAC4 soap_in_ns1__OPCQuality(struct soap *soap, const char *tag, ns1__OPCQuality *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OPCQuality *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OPCQuality, sizeof(ns1__OPCQuality), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OPCQuality)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OPCQuality *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "QualityField", 0);
		if (t)
		{	if (!(((ns1__OPCQuality *)a)->QualityField = (enum ns1__qualityBits *)soap_malloc(soap, sizeof(enum ns1__qualityBits))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2ns1__qualityBits(soap, t, ((ns1__OPCQuality *)a)->QualityField))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "LimitField", 0);
		if (t)
		{	if (!(((ns1__OPCQuality *)a)->LimitField = (enum ns1__limitBits *)soap_malloc(soap, sizeof(enum ns1__limitBits))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2ns1__limitBits(soap, t, ((ns1__OPCQuality *)a)->LimitField))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "VendorField", 0);
		if (t)
		{	if (!(((ns1__OPCQuality *)a)->VendorField = (unsigned short *)soap_malloc(soap, sizeof(unsigned short))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2unsignedShort(soap, t, ((ns1__OPCQuality *)a)->VendorField))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OPCQuality *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OPCQuality, 0, sizeof(ns1__OPCQuality), 0, soap_copy_ns1__OPCQuality);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__OPCQuality * SOAP_FMAC6 soap_new_ns1__OPCQuality(struct soap *soap, int n)
{	return soap_instantiate_ns1__OPCQuality(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__OPCQuality(struct soap *soap, ns1__OPCQuality *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__OPCQuality * SOAP_FMAC4 soap_instantiate_ns1__OPCQuality(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OPCQuality(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OPCQuality, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__OPCQuality;
		if (size)
			*size = sizeof(ns1__OPCQuality);
		((ns1__OPCQuality*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__OPCQuality[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OPCQuality);
		for (int i = 0; i < n; i++)
			((ns1__OPCQuality*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OPCQuality*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OPCQuality(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OPCQuality %p -> %p\n", q, p));
	*(ns1__OPCQuality*)p = *(ns1__OPCQuality*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ItemValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ItemValue*)this)->DiagnosticInfo = NULL;
	((ns1__ItemValue*)this)->Value = NULL;
	((ns1__ItemValue*)this)->Quality = NULL;
	((ns1__ItemValue*)this)->ValueTypeQualifier = NULL;
	((ns1__ItemValue*)this)->ItemPath = NULL;
	((ns1__ItemValue*)this)->ItemName = NULL;
	((ns1__ItemValue*)this)->ClientItemHandle = NULL;
	((ns1__ItemValue*)this)->Timestamp = NULL;
	((ns1__ItemValue*)this)->ResultID = NULL;
	/* transient soap skipped */
}

void ns1__ItemValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__ItemValue*)this)->DiagnosticInfo);
	soap_serialize_PointerTons1__OPCQuality(soap, &((ns1__ItemValue*)this)->Quality);
	/* transient soap skipped */
}

int ns1__ItemValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ItemValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ItemValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ItemValue(struct soap *soap, const char *tag, int id, const ns1__ItemValue *a, const char *type)
{
	if (((ns1__ItemValue *)a)->ValueTypeQualifier)
		soap_set_attr(soap, "ValueTypeQualifier", soap_QName2s(soap, ((ns1__ItemValue *)a)->ValueTypeQualifier->c_str()));
	if (((ns1__ItemValue *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__ItemValue *)a)->ItemPath->c_str());
	if (((ns1__ItemValue *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__ItemValue *)a)->ItemName->c_str());
	if (((ns1__ItemValue *)a)->ClientItemHandle)
		soap_set_attr(soap, "ClientItemHandle", ((ns1__ItemValue *)a)->ClientItemHandle->c_str());
	if (((ns1__ItemValue *)a)->Timestamp)
		soap_set_attr(soap, "Timestamp", soap_dateTime2s(soap, *((ns1__ItemValue *)a)->Timestamp));
	if (((ns1__ItemValue *)a)->ResultID)
		soap_set_attr(soap, "ResultID", soap_QName2s(soap, ((ns1__ItemValue *)a)->ResultID->c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ItemValue), type);
	soap_out_PointerTostd__string(soap, "ns1:DiagnosticInfo", -1, &(((ns1__ItemValue*)a)->DiagnosticInfo), "");
	soap_outliteral(soap, "ns1:Value", &(((ns1__ItemValue*)a)->Value), NULL);
	soap_out_PointerTons1__OPCQuality(soap, "ns1:Quality", -1, &(((ns1__ItemValue*)a)->Quality), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ItemValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ItemValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ItemValue * SOAP_FMAC4 soap_get_ns1__ItemValue(struct soap *soap, ns1__ItemValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ItemValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ItemValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ItemValue * SOAP_FMAC4 soap_in_ns1__ItemValue(struct soap *soap, const char *tag, ns1__ItemValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ItemValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ItemValue, sizeof(ns1__ItemValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ItemValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ItemValue *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ValueTypeQualifier", 0);
		if (t)
		{	if (!(((ns1__ItemValue *)a)->ValueTypeQualifier = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemValue *)a)->ValueTypeQualifier = soap_new_std__string(soap, -1);
			((ns1__ItemValue *)a)->ValueTypeQualifier->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__ItemValue *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemValue *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__ItemValue *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__ItemValue *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemValue *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__ItemValue *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientItemHandle", 0);
		if (t)
		{	if (!(((ns1__ItemValue *)a)->ClientItemHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemValue *)a)->ClientItemHandle = soap_new_std__string(soap, -1);
			((ns1__ItemValue *)a)->ClientItemHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "Timestamp", 0);
		if (t)
		{	if (!(((ns1__ItemValue *)a)->Timestamp = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2dateTime(soap, t, ((ns1__ItemValue *)a)->Timestamp))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ResultID", 0);
		if (t)
		{	if (!(((ns1__ItemValue *)a)->ResultID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ItemValue *)a)->ResultID = soap_new_std__string(soap, -1);
			((ns1__ItemValue *)a)->ResultID->assign(s);
		}
		}
	}
	short soap_flag_DiagnosticInfo1 = 1, soap_flag_Value1 = 1, soap_flag_Quality1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiagnosticInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:DiagnosticInfo", &(((ns1__ItemValue*)a)->DiagnosticInfo), "xsd:string"))
				{	soap_flag_DiagnosticInfo1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "ns1:Value", &(((ns1__ItemValue*)a)->Value)))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OPCQuality(soap, "ns1:Quality", &(((ns1__ItemValue*)a)->Quality), "ns1:OPCQuality"))
				{	soap_flag_Quality1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ItemValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ItemValue, 0, sizeof(ns1__ItemValue), 0, soap_copy_ns1__ItemValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ItemValue * SOAP_FMAC6 soap_new_ns1__ItemValue(struct soap *soap, int n)
{	return soap_instantiate_ns1__ItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ItemValue(struct soap *soap, ns1__ItemValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ItemValue * SOAP_FMAC4 soap_instantiate_ns1__ItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ItemValue;
		if (size)
			*size = sizeof(ns1__ItemValue);
		((ns1__ItemValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ItemValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ItemValue);
		for (int i = 0; i < n; i++)
			((ns1__ItemValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ItemValue*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ItemValue %p -> %p\n", q, p));
	*(ns1__ItemValue*)p = *(ns1__ItemValue*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ReplyItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ItemValue(soap, &((ns1__ReplyItemList*)this)->Items);
	((ns1__ReplyItemList*)this)->Reserved = NULL;
	/* transient soap skipped */
}

void ns1__ReplyItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ItemValue(soap, &((ns1__ReplyItemList*)this)->Items);
	/* transient soap skipped */
}

int ns1__ReplyItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReplyItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ReplyItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReplyItemList(struct soap *soap, const char *tag, int id, const ns1__ReplyItemList *a, const char *type)
{
	if (((ns1__ReplyItemList *)a)->Reserved)
		soap_set_attr(soap, "Reserved", ((ns1__ReplyItemList *)a)->Reserved->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReplyItemList), type);
	soap_out_std__vectorTemplateOfPointerTons1__ItemValue(soap, "ns1:Items", -1, &(((ns1__ReplyItemList*)a)->Items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ReplyItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReplyItemList * SOAP_FMAC4 soap_get_ns1__ReplyItemList(struct soap *soap, ns1__ReplyItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ReplyItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReplyItemList * SOAP_FMAC4 soap_in_ns1__ReplyItemList(struct soap *soap, const char *tag, ns1__ReplyItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReplyItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReplyItemList, sizeof(ns1__ReplyItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReplyItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReplyItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Reserved", 0);
		if (t)
		{	if (!(((ns1__ReplyItemList *)a)->Reserved = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReplyItemList *)a)->Reserved = soap_new_std__string(soap, -1);
			((ns1__ReplyItemList *)a)->Reserved->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ItemValue(soap, "ns1:Items", &(((ns1__ReplyItemList*)a)->Items), "ns1:ItemValue"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReplyItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReplyItemList, 0, sizeof(ns1__ReplyItemList), 0, soap_copy_ns1__ReplyItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ReplyItemList * SOAP_FMAC6 soap_new_ns1__ReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ReplyItemList(struct soap *soap, ns1__ReplyItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ReplyItemList * SOAP_FMAC4 soap_instantiate_ns1__ReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ReplyItemList;
		if (size)
			*size = sizeof(ns1__ReplyItemList);
		((ns1__ReplyItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ReplyItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReplyItemList);
		for (int i = 0; i < n; i++)
			((ns1__ReplyItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReplyItemList %p -> %p\n", q, p));
	*(ns1__ReplyItemList*)p = *(ns1__ReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ReadRequestItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ReadRequestItem*)this)->ItemPath = NULL;
	((ns1__ReadRequestItem*)this)->ReqType = NULL;
	((ns1__ReadRequestItem*)this)->ItemName = NULL;
	((ns1__ReadRequestItem*)this)->ClientItemHandle = NULL;
	((ns1__ReadRequestItem*)this)->MaxAge = NULL;
	/* transient soap skipped */
}

void ns1__ReadRequestItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__ReadRequestItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReadRequestItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ReadRequestItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReadRequestItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReadRequestItem(struct soap *soap, const char *tag, int id, const ns1__ReadRequestItem *a, const char *type)
{
	if (((ns1__ReadRequestItem *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__ReadRequestItem *)a)->ItemPath->c_str());
	if (((ns1__ReadRequestItem *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((ns1__ReadRequestItem *)a)->ReqType->c_str()));
	if (((ns1__ReadRequestItem *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((ns1__ReadRequestItem *)a)->ItemName->c_str());
	if (((ns1__ReadRequestItem *)a)->ClientItemHandle)
		soap_set_attr(soap, "ClientItemHandle", ((ns1__ReadRequestItem *)a)->ClientItemHandle->c_str());
	if (((ns1__ReadRequestItem *)a)->MaxAge)
		soap_set_attr(soap, "MaxAge", soap_int2s(soap, *((ns1__ReadRequestItem *)a)->MaxAge));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReadRequestItem), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ReadRequestItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReadRequestItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReadRequestItem * SOAP_FMAC4 soap_get_ns1__ReadRequestItem(struct soap *soap, ns1__ReadRequestItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReadRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ReadRequestItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReadRequestItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReadRequestItem * SOAP_FMAC4 soap_in_ns1__ReadRequestItem(struct soap *soap, const char *tag, ns1__ReadRequestItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReadRequestItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReadRequestItem, sizeof(ns1__ReadRequestItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReadRequestItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReadRequestItem *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItem *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReadRequestItem *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__ReadRequestItem *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItem *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReadRequestItem *)a)->ReqType = soap_new_std__string(soap, -1);
			((ns1__ReadRequestItem *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItem *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReadRequestItem *)a)->ItemName = soap_new_std__string(soap, -1);
			((ns1__ReadRequestItem *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientItemHandle", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItem *)a)->ClientItemHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReadRequestItem *)a)->ClientItemHandle = soap_new_std__string(soap, -1);
			((ns1__ReadRequestItem *)a)->ClientItemHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MaxAge", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItem *)a)->MaxAge = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ns1__ReadRequestItem *)a)->MaxAge))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReadRequestItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReadRequestItem, 0, sizeof(ns1__ReadRequestItem), 0, soap_copy_ns1__ReadRequestItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ReadRequestItem * SOAP_FMAC6 soap_new_ns1__ReadRequestItem(struct soap *soap, int n)
{	return soap_instantiate_ns1__ReadRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ReadRequestItem(struct soap *soap, ns1__ReadRequestItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ReadRequestItem * SOAP_FMAC4 soap_instantiate_ns1__ReadRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReadRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReadRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ReadRequestItem;
		if (size)
			*size = sizeof(ns1__ReadRequestItem);
		((ns1__ReadRequestItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ReadRequestItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReadRequestItem);
		for (int i = 0; i < n; i++)
			((ns1__ReadRequestItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReadRequestItem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReadRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReadRequestItem %p -> %p\n", q, p));
	*(ns1__ReadRequestItem*)p = *(ns1__ReadRequestItem*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ReadRequestItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, &((ns1__ReadRequestItemList*)this)->Items);
	((ns1__ReadRequestItemList*)this)->ItemPath = NULL;
	((ns1__ReadRequestItemList*)this)->ReqType = NULL;
	((ns1__ReadRequestItemList*)this)->MaxAge = NULL;
	/* transient soap skipped */
}

void ns1__ReadRequestItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, &((ns1__ReadRequestItemList*)this)->Items);
	/* transient soap skipped */
}

int ns1__ReadRequestItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReadRequestItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ReadRequestItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReadRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReadRequestItemList(struct soap *soap, const char *tag, int id, const ns1__ReadRequestItemList *a, const char *type)
{
	if (((ns1__ReadRequestItemList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((ns1__ReadRequestItemList *)a)->ItemPath->c_str());
	if (((ns1__ReadRequestItemList *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((ns1__ReadRequestItemList *)a)->ReqType->c_str()));
	if (((ns1__ReadRequestItemList *)a)->MaxAge)
		soap_set_attr(soap, "MaxAge", soap_int2s(soap, *((ns1__ReadRequestItemList *)a)->MaxAge));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReadRequestItemList), type);
	soap_out_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, "ns1:Items", -1, &(((ns1__ReadRequestItemList*)a)->Items), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ReadRequestItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReadRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReadRequestItemList * SOAP_FMAC4 soap_get_ns1__ReadRequestItemList(struct soap *soap, ns1__ReadRequestItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReadRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ReadRequestItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReadRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReadRequestItemList * SOAP_FMAC4 soap_in_ns1__ReadRequestItemList(struct soap *soap, const char *tag, ns1__ReadRequestItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReadRequestItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReadRequestItemList, sizeof(ns1__ReadRequestItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReadRequestItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReadRequestItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItemList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReadRequestItemList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((ns1__ReadRequestItemList *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItemList *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReadRequestItemList *)a)->ReqType = soap_new_std__string(soap, -1);
			((ns1__ReadRequestItemList *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MaxAge", 0);
		if (t)
		{	if (!(((ns1__ReadRequestItemList *)a)->MaxAge = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((ns1__ReadRequestItemList *)a)->MaxAge))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, "ns1:Items", &(((ns1__ReadRequestItemList*)a)->Items), "ns1:ReadRequestItem"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReadRequestItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReadRequestItemList, 0, sizeof(ns1__ReadRequestItemList), 0, soap_copy_ns1__ReadRequestItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ReadRequestItemList * SOAP_FMAC6 soap_new_ns1__ReadRequestItemList(struct soap *soap, int n)
{	return soap_instantiate_ns1__ReadRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ReadRequestItemList(struct soap *soap, ns1__ReadRequestItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ReadRequestItemList * SOAP_FMAC4 soap_instantiate_ns1__ReadRequestItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReadRequestItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReadRequestItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ReadRequestItemList;
		if (size)
			*size = sizeof(ns1__ReadRequestItemList);
		((ns1__ReadRequestItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ReadRequestItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReadRequestItemList);
		for (int i = 0; i < n; i++)
			((ns1__ReadRequestItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReadRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReadRequestItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReadRequestItemList %p -> %p\n", q, p));
	*(ns1__ReadRequestItemList*)p = *(ns1__ReadRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__RequestOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__RequestOptions*)this)->ReturnErrorText = NULL;
	((ns1__RequestOptions*)this)->ReturnDiagnosticInfo = NULL;
	((ns1__RequestOptions*)this)->ReturnItemTime = NULL;
	((ns1__RequestOptions*)this)->ReturnItemPath = NULL;
	((ns1__RequestOptions*)this)->ReturnItemName = NULL;
	((ns1__RequestOptions*)this)->RequestDeadline = NULL;
	((ns1__RequestOptions*)this)->ClientRequestHandle = NULL;
	((ns1__RequestOptions*)this)->LocaleID = NULL;
	/* transient soap skipped */
}

void ns1__RequestOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__RequestOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RequestOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__RequestOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RequestOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RequestOptions(struct soap *soap, const char *tag, int id, const ns1__RequestOptions *a, const char *type)
{
	if (((ns1__RequestOptions *)a)->ReturnErrorText)
		soap_set_attr(soap, "ReturnErrorText", soap_bool2s(soap, *((ns1__RequestOptions *)a)->ReturnErrorText));
	if (((ns1__RequestOptions *)a)->ReturnDiagnosticInfo)
		soap_set_attr(soap, "ReturnDiagnosticInfo", soap_bool2s(soap, *((ns1__RequestOptions *)a)->ReturnDiagnosticInfo));
	if (((ns1__RequestOptions *)a)->ReturnItemTime)
		soap_set_attr(soap, "ReturnItemTime", soap_bool2s(soap, *((ns1__RequestOptions *)a)->ReturnItemTime));
	if (((ns1__RequestOptions *)a)->ReturnItemPath)
		soap_set_attr(soap, "ReturnItemPath", soap_bool2s(soap, *((ns1__RequestOptions *)a)->ReturnItemPath));
	if (((ns1__RequestOptions *)a)->ReturnItemName)
		soap_set_attr(soap, "ReturnItemName", soap_bool2s(soap, *((ns1__RequestOptions *)a)->ReturnItemName));
	if (((ns1__RequestOptions *)a)->RequestDeadline)
		soap_set_attr(soap, "RequestDeadline", soap_dateTime2s(soap, *((ns1__RequestOptions *)a)->RequestDeadline));
	if (((ns1__RequestOptions *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((ns1__RequestOptions *)a)->ClientRequestHandle->c_str());
	if (((ns1__RequestOptions *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((ns1__RequestOptions *)a)->LocaleID->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RequestOptions), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RequestOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RequestOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RequestOptions * SOAP_FMAC4 soap_get_ns1__RequestOptions(struct soap *soap, ns1__RequestOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RequestOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RequestOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RequestOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RequestOptions * SOAP_FMAC4 soap_in_ns1__RequestOptions(struct soap *soap, const char *tag, ns1__RequestOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RequestOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RequestOptions, sizeof(ns1__RequestOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RequestOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RequestOptions *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnErrorText", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->ReturnErrorText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__RequestOptions *)a)->ReturnErrorText))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnDiagnosticInfo", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->ReturnDiagnosticInfo = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__RequestOptions *)a)->ReturnDiagnosticInfo))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnItemTime", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->ReturnItemTime = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__RequestOptions *)a)->ReturnItemTime))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnItemPath", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->ReturnItemPath = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__RequestOptions *)a)->ReturnItemPath))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnItemName", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->ReturnItemName = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((ns1__RequestOptions *)a)->ReturnItemName))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "RequestDeadline", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->RequestDeadline = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2dateTime(soap, t, ((ns1__RequestOptions *)a)->RequestDeadline))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__RequestOptions *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((ns1__RequestOptions *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((ns1__RequestOptions *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__RequestOptions *)a)->LocaleID = soap_new_std__string(soap, -1);
			((ns1__RequestOptions *)a)->LocaleID->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RequestOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RequestOptions, 0, sizeof(ns1__RequestOptions), 0, soap_copy_ns1__RequestOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RequestOptions * SOAP_FMAC6 soap_new_ns1__RequestOptions(struct soap *soap, int n)
{	return soap_instantiate_ns1__RequestOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RequestOptions(struct soap *soap, ns1__RequestOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__RequestOptions * SOAP_FMAC4 soap_instantiate_ns1__RequestOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RequestOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RequestOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RequestOptions;
		if (size)
			*size = sizeof(ns1__RequestOptions);
		((ns1__RequestOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RequestOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RequestOptions);
		for (int i = 0; i < n; i++)
			((ns1__RequestOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RequestOptions*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RequestOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RequestOptions %p -> %p\n", q, p));
	*(ns1__RequestOptions*)p = *(ns1__RequestOptions*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ServerStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ServerStatus*)this)->StatusInfo = NULL;
	((ns1__ServerStatus*)this)->VendorInfo = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((ns1__ServerStatus*)this)->SupportedLocaleIDs);
	soap_default_std__vectorTemplateOfns1__interfaceVersion(soap, &((ns1__ServerStatus*)this)->SupportedInterfaceVersions);
	soap_default_time(soap, &((ns1__ServerStatus*)this)->StartTime);
	((ns1__ServerStatus*)this)->ProductVersion = NULL;
	/* transient soap skipped */
}

void ns1__ServerStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__ServerStatus*)this)->StatusInfo);
	soap_serialize_PointerTostd__string(soap, &((ns1__ServerStatus*)this)->VendorInfo);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((ns1__ServerStatus*)this)->SupportedLocaleIDs);
	soap_serialize_std__vectorTemplateOfns1__interfaceVersion(soap, &((ns1__ServerStatus*)this)->SupportedInterfaceVersions);
	/* transient soap skipped */
}

int ns1__ServerStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ServerStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ServerStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ServerStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServerStatus(struct soap *soap, const char *tag, int id, const ns1__ServerStatus *a, const char *type)
{
	soap_set_attr(soap, "StartTime", soap_dateTime2s(soap, ((ns1__ServerStatus *)a)->StartTime));
	if (((ns1__ServerStatus *)a)->ProductVersion)
		soap_set_attr(soap, "ProductVersion", ((ns1__ServerStatus *)a)->ProductVersion->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServerStatus), type);
	soap_out_PointerTostd__string(soap, "ns1:StatusInfo", -1, &(((ns1__ServerStatus*)a)->StatusInfo), "");
	soap_out_PointerTostd__string(soap, "ns1:VendorInfo", -1, &(((ns1__ServerStatus*)a)->VendorInfo), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "ns1:SupportedLocaleIDs", -1, &(((ns1__ServerStatus*)a)->SupportedLocaleIDs), "");
	soap_out_std__vectorTemplateOfns1__interfaceVersion(soap, "ns1:SupportedInterfaceVersions", -1, &(((ns1__ServerStatus*)a)->SupportedInterfaceVersions), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ServerStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ServerStatus(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ServerStatus * SOAP_FMAC4 soap_get_ns1__ServerStatus(struct soap *soap, ns1__ServerStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServerStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ServerStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ServerStatus(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ServerStatus * SOAP_FMAC4 soap_in_ns1__ServerStatus(struct soap *soap, const char *tag, ns1__ServerStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ServerStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServerStatus, sizeof(ns1__ServerStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ServerStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ServerStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "StartTime", 1), &((ns1__ServerStatus *)a)->StartTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ProductVersion", 0);
		if (t)
		{	if (!(((ns1__ServerStatus *)a)->ProductVersion = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ServerStatus *)a)->ProductVersion = soap_new_std__string(soap, -1);
			((ns1__ServerStatus *)a)->ProductVersion->assign(s);
		}
		}
	}
	short soap_flag_StatusInfo1 = 1, soap_flag_VendorInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StatusInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:StatusInfo", &(((ns1__ServerStatus*)a)->StatusInfo), "xsd:string"))
				{	soap_flag_StatusInfo1--;
					continue;
				}
			if (soap_flag_VendorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:VendorInfo", &(((ns1__ServerStatus*)a)->VendorInfo), "xsd:string"))
				{	soap_flag_VendorInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns1:SupportedLocaleIDs", &(((ns1__ServerStatus*)a)->SupportedLocaleIDs), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__interfaceVersion(soap, "ns1:SupportedInterfaceVersions", &(((ns1__ServerStatus*)a)->SupportedInterfaceVersions), "ns1:interfaceVersion"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ServerStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServerStatus, 0, sizeof(ns1__ServerStatus), 0, soap_copy_ns1__ServerStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ServerStatus * SOAP_FMAC6 soap_new_ns1__ServerStatus(struct soap *soap, int n)
{	return soap_instantiate_ns1__ServerStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ServerStatus(struct soap *soap, ns1__ServerStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ServerStatus * SOAP_FMAC4 soap_instantiate_ns1__ServerStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ServerStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ServerStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ServerStatus;
		if (size)
			*size = sizeof(ns1__ServerStatus);
		((ns1__ServerStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ServerStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ServerStatus);
		for (int i = 0; i < n; i++)
			((ns1__ServerStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ServerStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ServerStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ServerStatus %p -> %p\n", q, p));
	*(ns1__ServerStatus*)p = *(ns1__ServerStatus*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ReplyBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &((ns1__ReplyBase*)this)->RcvTime);
	soap_default_time(soap, &((ns1__ReplyBase*)this)->ReplyTime);
	((ns1__ReplyBase*)this)->ClientRequestHandle = NULL;
	((ns1__ReplyBase*)this)->RevisedLocaleID = NULL;
	soap_default_ns1__serverState(soap, &((ns1__ReplyBase*)this)->ServerState);
	/* transient soap skipped */
}

void ns1__ReplyBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__ReplyBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ReplyBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ReplyBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ReplyBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ReplyBase(struct soap *soap, const char *tag, int id, const ns1__ReplyBase *a, const char *type)
{
	soap_set_attr(soap, "RcvTime", soap_dateTime2s(soap, ((ns1__ReplyBase *)a)->RcvTime));
	soap_set_attr(soap, "ReplyTime", soap_dateTime2s(soap, ((ns1__ReplyBase *)a)->ReplyTime));
	if (((ns1__ReplyBase *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((ns1__ReplyBase *)a)->ClientRequestHandle->c_str());
	if (((ns1__ReplyBase *)a)->RevisedLocaleID)
		soap_set_attr(soap, "RevisedLocaleID", ((ns1__ReplyBase *)a)->RevisedLocaleID->c_str());
	soap_set_attr(soap, "ServerState", soap_ns1__serverState2s(soap, ((ns1__ReplyBase *)a)->ServerState));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ReplyBase), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ReplyBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ReplyBase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ReplyBase * SOAP_FMAC4 soap_get_ns1__ReplyBase(struct soap *soap, ns1__ReplyBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ReplyBase(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ReplyBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ReplyBase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ReplyBase * SOAP_FMAC4 soap_in_ns1__ReplyBase(struct soap *soap, const char *tag, ns1__ReplyBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ReplyBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ReplyBase, sizeof(ns1__ReplyBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ReplyBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ReplyBase *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "RcvTime", 1), &((ns1__ReplyBase *)a)->RcvTime))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "ReplyTime", 1), &((ns1__ReplyBase *)a)->ReplyTime))
		return NULL;
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((ns1__ReplyBase *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReplyBase *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((ns1__ReplyBase *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "RevisedLocaleID", 0);
		if (t)
		{	if (!(((ns1__ReplyBase *)a)->RevisedLocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((ns1__ReplyBase *)a)->RevisedLocaleID = soap_new_std__string(soap, -1);
			((ns1__ReplyBase *)a)->RevisedLocaleID->assign(s);
		}
		}
	}
	if (soap_s2ns1__serverState(soap, soap_attr_value(soap, "ServerState", 1), &((ns1__ReplyBase *)a)->ServerState))
		return NULL;;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ReplyBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ReplyBase, 0, sizeof(ns1__ReplyBase), 0, soap_copy_ns1__ReplyBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ReplyBase * SOAP_FMAC6 soap_new_ns1__ReplyBase(struct soap *soap, int n)
{	return soap_instantiate_ns1__ReplyBase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ReplyBase(struct soap *soap, ns1__ReplyBase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ReplyBase * SOAP_FMAC4 soap_instantiate_ns1__ReplyBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ReplyBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ReplyBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ReplyBase;
		if (size)
			*size = sizeof(ns1__ReplyBase);
		((ns1__ReplyBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ReplyBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ReplyBase);
		for (int i = 0; i < n; i++)
			((ns1__ReplyBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ReplyBase*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ReplyBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ReplyBase %p -> %p\n", q, p));
	*(ns1__ReplyBase*)p = *(ns1__ReplyBase*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__decimal(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__decimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__QName(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}
#ifdef __cplusplus
}
#endif

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetProperties(struct soap *soap, struct __ns1__GetProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetProperties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetProperties(struct soap *soap, const struct __ns1__GetProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetProperties(soap, &a->ns1__GetProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetProperties(struct soap *soap, const struct __ns1__GetProperties *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetProperties(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetProperties(struct soap *soap, const char *tag, int id, const struct __ns1__GetProperties *a, const char *type)
{
	soap_out_PointerTo_ns1__GetProperties(soap, "ns1:GetProperties", -1, &a->ns1__GetProperties, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetProperties * SOAP_FMAC4 soap_get___ns1__GetProperties(struct soap *soap, struct __ns1__GetProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__GetProperties * SOAP_FMAC4 soap_in___ns1__GetProperties(struct soap *soap, const char *tag, struct __ns1__GetProperties *a, const char *type)
{
	short soap_flag_ns1__GetProperties = 1;
	int soap_flag;
	a = (struct __ns1__GetProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__GetProperties, sizeof(struct __ns1__GetProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetProperties(soap, "ns1:GetProperties", &a->ns1__GetProperties, ""))
				{	soap_flag_ns1__GetProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__GetProperties * SOAP_FMAC6 soap_new___ns1__GetProperties(struct soap *soap, int n)
{	return soap_instantiate___ns1__GetProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__GetProperties(struct soap *soap, struct __ns1__GetProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__GetProperties * SOAP_FMAC4 soap_instantiate___ns1__GetProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetProperties;
		if (size)
			*size = sizeof(struct __ns1__GetProperties);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetProperties);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetProperties*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetProperties %p -> %p\n", q, p));
	*(struct __ns1__GetProperties*)p = *(struct __ns1__GetProperties*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Browse(struct soap *soap, struct __ns1__Browse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Browse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Browse(struct soap *soap, const struct __ns1__Browse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Browse(soap, &a->ns1__Browse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Browse(struct soap *soap, const struct __ns1__Browse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Browse(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Browse(struct soap *soap, const char *tag, int id, const struct __ns1__Browse *a, const char *type)
{
	soap_out_PointerTo_ns1__Browse(soap, "ns1:Browse", -1, &a->ns1__Browse, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Browse * SOAP_FMAC4 soap_get___ns1__Browse(struct soap *soap, struct __ns1__Browse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Browse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__Browse * SOAP_FMAC4 soap_in___ns1__Browse(struct soap *soap, const char *tag, struct __ns1__Browse *a, const char *type)
{
	short soap_flag_ns1__Browse = 1;
	int soap_flag;
	a = (struct __ns1__Browse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__Browse, sizeof(struct __ns1__Browse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Browse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Browse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Browse(soap, "ns1:Browse", &a->ns1__Browse, ""))
				{	soap_flag_ns1__Browse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__Browse * SOAP_FMAC6 soap_new___ns1__Browse(struct soap *soap, int n)
{	return soap_instantiate___ns1__Browse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__Browse(struct soap *soap, struct __ns1__Browse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__Browse * SOAP_FMAC4 soap_instantiate___ns1__Browse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Browse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Browse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__Browse;
		if (size)
			*size = sizeof(struct __ns1__Browse);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__Browse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__Browse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__Browse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Browse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Browse %p -> %p\n", q, p));
	*(struct __ns1__Browse*)p = *(struct __ns1__Browse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SubscriptionCancel(struct soap *soap, struct __ns1__SubscriptionCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SubscriptionCancel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SubscriptionCancel(struct soap *soap, const struct __ns1__SubscriptionCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SubscriptionCancel(soap, &a->ns1__SubscriptionCancel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SubscriptionCancel(struct soap *soap, const struct __ns1__SubscriptionCancel *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SubscriptionCancel(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SubscriptionCancel(struct soap *soap, const char *tag, int id, const struct __ns1__SubscriptionCancel *a, const char *type)
{
	soap_out_PointerTo_ns1__SubscriptionCancel(soap, "ns1:SubscriptionCancel", -1, &a->ns1__SubscriptionCancel, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SubscriptionCancel * SOAP_FMAC4 soap_get___ns1__SubscriptionCancel(struct soap *soap, struct __ns1__SubscriptionCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SubscriptionCancel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__SubscriptionCancel * SOAP_FMAC4 soap_in___ns1__SubscriptionCancel(struct soap *soap, const char *tag, struct __ns1__SubscriptionCancel *a, const char *type)
{
	short soap_flag_ns1__SubscriptionCancel = 1;
	int soap_flag;
	a = (struct __ns1__SubscriptionCancel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__SubscriptionCancel, sizeof(struct __ns1__SubscriptionCancel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SubscriptionCancel(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SubscriptionCancel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SubscriptionCancel(soap, "ns1:SubscriptionCancel", &a->ns1__SubscriptionCancel, ""))
				{	soap_flag_ns1__SubscriptionCancel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__SubscriptionCancel * SOAP_FMAC6 soap_new___ns1__SubscriptionCancel(struct soap *soap, int n)
{	return soap_instantiate___ns1__SubscriptionCancel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__SubscriptionCancel(struct soap *soap, struct __ns1__SubscriptionCancel *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__SubscriptionCancel * SOAP_FMAC4 soap_instantiate___ns1__SubscriptionCancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SubscriptionCancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SubscriptionCancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__SubscriptionCancel;
		if (size)
			*size = sizeof(struct __ns1__SubscriptionCancel);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__SubscriptionCancel[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__SubscriptionCancel);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__SubscriptionCancel*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SubscriptionCancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SubscriptionCancel %p -> %p\n", q, p));
	*(struct __ns1__SubscriptionCancel*)p = *(struct __ns1__SubscriptionCancel*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SubscriptionPolledRefresh(struct soap *soap, struct __ns1__SubscriptionPolledRefresh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SubscriptionPolledRefresh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SubscriptionPolledRefresh(struct soap *soap, const struct __ns1__SubscriptionPolledRefresh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__SubscriptionPolledRefresh(soap, &a->ns1__SubscriptionPolledRefresh);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SubscriptionPolledRefresh(struct soap *soap, const struct __ns1__SubscriptionPolledRefresh *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__SubscriptionPolledRefresh(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SubscriptionPolledRefresh(struct soap *soap, const char *tag, int id, const struct __ns1__SubscriptionPolledRefresh *a, const char *type)
{
	soap_out_PointerTo_ns1__SubscriptionPolledRefresh(soap, "ns1:SubscriptionPolledRefresh", -1, &a->ns1__SubscriptionPolledRefresh, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SubscriptionPolledRefresh * SOAP_FMAC4 soap_get___ns1__SubscriptionPolledRefresh(struct soap *soap, struct __ns1__SubscriptionPolledRefresh *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SubscriptionPolledRefresh(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__SubscriptionPolledRefresh * SOAP_FMAC4 soap_in___ns1__SubscriptionPolledRefresh(struct soap *soap, const char *tag, struct __ns1__SubscriptionPolledRefresh *a, const char *type)
{
	short soap_flag_ns1__SubscriptionPolledRefresh = 1;
	int soap_flag;
	a = (struct __ns1__SubscriptionPolledRefresh *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__SubscriptionPolledRefresh, sizeof(struct __ns1__SubscriptionPolledRefresh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SubscriptionPolledRefresh(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SubscriptionPolledRefresh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SubscriptionPolledRefresh(soap, "ns1:SubscriptionPolledRefresh", &a->ns1__SubscriptionPolledRefresh, ""))
				{	soap_flag_ns1__SubscriptionPolledRefresh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__SubscriptionPolledRefresh * SOAP_FMAC6 soap_new___ns1__SubscriptionPolledRefresh(struct soap *soap, int n)
{	return soap_instantiate___ns1__SubscriptionPolledRefresh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__SubscriptionPolledRefresh(struct soap *soap, struct __ns1__SubscriptionPolledRefresh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__SubscriptionPolledRefresh * SOAP_FMAC4 soap_instantiate___ns1__SubscriptionPolledRefresh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SubscriptionPolledRefresh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SubscriptionPolledRefresh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__SubscriptionPolledRefresh;
		if (size)
			*size = sizeof(struct __ns1__SubscriptionPolledRefresh);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__SubscriptionPolledRefresh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__SubscriptionPolledRefresh);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__SubscriptionPolledRefresh*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SubscriptionPolledRefresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SubscriptionPolledRefresh %p -> %p\n", q, p));
	*(struct __ns1__SubscriptionPolledRefresh*)p = *(struct __ns1__SubscriptionPolledRefresh*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Subscribe(struct soap *soap, struct __ns1__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Subscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Subscribe(struct soap *soap, const struct __ns1__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Subscribe(soap, &a->ns1__Subscribe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Subscribe(struct soap *soap, const struct __ns1__Subscribe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Subscribe(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Subscribe(struct soap *soap, const char *tag, int id, const struct __ns1__Subscribe *a, const char *type)
{
	soap_out_PointerTo_ns1__Subscribe(soap, "ns1:Subscribe", -1, &a->ns1__Subscribe, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Subscribe * SOAP_FMAC4 soap_get___ns1__Subscribe(struct soap *soap, struct __ns1__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Subscribe(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__Subscribe * SOAP_FMAC4 soap_in___ns1__Subscribe(struct soap *soap, const char *tag, struct __ns1__Subscribe *a, const char *type)
{
	short soap_flag_ns1__Subscribe = 1;
	int soap_flag;
	a = (struct __ns1__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__Subscribe, sizeof(struct __ns1__Subscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Subscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Subscribe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Subscribe(soap, "ns1:Subscribe", &a->ns1__Subscribe, ""))
				{	soap_flag_ns1__Subscribe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__Subscribe * SOAP_FMAC6 soap_new___ns1__Subscribe(struct soap *soap, int n)
{	return soap_instantiate___ns1__Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__Subscribe(struct soap *soap, struct __ns1__Subscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__Subscribe * SOAP_FMAC4 soap_instantiate___ns1__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__Subscribe;
		if (size)
			*size = sizeof(struct __ns1__Subscribe);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__Subscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__Subscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__Subscribe*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Subscribe %p -> %p\n", q, p));
	*(struct __ns1__Subscribe*)p = *(struct __ns1__Subscribe*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Write(struct soap *soap, struct __ns1__Write *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Write = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Write(struct soap *soap, const struct __ns1__Write *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Write(soap, &a->ns1__Write);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Write(struct soap *soap, const struct __ns1__Write *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Write(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Write(struct soap *soap, const char *tag, int id, const struct __ns1__Write *a, const char *type)
{
	soap_out_PointerTo_ns1__Write(soap, "ns1:Write", -1, &a->ns1__Write, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Write * SOAP_FMAC4 soap_get___ns1__Write(struct soap *soap, struct __ns1__Write *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Write(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__Write * SOAP_FMAC4 soap_in___ns1__Write(struct soap *soap, const char *tag, struct __ns1__Write *a, const char *type)
{
	short soap_flag_ns1__Write = 1;
	int soap_flag;
	a = (struct __ns1__Write *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__Write, sizeof(struct __ns1__Write), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Write(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Write && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Write(soap, "ns1:Write", &a->ns1__Write, ""))
				{	soap_flag_ns1__Write--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__Write * SOAP_FMAC6 soap_new___ns1__Write(struct soap *soap, int n)
{	return soap_instantiate___ns1__Write(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__Write(struct soap *soap, struct __ns1__Write *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__Write * SOAP_FMAC4 soap_instantiate___ns1__Write(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Write(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Write, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__Write;
		if (size)
			*size = sizeof(struct __ns1__Write);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__Write[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__Write);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__Write*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Write(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Write %p -> %p\n", q, p));
	*(struct __ns1__Write*)p = *(struct __ns1__Write*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Read(struct soap *soap, struct __ns1__Read *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Read = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Read(struct soap *soap, const struct __ns1__Read *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__Read(soap, &a->ns1__Read);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Read(struct soap *soap, const struct __ns1__Read *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__Read(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Read(struct soap *soap, const char *tag, int id, const struct __ns1__Read *a, const char *type)
{
	soap_out_PointerTo_ns1__Read(soap, "ns1:Read", -1, &a->ns1__Read, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Read * SOAP_FMAC4 soap_get___ns1__Read(struct soap *soap, struct __ns1__Read *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Read(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__Read * SOAP_FMAC4 soap_in___ns1__Read(struct soap *soap, const char *tag, struct __ns1__Read *a, const char *type)
{
	short soap_flag_ns1__Read = 1;
	int soap_flag;
	a = (struct __ns1__Read *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__Read, sizeof(struct __ns1__Read), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Read(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Read && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Read(soap, "ns1:Read", &a->ns1__Read, ""))
				{	soap_flag_ns1__Read--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__Read * SOAP_FMAC6 soap_new___ns1__Read(struct soap *soap, int n)
{	return soap_instantiate___ns1__Read(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__Read(struct soap *soap, struct __ns1__Read *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__Read * SOAP_FMAC4 soap_instantiate___ns1__Read(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Read(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Read, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__Read;
		if (size)
			*size = sizeof(struct __ns1__Read);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__Read[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__Read);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__Read*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Read(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Read %p -> %p\n", q, p));
	*(struct __ns1__Read*)p = *(struct __ns1__Read*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStatus(struct soap *soap, struct __ns1__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStatus(struct soap *soap, const struct __ns1__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetStatus(soap, &a->ns1__GetStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStatus(struct soap *soap, const struct __ns1__GetStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStatus(struct soap *soap, const char *tag, int id, const struct __ns1__GetStatus *a, const char *type)
{
	soap_out_PointerTo_ns1__GetStatus(soap, "ns1:GetStatus", -1, &a->ns1__GetStatus, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStatus * SOAP_FMAC4 soap_get___ns1__GetStatus(struct soap *soap, struct __ns1__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __ns1__GetStatus * SOAP_FMAC4 soap_in___ns1__GetStatus(struct soap *soap, const char *tag, struct __ns1__GetStatus *a, const char *type)
{
	short soap_flag_ns1__GetStatus = 1;
	int soap_flag;
	a = (struct __ns1__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___ns1__GetStatus, sizeof(struct __ns1__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStatus(soap, "ns1:GetStatus", &a->ns1__GetStatus, ""))
				{	soap_flag_ns1__GetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__GetStatus * SOAP_FMAC6 soap_new___ns1__GetStatus(struct soap *soap, int n)
{	return soap_instantiate___ns1__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__GetStatus(struct soap *soap, struct __ns1__GetStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__GetStatus * SOAP_FMAC4 soap_instantiate___ns1__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__GetStatus;
		if (size)
			*size = sizeof(struct __ns1__GetStatus);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__GetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__GetStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__GetStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetStatus %p -> %p\n", q, p));
	*(struct __ns1__GetStatus*)p = *(struct __ns1__GetStatus*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPropertiesResponse(struct soap *soap, _ns1__GetPropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPropertiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPropertiesResponse(struct soap *soap, _ns1__GetPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPropertiesResponse);
	if (soap_out_PointerTo_ns1__GetPropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPropertiesResponse(struct soap *soap, const char *tag, int id, _ns1__GetPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPropertiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPropertiesResponse(struct soap *soap, _ns1__GetPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPropertiesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__GetPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPropertiesResponse(struct soap *soap, const char *tag, _ns1__GetPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPropertiesResponse **)soap_malloc(soap, sizeof(_ns1__GetPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPropertiesResponse *)soap_instantiate__ns1__GetPropertiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__GetPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPropertiesResponse, sizeof(_ns1__GetPropertiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetProperties(struct soap *soap, _ns1__GetProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetProperties(struct soap *soap, _ns1__GetProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetProperties);
	if (soap_out_PointerTo_ns1__GetProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetProperties(struct soap *soap, const char *tag, int id, _ns1__GetProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetProperties ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetProperties(struct soap *soap, _ns1__GetProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__GetProperties ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetProperties(struct soap *soap, const char *tag, _ns1__GetProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetProperties **)soap_malloc(soap, sizeof(_ns1__GetProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetProperties *)soap_instantiate__ns1__GetProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__GetProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetProperties, sizeof(_ns1__GetProperties), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BrowseResponse(struct soap *soap, _ns1__BrowseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BrowseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BrowseResponse(struct soap *soap, _ns1__BrowseResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__BrowseResponse);
	if (soap_out_PointerTo_ns1__BrowseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BrowseResponse(struct soap *soap, const char *tag, int id, _ns1__BrowseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BrowseResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__BrowseResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__BrowseResponse(struct soap *soap, _ns1__BrowseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BrowseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__BrowseResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__BrowseResponse(struct soap *soap, const char *tag, _ns1__BrowseResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BrowseResponse **)soap_malloc(soap, sizeof(_ns1__BrowseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BrowseResponse *)soap_instantiate__ns1__BrowseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__BrowseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BrowseResponse, sizeof(_ns1__BrowseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Browse(struct soap *soap, _ns1__Browse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Browse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Browse(struct soap *soap, _ns1__Browse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Browse);
	if (soap_out_PointerTo_ns1__Browse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Browse(struct soap *soap, const char *tag, int id, _ns1__Browse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Browse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Browse ** SOAP_FMAC4 soap_get_PointerTo_ns1__Browse(struct soap *soap, _ns1__Browse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Browse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__Browse ** SOAP_FMAC4 soap_in_PointerTo_ns1__Browse(struct soap *soap, const char *tag, _ns1__Browse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Browse **)soap_malloc(soap, sizeof(_ns1__Browse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Browse *)soap_instantiate__ns1__Browse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__Browse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Browse, sizeof(_ns1__Browse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubscriptionCancelResponse(struct soap *soap, _ns1__SubscriptionCancelResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubscriptionCancelResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubscriptionCancelResponse(struct soap *soap, _ns1__SubscriptionCancelResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubscriptionCancelResponse);
	if (soap_out_PointerTo_ns1__SubscriptionCancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubscriptionCancelResponse(struct soap *soap, const char *tag, int id, _ns1__SubscriptionCancelResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubscriptionCancelResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubscriptionCancelResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubscriptionCancelResponse(struct soap *soap, _ns1__SubscriptionCancelResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubscriptionCancelResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__SubscriptionCancelResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubscriptionCancelResponse(struct soap *soap, const char *tag, _ns1__SubscriptionCancelResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubscriptionCancelResponse **)soap_malloc(soap, sizeof(_ns1__SubscriptionCancelResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubscriptionCancelResponse *)soap_instantiate__ns1__SubscriptionCancelResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionCancelResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubscriptionCancelResponse, sizeof(_ns1__SubscriptionCancelResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubscriptionCancel(struct soap *soap, _ns1__SubscriptionCancel *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubscriptionCancel))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubscriptionCancel(struct soap *soap, _ns1__SubscriptionCancel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubscriptionCancel);
	if (soap_out_PointerTo_ns1__SubscriptionCancel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubscriptionCancel(struct soap *soap, const char *tag, int id, _ns1__SubscriptionCancel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubscriptionCancel);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubscriptionCancel ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubscriptionCancel(struct soap *soap, _ns1__SubscriptionCancel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubscriptionCancel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__SubscriptionCancel ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubscriptionCancel(struct soap *soap, const char *tag, _ns1__SubscriptionCancel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubscriptionCancel **)soap_malloc(soap, sizeof(_ns1__SubscriptionCancel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubscriptionCancel *)soap_instantiate__ns1__SubscriptionCancel(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionCancel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubscriptionCancel, sizeof(_ns1__SubscriptionCancel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubscriptionPolledRefreshResponse(struct soap *soap, _ns1__SubscriptionPolledRefreshResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubscriptionPolledRefreshResponse(struct soap *soap, _ns1__SubscriptionPolledRefreshResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefreshResponse);
	if (soap_out_PointerTo_ns1__SubscriptionPolledRefreshResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, int id, _ns1__SubscriptionPolledRefreshResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefreshResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubscriptionPolledRefreshResponse(struct soap *soap, _ns1__SubscriptionPolledRefreshResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubscriptionPolledRefreshResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefreshResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, _ns1__SubscriptionPolledRefreshResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubscriptionPolledRefreshResponse **)soap_malloc(soap, sizeof(_ns1__SubscriptionPolledRefreshResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubscriptionPolledRefreshResponse *)soap_instantiate__ns1__SubscriptionPolledRefreshResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionPolledRefreshResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse, sizeof(_ns1__SubscriptionPolledRefreshResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubscriptionPolledRefresh(struct soap *soap, _ns1__SubscriptionPolledRefresh *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubscriptionPolledRefresh))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubscriptionPolledRefresh(struct soap *soap, _ns1__SubscriptionPolledRefresh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubscriptionPolledRefresh);
	if (soap_out_PointerTo_ns1__SubscriptionPolledRefresh(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubscriptionPolledRefresh(struct soap *soap, const char *tag, int id, _ns1__SubscriptionPolledRefresh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubscriptionPolledRefresh);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefresh ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubscriptionPolledRefresh(struct soap *soap, _ns1__SubscriptionPolledRefresh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubscriptionPolledRefresh(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__SubscriptionPolledRefresh ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubscriptionPolledRefresh(struct soap *soap, const char *tag, _ns1__SubscriptionPolledRefresh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubscriptionPolledRefresh **)soap_malloc(soap, sizeof(_ns1__SubscriptionPolledRefresh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubscriptionPolledRefresh *)soap_instantiate__ns1__SubscriptionPolledRefresh(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__SubscriptionPolledRefresh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubscriptionPolledRefresh, sizeof(_ns1__SubscriptionPolledRefresh), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SubscribeResponse(struct soap *soap, _ns1__SubscribeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SubscribeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SubscribeResponse(struct soap *soap, _ns1__SubscribeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__SubscribeResponse);
	if (soap_out_PointerTo_ns1__SubscribeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SubscribeResponse(struct soap *soap, const char *tag, int id, _ns1__SubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SubscribeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__SubscribeResponse(struct soap *soap, _ns1__SubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SubscribeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__SubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__SubscribeResponse(struct soap *soap, const char *tag, _ns1__SubscribeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SubscribeResponse **)soap_malloc(soap, sizeof(_ns1__SubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SubscribeResponse *)soap_instantiate__ns1__SubscribeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__SubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SubscribeResponse, sizeof(_ns1__SubscribeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Subscribe(struct soap *soap, _ns1__Subscribe *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Subscribe))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Subscribe(struct soap *soap, _ns1__Subscribe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Subscribe);
	if (soap_out_PointerTo_ns1__Subscribe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Subscribe(struct soap *soap, const char *tag, int id, _ns1__Subscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Subscribe);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Subscribe ** SOAP_FMAC4 soap_get_PointerTo_ns1__Subscribe(struct soap *soap, _ns1__Subscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Subscribe(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__Subscribe ** SOAP_FMAC4 soap_in_PointerTo_ns1__Subscribe(struct soap *soap, const char *tag, _ns1__Subscribe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Subscribe **)soap_malloc(soap, sizeof(_ns1__Subscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Subscribe *)soap_instantiate__ns1__Subscribe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__Subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Subscribe, sizeof(_ns1__Subscribe), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WriteResponse(struct soap *soap, _ns1__WriteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WriteResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WriteResponse(struct soap *soap, _ns1__WriteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__WriteResponse);
	if (soap_out_PointerTo_ns1__WriteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WriteResponse(struct soap *soap, const char *tag, int id, _ns1__WriteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WriteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WriteResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__WriteResponse(struct soap *soap, _ns1__WriteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WriteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__WriteResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__WriteResponse(struct soap *soap, const char *tag, _ns1__WriteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WriteResponse **)soap_malloc(soap, sizeof(_ns1__WriteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WriteResponse *)soap_instantiate__ns1__WriteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__WriteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WriteResponse, sizeof(_ns1__WriteResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Write(struct soap *soap, _ns1__Write *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Write))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Write(struct soap *soap, _ns1__Write *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Write);
	if (soap_out_PointerTo_ns1__Write(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Write(struct soap *soap, const char *tag, int id, _ns1__Write *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Write);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Write ** SOAP_FMAC4 soap_get_PointerTo_ns1__Write(struct soap *soap, _ns1__Write **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Write(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__Write ** SOAP_FMAC4 soap_in_PointerTo_ns1__Write(struct soap *soap, const char *tag, _ns1__Write **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Write **)soap_malloc(soap, sizeof(_ns1__Write *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Write *)soap_instantiate__ns1__Write(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__Write **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Write, sizeof(_ns1__Write), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ReadResponse(struct soap *soap, _ns1__ReadResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ReadResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ReadResponse(struct soap *soap, _ns1__ReadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ReadResponse);
	if (soap_out_PointerTo_ns1__ReadResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ReadResponse(struct soap *soap, const char *tag, int id, _ns1__ReadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ReadResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__ReadResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ReadResponse(struct soap *soap, _ns1__ReadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__ReadResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ReadResponse(struct soap *soap, const char *tag, _ns1__ReadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ReadResponse **)soap_malloc(soap, sizeof(_ns1__ReadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ReadResponse *)soap_instantiate__ns1__ReadResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__ReadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ReadResponse, sizeof(_ns1__ReadResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Read(struct soap *soap, _ns1__Read *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Read))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Read(struct soap *soap, _ns1__Read *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__Read);
	if (soap_out_PointerTo_ns1__Read(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Read(struct soap *soap, const char *tag, int id, _ns1__Read *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Read);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Read ** SOAP_FMAC4 soap_get_PointerTo_ns1__Read(struct soap *soap, _ns1__Read **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Read(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__Read ** SOAP_FMAC4 soap_in_PointerTo_ns1__Read(struct soap *soap, const char *tag, _ns1__Read **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Read **)soap_malloc(soap, sizeof(_ns1__Read *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Read *)soap_instantiate__ns1__Read(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__Read **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Read, sizeof(_ns1__Read), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStatusResponse(struct soap *soap, _ns1__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStatusResponse(struct soap *soap, _ns1__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStatusResponse);
	if (soap_out_PointerTo_ns1__GetStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStatusResponse(struct soap *soap, const char *tag, int id, _ns1__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStatusResponse(struct soap *soap, _ns1__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStatusResponse(struct soap *soap, const char *tag, _ns1__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStatusResponse **)soap_malloc(soap, sizeof(_ns1__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStatusResponse *)soap_instantiate__ns1__GetStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStatusResponse, sizeof(_ns1__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStatus(struct soap *soap, _ns1__GetStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStatus(struct soap *soap, _ns1__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetStatus);
	if (soap_out_PointerTo_ns1__GetStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStatus(struct soap *soap, const char *tag, int id, _ns1__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStatus(struct soap *soap, _ns1__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _ns1__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStatus(struct soap *soap, const char *tag, _ns1__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStatus **)soap_malloc(soap, sizeof(_ns1__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStatus *)soap_instantiate__ns1__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_ns1__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStatus, sizeof(_ns1__GetStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PropertyReplyList(struct soap *soap, ns1__PropertyReplyList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PropertyReplyList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PropertyReplyList(struct soap *soap, ns1__PropertyReplyList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PropertyReplyList);
	if (soap_out_PointerTons1__PropertyReplyList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PropertyReplyList(struct soap *soap, const char *tag, int id, ns1__PropertyReplyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PropertyReplyList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PropertyReplyList ** SOAP_FMAC4 soap_get_PointerTons1__PropertyReplyList(struct soap *soap, ns1__PropertyReplyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PropertyReplyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PropertyReplyList ** SOAP_FMAC4 soap_in_PointerTons1__PropertyReplyList(struct soap *soap, const char *tag, ns1__PropertyReplyList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PropertyReplyList **)soap_malloc(soap, sizeof(ns1__PropertyReplyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PropertyReplyList *)soap_instantiate_ns1__PropertyReplyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__PropertyReplyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PropertyReplyList, sizeof(ns1__PropertyReplyList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemIdentifier(struct soap *soap, ns1__ItemIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemIdentifier))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemIdentifier(struct soap *soap, ns1__ItemIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ItemIdentifier);
	if (soap_out_PointerTons1__ItemIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemIdentifier(struct soap *soap, const char *tag, int id, ns1__ItemIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ItemIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ItemIdentifier ** SOAP_FMAC4 soap_get_PointerTons1__ItemIdentifier(struct soap *soap, ns1__ItemIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemIdentifier(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemIdentifier ** SOAP_FMAC4 soap_in_PointerTons1__ItemIdentifier(struct soap *soap, const char *tag, ns1__ItemIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ItemIdentifier **)soap_malloc(soap, sizeof(ns1__ItemIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ItemIdentifier *)soap_instantiate_ns1__ItemIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ItemIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ItemIdentifier, sizeof(ns1__ItemIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BrowseElement(struct soap *soap, ns1__BrowseElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BrowseElement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BrowseElement(struct soap *soap, ns1__BrowseElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BrowseElement);
	if (soap_out_PointerTons1__BrowseElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BrowseElement(struct soap *soap, const char *tag, int id, ns1__BrowseElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BrowseElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BrowseElement ** SOAP_FMAC4 soap_get_PointerTons1__BrowseElement(struct soap *soap, ns1__BrowseElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BrowseElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__BrowseElement ** SOAP_FMAC4 soap_in_PointerTons1__BrowseElement(struct soap *soap, const char *tag, ns1__BrowseElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BrowseElement **)soap_malloc(soap, sizeof(ns1__BrowseElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BrowseElement *)soap_instantiate_ns1__BrowseElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__BrowseElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BrowseElement, sizeof(ns1__BrowseElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__browseFilter(struct soap *soap, enum ns1__browseFilter *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__browseFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__browseFilter(struct soap *soap, enum ns1__browseFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__browseFilter);
	if (soap_out_PointerTons1__browseFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__browseFilter(struct soap *soap, const char *tag, int id, enum ns1__browseFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__browseFilter);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__browseFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__browseFilter ** SOAP_FMAC4 soap_get_PointerTons1__browseFilter(struct soap *soap, enum ns1__browseFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__browseFilter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns1__browseFilter ** SOAP_FMAC4 soap_in_PointerTons1__browseFilter(struct soap *soap, const char *tag, enum ns1__browseFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__browseFilter **)soap_malloc(soap, sizeof(enum ns1__browseFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__browseFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__browseFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__browseFilter, sizeof(enum ns1__browseFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, ns1__SubscribePolledRefreshReplyItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, ns1__SubscribePolledRefreshReplyItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SubscribePolledRefreshReplyItemList);
	if (soap_out_PointerTons1__SubscribePolledRefreshReplyItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, int id, ns1__SubscribePolledRefreshReplyItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SubscribePolledRefreshReplyItemList ** SOAP_FMAC4 soap_get_PointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, ns1__SubscribePolledRefreshReplyItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubscribePolledRefreshReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SubscribePolledRefreshReplyItemList ** SOAP_FMAC4 soap_in_PointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, ns1__SubscribePolledRefreshReplyItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubscribePolledRefreshReplyItemList **)soap_malloc(soap, sizeof(ns1__SubscribePolledRefreshReplyItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubscribePolledRefreshReplyItemList *)soap_instantiate_ns1__SubscribePolledRefreshReplyItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SubscribePolledRefreshReplyItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList, sizeof(ns1__SubscribePolledRefreshReplyItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubscribeReplyItemList(struct soap *soap, ns1__SubscribeReplyItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubscribeReplyItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubscribeReplyItemList(struct soap *soap, ns1__SubscribeReplyItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SubscribeReplyItemList);
	if (soap_out_PointerTons1__SubscribeReplyItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubscribeReplyItemList(struct soap *soap, const char *tag, int id, ns1__SubscribeReplyItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubscribeReplyItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SubscribeReplyItemList ** SOAP_FMAC4 soap_get_PointerTons1__SubscribeReplyItemList(struct soap *soap, ns1__SubscribeReplyItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubscribeReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SubscribeReplyItemList ** SOAP_FMAC4 soap_in_PointerTons1__SubscribeReplyItemList(struct soap *soap, const char *tag, ns1__SubscribeReplyItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubscribeReplyItemList **)soap_malloc(soap, sizeof(ns1__SubscribeReplyItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubscribeReplyItemList *)soap_instantiate_ns1__SubscribeReplyItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeReplyItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubscribeReplyItemList, sizeof(ns1__SubscribeReplyItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubscribeRequestItemList(struct soap *soap, ns1__SubscribeRequestItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubscribeRequestItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubscribeRequestItemList(struct soap *soap, ns1__SubscribeRequestItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SubscribeRequestItemList);
	if (soap_out_PointerTons1__SubscribeRequestItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubscribeRequestItemList(struct soap *soap, const char *tag, int id, ns1__SubscribeRequestItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubscribeRequestItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SubscribeRequestItemList ** SOAP_FMAC4 soap_get_PointerTons1__SubscribeRequestItemList(struct soap *soap, ns1__SubscribeRequestItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubscribeRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SubscribeRequestItemList ** SOAP_FMAC4 soap_in_PointerTons1__SubscribeRequestItemList(struct soap *soap, const char *tag, ns1__SubscribeRequestItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubscribeRequestItemList **)soap_malloc(soap, sizeof(ns1__SubscribeRequestItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubscribeRequestItemList *)soap_instantiate_ns1__SubscribeRequestItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeRequestItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubscribeRequestItemList, sizeof(ns1__SubscribeRequestItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__WriteRequestItemList(struct soap *soap, ns1__WriteRequestItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__WriteRequestItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__WriteRequestItemList(struct soap *soap, ns1__WriteRequestItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__WriteRequestItemList);
	if (soap_out_PointerTons1__WriteRequestItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__WriteRequestItemList(struct soap *soap, const char *tag, int id, ns1__WriteRequestItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__WriteRequestItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__WriteRequestItemList ** SOAP_FMAC4 soap_get_PointerTons1__WriteRequestItemList(struct soap *soap, ns1__WriteRequestItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__WriteRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__WriteRequestItemList ** SOAP_FMAC4 soap_in_PointerTons1__WriteRequestItemList(struct soap *soap, const char *tag, ns1__WriteRequestItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__WriteRequestItemList **)soap_malloc(soap, sizeof(ns1__WriteRequestItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__WriteRequestItemList *)soap_instantiate_ns1__WriteRequestItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__WriteRequestItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__WriteRequestItemList, sizeof(ns1__WriteRequestItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OPCError(struct soap *soap, ns1__OPCError *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OPCError))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OPCError(struct soap *soap, ns1__OPCError *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OPCError);
	if (soap_out_PointerTons1__OPCError(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OPCError(struct soap *soap, const char *tag, int id, ns1__OPCError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OPCError);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OPCError ** SOAP_FMAC4 soap_get_PointerTons1__OPCError(struct soap *soap, ns1__OPCError **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OPCError(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__OPCError ** SOAP_FMAC4 soap_in_PointerTons1__OPCError(struct soap *soap, const char *tag, ns1__OPCError **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OPCError **)soap_malloc(soap, sizeof(ns1__OPCError *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OPCError *)soap_instantiate_ns1__OPCError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__OPCError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OPCError, sizeof(ns1__OPCError), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReplyItemList(struct soap *soap, ns1__ReplyItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReplyItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReplyItemList(struct soap *soap, ns1__ReplyItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReplyItemList);
	if (soap_out_PointerTons1__ReplyItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReplyItemList(struct soap *soap, const char *tag, int id, ns1__ReplyItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReplyItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReplyItemList ** SOAP_FMAC4 soap_get_PointerTons1__ReplyItemList(struct soap *soap, ns1__ReplyItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ReplyItemList ** SOAP_FMAC4 soap_in_PointerTons1__ReplyItemList(struct soap *soap, const char *tag, ns1__ReplyItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReplyItemList **)soap_malloc(soap, sizeof(ns1__ReplyItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReplyItemList *)soap_instantiate_ns1__ReplyItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ReplyItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReplyItemList, sizeof(ns1__ReplyItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReadRequestItemList(struct soap *soap, ns1__ReadRequestItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReadRequestItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReadRequestItemList(struct soap *soap, ns1__ReadRequestItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReadRequestItemList);
	if (soap_out_PointerTons1__ReadRequestItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReadRequestItemList(struct soap *soap, const char *tag, int id, ns1__ReadRequestItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReadRequestItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReadRequestItemList ** SOAP_FMAC4 soap_get_PointerTons1__ReadRequestItemList(struct soap *soap, ns1__ReadRequestItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReadRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ReadRequestItemList ** SOAP_FMAC4 soap_in_PointerTons1__ReadRequestItemList(struct soap *soap, const char *tag, ns1__ReadRequestItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReadRequestItemList **)soap_malloc(soap, sizeof(ns1__ReadRequestItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReadRequestItemList *)soap_instantiate_ns1__ReadRequestItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ReadRequestItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReadRequestItemList, sizeof(ns1__ReadRequestItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RequestOptions(struct soap *soap, ns1__RequestOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RequestOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RequestOptions(struct soap *soap, ns1__RequestOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RequestOptions);
	if (soap_out_PointerTons1__RequestOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RequestOptions(struct soap *soap, const char *tag, int id, ns1__RequestOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RequestOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RequestOptions ** SOAP_FMAC4 soap_get_PointerTons1__RequestOptions(struct soap *soap, ns1__RequestOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RequestOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RequestOptions ** SOAP_FMAC4 soap_in_PointerTons1__RequestOptions(struct soap *soap, const char *tag, ns1__RequestOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RequestOptions **)soap_malloc(soap, sizeof(ns1__RequestOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RequestOptions *)soap_instantiate_ns1__RequestOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__RequestOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RequestOptions, sizeof(ns1__RequestOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ServerStatus(struct soap *soap, ns1__ServerStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ServerStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ServerStatus(struct soap *soap, ns1__ServerStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ServerStatus);
	if (soap_out_PointerTons1__ServerStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ServerStatus(struct soap *soap, const char *tag, int id, ns1__ServerStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ServerStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ServerStatus ** SOAP_FMAC4 soap_get_PointerTons1__ServerStatus(struct soap *soap, ns1__ServerStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ServerStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ServerStatus ** SOAP_FMAC4 soap_in_PointerTons1__ServerStatus(struct soap *soap, const char *tag, ns1__ServerStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ServerStatus **)soap_malloc(soap, sizeof(ns1__ServerStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ServerStatus *)soap_instantiate_ns1__ServerStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ServerStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ServerStatus, sizeof(ns1__ServerStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReplyBase(struct soap *soap, ns1__ReplyBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReplyBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReplyBase(struct soap *soap, ns1__ReplyBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReplyBase);
	if (soap_out_PointerTons1__ReplyBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReplyBase(struct soap *soap, const char *tag, int id, ns1__ReplyBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReplyBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReplyBase ** SOAP_FMAC4 soap_get_PointerTons1__ReplyBase(struct soap *soap, ns1__ReplyBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReplyBase(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ReplyBase ** SOAP_FMAC4 soap_in_PointerTons1__ReplyBase(struct soap *soap, const char *tag, ns1__ReplyBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReplyBase **)soap_malloc(soap, sizeof(ns1__ReplyBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReplyBase *)soap_instantiate_ns1__ReplyBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ReplyBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReplyBase, sizeof(ns1__ReplyBase), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemProperty(struct soap *soap, ns1__ItemProperty *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemProperty))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemProperty(struct soap *soap, ns1__ItemProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ItemProperty);
	if (soap_out_PointerTons1__ItemProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemProperty(struct soap *soap, const char *tag, int id, ns1__ItemProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ItemProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ItemProperty ** SOAP_FMAC4 soap_get_PointerTons1__ItemProperty(struct soap *soap, ns1__ItemProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemProperty ** SOAP_FMAC4 soap_in_PointerTons1__ItemProperty(struct soap *soap, const char *tag, ns1__ItemProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ItemProperty **)soap_malloc(soap, sizeof(ns1__ItemProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ItemProperty *)soap_instantiate_ns1__ItemProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ItemProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ItemProperty, sizeof(ns1__ItemProperty), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubscribeItemValue(struct soap *soap, ns1__SubscribeItemValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubscribeItemValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubscribeItemValue(struct soap *soap, ns1__SubscribeItemValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SubscribeItemValue);
	if (soap_out_PointerTons1__SubscribeItemValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubscribeItemValue(struct soap *soap, const char *tag, int id, ns1__SubscribeItemValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubscribeItemValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SubscribeItemValue ** SOAP_FMAC4 soap_get_PointerTons1__SubscribeItemValue(struct soap *soap, ns1__SubscribeItemValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubscribeItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SubscribeItemValue ** SOAP_FMAC4 soap_in_PointerTons1__SubscribeItemValue(struct soap *soap, const char *tag, ns1__SubscribeItemValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubscribeItemValue **)soap_malloc(soap, sizeof(ns1__SubscribeItemValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubscribeItemValue *)soap_instantiate_ns1__SubscribeItemValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeItemValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubscribeItemValue, sizeof(ns1__SubscribeItemValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SubscribeRequestItem(struct soap *soap, ns1__SubscribeRequestItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SubscribeRequestItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SubscribeRequestItem(struct soap *soap, ns1__SubscribeRequestItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SubscribeRequestItem);
	if (soap_out_PointerTons1__SubscribeRequestItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SubscribeRequestItem(struct soap *soap, const char *tag, int id, ns1__SubscribeRequestItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SubscribeRequestItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SubscribeRequestItem ** SOAP_FMAC4 soap_get_PointerTons1__SubscribeRequestItem(struct soap *soap, ns1__SubscribeRequestItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SubscribeRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SubscribeRequestItem ** SOAP_FMAC4 soap_in_PointerTons1__SubscribeRequestItem(struct soap *soap, const char *tag, ns1__SubscribeRequestItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SubscribeRequestItem **)soap_malloc(soap, sizeof(ns1__SubscribeRequestItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SubscribeRequestItem *)soap_instantiate_ns1__SubscribeRequestItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SubscribeRequestItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SubscribeRequestItem, sizeof(ns1__SubscribeRequestItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedShort(struct soap *soap, unsigned short *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedShort(struct soap *soap, unsigned short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedShort);
	if (soap_out_PointerTounsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedShort(struct soap *soap, const char *tag, int id, unsigned short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedShort);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedShort(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned short ** SOAP_FMAC4 soap_get_PointerTounsignedShort(struct soap *soap, unsigned short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short ** SOAP_FMAC4 soap_in_PointerTounsignedShort(struct soap *soap, const char *tag, unsigned short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned short **)soap_malloc(soap, sizeof(unsigned short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedShort(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedShort, sizeof(unsigned short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__limitBits(struct soap *soap, enum ns1__limitBits *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__limitBits);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__limitBits(struct soap *soap, enum ns1__limitBits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__limitBits);
	if (soap_out_PointerTons1__limitBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__limitBits(struct soap *soap, const char *tag, int id, enum ns1__limitBits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__limitBits);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__limitBits(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__limitBits ** SOAP_FMAC4 soap_get_PointerTons1__limitBits(struct soap *soap, enum ns1__limitBits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__limitBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns1__limitBits ** SOAP_FMAC4 soap_in_PointerTons1__limitBits(struct soap *soap, const char *tag, enum ns1__limitBits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__limitBits **)soap_malloc(soap, sizeof(enum ns1__limitBits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__limitBits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__limitBits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__limitBits, sizeof(enum ns1__limitBits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__qualityBits(struct soap *soap, enum ns1__qualityBits *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__qualityBits);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__qualityBits(struct soap *soap, enum ns1__qualityBits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__qualityBits);
	if (soap_out_PointerTons1__qualityBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__qualityBits(struct soap *soap, const char *tag, int id, enum ns1__qualityBits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__qualityBits);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__qualityBits(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__qualityBits ** SOAP_FMAC4 soap_get_PointerTons1__qualityBits(struct soap *soap, enum ns1__qualityBits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__qualityBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum ns1__qualityBits ** SOAP_FMAC4 soap_in_PointerTons1__qualityBits(struct soap *soap, const char *tag, enum ns1__qualityBits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__qualityBits **)soap_malloc(soap, sizeof(enum ns1__qualityBits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__qualityBits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__qualityBits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__qualityBits, sizeof(enum ns1__qualityBits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OPCQuality(struct soap *soap, ns1__OPCQuality *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OPCQuality))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OPCQuality(struct soap *soap, ns1__OPCQuality *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OPCQuality);
	if (soap_out_PointerTons1__OPCQuality(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OPCQuality(struct soap *soap, const char *tag, int id, ns1__OPCQuality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OPCQuality);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OPCQuality ** SOAP_FMAC4 soap_get_PointerTons1__OPCQuality(struct soap *soap, ns1__OPCQuality **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OPCQuality(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__OPCQuality ** SOAP_FMAC4 soap_in_PointerTons1__OPCQuality(struct soap *soap, const char *tag, ns1__OPCQuality **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OPCQuality **)soap_malloc(soap, sizeof(ns1__OPCQuality *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OPCQuality *)soap_instantiate_ns1__OPCQuality(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__OPCQuality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OPCQuality, sizeof(ns1__OPCQuality), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ItemValue(struct soap *soap, ns1__ItemValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ItemValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ItemValue(struct soap *soap, ns1__ItemValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ItemValue);
	if (soap_out_PointerTons1__ItemValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ItemValue(struct soap *soap, const char *tag, int id, ns1__ItemValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ItemValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ItemValue ** SOAP_FMAC4 soap_get_PointerTons1__ItemValue(struct soap *soap, ns1__ItemValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ItemValue ** SOAP_FMAC4 soap_in_PointerTons1__ItemValue(struct soap *soap, const char *tag, ns1__ItemValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ItemValue **)soap_malloc(soap, sizeof(ns1__ItemValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ItemValue *)soap_instantiate_ns1__ItemValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ItemValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ItemValue, sizeof(ns1__ItemValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__QName);
	if (soap_out_PointerToxsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ReadRequestItem(struct soap *soap, ns1__ReadRequestItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ReadRequestItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ReadRequestItem(struct soap *soap, ns1__ReadRequestItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ReadRequestItem);
	if (soap_out_PointerTons1__ReadRequestItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ReadRequestItem(struct soap *soap, const char *tag, int id, ns1__ReadRequestItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ReadRequestItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ReadRequestItem ** SOAP_FMAC4 soap_get_PointerTons1__ReadRequestItem(struct soap *soap, ns1__ReadRequestItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ReadRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ReadRequestItem ** SOAP_FMAC4 soap_in_PointerTons1__ReadRequestItem(struct soap *soap, const char *tag, ns1__ReadRequestItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ReadRequestItem **)soap_malloc(soap, sizeof(ns1__ReadRequestItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ReadRequestItem *)soap_instantiate_ns1__ReadRequestItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ReadRequestItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ReadRequestItem, sizeof(ns1__ReadRequestItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, std::vector<ns1__PropertyReplyList * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, const std::vector<ns1__PropertyReplyList * >*a)
{
	for (std::vector<ns1__PropertyReplyList * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__PropertyReplyList(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, const char *tag, int id, const std::vector<ns1__PropertyReplyList * >*a, const char *type)
{
	for (std::vector<ns1__PropertyReplyList * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__PropertyReplyList(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__PropertyReplyList * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, const char *tag, std::vector<ns1__PropertyReplyList * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, -1)))
		return NULL;
	ns1__PropertyReplyList *n;
	ns1__PropertyReplyList **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__PropertyReplyList, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PropertyReplyList, sizeof(ns1__PropertyReplyList), 1))
				break;
			if (!(p = soap_in_PointerTons1__PropertyReplyList(soap, tag, NULL, "ns1:PropertyReplyList")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__PropertyReplyList(soap, tag, &n, "ns1:PropertyReplyList"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__PropertyReplyList * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__PropertyReplyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, std::vector<ns1__PropertyReplyList * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__PropertyReplyList * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__PropertyReplyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__PropertyReplyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__PropertyReplyList * >;
		if (size)
			*size = sizeof(std::vector<ns1__PropertyReplyList * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__PropertyReplyList * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__PropertyReplyList * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__PropertyReplyList * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__PropertyReplyList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__PropertyReplyList * > %p -> %p\n", q, p));
	*(std::vector<ns1__PropertyReplyList * >*)p = *(std::vector<ns1__PropertyReplyList * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, std::vector<ns1__ItemIdentifier * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, const std::vector<ns1__ItemIdentifier * >*a)
{
	for (std::vector<ns1__ItemIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ItemIdentifier(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, const char *tag, int id, const std::vector<ns1__ItemIdentifier * >*a, const char *type)
{
	for (std::vector<ns1__ItemIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ItemIdentifier(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ItemIdentifier * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, const char *tag, std::vector<ns1__ItemIdentifier * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, -1)))
		return NULL;
	ns1__ItemIdentifier *n;
	ns1__ItemIdentifier **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ItemIdentifier, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemIdentifier, sizeof(ns1__ItemIdentifier), 1))
				break;
			if (!(p = soap_in_PointerTons1__ItemIdentifier(soap, tag, NULL, "ns1:ItemIdentifier")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__ItemIdentifier(soap, tag, &n, "ns1:ItemIdentifier"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ItemIdentifier * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ItemIdentifier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, std::vector<ns1__ItemIdentifier * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__ItemIdentifier * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ItemIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ItemIdentifier * >;
		if (size)
			*size = sizeof(std::vector<ns1__ItemIdentifier * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ItemIdentifier * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ItemIdentifier * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ItemIdentifier * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ItemIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ItemIdentifier * > %p -> %p\n", q, p));
	*(std::vector<ns1__ItemIdentifier * >*)p = *(std::vector<ns1__ItemIdentifier * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, std::vector<ns1__BrowseElement * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, const std::vector<ns1__BrowseElement * >*a)
{
	for (std::vector<ns1__BrowseElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__BrowseElement(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, const char *tag, int id, const std::vector<ns1__BrowseElement * >*a, const char *type)
{
	for (std::vector<ns1__BrowseElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__BrowseElement(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__BrowseElement * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, const char *tag, std::vector<ns1__BrowseElement * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__BrowseElement(soap, -1)))
		return NULL;
	ns1__BrowseElement *n;
	ns1__BrowseElement **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__BrowseElement, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BrowseElement, sizeof(ns1__BrowseElement), 1))
				break;
			if (!(p = soap_in_PointerTons1__BrowseElement(soap, tag, NULL, "ns1:BrowseElement")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__BrowseElement(soap, tag, &n, "ns1:BrowseElement"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__BrowseElement * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__BrowseElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, std::vector<ns1__BrowseElement * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__BrowseElement * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__BrowseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__BrowseElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__BrowseElement * >;
		if (size)
			*size = sizeof(std::vector<ns1__BrowseElement * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__BrowseElement * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__BrowseElement * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__BrowseElement * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__BrowseElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__BrowseElement * > %p -> %p\n", q, p));
	*(std::vector<ns1__BrowseElement * >*)p = *(std::vector<ns1__BrowseElement * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__QName(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_xsd__QName(soap, tag, NULL, "xsd:QName")))
				break;
		}
		else
		{	soap_default_xsd__QName(soap, &n);
			if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfxsd__QName(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfxsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, std::vector<ns1__SubscribePolledRefreshReplyItemList * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, const std::vector<ns1__SubscribePolledRefreshReplyItemList * >*a)
{
	for (std::vector<ns1__SubscribePolledRefreshReplyItemList * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SubscribePolledRefreshReplyItemList(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, int id, const std::vector<ns1__SubscribePolledRefreshReplyItemList * >*a, const char *type)
{
	for (std::vector<ns1__SubscribePolledRefreshReplyItemList * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SubscribePolledRefreshReplyItemList(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SubscribePolledRefreshReplyItemList * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, std::vector<ns1__SubscribePolledRefreshReplyItemList * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, -1)))
		return NULL;
	ns1__SubscribePolledRefreshReplyItemList *n;
	ns1__SubscribePolledRefreshReplyItemList **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList, sizeof(ns1__SubscribePolledRefreshReplyItemList), 1))
				break;
			if (!(p = soap_in_PointerTons1__SubscribePolledRefreshReplyItemList(soap, tag, NULL, "ns1:SubscribePolledRefreshReplyItemList")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__SubscribePolledRefreshReplyItemList(soap, tag, &n, "ns1:SubscribePolledRefreshReplyItemList"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__SubscribePolledRefreshReplyItemList * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, std::vector<ns1__SubscribePolledRefreshReplyItemList * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__SubscribePolledRefreshReplyItemList * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__SubscribePolledRefreshReplyItemList * >;
		if (size)
			*size = sizeof(std::vector<ns1__SubscribePolledRefreshReplyItemList * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__SubscribePolledRefreshReplyItemList * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SubscribePolledRefreshReplyItemList * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SubscribePolledRefreshReplyItemList * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SubscribePolledRefreshReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SubscribePolledRefreshReplyItemList * > %p -> %p\n", q, p));
	*(std::vector<ns1__SubscribePolledRefreshReplyItemList * >*)p = *(std::vector<ns1__SubscribePolledRefreshReplyItemList * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, std::vector<ns1__OPCError * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, const std::vector<ns1__OPCError * >*a)
{
	for (std::vector<ns1__OPCError * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__OPCError(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, const char *tag, int id, const std::vector<ns1__OPCError * >*a, const char *type)
{
	for (std::vector<ns1__OPCError * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__OPCError(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__OPCError * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, const char *tag, std::vector<ns1__OPCError * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__OPCError(soap, -1)))
		return NULL;
	ns1__OPCError *n;
	ns1__OPCError **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__OPCError, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OPCError, sizeof(ns1__OPCError), 1))
				break;
			if (!(p = soap_in_PointerTons1__OPCError(soap, tag, NULL, "ns1:OPCError")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__OPCError(soap, tag, &n, "ns1:OPCError"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__OPCError * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__OPCError(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, std::vector<ns1__OPCError * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__OPCError * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__OPCError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__OPCError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__OPCError * >;
		if (size)
			*size = sizeof(std::vector<ns1__OPCError * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__OPCError * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__OPCError * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__OPCError * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__OPCError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__OPCError * > %p -> %p\n", q, p));
	*(std::vector<ns1__OPCError * >*)p = *(std::vector<ns1__OPCError * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, std::vector<ns1__ItemProperty * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, const std::vector<ns1__ItemProperty * >*a)
{
	for (std::vector<ns1__ItemProperty * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ItemProperty(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, const char *tag, int id, const std::vector<ns1__ItemProperty * >*a, const char *type)
{
	for (std::vector<ns1__ItemProperty * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ItemProperty(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ItemProperty * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, const char *tag, std::vector<ns1__ItemProperty * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ItemProperty(soap, -1)))
		return NULL;
	ns1__ItemProperty *n;
	ns1__ItemProperty **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ItemProperty, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemProperty, sizeof(ns1__ItemProperty), 1))
				break;
			if (!(p = soap_in_PointerTons1__ItemProperty(soap, tag, NULL, "ns1:ItemProperty")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__ItemProperty(soap, tag, &n, "ns1:ItemProperty"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ItemProperty * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ItemProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, std::vector<ns1__ItemProperty * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__ItemProperty * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ItemProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ItemProperty * >;
		if (size)
			*size = sizeof(std::vector<ns1__ItemProperty * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ItemProperty * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ItemProperty * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ItemProperty * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ItemProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ItemProperty * > %p -> %p\n", q, p));
	*(std::vector<ns1__ItemProperty * >*)p = *(std::vector<ns1__ItemProperty * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, std::vector<ns1__SubscribeItemValue * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, const std::vector<ns1__SubscribeItemValue * >*a)
{
	for (std::vector<ns1__SubscribeItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SubscribeItemValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, const char *tag, int id, const std::vector<ns1__SubscribeItemValue * >*a, const char *type)
{
	for (std::vector<ns1__SubscribeItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SubscribeItemValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SubscribeItemValue * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, const char *tag, std::vector<ns1__SubscribeItemValue * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, -1)))
		return NULL;
	ns1__SubscribeItemValue *n;
	ns1__SubscribeItemValue **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SubscribeItemValue, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeItemValue, sizeof(ns1__SubscribeItemValue), 1))
				break;
			if (!(p = soap_in_PointerTons1__SubscribeItemValue(soap, tag, NULL, "ns1:SubscribeItemValue")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__SubscribeItemValue(soap, tag, &n, "ns1:SubscribeItemValue"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__SubscribeItemValue * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, std::vector<ns1__SubscribeItemValue * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__SubscribeItemValue * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__SubscribeItemValue * >;
		if (size)
			*size = sizeof(std::vector<ns1__SubscribeItemValue * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__SubscribeItemValue * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SubscribeItemValue * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SubscribeItemValue * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SubscribeItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SubscribeItemValue * > %p -> %p\n", q, p));
	*(std::vector<ns1__SubscribeItemValue * >*)p = *(std::vector<ns1__SubscribeItemValue * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, std::vector<ns1__SubscribeRequestItem * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, const std::vector<ns1__SubscribeRequestItem * >*a)
{
	for (std::vector<ns1__SubscribeRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__SubscribeRequestItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, const char *tag, int id, const std::vector<ns1__SubscribeRequestItem * >*a, const char *type)
{
	for (std::vector<ns1__SubscribeRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__SubscribeRequestItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__SubscribeRequestItem * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, const char *tag, std::vector<ns1__SubscribeRequestItem * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, -1)))
		return NULL;
	ns1__SubscribeRequestItem *n;
	ns1__SubscribeRequestItem **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__SubscribeRequestItem, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeRequestItem, sizeof(ns1__SubscribeRequestItem), 1))
				break;
			if (!(p = soap_in_PointerTons1__SubscribeRequestItem(soap, tag, NULL, "ns1:SubscribeRequestItem")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__SubscribeRequestItem(soap, tag, &n, "ns1:SubscribeRequestItem"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__SubscribeRequestItem * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, std::vector<ns1__SubscribeRequestItem * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__SubscribeRequestItem * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__SubscribeRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__SubscribeRequestItem * >;
		if (size)
			*size = sizeof(std::vector<ns1__SubscribeRequestItem * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__SubscribeRequestItem * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__SubscribeRequestItem * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__SubscribeRequestItem * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__SubscribeRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__SubscribeRequestItem * > %p -> %p\n", q, p));
	*(std::vector<ns1__SubscribeRequestItem * >*)p = *(std::vector<ns1__SubscribeRequestItem * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfshort(struct soap *soap, std::vector<short >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfshort(struct soap *soap, const std::vector<short >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfshort(struct soap *soap, const char *tag, int id, const std::vector<short >*a, const char *type)
{
	for (std::vector<short >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_short(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<short >* SOAP_FMAC4 soap_in_std__vectorTemplateOfshort(struct soap *soap, const char *tag, std::vector<short >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfshort(soap, -1)))
		return NULL;
	short n;
	short *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_short, SOAP_TYPE_std__vectorTemplateOfshort, sizeof(short), 0))
				break;
			if (!(p = soap_in_short(soap, tag, NULL, "xsd:short")))
				break;
		}
		else
		{	soap_default_short(soap, &n);
			if (!soap_in_short(soap, tag, &n, "xsd:short"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<short > * SOAP_FMAC6 soap_new_std__vectorTemplateOfshort(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfshort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfshort(struct soap *soap, std::vector<short >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<short > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfshort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfshort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfshort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<short >;
		if (size)
			*size = sizeof(std::vector<short >);
	}
	else
	{	cp->ptr = (void*)new std::vector<short >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<short >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<short >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfshort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<short > %p -> %p\n", q, p));
	*(std::vector<short >*)p = *(std::vector<short >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbyte(struct soap *soap, std::vector<char >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbyte(struct soap *soap, const std::vector<char >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbyte(struct soap *soap, const char *tag, int id, const std::vector<char >*a, const char *type)
{
	for (std::vector<char >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_byte(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char >* SOAP_FMAC4 soap_in_std__vectorTemplateOfbyte(struct soap *soap, const char *tag, std::vector<char >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfbyte(soap, -1)))
		return NULL;
	char n;
	char *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_byte, SOAP_TYPE_std__vectorTemplateOfbyte, sizeof(char), 0))
				break;
			if (!(p = soap_in_byte(soap, tag, NULL, "xsd:byte")))
				break;
		}
		else
		{	soap_default_byte(soap, &n);
			if (!soap_in_byte(soap, tag, &n, "xsd:byte"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char > * SOAP_FMAC6 soap_new_std__vectorTemplateOfbyte(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfbyte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfbyte(struct soap *soap, std::vector<char >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfbyte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfbyte(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfbyte, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char >;
		if (size)
			*size = sizeof(std::vector<char >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfbyte(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char > %p -> %p\n", q, p));
	*(std::vector<char >*)p = *(std::vector<char >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__decimal(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__decimal(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__decimal(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__decimal(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__decimal(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__decimal(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__decimal(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__decimal, SOAP_TYPE_std__vectorTemplateOfxsd__decimal, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal")))
				break;
		}
		else
		{	soap_default_xsd__decimal(soap, &n);
			if (!soap_in_xsd__decimal(soap, tag, &n, "xsd:decimal"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfxsd__decimal(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfxsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__decimal(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfxsd__decimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__decimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__decimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__decimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	char **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!(p = soap_inliteral(soap, tag, NULL)))
				break;
		}
		else
		{	n = NULL;
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftime(struct soap *soap, std::vector<time_t >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftime(struct soap *soap, const std::vector<time_t >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftime(struct soap *soap, const char *tag, int id, const std::vector<time_t >*a, const char *type)
{
	for (std::vector<time_t >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_time(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<time_t >* SOAP_FMAC4 soap_in_std__vectorTemplateOftime(struct soap *soap, const char *tag, std::vector<time_t >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOftime(soap, -1)))
		return NULL;
	time_t n;
	time_t *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_time, SOAP_TYPE_std__vectorTemplateOftime, sizeof(time_t), 0))
				break;
			if (!(p = soap_in_time(soap, tag, NULL, "xsd:dateTime")))
				break;
		}
		else
		{	soap_default_time(soap, &n);
			if (!soap_in_time(soap, tag, &n, "xsd:dateTime"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<time_t > * SOAP_FMAC6 soap_new_std__vectorTemplateOftime(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOftime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOftime(struct soap *soap, std::vector<time_t >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<time_t > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOftime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOftime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<time_t >;
		if (size)
			*size = sizeof(std::vector<time_t >);
	}
	else
	{	cp->ptr = (void*)new std::vector<time_t >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<time_t >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<time_t >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOftime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<time_t > %p -> %p\n", q, p));
	*(std::vector<time_t >*)p = *(std::vector<time_t >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbool(struct soap *soap, std::vector<bool >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbool(struct soap *soap, const std::vector<bool >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbool(struct soap *soap, const char *tag, int id, const std::vector<bool >*a, const char *type)
{
	for (std::vector<bool >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		bool b = (*i);
		if (soap_out_bool(soap, tag, id, &b, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bool >* SOAP_FMAC4 soap_in_std__vectorTemplateOfbool(struct soap *soap, const char *tag, std::vector<bool >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfbool(soap, -1)))
		return NULL;
	bool n;
	bool *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bool, SOAP_TYPE_std__vectorTemplateOfbool, sizeof(bool), 0))
				break;
			if (!(p = soap_in_bool(soap, tag, NULL, "xsd:boolean")))
				break;
		}
		else
		{	soap_default_bool(soap, &n);
			if (!soap_in_bool(soap, tag, &n, "xsd:boolean"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bool > * SOAP_FMAC6 soap_new_std__vectorTemplateOfbool(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfbool(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfbool(struct soap *soap, std::vector<bool >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bool > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfbool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfbool(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfbool, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bool >;
		if (size)
			*size = sizeof(std::vector<bool >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bool >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bool >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bool >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfbool(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bool > %p -> %p\n", q, p));
	*(std::vector<bool >*)p = *(std::vector<bool >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedShort(struct soap *soap, std::vector<unsigned short >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedShort(struct soap *soap, const std::vector<unsigned short >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedShort(struct soap *soap, const char *tag, int id, const std::vector<unsigned short >*a, const char *type)
{
	for (std::vector<unsigned short >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedShort(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned short >* SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedShort(struct soap *soap, const char *tag, std::vector<unsigned short >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfunsignedShort(soap, -1)))
		return NULL;
	unsigned short n;
	unsigned short *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_unsignedShort, SOAP_TYPE_std__vectorTemplateOfunsignedShort, sizeof(unsigned short), 0))
				break;
			if (!(p = soap_in_unsignedShort(soap, tag, NULL, "xsd:unsignedShort")))
				break;
		}
		else
		{	soap_default_unsignedShort(soap, &n);
			if (!soap_in_unsignedShort(soap, tag, &n, "xsd:unsignedShort"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<unsigned short > * SOAP_FMAC6 soap_new_std__vectorTemplateOfunsignedShort(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfunsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedShort(struct soap *soap, std::vector<unsigned short >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<unsigned short > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfunsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<unsigned short >;
		if (size)
			*size = sizeof(std::vector<unsigned short >);
	}
	else
	{	cp->ptr = (void*)new std::vector<unsigned short >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<unsigned short >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<unsigned short >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<unsigned short > %p -> %p\n", q, p));
	*(std::vector<unsigned short >*)p = *(std::vector<unsigned short >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdouble(struct soap *soap, const std::vector<double >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, int id, const std::vector<double >*a, const char *type)
{
	for (std::vector<double >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_double(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<double >* SOAP_FMAC4 soap_in_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, std::vector<double >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfdouble(soap, -1)))
		return NULL;
	double n;
	double *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_double, SOAP_TYPE_std__vectorTemplateOfdouble, sizeof(double), 0))
				break;
			if (!(p = soap_in_double(soap, tag, NULL, "xsd:double")))
				break;
		}
		else
		{	soap_default_double(soap, &n);
			if (!soap_in_double(soap, tag, &n, "xsd:double"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<double > * SOAP_FMAC6 soap_new_std__vectorTemplateOfdouble(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfdouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<double > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<double >;
		if (size)
			*size = sizeof(std::vector<double >);
	}
	else
	{	cp->ptr = (void*)new std::vector<double >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<double >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<double >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<double > %p -> %p\n", q, p));
	*(std::vector<double >*)p = *(std::vector<double >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedLONG64(struct soap *soap, std::vector<ULONG64 >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedLONG64(struct soap *soap, const std::vector<ULONG64 >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedLONG64(struct soap *soap, const char *tag, int id, const std::vector<ULONG64 >*a, const char *type)
{
	for (std::vector<ULONG64 >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedLONG64(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ULONG64 >* SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedLONG64(struct soap *soap, const char *tag, std::vector<ULONG64 >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfunsignedLONG64(soap, -1)))
		return NULL;
	ULONG64 n;
	ULONG64 *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_unsignedLONG64, SOAP_TYPE_std__vectorTemplateOfunsignedLONG64, sizeof(ULONG64), 0))
				break;
			if (!(p = soap_in_unsignedLONG64(soap, tag, NULL, "xsd:unsignedLong")))
				break;
		}
		else
		{	soap_default_unsignedLONG64(soap, &n);
			if (!soap_in_unsignedLONG64(soap, tag, &n, "xsd:unsignedLong"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ULONG64 > * SOAP_FMAC6 soap_new_std__vectorTemplateOfunsignedLONG64(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfunsignedLONG64(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedLONG64(struct soap *soap, std::vector<ULONG64 >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ULONG64 > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfunsignedLONG64(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedLONG64(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedLONG64, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ULONG64 >;
		if (size)
			*size = sizeof(std::vector<ULONG64 >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ULONG64 >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ULONG64 >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ULONG64 >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedLONG64(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ULONG64 > %p -> %p\n", q, p));
	*(std::vector<ULONG64 >*)p = *(std::vector<ULONG64 >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfLONG64(struct soap *soap, const std::vector<LONG64 >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, int id, const std::vector<LONG64 >*a, const char *type)
{
	for (std::vector<LONG64 >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_LONG64(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64 >* SOAP_FMAC4 soap_in_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, std::vector<LONG64 >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfLONG64(soap, -1)))
		return NULL;
	LONG64 n;
	LONG64 *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_LONG64, SOAP_TYPE_std__vectorTemplateOfLONG64, sizeof(LONG64), 0))
				break;
			if (!(p = soap_in_LONG64(soap, tag, NULL, "xsd:long")))
				break;
		}
		else
		{	soap_default_LONG64(soap, &n);
			if (!soap_in_LONG64(soap, tag, &n, "xsd:long"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<LONG64 > * SOAP_FMAC6 soap_new_std__vectorTemplateOfLONG64(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfLONG64(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<LONG64 > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfLONG64(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfLONG64(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfLONG64, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<LONG64 >;
		if (size)
			*size = sizeof(std::vector<LONG64 >);
	}
	else
	{	cp->ptr = (void*)new std::vector<LONG64 >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<LONG64 >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<LONG64 >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfLONG64(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<LONG64 > %p -> %p\n", q, p));
	*(std::vector<LONG64 >*)p = *(std::vector<LONG64 >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedInt(struct soap *soap, std::vector<unsigned int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedInt(struct soap *soap, const std::vector<unsigned int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedInt(struct soap *soap, const char *tag, int id, const std::vector<unsigned int >*a, const char *type)
{
	for (std::vector<unsigned int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedInt(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedInt(struct soap *soap, const char *tag, std::vector<unsigned int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfunsignedInt(soap, -1)))
		return NULL;
	unsigned int n;
	unsigned int *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_unsignedInt, SOAP_TYPE_std__vectorTemplateOfunsignedInt, sizeof(unsigned int), 0))
				break;
			if (!(p = soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt")))
				break;
		}
		else
		{	soap_default_unsignedInt(soap, &n);
			if (!soap_in_unsignedInt(soap, tag, &n, "xsd:unsignedInt"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<unsigned int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfunsignedInt(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfunsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedInt(struct soap *soap, std::vector<unsigned int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<unsigned int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfunsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<unsigned int >;
		if (size)
			*size = sizeof(std::vector<unsigned int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<unsigned int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<unsigned int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<unsigned int >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<unsigned int > %p -> %p\n", q, p));
	*(std::vector<unsigned int >*)p = *(std::vector<unsigned int >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	int *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!(p = soap_in_int(soap, tag, NULL, "xsd:int")))
				break;
		}
		else
		{	soap_default_int(soap, &n);
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfint(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<int >;
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffloat(struct soap *soap, std::vector<float >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffloat(struct soap *soap, const std::vector<float >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffloat(struct soap *soap, const char *tag, int id, const std::vector<float >*a, const char *type)
{
	for (std::vector<float >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_float(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<float >* SOAP_FMAC4 soap_in_std__vectorTemplateOffloat(struct soap *soap, const char *tag, std::vector<float >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOffloat(soap, -1)))
		return NULL;
	float n;
	float *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_float, SOAP_TYPE_std__vectorTemplateOffloat, sizeof(float), 0))
				break;
			if (!(p = soap_in_float(soap, tag, NULL, "xsd:float")))
				break;
		}
		else
		{	soap_default_float(soap, &n);
			if (!soap_in_float(soap, tag, &n, "xsd:float"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<float > * SOAP_FMAC6 soap_new_std__vectorTemplateOffloat(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOffloat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOffloat(struct soap *soap, std::vector<float >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<float > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOffloat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffloat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOffloat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<float >;
		if (size)
			*size = sizeof(std::vector<float >);
	}
	else
	{	cp->ptr = (void*)new std::vector<float >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<float >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<float >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOffloat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<float > %p -> %p\n", q, p));
	*(std::vector<float >*)p = *(std::vector<float >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, std::vector<ns1__ItemValue * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, const std::vector<ns1__ItemValue * >*a)
{
	for (std::vector<ns1__ItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ItemValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, const char *tag, int id, const std::vector<ns1__ItemValue * >*a, const char *type)
{
	for (std::vector<ns1__ItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ItemValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ItemValue * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, const char *tag, std::vector<ns1__ItemValue * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ItemValue(soap, -1)))
		return NULL;
	ns1__ItemValue *n;
	ns1__ItemValue **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ItemValue, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemValue, sizeof(ns1__ItemValue), 1))
				break;
			if (!(p = soap_in_PointerTons1__ItemValue(soap, tag, NULL, "ns1:ItemValue")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__ItemValue(soap, tag, &n, "ns1:ItemValue"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ItemValue * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, std::vector<ns1__ItemValue * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__ItemValue * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ItemValue * >;
		if (size)
			*size = sizeof(std::vector<ns1__ItemValue * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ItemValue * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ItemValue * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ItemValue * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ItemValue * > %p -> %p\n", q, p));
	*(std::vector<ns1__ItemValue * >*)p = *(std::vector<ns1__ItemValue * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, std::vector<ns1__ReadRequestItem * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, const std::vector<ns1__ReadRequestItem * >*a)
{
	for (std::vector<ns1__ReadRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ReadRequestItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, const char *tag, int id, const std::vector<ns1__ReadRequestItem * >*a, const char *type)
{
	for (std::vector<ns1__ReadRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ReadRequestItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ReadRequestItem * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, const char *tag, std::vector<ns1__ReadRequestItem * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, -1)))
		return NULL;
	ns1__ReadRequestItem *n;
	ns1__ReadRequestItem **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ReadRequestItem, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReadRequestItem, sizeof(ns1__ReadRequestItem), 1))
				break;
			if (!(p = soap_in_PointerTons1__ReadRequestItem(soap, tag, NULL, "ns1:ReadRequestItem")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTons1__ReadRequestItem(soap, tag, &n, "ns1:ReadRequestItem"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ReadRequestItem * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ReadRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, std::vector<ns1__ReadRequestItem * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__ReadRequestItem * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ReadRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ReadRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ReadRequestItem * >;
		if (size)
			*size = sizeof(std::vector<ns1__ReadRequestItem * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ReadRequestItem * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ReadRequestItem * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ReadRequestItem * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ReadRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ReadRequestItem * > %p -> %p\n", q, p));
	*(std::vector<ns1__ReadRequestItem * >*)p = *(std::vector<ns1__ReadRequestItem * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, std::vector<enum ns1__interfaceVersion >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, const std::vector<enum ns1__interfaceVersion >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__interfaceVersion >*a, const char *type)
{
	for (std::vector<enum ns1__interfaceVersion >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__interfaceVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__interfaceVersion >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, const char *tag, std::vector<enum ns1__interfaceVersion >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns1__interfaceVersion(soap, -1)))
		return NULL;
	enum ns1__interfaceVersion n;
	enum ns1__interfaceVersion *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__interfaceVersion, SOAP_TYPE_std__vectorTemplateOfns1__interfaceVersion, sizeof(enum ns1__interfaceVersion), 0))
				break;
			if (!(p = soap_in_ns1__interfaceVersion(soap, tag, NULL, "ns1:interfaceVersion")))
				break;
		}
		else
		{	soap_default_ns1__interfaceVersion(soap, &n);
			if (!soap_in_ns1__interfaceVersion(soap, tag, &n, "ns1:interfaceVersion"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<enum ns1__interfaceVersion > * SOAP_FMAC6 soap_new_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfns1__interfaceVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, std::vector<enum ns1__interfaceVersion >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<enum ns1__interfaceVersion > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__interfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__interfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<enum ns1__interfaceVersion >;
		if (size)
			*size = sizeof(std::vector<enum ns1__interfaceVersion >);
	}
	else
	{	cp->ptr = (void*)new std::vector<enum ns1__interfaceVersion >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns1__interfaceVersion >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns1__interfaceVersion >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns1__interfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns1__interfaceVersion > %p -> %p\n", q, p));
	*(std::vector<enum ns1__interfaceVersion >*)p = *(std::vector<enum ns1__interfaceVersion >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_std__string(soap, tag, NULL, "xsd:string")))
				break;
		}
		else
		{	soap_default_std__string(soap, &n);
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}
#ifdef __cplusplus
}
#endif

/* End of opc_soap_C.cpp */
