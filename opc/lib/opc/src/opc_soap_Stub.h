/* opc_soap_Stub.h
   Generated by gSOAP 2.7.9d from opc_msg.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef opc_soap_Stub_H
#define opc_soap_Stub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__serverState
#define SOAP_TYPE_ns1__serverState (59)
/* ns1:serverState */
enum ns1__serverState {ns1__serverState__running = 0, ns1__serverState__failed = 1, ns1__serverState__noConfig = 2, ns1__serverState__suspended = 3, ns1__serverState__test = 4, ns1__serverState__commFault = 5};
#endif

#ifndef SOAP_TYPE_ns1__interfaceVersion
#define SOAP_TYPE_ns1__interfaceVersion (60)
/* ns1:interfaceVersion */
enum ns1__interfaceVersion {ns1__interfaceVersion__XML_USCOREDA_USCOREVersion_USCORE1_USCORE0 = 0};
#endif

#ifndef SOAP_TYPE_ns1__qualityBits
#define SOAP_TYPE_ns1__qualityBits (61)
/* ns1:qualityBits */
enum ns1__qualityBits {ns1__qualityBits__bad = 0, ns1__qualityBits__badConfigurationError = 1, ns1__qualityBits__badNotConnected = 2, ns1__qualityBits__badDeviceFailure = 3, ns1__qualityBits__badSensorFailure = 4, ns1__qualityBits__badLastKnownValue = 5, ns1__qualityBits__badCommFailure = 6, ns1__qualityBits__badOutOfService = 7, ns1__qualityBits__badWaitingForInitialData = 8, ns1__qualityBits__uncertain = 9, ns1__qualityBits__uncertainLastUsableValue = 10, ns1__qualityBits__uncertainSensorNotAccurate = 11, ns1__qualityBits__uncertainEUExceeded = 12, ns1__qualityBits__uncertainSubNormal = 13, ns1__qualityBits__good = 14, ns1__qualityBits__goodLocalOverride = 15};
#endif

#ifndef SOAP_TYPE_ns1__limitBits
#define SOAP_TYPE_ns1__limitBits (62)
/* ns1:limitBits */
enum ns1__limitBits {ns1__limitBits__none = 0, ns1__limitBits__low = 1, ns1__limitBits__high = 2, ns1__limitBits__constant = 3};
#endif

#ifndef SOAP_TYPE_ns1__browseFilter
#define SOAP_TYPE_ns1__browseFilter (63)
/* ns1:browseFilter */
enum ns1__browseFilter {ns1__browseFilter__all = 0, ns1__browseFilter__branch = 1, ns1__browseFilter__item = 2};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare */

#endif



#ifndef SOAP_TYPE_ns1__ReplyBase
#define SOAP_TYPE_ns1__ReplyBase (10)
/* ns1:ReplyBase */
class SOAP_CMAC ns1__ReplyBase
{
public:
	time_t RcvTime;	/* required attribute */
	time_t ReplyTime;	/* required attribute */
	std::string *ClientRequestHandle;	/* optional attribute */
	std::string *RevisedLocaleID;	/* optional attribute */
	enum ns1__serverState ServerState;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__ReplyBase */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ReplyBase() : ClientRequestHandle(NULL), RevisedLocaleID(NULL), soap(NULL) { }
	virtual ~ns1__ReplyBase() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ServerStatus
#define SOAP_TYPE_ns1__ServerStatus (11)
/* ns1:ServerStatus */
class SOAP_CMAC ns1__ServerStatus
{
public:
	std::string *StatusInfo;	/* optional element of type xsd:string */
	std::string *VendorInfo;	/* optional element of type xsd:string */
	std::vector<std::string >SupportedLocaleIDs;	/* optional element of type xsd:string */
	std::vector<enum ns1__interfaceVersion >SupportedInterfaceVersions;	/* optional element of type ns1:interfaceVersion */
	time_t StartTime;	/* required attribute */
	std::string *ProductVersion;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__ServerStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ServerStatus() : StatusInfo(NULL), VendorInfo(NULL), ProductVersion(NULL), soap(NULL) { }
	virtual ~ns1__ServerStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RequestOptions
#define SOAP_TYPE_ns1__RequestOptions (12)
/* ns1:RequestOptions */
class SOAP_CMAC ns1__RequestOptions
{
public:
	bool *ReturnErrorText;	/* optional attribute */
	bool *ReturnDiagnosticInfo;	/* optional attribute */
	bool *ReturnItemTime;	/* optional attribute */
	bool *ReturnItemPath;	/* optional attribute */
	bool *ReturnItemName;	/* optional attribute */
	time_t *RequestDeadline;	/* optional attribute */
	std::string *ClientRequestHandle;	/* optional attribute */
	std::string *LocaleID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__RequestOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RequestOptions() : ReturnErrorText(NULL), ReturnDiagnosticInfo(NULL), ReturnItemTime(NULL), ReturnItemPath(NULL), ReturnItemName(NULL), RequestDeadline(NULL), ClientRequestHandle(NULL), LocaleID(NULL), soap(NULL) { }
	virtual ~ns1__RequestOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ReadRequestItemList
#define SOAP_TYPE_ns1__ReadRequestItemList (13)
/* ns1:ReadRequestItemList */
class SOAP_CMAC ns1__ReadRequestItemList
{
public:
	std::vector<class ns1__ReadRequestItem * >Items;	/* optional element of type ns1:ReadRequestItem */
	std::string *ItemPath;	/* optional attribute */
	std::string *ReqType;	/* optional attribute */
	int *MaxAge;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__ReadRequestItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ReadRequestItemList() : ItemPath(NULL), ReqType(NULL), MaxAge(NULL), soap(NULL) { }
	virtual ~ns1__ReadRequestItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ReadRequestItem
#define SOAP_TYPE_ns1__ReadRequestItem (14)
/* ns1:ReadRequestItem */
class SOAP_CMAC ns1__ReadRequestItem
{
public:
	std::string *ItemPath;	/* optional attribute */
	std::string *ReqType;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	std::string *ClientItemHandle;	/* optional attribute */
	int *MaxAge;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__ReadRequestItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ReadRequestItem() : ItemPath(NULL), ReqType(NULL), ItemName(NULL), ClientItemHandle(NULL), MaxAge(NULL), soap(NULL) { }
	virtual ~ns1__ReadRequestItem() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ReplyItemList
#define SOAP_TYPE_ns1__ReplyItemList (15)
/* ns1:ReplyItemList */
class SOAP_CMAC ns1__ReplyItemList
{
public:
	std::vector<class ns1__ItemValue * >Items;	/* optional element of type ns1:ItemValue */
	std::string *Reserved;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__ReplyItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ReplyItemList() : Reserved(NULL), soap(NULL) { }
	virtual ~ns1__ReplyItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ItemValue
#define SOAP_TYPE_ns1__ItemValue (16)
/* ns1:ItemValue */
class SOAP_CMAC ns1__ItemValue
{
public:
	std::string *DiagnosticInfo;	/* optional element of type xsd:string */
	char *Value;	/* optional element of type xsd:anyType */
	char ValueType[80]; /* !! Value type added !! */
	class ns1__OPCQuality *Quality;	/* optional element of type ns1:OPCQuality */
	std::string *ValueTypeQualifier;	/* optional attribute */
	std::string *ItemPath;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	std::string *ClientItemHandle;	/* optional attribute */
	time_t *Timestamp;	/* optional attribute */
	std::string *ResultID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__ItemValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ItemValue() : DiagnosticInfo(NULL), Value(NULL), Quality(NULL), ValueTypeQualifier(NULL), ItemPath(NULL), ItemName(NULL), ClientItemHandle(NULL), Timestamp(NULL), ResultID(NULL), soap(NULL) { }
	virtual ~ns1__ItemValue() { }
};
#endif

#ifndef SOAP_TYPE_ns1__OPCQuality
#define SOAP_TYPE_ns1__OPCQuality (17)
/* ns1:OPCQuality */
class SOAP_CMAC ns1__OPCQuality
{
public:
	enum ns1__qualityBits *QualityField;	/* optional attribute */
	enum ns1__limitBits *LimitField;	/* optional attribute */
	unsigned short *VendorField;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__OPCQuality */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__OPCQuality() : QualityField(NULL), LimitField(NULL), VendorField(NULL), soap(NULL) { }
	virtual ~ns1__OPCQuality() { }
};
#endif

#ifndef SOAP_TYPE_ns1__OPCError
#define SOAP_TYPE_ns1__OPCError (18)
/* ns1:OPCError */
class SOAP_CMAC ns1__OPCError
{
public:
	std::string *Text;	/* optional element of type xsd:string */
	std::string ID;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__OPCError */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__OPCError() : Text(NULL), soap(NULL) { }
	virtual ~ns1__OPCError() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfFloat
#define SOAP_TYPE_ns1__ArrayOfFloat (19)
/* ns1:ArrayOfFloat */
class SOAP_CMAC ns1__ArrayOfFloat
{
public:
	std::vector<float >float_;	/* optional element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__ArrayOfFloat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfFloat() : soap(NULL) { }
	virtual ~ns1__ArrayOfFloat() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfInt
#define SOAP_TYPE_ns1__ArrayOfInt (20)
/* ns1:ArrayOfInt */
class SOAP_CMAC ns1__ArrayOfInt
{
public:
	std::vector<int >int_;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__ArrayOfInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfInt() : soap(NULL) { }
	virtual ~ns1__ArrayOfInt() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfUnsignedInt
#define SOAP_TYPE_ns1__ArrayOfUnsignedInt (21)
/* ns1:ArrayOfUnsignedInt */
class SOAP_CMAC ns1__ArrayOfUnsignedInt
{
public:
	std::vector<unsigned int >unsignedInt;	/* optional element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__ArrayOfUnsignedInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfUnsignedInt() : soap(NULL) { }
	virtual ~ns1__ArrayOfUnsignedInt() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfLong
#define SOAP_TYPE_ns1__ArrayOfLong (22)
/* ns1:ArrayOfLong */
class SOAP_CMAC ns1__ArrayOfLong
{
public:
	std::vector<LONG64 >long_;	/* optional element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__ArrayOfLong */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfLong() : soap(NULL) { }
	virtual ~ns1__ArrayOfLong() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfUnsignedLong
#define SOAP_TYPE_ns1__ArrayOfUnsignedLong (23)
/* ns1:ArrayOfUnsignedLong */
class SOAP_CMAC ns1__ArrayOfUnsignedLong
{
public:
	std::vector<ULONG64 >unsignedLong;	/* optional element of type xsd:unsignedLong */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__ArrayOfUnsignedLong */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfUnsignedLong() : soap(NULL) { }
	virtual ~ns1__ArrayOfUnsignedLong() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfDouble
#define SOAP_TYPE_ns1__ArrayOfDouble (24)
/* ns1:ArrayOfDouble */
class SOAP_CMAC ns1__ArrayOfDouble
{
public:
	std::vector<double >double_;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__ArrayOfDouble */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfDouble() : soap(NULL) { }
	virtual ~ns1__ArrayOfDouble() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfUnsignedShort
#define SOAP_TYPE_ns1__ArrayOfUnsignedShort (25)
/* ns1:ArrayOfUnsignedShort */
class SOAP_CMAC ns1__ArrayOfUnsignedShort
{
public:
	std::vector<unsigned short >unsignedShort;	/* optional element of type xsd:unsignedShort */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__ArrayOfUnsignedShort */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfUnsignedShort() : soap(NULL) { }
	virtual ~ns1__ArrayOfUnsignedShort() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfBoolean
#define SOAP_TYPE_ns1__ArrayOfBoolean (26)
/* ns1:ArrayOfBoolean */
class SOAP_CMAC ns1__ArrayOfBoolean
{
public:
	std::vector<bool >boolean;	/* optional element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__ArrayOfBoolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfBoolean() : soap(NULL) { }
	virtual ~ns1__ArrayOfBoolean() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (27)
/* ns1:ArrayOfString */
class SOAP_CMAC ns1__ArrayOfString
{
public:
	std::vector<std::string >string;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__ArrayOfString */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfString() : soap(NULL) { }
	virtual ~ns1__ArrayOfString() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfDateTime
#define SOAP_TYPE_ns1__ArrayOfDateTime (28)
/* ns1:ArrayOfDateTime */
class SOAP_CMAC ns1__ArrayOfDateTime
{
public:
	std::vector<time_t >dateTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__ArrayOfDateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfDateTime() : soap(NULL) { }
	virtual ~ns1__ArrayOfDateTime() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfAnyType
#define SOAP_TYPE_ns1__ArrayOfAnyType (29)
/* ns1:ArrayOfAnyType */
class SOAP_CMAC ns1__ArrayOfAnyType
{
public:
	std::vector<char * >anyType;	/* optional element of type xsd:anyType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__ArrayOfAnyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfAnyType() : soap(NULL) { }
	virtual ~ns1__ArrayOfAnyType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfDecimal
#define SOAP_TYPE_ns1__ArrayOfDecimal (30)
/* ns1:ArrayOfDecimal */
class SOAP_CMAC ns1__ArrayOfDecimal
{
public:
	std::vector<std::string >decimal;	/* optional element of type xsd:decimal */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__ArrayOfDecimal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfDecimal() : soap(NULL) { }
	virtual ~ns1__ArrayOfDecimal() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfByte
#define SOAP_TYPE_ns1__ArrayOfByte (31)
/* ns1:ArrayOfByte */
class SOAP_CMAC ns1__ArrayOfByte
{
public:
	std::vector<char >byte;	/* optional element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__ArrayOfByte */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfByte() : soap(NULL) { }
	virtual ~ns1__ArrayOfByte() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfShort
#define SOAP_TYPE_ns1__ArrayOfShort (32)
/* ns1:ArrayOfShort */
class SOAP_CMAC ns1__ArrayOfShort
{
public:
	std::vector<short >short_;	/* optional element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__ArrayOfShort */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfShort() : soap(NULL) { }
	virtual ~ns1__ArrayOfShort() { }
};
#endif

#ifndef SOAP_TYPE_ns1__WriteRequestItemList
#define SOAP_TYPE_ns1__WriteRequestItemList (33)
/* ns1:WriteRequestItemList */
class SOAP_CMAC ns1__WriteRequestItemList
{
public:
	std::vector<ns1__ItemValue * >Items;	/* optional element of type ns1:ItemValue */
	std::string *ItemPath;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__WriteRequestItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__WriteRequestItemList() : ItemPath(NULL), soap(NULL) { }
	virtual ~ns1__WriteRequestItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscribeRequestItemList
#define SOAP_TYPE_ns1__SubscribeRequestItemList (34)
/* ns1:SubscribeRequestItemList */
class SOAP_CMAC ns1__SubscribeRequestItemList
{
public:
	std::vector<class ns1__SubscribeRequestItem * >Items;	/* optional element of type ns1:SubscribeRequestItem */
	std::string *ItemPath;	/* optional attribute */
	std::string *ReqType;	/* optional attribute */
	float *Deadband;	/* optional attribute */
	int *RequestedSamplingRate;	/* optional attribute */
	bool *EnableBuffering;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__SubscribeRequestItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscribeRequestItemList() : ItemPath(NULL), ReqType(NULL), Deadband(NULL), RequestedSamplingRate(NULL), EnableBuffering(NULL), soap(NULL) { }
	virtual ~ns1__SubscribeRequestItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscribeRequestItem
#define SOAP_TYPE_ns1__SubscribeRequestItem (35)
/* ns1:SubscribeRequestItem */
class SOAP_CMAC ns1__SubscribeRequestItem
{
public:
	std::string *ItemPath;	/* optional attribute */
	std::string *ReqType;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	std::string *ClientItemHandle;	/* optional attribute */
	float *Deadband;	/* optional attribute */
	int *RequestedSamplingRate;	/* optional attribute */
	bool *EnableBuffering;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__SubscribeRequestItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscribeRequestItem() : ItemPath(NULL), ReqType(NULL), ItemName(NULL), ClientItemHandle(NULL), Deadband(NULL), RequestedSamplingRate(NULL), EnableBuffering(NULL), soap(NULL) { }
	virtual ~ns1__SubscribeRequestItem() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscribeReplyItemList
#define SOAP_TYPE_ns1__SubscribeReplyItemList (36)
/* ns1:SubscribeReplyItemList */
class SOAP_CMAC ns1__SubscribeReplyItemList
{
public:
	std::vector<class ns1__SubscribeItemValue * >Items;	/* optional element of type ns1:SubscribeItemValue */
	int *RevisedSamplingRate;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__SubscribeReplyItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscribeReplyItemList() : RevisedSamplingRate(NULL), soap(NULL) { }
	virtual ~ns1__SubscribeReplyItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscribeItemValue
#define SOAP_TYPE_ns1__SubscribeItemValue (37)
/* ns1:SubscribeItemValue */
class SOAP_CMAC ns1__SubscribeItemValue
{
public:
	ns1__ItemValue *ItemValue;	/* optional element of type ns1:ItemValue */
	int *RevisedSamplingRate;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__SubscribeItemValue */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscribeItemValue() : ItemValue(NULL), RevisedSamplingRate(NULL), soap(NULL) { }
	virtual ~ns1__SubscribeItemValue() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList
#define SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList (38)
/* ns1:SubscribePolledRefreshReplyItemList */
class SOAP_CMAC ns1__SubscribePolledRefreshReplyItemList
{
public:
	std::vector<ns1__ItemValue * >Items;	/* optional element of type ns1:ItemValue */
	std::string *SubscriptionHandle;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__SubscribePolledRefreshReplyItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubscribePolledRefreshReplyItemList() : SubscriptionHandle(NULL), soap(NULL) { }
	virtual ~ns1__SubscribePolledRefreshReplyItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BrowseElement
#define SOAP_TYPE_ns1__BrowseElement (39)
/* ns1:BrowseElement */
class SOAP_CMAC ns1__BrowseElement
{
public:
	std::vector<class ns1__ItemProperty * >Properties;	/* optional element of type ns1:ItemProperty */
	std::string *Name;	/* optional attribute */
	std::string *ItemPath;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	bool IsItem;	/* required attribute */
	bool HasChildren;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__BrowseElement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BrowseElement() : Name(NULL), ItemPath(NULL), ItemName(NULL), soap(NULL) { }
	virtual ~ns1__BrowseElement() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ItemProperty
#define SOAP_TYPE_ns1__ItemProperty (40)
/* ns1:ItemProperty */
class SOAP_CMAC ns1__ItemProperty
{
public:
	char *Value;	/* optional element of type xsd:anyType */
	char ValueType[80]; /* !! Added to insert value type !! */
	std::string Name;	/* required attribute */
	std::string *Description;	/* optional attribute */
	std::string *ItemPath;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	std::string *ResultID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__ItemProperty */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ItemProperty() : Value(NULL), Description(NULL), ItemPath(NULL), ItemName(NULL), ResultID(NULL), soap(NULL) { }
	virtual ~ns1__ItemProperty() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ItemIdentifier
#define SOAP_TYPE_ns1__ItemIdentifier (41)
/* ns1:ItemIdentifier */
class SOAP_CMAC ns1__ItemIdentifier
{
public:
	std::string *ItemPath;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__ItemIdentifier */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ItemIdentifier() : ItemPath(NULL), ItemName(NULL), soap(NULL) { }
	virtual ~ns1__ItemIdentifier() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PropertyReplyList
#define SOAP_TYPE_ns1__PropertyReplyList (42)
/* ns1:PropertyReplyList */
class SOAP_CMAC ns1__PropertyReplyList
{
public:
	std::vector<ns1__ItemProperty * >Properties;	/* optional element of type ns1:ItemProperty */
	std::string *ItemPath;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	std::string *ResultID;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__PropertyReplyList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PropertyReplyList() : ItemPath(NULL), ItemName(NULL), ResultID(NULL), soap(NULL) { }
	virtual ~ns1__PropertyReplyList() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStatus
#define SOAP_TYPE__ns1__GetStatus (43)
/* ns1:GetStatus */
class SOAP_CMAC _ns1__GetStatus
{
public:
	std::string *LocaleID;	/* optional attribute */
	std::string *ClientRequestHandle;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__ns1__GetStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStatus() : LocaleID(NULL), ClientRequestHandle(NULL), soap(NULL) { }
	virtual ~_ns1__GetStatus() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStatusResponse
#define SOAP_TYPE__ns1__GetStatusResponse (44)
/* ns1:GetStatusResponse */
class SOAP_CMAC _ns1__GetStatusResponse
{
public:
	ns1__ReplyBase *GetStatusResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	ns1__ServerStatus *Status;	/* optional element of type ns1:ServerStatus */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__ns1__GetStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStatusResponse() : GetStatusResult(NULL), Status(NULL), soap(NULL) { }
	virtual ~_ns1__GetStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Read
#define SOAP_TYPE__ns1__Read (45)
/* ns1:Read */
class SOAP_CMAC _ns1__Read
{
public:
	ns1__RequestOptions *Options;	/* optional element of type ns1:RequestOptions */
	ns1__ReadRequestItemList *ItemList;	/* optional element of type ns1:ReadRequestItemList */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__ns1__Read */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Read() : Options(NULL), ItemList(NULL), soap(NULL) { }
	virtual ~_ns1__Read() { }
};
#endif

#ifndef SOAP_TYPE__ns1__ReadResponse
#define SOAP_TYPE__ns1__ReadResponse (46)
/* ns1:ReadResponse */
class SOAP_CMAC _ns1__ReadResponse
{
public:
	ns1__ReplyBase *ReadResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	ns1__ReplyItemList *RItemList;	/* optional element of type ns1:ReplyItemList */
	std::vector<ns1__OPCError * >Errors;	/* optional element of type ns1:OPCError */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__ns1__ReadResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__ReadResponse() : ReadResult(NULL), RItemList(NULL), soap(NULL) { }
	virtual ~_ns1__ReadResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Write
#define SOAP_TYPE__ns1__Write (47)
/* ns1:Write */
class SOAP_CMAC _ns1__Write
{
public:
	ns1__RequestOptions *Options;	/* optional element of type ns1:RequestOptions */
	ns1__WriteRequestItemList *ItemList;	/* optional element of type ns1:WriteRequestItemList */
	bool ReturnValuesOnReply;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__ns1__Write */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Write() : Options(NULL), ItemList(NULL), soap(NULL) { }
	virtual ~_ns1__Write() { }
};
#endif

#ifndef SOAP_TYPE__ns1__WriteResponse
#define SOAP_TYPE__ns1__WriteResponse (48)
/* ns1:WriteResponse */
class SOAP_CMAC _ns1__WriteResponse
{
public:
	ns1__ReplyBase *WriteResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	ns1__ReplyItemList *RItemList;	/* optional element of type ns1:ReplyItemList */
	std::vector<ns1__OPCError * >Errors;	/* optional element of type ns1:OPCError */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__ns1__WriteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__WriteResponse() : WriteResult(NULL), RItemList(NULL), soap(NULL) { }
	virtual ~_ns1__WriteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Subscribe
#define SOAP_TYPE__ns1__Subscribe (49)
/* ns1:Subscribe */
class SOAP_CMAC _ns1__Subscribe
{
public:
	ns1__RequestOptions *Options;	/* optional element of type ns1:RequestOptions */
	ns1__SubscribeRequestItemList *ItemList;	/* optional element of type ns1:SubscribeRequestItemList */
	bool ReturnValuesOnReply;	/* required attribute */
	int *SubscriptionPingRate;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__ns1__Subscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Subscribe() : Options(NULL), ItemList(NULL), SubscriptionPingRate(NULL), soap(NULL) { }
	virtual ~_ns1__Subscribe() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscribeResponse
#define SOAP_TYPE__ns1__SubscribeResponse (50)
/* ns1:SubscribeResponse */
class SOAP_CMAC _ns1__SubscribeResponse
{
public:
	ns1__ReplyBase *SubscribeResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	ns1__SubscribeReplyItemList *RItemList;	/* optional element of type ns1:SubscribeReplyItemList */
	std::vector<ns1__OPCError * >Errors;	/* optional element of type ns1:OPCError */
	std::string *ServerSubHandle;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__ns1__SubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscribeResponse() : SubscribeResult(NULL), RItemList(NULL), ServerSubHandle(NULL), soap(NULL) { }
	virtual ~_ns1__SubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscriptionPolledRefresh
#define SOAP_TYPE__ns1__SubscriptionPolledRefresh (51)
/* ns1:SubscriptionPolledRefresh */
class SOAP_CMAC _ns1__SubscriptionPolledRefresh
{
public:
	ns1__RequestOptions *Options;	/* optional element of type ns1:RequestOptions */
	std::vector<std::string >ServerSubHandles;	/* optional element of type xsd:string */
	time_t *HoldTime;	/* optional attribute */
	int *WaitTime;	/* optional attribute */
	bool *ReturnAllItems;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__ns1__SubscriptionPolledRefresh */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscriptionPolledRefresh() : Options(NULL), HoldTime(NULL), WaitTime(NULL), ReturnAllItems(NULL), soap(NULL) { }
	virtual ~_ns1__SubscriptionPolledRefresh() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse
#define SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse (52)
/* ns1:SubscriptionPolledRefreshResponse */
class SOAP_CMAC _ns1__SubscriptionPolledRefreshResponse
{
public:
	ns1__ReplyBase *SubscriptionPolledRefreshResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	std::vector<std::string >InvalidServerSubHandles;	/* optional element of type xsd:string */
	std::vector<ns1__SubscribePolledRefreshReplyItemList * >RItemList;	/* optional element of type ns1:SubscribePolledRefreshReplyItemList */
	std::vector<ns1__OPCError * >Errors;	/* optional element of type ns1:OPCError */
	bool *DataBufferOverflow;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__ns1__SubscriptionPolledRefreshResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscriptionPolledRefreshResponse() : SubscriptionPolledRefreshResult(NULL), DataBufferOverflow(NULL), soap(NULL) { }
	virtual ~_ns1__SubscriptionPolledRefreshResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscriptionCancel
#define SOAP_TYPE__ns1__SubscriptionCancel (53)
/* ns1:SubscriptionCancel */
class SOAP_CMAC _ns1__SubscriptionCancel
{
public:
	std::string *ServerSubHandle;	/* optional attribute */
	std::string *ClientRequestHandle;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns1__SubscriptionCancel */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscriptionCancel() : ServerSubHandle(NULL), ClientRequestHandle(NULL), soap(NULL) { }
	virtual ~_ns1__SubscriptionCancel() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SubscriptionCancelResponse
#define SOAP_TYPE__ns1__SubscriptionCancelResponse (54)
/* ns1:SubscriptionCancelResponse */
class SOAP_CMAC _ns1__SubscriptionCancelResponse
{
public:
	std::string *ClientRequestHandle;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns1__SubscriptionCancelResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SubscriptionCancelResponse() : ClientRequestHandle(NULL), soap(NULL) { }
	virtual ~_ns1__SubscriptionCancelResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Browse
#define SOAP_TYPE__ns1__Browse (55)
/* ns1:Browse */
class SOAP_CMAC _ns1__Browse
{
public:
	std::vector<std::string >PropertyNames;	/* optional element of type xsd:QName */
	std::string *LocaleID;	/* optional attribute */
	std::string *ClientRequestHandle;	/* optional attribute */
	std::string *ItemPath;	/* optional attribute */
	std::string *ItemName;	/* optional attribute */
	std::string *ContinuationPoint;	/* optional attribute */
	int *MaxElementsReturned;	/* optional attribute */
	enum ns1__browseFilter *BrowseFilter;	/* optional attribute */
	std::string *ElementNameFilter;	/* optional attribute */
	std::string *VendorFilter;	/* optional attribute */
	bool *ReturnAllProperties;	/* optional attribute */
	bool *ReturnPropertyValues;	/* optional attribute */
	bool *ReturnErrorText;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns1__Browse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Browse() : LocaleID(NULL), ClientRequestHandle(NULL), ItemPath(NULL), ItemName(NULL), ContinuationPoint(NULL), MaxElementsReturned(NULL), BrowseFilter(NULL), ElementNameFilter(NULL), VendorFilter(NULL), ReturnAllProperties(NULL), ReturnPropertyValues(NULL), ReturnErrorText(NULL), soap(NULL) { }
	virtual ~_ns1__Browse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__BrowseResponse
#define SOAP_TYPE__ns1__BrowseResponse (56)
/* ns1:BrowseResponse */
class SOAP_CMAC _ns1__BrowseResponse
{
public:
	ns1__ReplyBase *BrowseResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	std::vector<ns1__BrowseElement * >Elements;	/* optional element of type ns1:BrowseElement */
	std::vector<ns1__OPCError * >Errors;	/* optional element of type ns1:OPCError */
	std::string *ContinuationPoint;	/* optional attribute */
	bool *MoreElements;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns1__BrowseResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__BrowseResponse() : BrowseResult(NULL), ContinuationPoint(NULL), MoreElements(NULL), soap(NULL) { }
	virtual ~_ns1__BrowseResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProperties
#define SOAP_TYPE__ns1__GetProperties (57)
/* ns1:GetProperties */
class SOAP_CMAC _ns1__GetProperties
{
public:
	std::vector<ns1__ItemIdentifier * >ItemIDs;	/* optional element of type ns1:ItemIdentifier */
	std::vector<std::string >PropertyNames;	/* optional element of type xsd:QName */
	std::string *LocaleID;	/* optional attribute */
	std::string *ClientRequestHandle;	/* optional attribute */
	std::string *ItemPath;	/* optional attribute */
	bool *ReturnAllProperties;	/* optional attribute */
	bool *ReturnPropertyValues;	/* optional attribute */
	bool *ReturnErrorText;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns1__GetProperties */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProperties() : LocaleID(NULL), ClientRequestHandle(NULL), ItemPath(NULL), ReturnAllProperties(NULL), ReturnPropertyValues(NULL), ReturnErrorText(NULL), soap(NULL) { }
	virtual ~_ns1__GetProperties() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetPropertiesResponse
#define SOAP_TYPE__ns1__GetPropertiesResponse (58)
/* ns1:GetPropertiesResponse */
class SOAP_CMAC _ns1__GetPropertiesResponse
{
public:
	ns1__ReplyBase *GetPropertiesResult;	/* RPC return element */	/* optional element of type ns1:ReplyBase */
	std::vector<ns1__PropertyReplyList * >PropertyLists;	/* optional element of type ns1:PropertyReplyList */
	std::vector<ns1__OPCError * >Errors;	/* optional element of type ns1:OPCError */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns1__GetPropertiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetPropertiesResponse() : GetPropertiesResult(NULL), soap(NULL) { }
	virtual ~_ns1__GetPropertiesResponse() { }
};
#endif

#ifndef SOAP_TYPE___ns1__GetStatus
#define SOAP_TYPE___ns1__GetStatus (133)
/* Operation wrapper: */
struct __ns1__GetStatus
{
public:
	_ns1__GetStatus *ns1__GetStatus;	/* optional element of type ns1:GetStatus */
};
#endif

#ifndef SOAP_TYPE___ns1__Read
#define SOAP_TYPE___ns1__Read (137)
/* Operation wrapper: */
struct __ns1__Read
{
public:
	_ns1__Read *ns1__Read;	/* optional element of type ns1:Read */
};
#endif

#ifndef SOAP_TYPE___ns1__Write
#define SOAP_TYPE___ns1__Write (141)
/* Operation wrapper: */
struct __ns1__Write
{
public:
	_ns1__Write *ns1__Write;	/* optional element of type ns1:Write */
};
#endif

#ifndef SOAP_TYPE___ns1__Subscribe
#define SOAP_TYPE___ns1__Subscribe (145)
/* Operation wrapper: */
struct __ns1__Subscribe
{
public:
	_ns1__Subscribe *ns1__Subscribe;	/* optional element of type ns1:Subscribe */
};
#endif

#ifndef SOAP_TYPE___ns1__SubscriptionPolledRefresh
#define SOAP_TYPE___ns1__SubscriptionPolledRefresh (149)
/* Operation wrapper: */
struct __ns1__SubscriptionPolledRefresh
{
public:
	_ns1__SubscriptionPolledRefresh *ns1__SubscriptionPolledRefresh;	/* optional element of type ns1:SubscriptionPolledRefresh */
};
#endif

#ifndef SOAP_TYPE___ns1__SubscriptionCancel
#define SOAP_TYPE___ns1__SubscriptionCancel (153)
/* Operation wrapper: */
struct __ns1__SubscriptionCancel
{
public:
	_ns1__SubscriptionCancel *ns1__SubscriptionCancel;	/* optional element of type ns1:SubscriptionCancel */
};
#endif

#ifndef SOAP_TYPE___ns1__Browse
#define SOAP_TYPE___ns1__Browse (157)
/* Operation wrapper: */
struct __ns1__Browse
{
public:
	_ns1__Browse *ns1__Browse;	/* optional element of type ns1:Browse */
};
#endif

#ifndef SOAP_TYPE___ns1__GetProperties
#define SOAP_TYPE___ns1__GetProperties (161)
/* Operation wrapper: */
struct __ns1__GetProperties
{
public:
	_ns1__GetProperties *ns1__GetProperties;	/* optional element of type ns1:GetProperties */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (164)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	void *dummy;	/* transient */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (165)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (167)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (168)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (169)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (4)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (8)
typedef std::string xsd__QName;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (9)
typedef std::string xsd__decimal;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operations                                                         *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetStatus(struct soap*, _ns1__GetStatus *ns1__GetStatus, _ns1__GetStatusResponse *ns1__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__Read(struct soap*, _ns1__Read *ns1__Read, _ns1__ReadResponse *ns1__ReadResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__Write(struct soap*, _ns1__Write *ns1__Write, _ns1__WriteResponse *ns1__WriteResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__Subscribe(struct soap*, _ns1__Subscribe *ns1__Subscribe, _ns1__SubscribeResponse *ns1__SubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__SubscriptionPolledRefresh(struct soap*, _ns1__SubscriptionPolledRefresh *ns1__SubscriptionPolledRefresh, _ns1__SubscriptionPolledRefreshResponse *ns1__SubscriptionPolledRefreshResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__SubscriptionCancel(struct soap*, _ns1__SubscriptionCancel *ns1__SubscriptionCancel, _ns1__SubscriptionCancelResponse *ns1__SubscriptionCancelResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__Browse(struct soap*, _ns1__Browse *ns1__Browse, _ns1__BrowseResponse *ns1__BrowseResponse);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__GetProperties(struct soap*, _ns1__GetProperties *ns1__GetProperties, _ns1__GetPropertiesResponse *ns1__GetPropertiesResponse);

/******************************************************************************\
 *                                                                            *
 * Stubs                                                                      *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetStatus *ns1__GetStatus, _ns1__GetStatusResponse *ns1__GetStatusResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Read(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Read *ns1__Read, _ns1__ReadResponse *ns1__ReadResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Write(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Write *ns1__Write, _ns1__WriteResponse *ns1__WriteResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Subscribe(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Subscribe *ns1__Subscribe, _ns1__SubscribeResponse *ns1__SubscribeResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SubscriptionPolledRefresh(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SubscriptionPolledRefresh *ns1__SubscriptionPolledRefresh, _ns1__SubscriptionPolledRefreshResponse *ns1__SubscriptionPolledRefreshResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__SubscriptionCancel(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__SubscriptionCancel *ns1__SubscriptionCancel, _ns1__SubscriptionCancelResponse *ns1__SubscriptionCancelResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Browse(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Browse *ns1__Browse, _ns1__BrowseResponse *ns1__BrowseResponse);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__GetProperties(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__GetProperties *ns1__GetProperties, _ns1__GetPropertiesResponse *ns1__GetPropertiesResponse);

/******************************************************************************\
 *                                                                            *
 * Skeletons                                                                  *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Read(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Write(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Subscribe(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SubscriptionPolledRefresh(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__SubscriptionCancel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__Browse(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__GetProperties(struct soap*);

#endif

/* End of opc_soap_Stub.h */
