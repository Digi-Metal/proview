/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#ifndef sev_valuecache_h
#define sev_valuecache_h

#include "pwr.h"
#include "co_time.h"

typedef enum {
  sev_eCvType_Point,
  sev_eCvType_Mean,
} sev_eCvType;

typedef struct {
  double val;
  double time;
  double epsilon;
} sev_sCacheValueDouble;

typedef struct {
  pwr_tBoolean val;
  pwr_tTime time;
} sev_sCacheValueBool;

#define VALUECACHE_SIZE 20

class sev_valuecache {
 public:
  sev_eCvType m_type;
  void *m_userdata;
  int m_useridx;
  void (*m_write_cb)( void *, int , void *, pwr_tTime *);

  sev_valuecache( sev_eCvType type) : m_type(type), m_userdata(0), m_useridx(0), m_write_cb(0) {}
  sev_valuecache( const sev_valuecache& x) : m_type(x.m_type), m_userdata(x.m_userdata), m_useridx(x.m_useridx), 
    m_write_cb(x.m_write_cb) {}
  virtual ~sev_valuecache() {};
  virtual void add( void *value, pwr_tTime *time) {};
  virtual void evaluate( double maxtime) {};
  virtual void write( int index) {};
  virtual void set_write_cb( void (*write_cb)( void *, int, void *, pwr_tTime *), void *userdata, int idx) {
    m_write_cb = write_cb;
    m_userdata = userdata;
    m_useridx = idx;
  }
};


class sev_valuecache_double : public sev_valuecache  {
  static const int m_size;
  int m_length;
  int m_first;
  int m_last;
  bool m_inited;
  sev_sCacheValueDouble m_val[VALUECACHE_SIZE];
  sev_sCacheValueDouble m_wval;
  double m_k;
  double m_m;
  double m_deadband;
  double m_deadband_value;
  double m_deadband_time;
  int m_last_opt_write;
  pwr_tTime m_start_time;
  double m_last_k;

 public:
  sev_valuecache_double( sev_eCvType type, double deadband_value, double deadband_time) : 
    sev_valuecache(type), m_length(0), m_first(0), m_last(0), m_inited(false), 
    m_deadband_value(deadband_value), m_deadband_time(deadband_time) {
    memset( &m_wval, 0, sizeof(m_wval));
    time_GetTime(&m_start_time);
  }
  sev_valuecache_double( const sev_valuecache_double& x) : 
    sev_valuecache(x), m_length(x.m_length),
    m_first(x.m_first), m_last(x.m_last), m_inited(x.m_inited), m_k(x.m_k), m_deadband(x.m_deadband), 
    m_deadband_value(x.m_deadband_value), m_deadband_time(x.m_deadband_time), m_last_opt_write(x.m_last_opt_write),
    m_start_time(x.m_start_time), m_last_k(x.m_last_k) {
    memcpy( m_val, x.m_val, sizeof(m_val));
    memcpy( &m_wval, &x.m_wval, sizeof(m_wval));
  }
  ~sev_valuecache_double() {}
  int length() { return m_length;}
  int idx( int index);
  sev_sCacheValueDouble& operator[]( const int index);
  sev_sCacheValueDouble& wval() { return m_wval;}
  void add( void *value, pwr_tTime *time);
  void evaluate( double maxtime);
  void calculate_k();
  void write( int index);
  void calculate_epsilon();
  void calculate_epsilon( int index);
  bool check_deadband( int index);
  bool check_deadband();
  int get_optimal_write();
  double epsilon(int index) { return m_val[idx(index)].epsilon;}
  double get_k() { return m_k;}
};

class sev_valuecache_bool : public sev_valuecache  {
  bool m_inited;
  sev_sCacheValueBool m_val;
  sev_sCacheValueBool m_wval;

 public:
  sev_valuecache_bool( sev_eCvType type) : 
    sev_valuecache(type), m_inited(false) {
    memset( &m_wval, 0, sizeof(m_wval));
  }
  sev_valuecache_bool( const sev_valuecache_bool& x) : 
    sev_valuecache(x), m_inited(x.m_inited) {
    memcpy( &m_wval, &x.m_wval, sizeof(m_wval));
  }
  ~sev_valuecache_bool() {}
  sev_sCacheValueBool& wval() { return m_wval;}
  void add( void *value, pwr_tTime *time);
  void evaluate( double maxtime);
  void write( int index);
};


#endif
