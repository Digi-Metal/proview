
<topic> __DocumentTitlePage

<image> pwr_logga.gif






<h1> Designer's Guide
























<hr>
2005-04-19
Version 4.1.0	
<hr>
</topic>

<topic> __DocumentInfoPage


Copyright (C) 2005 SSAB Oxelösund AB

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.


First Edition Mars 2005




</topic>

<chapter>
<topic> introduction
Introduction

Proview is a modern, powerful and general process control system. It contains all functions
normally required for successful sequential control, adjustment, data acquisition, 
communication, supervision, etc. 

The configuration of a Proview system is done graphically, making the application adaptation
simple, reliable, and flexible. Proview is a distributed system, which means that the system
consists of several computers, connected via a network . Via the network computers exchange 
data with each other. In this way, for instance, the measuring signals will be known on all 
the process - and operator stations of a Proview system. 

A Proview system is defined with objects. Each object represents a physical or abstract 
entity in the system. The objects are structured in hierarchical tree structures, making it 
possible to describe the system in a structured way. The tree structure also imposes a 
hierarchical naming of all objects. By carefully choosing names when configuring a system, 
the full name of an object will identify its function, or role in the system. 

The hierarchies are divided into two groups; one called the Plant Configuration, describing 
the logical view of a system; and one called the Node Configuration , describing the physical
view of the system. The configuration of these two parts can be done independently. Eventually
the two parts are connected to each other. 

To configure a system you use the Proview Workbench. The workbench comprises a permanent 
database and a number of tools to help you configuring the objects needed to define the 
system. From the workbench you create a runnable system as well as documentation about the 
system. 

The purpose of Proview is to help you creating automated systems. Suppose you have a 
process that you wish to control, Proview helps you creating the control system for this 
process. When the system is created, you will find that you have also created the 
documentation for the system. 
</topic>
</chapter>

<option> printdisable
<topic> index
Designer's Guide

Overview <link> design_overview
Database structure <link> database_structure
A case study <link> case_study
Administration <link> administrator
Configure the directoryvolume <link> configure_directoryvolume
Configure the rootvolume <link> configure_rootvolume
Plc programming <link>plc_programming
Creating Process Graphics  <link> ge_man
Running and Testing a Proview System <link> conf_test

<b>Reference Manuals
The Configurator <link> configurator_refman
The Object Editor<link> objecteditor_refman
The Spreadsheet Editor<link> spreadsheeteditor_refman
The PlcEditor<link> plceditor_refman
Commands <link> help command
Script <link> script
</topic>
<option> printenable

<chapter>
<topic> design_overview
Overview

As this is a guide for designers, we to start with a description of what the design of a 
control system imply. The description can also work as an introduction to the different 
concepts that are used in this guide.

A designer's starting point is, of course, the process that is to be controled by the system,
and the first task is to learn about the process, and to figure out the best way to control
it: which control loops is needed, which interlockings, how is the startup and shutdown 
carried out, how is operators and maintainers going to work with the system. This is 
summed up in a Design specification.

At the same time you have to consider what information about the process the control system
need to perform its task, i.e. which sensors should be placed in the plant. The control
system also has to influence the process i varous ways, for example with valves and engines.
This ends in a Signal list, that is alist of all input and output signals of the system.

At this point the question of which control system is to be used is raised, and on alternative
is of course Proview. You also has to decide whick IO-system to use, and how to devide the
function i different process stations.

<h1>IO-systems
The task of the IO-system is to bring signals from the process to the control system, and to
put out signals to influence the process. The signals are usually digital or analog, but
there are also other types as integers and counters. You can choose between a rack and card
system connected to the process station, or a distributed io, e.g profibus.

<h1>Configure the system
When it's time to start configure the system, you first create a new project in the
Administrator. The Administartor is a tool to create order among all the projects, as there
can be plenty of them in time.

The configuration of a system is mainly done by creating objects in a database, the Workbench. 
There is a large amount of objects to configure everything from IO-channels to PLC programs.
The Proview Object Reference Manual contains over 400 different types of objects. The objects
are placed in a tree structure, and you use a tool called the Configurator to create objects and
to navigate it the object tree.

The object tree is separated in to parts, the plant hierarchy and the node hierarchy.
The Plant hierarchy reflects the different functions in the plant and in the process, while
the Node hierarchy reflects the hardware of the control system, with computors, IO-racks and
IO-cards.

When later the control system is started in runtime, a copy of the object tree is created in
a realtime database, rtdb. The transfer from the Workbench to rtdb is done with so called
loadfiles, files that are generated from the Workbench and contains all its objects.

<h1>Control program
Proview offers a graphical programming language in witch logic, Grafcet sequences and control
loops is programmed. It is named the PLC program. Also the PLC program is a part of the object
tree. It is configured by placing specific program objects, PlcPgm, in the Plant hierarchy. 
When opening a PlcPgm you enter the Plc Editor, in which the graphical programming is preformed.
Function blocks is created, and connected in a signal flow of digital and analogous signals,
where the input signals are feched at the left side, transformed in different function blocks,
and finally stored in ouput signals at the right side.

A complement to the PLC program is application programs, which are written in the c, c++ or
java language. Applications are written and started as separate programs and connected to
the realtimedatabase through an API.

<h1>Simulation
The realtime database, the PLC program and possible applications kan easily be started in the
development station. This makes it possible to test the programs in direct connection with
the programming. You kan even write special simulation programas which reads the output signals,
simulates the ouputs influence of the process, calculates values of different sensors and puts
this values in the input signals.

The configuration and programming of the system is then a process, where you altertately
configure/program and test. The result i carefully debugged programs and a fast and efficiant
commissioning of the plant. It also result in better programs, and more thoroughly workt
through functions, beacause the feedback is greater in the create process that the construction
of a process control system implies.

At the simulation and commissioning it is of greate importance to have access to tools that
makes it possible to monitor and examine the system, and quickly locacalize possible 
malfunctions. In Proview this tools is called Xtt. Xtt containts a lot of functions to examine
the content of the realtime database, to flow the signal flow, to log fast or slow sequences,
etc.

<h1>Operator interface
There are a number of different groups of professionals that shall gain access to the system, 
operators running the plant on a daily basis, maintaners occasionally correcting som 
malfuncions, process engineers requesting various process data. All have their demands on the 
system interface. Furthermore the limits between the various groups of professionals might be
fluid, operators that are both operators and maintainers, and perhaps even process engineers.
This makes high demands on the functionality and flexibility of the operator interface. You
can rapidly and easy trough, so called methods that i activated from popupmenues, fetch all the
information of various objects, that i stored in the realtime database, or in different server
systems.

<h1>Process graphics
Process graphics are build in a grapical editor. The grapics are vector based, which makes all
graphs and components unlimitede scalable. Components have a preprogrammed dynamic to change
color and shape, depending of signals in the realtime database, or to respond to mouse clicks
and set values in the database. In each component that is sensible to mouse click or input,
you can state access, and selectively allow or hinder users to influence the system. Process
graphs can also, besides beeing displayed in the ordinary operator environment, be exported to 
java, which makes them viewable on the web with all dynamics.

<h1>Supervision
If any malfunction arise in the system, the operator has to be noticed. This is done with
special supervisory objects, that is configured in the plant hierarchy or in the PLC program,
and which originate alarms and events. The alarms have four priority levels: A, B, C and D,
and is diplayed to the operator in the alarm list, the event list and the historical event list.

The alarmlist contains unacknowledged alarms and alarms in alarm state. An alarm normally has
to be acknowledged before it disapperas from the list. If the alarm state is active, the alarm
remains in the list as long as it is active.

Alarm also are registred in the event list, that displays events in a chronological order.

The historical eventlist is a database, also registrering event. Here you can search for events,
stating criteria as priority and process part. 

If a plant part is shut down, it is possible to block the alarms, to avoid to distract the
operator. Blocked plant parts are displayed in the Block list.

<h1>Data Storage
You often want to follow the change of a signal over time, in the shape of a curve. In Proview
there are there kinds of funktions for this, DsTrend, DsFast and DsHist.

DsTrend is a trend that is stored in the realtime database. The value of a signal is stored
continously with an interval of 1 second and upwards. For each curve there is space for about
500 samples, so if you choose to store a new sample every second, you have a trend of the
signal of about 8 minutes.

DsHist store signales in a similar way in a database on disk, which makes it possible to store
values a longer period of time then DsTrend.

DsFast store more rapid sequences, where the storage is started on a trigg condition, and 
continues a specified time, and is then displayed as a curve.
</topic>
</chapter>

<chapter>
<topic> database_structure
Database structure

As we have seen earlier, the main part of the configuration of a Proview system is taken place
in a database, the Workbench. In the Workbench you create objects in a tree structure, and
every object arise a certain function i the control system. Proview is what is called object
oriented, so let us look a little closer at what a Proview object really is.

<option> printdisable
Objects <link> object
Volumes <link> volume
Attribute <link> attribute
Class <link> class
Object Tree <link> object_tree
Object Name <link> object_name
Mounting <link> mounting
Object Identity <link> object_identity
<option> printenable

</topic>

<topic> object
Object

An object consists of a quantity of data, that in some way defines the state of the object or 
the properties of the object. The data quantity can be very simple, as for an And-gate, where
it consists of a boolean value that is true or false. However, a PID controler has a more
complex quantity of data. It contains gain, integration time, output, force etc. It consists
of a mix of digital, analogous and integer values. Some values are configured in the development
environment and some are calculated in runtime.

The quantity of data is called the body of the object. The body is divided in attributes, where
every attribute has a name and a type. The body of an And-gate consists of the attribute Status
which is of type Boolean, while the body of a PID controler consists of 47 attributes: ProcVal,
SetVal, Bias, ForceVal etc.

All PID objects has its quantity of data structured in the same way, you say they are a member
of the same class. The PID objects are memebers of the PID class, and the And-gates are members
of the And class. A class is a kind of model of how objects that belongs to the class appear,
for example which the attributes are, and the name and type of the attribues.

Besides a body, an objects also has a header. In the header, the class and identity of the 
objects is found, and also its relation to other objects. The objects are ordered in a tree
structure, and in the header there are link to the parent, and the closest siblings of the
object.
</topic>

<topic>volume
Volumes
When configuring a system, and creating objects, you usually know to which node the objects
will belong in runtime. You could group the objects after which node they will belong to,
but a more flexibel grouping is made, so instead you group the objects in volumes. A volume
is a kind of container for objects. The volume has a name and an identity, and it contains
a number of objects ordered in a tree structure.

There are a number of different types of volumes, and the first you get into contact with is
a root volume. When configuring a node, you usually work in a root volume. Every node is
connected to a root volume, i.e when the node is starting up in runtime, the root volume,
and its objects, is loaded into the node. Below is a description of the different types of
volumes.

<h2>RootVolume
A root volume contains the root of the object tree in a node. At startup, the node is loading
the root volume.

A node is connected to one and only one root volume. Furthermore, a root volume can be loaded
into several nodes. When a process station is running i production, the same volume can
concurrently be loaded into a develoopment station for simulation, and a third node kan run
the volume in educational purposes. Though, you have to consider that the nodes has to run
in different communication busses.

<h2>SubVolume
Some of the objects in a node can be placed in a sub volume. The reason to divide the objects
of a node in a root volume and in one or several sub volumes, could be that a number of persons
has to configure the node simultaneously, or that you plan to move parts of the control of
some plant parts to another node later.

<h2>ClassVolume
The definition of different classes reside in a special type of volume, called ClassVolume.
Here the description of a class i built with objects that define the name of the class
and the attributes of the class.

There are two classvolumes that you always include in a Proview system, pwrs and pwrb. pwrs
contains the system classes, mainly classes used in class definitions. pwrb contains base
classes, i.e standard classes that is neede to build a process or operator station.

<h2>DynamicVolume
A dynamic volume contains dynamic objects, i.e. volatile objects created at runtime. If you
have a material planning module in the system, an objects i created for each material that
is processed in the plant. When the processing is completed, the object is removed.

<h2>SystemVolume
The system volume is a dynamic volume that reside in every node, and that keeps various
system objects.

<h2>DirectoryVolume
The Directoy volume only exists in the development environment. Here the volumes and nodes of
the system are configured.

<h1>Volyme Identity
Each volume has a unic identity, that is written with four numbers, separated with points,
e.g. "_V0.3.4.23". The prefix _V states that it is a volume identity. To verify that the volume
identities are unic, there is a global volumelist that contains all volumes. Before creating
a project, the volumes of the project should be registred in the volume list.
</topic>

<topic> attribute
Attribute
The quantity of data for an object is divided into attributes. Each attribut has a name and a
type. Here follows a description of the most common attribute types.

<h2>Boolean
Digital attributes are of type boolean. The value can be true (1) or false (0).

<h2>Float32
Analogue attributes are of type Float32, i.e. a 32-bit float.

<h2>Int32
Integer attributes are usually of type Int32, i.e. a 32-bit integer. There are also a number
of other integer types, e.g. Int8, Int16, UInt8 and UInt16.

<h2>String
In a string attribute a character string is stored. There are different string types with
variuos length, e.g. String8, String16, String40, String80, String256.

<h2>Time
Time contains an absolute time, e.g. 1-MAR-2005 12:35:00.00.

<h2>DeltaTime
DeltaTime contains an delta time, e.g. 1:12:22.13 (1 hour, 12 minutes, 22.13 seconds).

<h2>Enum
Enum is an enumeration type, used to chose one alternative of several alternatives.
It can be assigned one integer value, in a serie of integer values, where each value is 
associated with a name. There are, for example, the enumeration ParityEnum which kan have the
values 0 (None), 1 (Odd) or 2 (Even).
Enum is a basic type and ParityEnum is a derived type.

<h2>Mask
Mask is used when to choose one, or several, of a number of alternatives. The alternatives
are represented by the bits in a 32-bit integer.

An attribute can also consist of a more complex datastructure. It can be an array with a 
specified number of elements, and it may also be another object, a so called attribute object.
</topic>

<topic>class
Class

A Class is a description of how an object that is a member of the class shall look like. An
object that belong to the class is called an intance. The class defines how the data of the
instances are structured in attributes of various type, or the graphic representation of objects
in the PLCeditor or in the operator environment.

Each class has a template object, i.e. an instance of the class that contains default values
for the attributes of the class.

Proview's basesystem conatins about 500 classes. See Object Reference Manaual detailed
description. The designer can also create his own classes within a project.
</topic>

<topic>object_tree
Object Tree
The object in a volums are ordered in a tree structure. In the volume there is one, or several
top objects, each top object can have one or several children, which can have children etc.
You usually talk about the relations between objects in the tree in terms as parent, sibling,
child, ancestor and descendants.
</topic>

<topic>object_name
Object Name

Each object has a name that is unic whithin its siblinghood. The object also has a path name
that is unic within the world. The pathname includes, besides the object name, the volume
name and the name of all the ancestors, e.g 

<c>VolTrafficCross1:TrafficCross1-ControlSignals-Reset

If you want to be more specific, and point out an attribute in an object, you add the attribute
name to the object name with a point between, e.g.

<c>VolTrafficCross1:TrafficCross1-ControlSignals-Reset.ActualValue

Also an attribute can have several segments, since an attribute can consist of an object. The
attribute name segments are separated by points, e.g

<c>VolTrafficCross1:Hydr-Valve.OpenSw.ActualValue
</topic>

<topic>mounting
Mounting

An operator station has to display values of signals and attributes that reside in the volumes
of process stations. This is achieved by a mechanism, where an operator station mounts the 
volumes of the process stations, in its own object tree. A mounting means that you hang an
object tree of another volume in the own rootvolume. Where in the tree the volumes is hanged,
is configured wiht a MountObject object. In the MountObject states, which object in the other
volumes that is mounted. The result is, that the MountObject is displayed as the mounted object,
with the objecttree beneath is. It apparently looks as if the objects belong to the own root
volume, while they in reality reside in another node.

If you use subvolumes, they also have to be mounted in a root volume, to make the objects
available.

When you choose mounting points and names of mounting points, it is suitable to do this in a
way, that the objects have the same pathname in both volumes.
</topic>

<topic>object_identity
Objekt Identity
An object has an identity that is unic. It consits of the volume identity, and an object index
that is unic within the volume. An object identity is written for example "_O0.3.4.23:34" where
0.3.4.23 is the volume identity, and 34 the object index. The prefix _O states that it is an
object identity.
</topic>
</chapter>

<chapter>
<topic>development environment
Development environment

The configuration of a Proview system is done in a development station. The Proview development
enviroment is installed in the development station.
</topic>
</chapter>

<chapter>
<topic>case_study
A Case Stydy

<option> printdisable
Specification of I/O<link>io_specification
Administration <link> administration
Plant Configuration <link> plant_configuration
Node Configuration <link> node_configuration
PLC program <link> plcprogram
Plant Graphics <link> process_graphics

<option> printenable
In this chapter we will give you an idea of how a Proview system is created. The process to 
control in this case study is very simple - an intersection with four traffic lights - but it
will give you an idea of the steps you have to go through when creating a Proview system.

The traffic lights should be able to operate in two different modes:

  - Normal: The traffic lights run normal cycle of red, yellow and green.
  - Flash: The traffic lights are flashing yellow.

<image> dg_fig1.gif
<b>Traffic lights in an Intersecion

The operating mode of the traffic lights is decided by an operator at via operator station, or 
by a maintenance technician, who influences a switch. The maintenance technician can change 
mode, only if the operator have switched the traffic lights to service mode. 

Figure 'Traffic Lights, Control Panels' shows the different switches and indicators needed by 
the operator and maintenance technician respectively, to be able to monitor and control the 
system. These could be realized with plant graphics on the operator station or with hardware. 

<image> dg_fig2.gif
<b>Traffic Lights, Control Panels
</topic>

<topic> io_specification
Specification of I/O
We start with analysing the task to decide what hardware to use. 

<h2>Digital Outputs
We have four traffic lights, but the traffic lights in the same street can be connected in 
parallel, which means that we can treat them as two lights. 

Three outputs per light: 2 × 3 = 6
Indication: Operating mode 1
Indication: Control 1
----------------------------------
Total number of digital outputs: 8 


<h2>Digital Inputs
The only digital input needed is for the maintenance technician's switch. The operator controls
the process from the computer display, and this requires no physical signals. 

Switch: Operating mode 1
---------------------------------
Total number of digital inputs: 1 

Den enda digitala ingång som behövs är för underhållsteknikerns vred. Operatören styr 

<h2>Analog I/O 
No analog in- or outputs are needed for this task. 

<h2>Specification of the Process Station 
When we have decided upon the I/O needed, we can choose the hardware. We choose: 

1 Linux PC with rack.
1 card with 16 digital inputs.
1 card with 16 digital outputs. 

<h2>Specification of the Operator Station 
1 Linux PC.

<h2>Specification of Plant Graphics 
We need a display from which the operator can control and survey the traffic lights. 

</topic>

<topic> administration
Administration

First we have to register a new volume, create a project, and, if necessary, create new users.
For this we need

- A name for the project. We call it trafficcross1.
- Two volumes, one for the process station and one for the operator station.
- We need three users: one developer, one operator and one maintenance technician.

Volumes, projects and users are registred and created in the administrator tool.

<h2>Register volume
For this project, we need two volumes, one for the process station, and one for the operator
station. They are root volumes so we can choose an idle volume identity in the intervall
0.1-254.1-254.1-254. We choose 0.1.1.1 to the operator station and 0.1.1.2 to the process
station, and enter the volume mode in the administator to register these volumes.

<image> dg_fig11.gif
<b>Volume registration

<h2>Create users
Eric is a developer in the traffec department, an Carl is an operator. They are both involved
in all the projects at the traffic department, so we create a common systemgroup for all the
projects and let them share users. We grant Eric developer and system privileges, Carl
operator privileges and Lisa maintenance privileges.

<image> dg_fig4.gif
<b>Created users

<h2>Create Project
We create the project with the hierarchy name 'trafiic-trafficcross1'.

<image> dg_fig10.gif
<b>Created project

<h1>Configure the project
The project has a directory volume in which the nodes and volumes of the project are configured.
In the upper window the volumes are configured with RootVolumeConfig objects. In the lower
window the process and the operator station are configured with NodeConfig objects. The
NodeConfig objects is put beneath a BusConfig object that states in which QCOM bus the nodes are
communicating. 

The NodeConfig objects contains

- Nodename
- ip adress of the node

Below each NodeConfig object there is a RootVolumeLoad object that states the volume to load
at runtime startup.

Note also the system object with the attribute SystemGroup that is assigned the value
'trafficdepartment'. This grants the users eric, carl and lisa access to the project.

<image>dg_fig5.gif
<b>The Directory Voluem
</topic>

<topic> plant_configuration
Plant Configuration
Once the configuring of the project is done, next step is to configure the plant. The 
configuration is done in the Configuration Editor. The plant is a logical description of the 
reality, which is to be controlled and supervised. 

The plant is structured hierarchically. Examples of levels in the plant can be plant, process, process part, component, and signal. These are the logical signals represented by signal objects which will be connected to physical channels. 


<h2>The Process Station
Den största delen av konfigureringen görs i processtationens volym, VolTrafficCross1. Det
är ju här som all kort, kanaler, signaler och PLC program ska konfigureras.

The plant is structured hierarchically. Examples of levels in the plant can be plant, process, 
process part, component, and signal. These are the logical signals represented by signal 
objects which will be connected to physical channels. 

Sometimes it can be difficult to configure each signal in an initial stage, but it must at any 
rate be decided how possible signals shall be grouped. 

The figure below illustrates how a plant has been configured. We see how signals have been 
configured on different levels, and even how the PLC programs are configured in the plant. 

<image> dg_fig3.gif
<b>An Example of a Plant Configuration

We choose to call our plant TrafficCross1 and we decide on the following structure: 

- Two traffic lights, each one consisting of a green, a yellow, and a red lamp. Since the 
  streets run north-south and west-east respectively, we call them TrafficLightNS and 
  TrafficLightWE. Each lamp requires a signal. These are digital output signals and are 
  called RedNS, RedWE, etc. 

- A PLC program to control the traffic lights. 

- A number of control signals to select operating mode and function. We choose to put them in 
  one folder, ControlSignals. The table below shows the signals required. 

Figure shows the resulting Plant Configuration. 

We choose to call our plant TrafficCross1 and decide the following structure:

<b>Signal Name <t>Signal Type <t>Function 
 
ServiceSwitch  <t>Di <t>A switch which the maintenance technician can influence to
               <t>   <t>change the operating mode. 
OperatorSwitch <t>Di <t>A value which the operator can influence to change the operating 
               <t>   <t>mode. 
ServiceMode    <t>Di <t>A value which the operator can influence to change the function 
               <t>   <t>to service mode. 
ServiceModeInd <t>Do <t>A signal which shows the maintenance technician that the program 
               <t>   <t>is in service mode.  
Mode           <t>Dv <t>Indicates whether the program is in normal or flashing mode. 
ModeInd        <t>Do <t>Indicates whether the program is in normal or flashing mode. 
Reset          <t>Dv <t>A value which is used to reset the program to initial mode. 

<bookmark> plant_example
<image> dg_fig6.gif
<b>The Plant Configuration of the Intersection

As you can see we have a plant object at the topmost level, TrafficCross1 of the class 
$PlantHier. We use other objects of class $PlantHier to group our objects. We also create an 
object, which defines a PLC program, the ControlPgm object of the class PlcPgm . 

<h2>The Operator Station
The configuration of the operator station is performed in the volume VolOpTrafficCross1. In the
Plant side there is only a mount object, that makes the plant hierarchy of the process node
available in the operator station. We have mounted the topmost $PlantHier object, 
'TrafficCross1' with a MountObject with the same name.

<image> dg_fig14.gif
<b>The Plant Configuration in the operator volume.
</topic>

<topic> node_configuration
Node Configration

When you have configured the plant, continue to configure the nodes.

<h2>Processtation
In this example we choose to start configuring the process station. We name the process station
"cross1". It is advisable to give the process stations descriptive names. In the node 
hierarchy we create a $NodeHier object 'Nodes' and below, a $Node object 'cross1' that 
configures the node.

In the analysis phase we decided that the process station should consist of the following 
hardware: 

- 1 Linux PC
- 1 rack with 16 slots
- 1 card with 16 digital inputs (Di channels).
- 1 card with 16 digital outputs (Do channels).

The rack and the cards are configured in a manner much like what you would do physically. You 
have a node, place the rack in the node, the card in the rack, and the channels on each card. 

<image> dg_fig7.gif
<b>Node Configuration of the Process Station

We also configure the PLC program with a PlcProcess object, and below this, a  PlcThread object
for each time base. We are content with one 100 ms timebase.

<image> dg_fig12.gif
<b>Timebase configuration of the PLC program

Each object has a number of attributes that you may have to change. To give an understanding of
how to change attributes, some of the attributes in the PlcProcess object are edited below.

<image> dg_fig13.gif
<b>Change of Attribute Value

<h2>Operator Station
The node hierarchy of the operator station is configured in the volume VolOpTrafficCross1. 
Below the node object we find an OpPlace object that defines the operator place, and below
this a User object that defines a user. Below the OpPlace object there is also a XttGraph object
for the process graph of the operator station.

<image> dg_fig8.gif
<b>The Node Configuration i the Operator Volume.

<h1> Connecting channels to signals
When you have configured the plant and the nodes, it is time to connect the logical signals to 
the physical channels. Each logical signal in the Plant Configuration must be connected to one 
channel in the Node Configuration; a Di to a ChanDi, a Do to a ChanDo, an Ai to a ChanAi and 
an Ao to a ChanAo , etc. 

You can se the connection as a representation of the copper cable between the components in the 
plant, and the channel in the I/O rack. In the figure below there is a cable between the switch
and channel 0 in the Di-card. As the Di-signal SeviceSwitch is representing the switch and
Di-channel Di4-00 is representing the channel, we have to make a connection between these two
objects.

<image> dg_fig15.gif
<b>Connection between a signal and a channel

<image> dg_fig9.gif
<b>Connect a signal to a channel
</topic>

<topic>plcprogram
PLC program
We use the Graphical PLC Editor to create PLC programs. 

However we must first connect the PlcPgm object to a PlcThread object in the node hierarchy.
This states which timebase the PLC programm is executed on.

<image> dg_fig16.gif
<b>The Graphical PLC Editor

We will use the PLC Editor to create a sequential control program for the traffic lights. There
are two ways to solve the problem concerning the two operating modes for a traffic light, 
normal and flash: 

1. Use one Grafcet sequence with conditional branches, i.e. one branch for the normal operating
   mode sequence and one for the flash operating mode sequence. 
2. Use two separate Grafcet sequences with different start conditions. 

Here we choose to use the second alternative. In chapter 4, Graphical PLC Programming a more 
detailed description of Grafcet and sequential control can be found. 

Grafcet programs are based on activating and deactivating a number of steps in sequence. In 
linear sequences only one step at a time can be active. To each step you tie a number of orders
that are to be executed when the step is active. This can be e.g. to set (with a StoDo object) 
a digital output signal, which turns on a lamp. The PLC programs thus control the logical 
signals. 


<image>dg_fig17.gif
<b>The Flashing Light Sequence 

This is the sequence that will be executed when you want the lights to flash yellow. 

The start condition for this sequence is inverted in relation to the start condition for the 
normal operating mode sequence. This implies that the two sequences cannot execute at the same 
time. 

<image>dg_fig18.gif
<b>The Normal Sequence 

The program for the normal operating mode is based on a traffic light following the sequence: 

<b>   <t>North-South <t>West-East
1     <t>Red         <t>Red
2     <t>Red, Yellow <t>Red
3     <t>Grön        <t>Red
4     <t>Yellow, Green <t>Red
5     <t>Red         <t>Red
6     <t>Red         <t>Red, Yellow
7     <t>Red         <t>Green
8     <t>Red         <t>Yellow, Green
9     <t>Back to step 1

The program starts in the initial step. If the start condition is fulfilled, step S1 will 
become active and the red lamps are turned on. After a certain time, step S1 will become 
inactive and step S2 will become active, and a yellow lamp will also be turned on, and so on. 
When step S8 has been active for a certain time, it will be deactivated, and the initial step 
is once again activated. 

<image> dg_fig19.gif
<b>Trigger Signals

The program above shows the logic that controls different operating modes. 

At the very top to the right you set the Dv signal "Mode". If this is set to a logical 1, the 
sequence for the light's normal operating mode will be run, otherwise the sequence for flashing
lights will be run. 

The Dv signal "Reset" will be set to a logical 1 during one execution cycle when the signal 
Mode changes value. This implies that the two Grafcet sequences will return to the initial 
step. The chosen sequence will be executed again when Reset is set to a logical 0. 

The PLC programs you have created must be compiled before they can be executed on a process 
station. 
</topic>

<topic> process_graphics
Plant Graphics 

Plant graphics are often used as an interface between the operator and the process. Plant 
graphics are created with the Plant Graphics Editor. 

<image> dg_fig20.gif
<b>The Plant Graphics Edtitor

Plant graphics can contain dynamics, which are connected to the logical signals, e.g.: 

- Text that becomes visible when a signal reaches a certain value 
- Graphical objects that change color when a signal reaches a certain value 
- Graphical objects that become invisible when a signal reaches a certain value 
- Graphical objects that move depending on the value of a signal 

You can also place push buttons in the plant graphics, which the operator can use for changing 
values of digital signals. To change analog signals you use an input entry field. 

In our example we choose to make a plant graphics, showing a road crossing, where the traffic 
lights (red, yellow, and green) are dynamic as shown in figure. How to create the plant 
graphics is described in chapter 5 Creating Plant Graphics . 

<image>dg_fig21.gif
<b>The Plant Graphics for the Intersection
</topic>
</chapter>

<chapter>
<topic>administrator
Administration

<option> printdisable
Create users <link> adm_user
Register volumes <link> register_volumes
Create project <link> create_project
<option> printenable
</topic>

<topic> adm_user
Users

To gain access to the Proview development and runtime environment you need to login with 
username and password. Users are kept in the user database and are granted privileges which 
states the users authority to make changes in the system.

Systems that share the same users are grouped into a system group, and the the users for this 
group is defined. You can also build a hierarchy of system groups where child groups inherit 
the users of their parent, and additional users can be defined for each child.

A system is connected to a systemgroup by the SystemGroup attribute in the $System object. 
The notation for a system group in a hierarchy is the names of the group separated by a point, 
for example 'Main.West.F1.

In the example below Eric is responsible for all the systems in the plant, and is defined on 
the highest level in the hierarchy. Nils is working with the west side of the plant and is 
defined on the 'West system group. Finally, Carl working with the systems in the F1 part of 
the plant. All system groups has the attribute UserInherit, that states that a child group
inherits all the users of the parent.
 

<image> dg_fig22.gif

Users and systemgroups are created in the administrator:

- Start the administrator with the command 'pwra'
- Enter the UserDatabase from the menu 'File/Open/UserDatabase'.
- Login by entering the login command. Open the login prompt from the menu 'Functions/Command'
  and enter 'login /adm on the command line. If the systemgroup 'administrator is presen
  you also has to add username and password to a user defined in the administrator systemgroup.
- Enter edit mode from the menu 'Edit/Edit mode'.
  Systemgroups and users are represented by object of the classes SystemGroupReg and
  UserReg, that are displayed in the palette to the left. An object is created by selecting
  a class in the palette. After that, you click with the middle mousebutton on the future 
  sibling or parent to the new object. If you click on the map/leaf in the destination object, 
  the new object is placed as the first child, if you click to the right of the map/leaf, 
  it is placed as a sibling.
- Create a systemgroup by selecting 'SystemGroupReg' in the palette, and click with MB2
  (the middle mousebutton) in the right window. Open the SystemGroupReg object and enter
  name ant attribute for the system group. Enter the complete hierarchy name, e.g. 
  'Main.West'.
- Create a user by selecting 'UserReg' in the palette and click with MB2 on the map/leaf
  of the SystemGroupReg object that the UserReg should be a child of. Open the object and
  enter username, password and privileges for the user.
- Save.
- Logout with the command 'logout'.


The user database reside in the directory $pwra_db.

</topic>

<topic>register_volumes
Register Volumes

All volumes in a network has to have a unique volumname and volume identity. To assure this, 
all volumes is registered in a global volume.

The registration is done by the administrator:

- Start the administrator with the command 'pwra
- Enter volume mode from the menu 'File/Open/GlobalVolumeList'.
- Login as administartor.
- Enter edit mode from the menu 'Edit/Edit mode'.
  Volumes are registred by objects of class VolumeReg, that is dislayed in the palette to
  the left. In the palette, there is also the $Hier class, that can be used to order the
  VolumeReg objects in a tree structure.
- Create a VolumeReg object, open the object and enter volumename (equals objectname),
  volumeidentity and project.  
- Save.
- Logout with the command 'logout'.

<h2>Volume name
The name of the volume, a unic name with max 31 characters.

<h2>Volume Identity
The volume identity is a 32 bit word specified in the form v1.v2.v3.v4 where v1, v2, v3 and v4 
are numbers in the interval 0-255. Dependent on the class of the volume, the numbers can be 
chosen in separate intervals. 

RootVolumes            <t>0. 1-254. 1-254. 1-254
User ClassVolumes      <t>0. 0. 2-254. 1-254

The DirectoryVolume always has the identity 254.254.254.253
</topic>

<topic>create_project
Create project

A project is a number of nodes and volumes that share the same development environment. Usually
it consist of some process stations and a couple of operators stations that control a part of 
the plant, but there are no restrictions in the size of a project. You can choose to have each 
node in its own project or all the nodes in the same project.

- All the nodes in a project (on the same bus) has a nethandler link between each other.
- All the volumes and nodes share the same directory tree.
- All node has to be upgraded to new Proview versions at the same time.

A common size is 1-10 nodes in a project. Too many nodes will increase the communication 
overhead and make it harder to upgrade the project.

Create the project in the administrator:

- Start the administrator with the command 'pwra.
- The projectlist is shown as default when starting the administrator. It can also be opened
  from the menu (File/Open/ProjectList).
- Login as administrator.
- Enter edit mode from the menu 'Edit/Edit mode'.
  Projects are represented by objects of class ProjectReg, that is displayed in the palette
  to the left. $Hier objects can be used to order the ProjectReg objects in a tree structure.
- Create a ProjectReg object and enter project name, base version, path and description.
- The project is created when saving. First you have to confirm the changes.
- Save and logout.

<h2>Project name
A project has a project name that identifies the project in the development environment. It is 
similar the system name that identifies the project in the runtime environment, but it 
doesnt have to be the same. Actually a system can have several projects in the development 
environment. When upgrading or making a major modification of the system, it is advisable to 
take a copy of the project and keep the currently running version of the system available for 
minor corrections. The copy is then created under a new project name, though it has the same 
system name.

<h2>Base
Proview is a multiversion system, i.e. different versions of proview can be installed in 
the same development environment and projects of different proview versions can coexist in 
the same development environment. A project points at a Proview base, e.g. V3.4, V4.0, and 
when creating a project you have to choose which base the project should point at.

<h2>Path
The project consist of a directory tree where databases, source files, archives etc is stored. 
The path is the root directory of this tree.

</topic>
</chapter>

<chapter>
<topic>configure_directoryvolume
Directory Volume Configuration

<h1>Open a project
When the project is created, it is found in the administrator project tree. You open a project 
by activating 'Open Project' in the popupmenu for a ProjectReg object. The workbench is now 
opened for the project, and the Volume selection window is displayed, showing all the volumes 
in the project. So far, only the DirectoryVolume is created, and our first task is to configure 
this volume, with the volumes and nodes of the system.

Select the DirectoryVolume and click on the Ok button to open the configuration editor for the 
volume. 

<image> dg_fig23.gif

You can also create a project with a shell command. You tie to the project with the commmand

> pwrp set project 'projektname'

The Workbench is opened with the command

> wb

wb takes user, password and volume as arguments.

<h2>The Configuration Editor

The configuration editor displays two windows, and for the DirectoryVolume, the upper shows 
the volume configuration, and the lower the node configuration. 

<h2>Configure Volumes
First we configure all the root volumes, sub volumes and class volumes in the project. This
i done in the volume window in the directory volume. We start by creating a RootVolumeConfig
object the configures a root volume.

- Enter the edit mode from the menu 'Edit/Edit mode'. Now the palette is visible to the right 
  in the window, and maps can be opened with a click on the map symbol or a double click on 
  the text. 
- Open the Volume map and select the 'RootVolumeConfig' class.
- Click with MB2 in the volume configuration window, and the object is created.
- Select the object and open the object editor from the menu 'Functions/Open Object'.
- Select ObjectName and activate 'Functions/Change value' in the object editor menu.
- Enter the name of the object. The name should be the same as the name of the volume.
- Close the object editor.

Create the RootVolumeConfig objects for the other rootvolumes of the project. For the following
objects you can control the position of the object. If you click with MB2 on the object name of
an object, the new object will be a sibling to this object. If you click on the leaf or map 
symbol, the object will be a child.

Also subvolumes and classvolumes is configured in a similar way with SubVolumeConfig and
ClassVolumeConfig objects.

It is also possible to display the attributes of an object directly in the configuration editor:

- Press Shift and click MB1 on the object to open the object
- Select an attribute and activate Functions/Change value to modify a value.

<h2>Configure the nodes

In the lower window, the nodes in the project is configured. You group the nodes by which
QCOM bus they communicate on. We create two BusConfig objects, one for the produktion nodes
and one for simutation. In the BusNumber attribute the busnumber is defined.

As children to the BusConfig object, the NodeConfig objects are created, one for each process
and operator station. When the NodeConfig objects are created, some additional objects are
created

- a RootVolumeLoad objects, that states the rootvolume to load when the runtime environment is
  started on this node. The name of the object should be equal to the name of the root volume.
- a Distribute object that configures which files are copied from the development environment
  to the process or operator station.

Open the NodeConfig object an enter nodename, operating system and ip address.

Below the BusConfig object for the simulation bus, it is suitable to place a NodeConfig object
for the development station, and below this, a RootVolumeLoad that states the volume of the
process station you are going to work with first. In this way you can start the volume in 
runtime and test it on the development environment. State the name, operating system and
ip address of the development station in the NodeConfig object.

<b>System object
Create also a $System object in the node configuration window. The system object has the 
attributes SystemName and SystemGroup.

- The system name in this state, often is equal to the project name.
- The system group attribute makes the system a member of a system group in the user database, 
  which defines the users for the system. Once the system object is created you have to state 
  a valid username and password when entering the workbench.

<b>Save
Save the session from the menu 'File/Save'. If the configuration passes the syntax check, you 
will receive a question if you want to create the configured volumes. Answer Ok to these 
questions and create the volumes.

If the volume selection window is opened now, 'File/Open' in the menu, all the configured 
volumes are displayed. The next step is to configure a RootVolume.
</topic>

<topic>configure_rootvolume
Configure a Root Volume
A root volume is opened from the volume selection window. Select the volume and click on the 
Ok button. This will start the configration editor for the root volume. As for the 
DirectoryVolume it is separated in two windows, but this time, the upper window shows the 
plant configuration and the lower the node configuration.

<h1>Plant Configuration
The Plant Configuration describes the different plants which you can find in the Proview 
system. A plant is a logical description of e.g. a production process, functions, equipment, 
that is to be controlled, supervised, etc. 
Se an example of a plant configuration <link>plant_configuration, plant_example

<h2>$PlantHier Object
The top object in the plant hierarchy is the $PlantHier object. This object identifies the 
plant or parts of it. 
 
The $PlantHier object is used to group objects and to structure the plant. This object can, 
for instance, be used to group signal objects. 

<h2>Signal Objects
The signal objects define logical signals, or points, representing a quantity or value 
somewhere in the process; whereas contrast to the channel objects, which define physical 
signals. The signal objects are generic, i.e. they can be used with any I/O-system. 

There are some classes of signals that cannot be connected to hardware signal, i.e. the Dv, 
Iv, Av and Sv objects (DigitalValue, IntegerValue, AnalogValue and StringValue). These objects 
are used to store a logical values, integer value, real numbers and strings respectively. 

The actual value of the signal is defined by the attribute ActualValue. 

At present the following signal objects are available: 

Ai <t>Analog input.
Ao <t>Analog outupt.
Av <t>Analogt value.
Ii <t>Integer input.
Io <t>Integer output.
Iv <t>Integer value.
Di <t>Digital input.
Do <t>Digital output.
Po <t>Pulsed digital output.
Dv <t>Digital value.
Co <t>Counter input.
Sv <t>String value.

Note! The PLC program can read signals placed on remote nodes, but cannot write to them.

<h2>PlcPgm Object
The PlcPgm object defines a PLC program. It is possible to have several PLC programs in a 
plant. The following attribute must be given a value: 

- ThreadObject indicates the plc thread where the program is executed. It references a 
  PlcThread object in the node configuration.
- If the program contains a GRAFCET sequence, the ResetObject must be given. This is a Dv, Di 
  or Do that reset the sequence to its initial state.

<bookmark> backup_object 
<h2>Backup Object
The Backup object is used to point out the object or attribute, for which the backup will be 
made. It is also indicated whether storing will take place with fast or slow cycle time.

<h2>MountObject
The MountObject mounts an object in another volume. The attribute Object specifies the mounted 
object.

<h1>Node Configuration
The Node Configuration defines the nodes of your PROVIEW/R system. The nodes are named and 
their contents specified. 

<b>Node Configuration
<image> dg_fig44.gif

<h2>$NodeHier Object
The node hierarchy object is used to group objects in the Node Configuration. This object is 
of the $NodeHier class. The object can be used to group for instance $Node objects or XttGraph
objects. 
See $NodeHier i Object Reference Manual <link>nodehier,"",$pwr_lang/pwrs_xtthelp.dat

<h2>$Node
To define the nodes of the system, you use node objects. The node object is of the $Node class.
When the node object is created, a number of server and operator objects are created.

See $Node i Object Reference Manual <link>node,"",$pwr_lang/pwrs_xtthelp.dat

<h2>I/O Objects
The configuration of the I/O system is dependent of which type of I/O system you use. Proview
has a modular I/O that can handle different types of I/O systems: rack and card systems,
distributed bussystems, or systems connected with some network.

The modolar I/O is devided in four levels: agent, rack, card and channel.

<b>Rack and Card System
We will take the PSS9000 as an example of an rack and card I/O. The system consists of analog
and digital input and output cards that i mounted i racks. The rack i connected via a bus
cable to a busconvertercard in the computor, that converts the PSS9000 bus to the computors
PCI bus.

In this case, the agent level is not used, so the $Node object works as an agent. The rack
level is configured with SSAB_Rack objects that is placed below the $Node object, one for
each rack in the system. The cards are configured with objects below the rack object, that is 
specific for different kind of IO cards. For PSS9000 there are card objects like Ai_Ai32uP,
Ao_Ao4uP, Di_DIX2 and Do_DVDO32. Below a card object, there are placed channel objects, one for
each channel on the card.

Common for the different I/O systems is the channel objects, that defines the input or output
channels of a card or module. There are som different types of channels.

ChanDi <t>Digital input.
ChanDo <t>Digital output.
ChanAi <t>Analog input.
ChanAit <t>Analog input with conversion of the signalvalue from a table.
ChanAo <t>Analog output.
ChanIi <t>Integer input.
ChanIo <t>Integer output.
ChanCo <t>Counter input.

<b>I/O configuration
<image> dg_fig43.gif

<b>Distributed I/O
As an example of distributed I/O we choose profibus. In this case, all the four levels is used.
In the PCI bus of the computor, there is a mastercard the communicates with a number of slaves
on the profibus circuit. The mastercard is configured with a Pb_Profiboard card on the agent
level. Below this, we find the different slaves configured with Pb_DP_Slave objects. They
represent the rack level. Below the slave objects there are module objects of type Pb_Ai,
Pb_Ao, Pb_Di, Pb_Do etc, that are placed on the card level. Below the module objects finally,
the channels are configured with the channel objects ChanDi, ChanDo etc.

<b>Process and thread for I/O objects
I/O objects of the card level, often contains the attributes Process and ThreadObject. In 
Process which process to handle the card is defined.

The card can be handled by the PLC program, that is, reading and writing is made syncroized
with the execution of the PLC. You can also specify a thread in the PLC that should handle the
card, i.e. which timebase is used to read or write the card (the PlcThread attribute).

The card can also be handled by the rt_io process, that usually has a lower priority then the
PLC, and that is not syncronized with the PLC. Certain types of analog inputcards that takes
some time to read, are with advantage handled by this process.

You can also write an application that handles reading and writing of cards. There are an
API to initiate, read and write the cards. This is useful if the reading and writing of a 
card has to be syncronized with the application.

<h2>MessageHandler Object
The MessageHandler object configures the server process rt_emon, that handles the supervision
objects (DSup, ASup, CycleSup). When an event is detected by the server, a message is sent
to the outunits that has has interesst of this specific event.

In the object indicates, for example the number of events that is stored in the node. The object
is automatically create below a $Node object.
See MessageHandler i Object Reference Manual <link>messagehandler,"",$pwr_lang/pwrb_xtthelp.dat

<h2>IOHandler objekt
IOHandler configures properties for the I/O handling.

- ReadWriteFlag specifies whether to adress physical hardware or not.
- IOSimulFlag indicates wether to use the hardware or not.
- The timebase for the rt_io process, i.e. the process that handles slower types of I/O cards
  that are not suitable to be handled by the PLC.

In the production system for a process station, ReadWriteFlag is set to 1 and IOSimulFlag is
set to 0. If you want to simulate the process station, for example on the development station, 
ReadWriteFlag is set to 0 and IOSimulFlag is set to 1.

The IOHandler object is created automatically, when creating a $Node object.
See IOHandler i Object Reference Manual <link>iohandler,"",$pwr_lang/pwrb_xtthelp.dat

<h2>Backup_Conf Object - Configuration Object for Backup 
Sometimes it may be desirable to have a backup of a number of objects in your system. In that 
case you place a backup configuration object, Backup_Conf, under the node object. The backup 
is carried out with two different cycles, one fast cycle and one slow. 

In order to indicate which objects/attributes that should be backed up you use backup objects.
See description of the Backup object <link> configure_rootvolume, backup_object
See Backup_Conf in Object Reference Manual <link>backup_conf,"",$pwr_lang/pwrb_xtthelp.dat

<h2>Operator Place Object
To define an operator place you place an object of the OpPlace class under the $Node object.
 
The following attributes must be given values: 

- OpNumber indicates the number of the operator place. Every operator place in the node
  should be allocated a unique integer. 

See OpPlace i Object Reference Manual <link>opplace,"",$pwr_lang/pwrb_xtthelp.dat

<h2>User Object
For each operator place you must define an out unit of the user type (operator). To do this 
you use a User object. You can only have one user per operator place. User objects should
also be defined for RttConfig and WebHandler objects.
	
The following attributes must be given values: 
	
- UserName indicates the name of the user. 
- OpNumber must have the same number as the operator place. 
- MaxNoOfEvents indicates the number of events which the operator's event list can hold at 
  the same time.
- SelectList indicates the object hierarchies in the Plant Configuration, from which the
   operator will be receiving events.

If we look at the figure above, which illustrates the plant A, and assume that we want to 
receive events only from the encircled objects, we state 'A-C' as an alternative in the 
select list. This choice means that we will be receiving events from the supervised object C, 
and from all supervised objects, which have C as their parent.

<b>SelectList example 1
<image> dg_fig41.gif

Another example:

We look at the figure below, which illustrates the plant TrafficCross1. If you want to receive 
all events from the plant TrafficCross1, you state TrafficCross1 as an alternative. 
TrafficCross1 handles two traffic lights, TrafficLightNS and TrafficLightWE. Let us say that 
we want events only from TrafficLightNS. In that case we state 'TrafficCross1-TrafficLightNS'
instead of TrafficCross1.

<b>Selectlist example 2
<image> dg_fig42.gif

If you want to receive messages from the CycleSup object the supervises the plc threads, you 
must also state the hierarchy name of the $Node object.

In FastAvail you specify the complete hierarchy name of the XttGraph object, which will be 
possible to start from the graphics buttons of the Operator Window  NoFastAvail specifies 
the number of graphics buttons to be used. You can have 0- 15 push buttons. Buttons which are 
not used become invisible.

See User i Object Reference Manual <link>user,"",$pwr_lang/pwrb_xtthelp.dat

<b>Operator Window
<image> dg_fig45.gif

<h2>The Plant Graphics Object - the XttGraph Object 
In order to be able to show plant graphics which are unique to the project in the operator 
station, you must configure XttGraph objects. These objects define, for instance, what the 
files with the plant graphics are called. The objects are refered to in the User object
FastAvail attribute, and in the DefGraph attribute that is found in $PlantHier and signal
objects.

When the object is refered in a FastAvail you can use the possibility to execute a Xtt command
from the XttGraph object. In this way, you can set a signal from a pushbutton in the opeator
window.

- Action. States a Ge graph to open, or an Xtt command to execute.

See XttGraph in Object Reference Manual <link>xttgraph,"",$pwr_lang/pwrb_xtthelp.dat
</topic>
</chapter>

<chapter>
<topic>plc_programming
Graphical PLC Programming 
	 
This chapter describes how you create PLC programs. 

<h1>The Editor
You enter the plc editor from a PlcPgm object in the plant configuration. Select the object 
and activate 'Functions/Open Program' in the menu. The first time the program is opened, you 
will find an empty document object. The program consist functions blocks and Grafcet sequences.

Programming with function block is made in a horizontal net of nodes and connections from left 
to right in the document. Signals or attributes are fetched on the left side of the net, and 
the values are transferred via connections from output pins to input pins of functions blocks. 
The function blocks operate on the values, and on the left side of the net, the values are 
stored in signals or attributes.
	
Grafcet sequences consist of a vertical net of nodes and connections. A state is transferred 
between the steps in the sequence via the connections. Grafcet and function block nets can 
interact with each other and be combined to one net.




<h2>Edit function objects

The plc editor consists of 
- a working area.
- a palette with grafcet objects and function blocks, and a palette with connections.
- a navigation window, from which the work area can be scrolled and zoomed.

<b>The Plc editor
<image> dg_fig46.gif

A function object is created by selecting a class in the palette, and pressing MB2 in the 
working area. 

<h2>Modify the object
The objects is modified from the object editor. This is opened by selecting the object and 
activate 'Functions/Open Objects' in the menu. Values of the object attributes is modified 
with 'Functions/Change value' in the object editor menu. If an input or output is not used it 
can be removed with a checkbox. There is also a checkbox which states that the value of a 
digital input should be inverted.

<h2>Connect function objects
A output pin and a input pin is connected by

- Place the cursor on the pin, or in an area in the function object close to the pin, and 
  press MB2.
- Drag the cursor to the other pin, or to an area in the function object close to the pin, and 
  release MB2.

A connection is now created between the function objects.

<h2>Fetch a signal value
The value of a Di signal is fetched with a GetDi object. The GetDi object has to point at a 
Di signal and this is done by selecting the signal in the plant configuration, and then press 
Ctrl and double click on the GetDi object. The name of the signal is now displayed in the 
drawing. Dv signals, Do signals and attributes are fetched in the same way, with GetDv, GetDo 
and  GetDp objects.

<h2>Store a value to a signal
The value of an output from a function object is stored in Do signal with a StoDo objects. 
The StoDo object is connected to a Do signal in the same way as the Get objects. Dv signals 
and attributes are stored with StoDv and StoDp objects.

<h1>Grafcet Basics
This section gives a brief introduction to Grafcet. For a more detailed description, please 
read a reference manual on Grafcet. Grafcet is an international norm or method to use at 
sequential control. 

Grafcet consists of a number of steps, and to each step one or more orders are connected, which
will be executed when the step is active. In order to move from one step to another, a 
transition is used. For each transition you have transition conditions, and the move can only 
take place when the transition conditions have been fulfilled. 

<b>Single Straight Sequence 
We look at the single sequence below and assume that the step is active, which means that the 
order connected with the initial step will be carried out. This order will be carried out, 
until the initial step becomes inactive. Step 1 becomes active, when the transition condition 
for transition 1 has been fulfilled. Then the initial step becomes inactive. 

A Grafcet program is always a closed sequence. 

<b>A Simple Straight Grafcet Sequence
<image> dg_fig47.gif

<h2>Förgrenad sekvens

A straight sequence is the most simple variant of sequences. Sometimes you may require 
alternative branches in your program, for instance when you have a machine, which can 
manufacture three different products. At the points where the production differs, you introduce
alternative branches.

<b>Sequece Selection
<image> dg_fig48.gif

The example in the figure above shows the sequence for a machine which can manufacture the 
three products, Red, Green, and Blue. At the point of divergence, point 1 in the figure, you
choose the disired branch depending on the product to produce. The alternative branches diverge
from a step, that is followed by one transition condition in each branch. It is the
constructors task to see that only one of the transition conditions is fullfilled. If several
are fullfilled, which one that is selected is undefined. At point 2 in the figure, the branches
are converging to a common step.

<h2>Parallel Sequences
Sometimes it may be necessary to start several parallel working procedures at the same time. 
It must be possible for these working procedures to operate independent of each other. In 
order to do this, parallel sequences are used. 

<b>Parallel Sequences
<image> dg_fig49.gif

The example in the figure above illustrates the sequence for two machines, which are drilling 
two holes at the same time and independent of each other. When the transition condition before
the parallel divergence (point 1 in the figure), is fullfilled, the activity is moved to
both branches, and the machines start drilling. The drilling is preformed independent of each
other.

The branches are converging to a transition condition (point 2 in the figure), and when the
drilling is completed in both machines, i.e. both S12 and S13 are active, and the transition
condition T17 is fullfulled, the activity is moved to the init step IS2.

<h2>Step
<image> dg_fig51.gif

A Step is used to describe a state in the process. The following applies to a step: 

- A step can be active or inactive. 
- An attribute, Order , indicates whether the step is active or not. 
- You can connect one or more orders to a step. 
- The step can be allocated a name at your own discretion. 

<h2>InitStep
<image> dg_fig50.gif

In each sequence you must have an initial step (InitStep) which differs from a usual step 
at the following points: 

- You should only have one initial step in a sequence. 
- When the program starts its execution, the initial step is active. 
- You can always make the initial step active by setting the reset signal. 

<h2>Transition - Trans
As mentioned above, the transition (Trans) is used to start a transition between an active 
and an inactive step. A logical condition, for instance a digital signal, is connected to a 
transition, and determines when the transition is taken place.

<b>A Transition Example
<image>dg_fig52.gif

<h2>Order
It is possible to connect one or more orders to each step. 

<b>An Order Example
<image>dg_fig53.gif

Normally the output is active when the input is active, but for each order you have a number 
of attributes, with which you can influence the function of the output: 

- D Delay 
- L Time limit 
- P Pulse 
- C Conditional 
- S Stored 

These functions are described in detail in Proview Objects Reference Manual. The principles are
that you indicate the name of the attribute (capital letters) and possible time by means of the
Object Editor. The figure below illustrates how to delay an order from being active for 10 
seconds. 

<b>DOrder Attributes
<image>dg_fig54.gif

The selected order attributes are written in the order symbol. 

The figure below illustrates how you can use an order object with delay to make a step active
for a certain time. 

<b>A Delayed Transition
<image>dg_fig55.gif

Note! You must use a ConFeedbackDigital connection to connect the delayed order object with 
the transition object, otherwise the order of execution will be ambigous. 
See Feedback Connection <link>plceditor_refman, feedback_connection

<h2>Subsekvens - SubStep

När man skapar komplexa Grafcet program, är det ofta en fördel att använda underfönster,
och i dessa placera subsekvenser. På det här sättet får man en bättre layout på programmet.

<b>Subsequence
<image>dg_fig56.gif

The above figure shows the sub sequence of a SubStep. A sub sequence always starts with an 
SsBegin object, and ends with an SsEnd object. In its turn a subsequence can contain 
subsequences. 

<h1>An Introduction to Function Block Programming 

<h2>Block to fetch and store values
Block to fetch and store are used to read and write values. There are fetch and store blocks
for each type of signal. In the figure below a number of these blocks are displayed. They
are found in the 'Signal' folder in the palette.

<b>Block to fetch and store values
<image>dg_fig57.gif

To read signals you use blocka like GetAi, GetIi, GetDv or GetAo. When you want to give a value
to a signal, you use for instance StoAv, StoDo, SetDv or ResDo. 

Digital values can be written in two ways: 

- 'Sto' stores the input value, i.e. if the input is 1 the signal becomes 1, and if the input is
  zero the signal becomes zero. 
- 'Set' sets the signal to one if the input is true, Res sets the signal to zero if the input 
  is true. For instance, if you set a digital output signal with a SetDo object, this will 
  remain set until you reset it with a ResDo object.

To read, respectively assign attribute values other than the ActualValue attribute, you use the
following: 

- analog attributes, GetAp and StoAp 
- integer attributes, GetIp and StoIp
- digital attributes, GetDp and StoDp, SetDp or ResDp 


<h2>Logic Blocks 
A number of objects are available for logical programming, for instance And-gate (And), 
Or-gate (Or), inverter or timer. For the logical programming digital signals are used. The 
objects are placed in the folder Logic. 

<b>Logic Blocks 
<image> dg_fig58.gif

The figure below shows an And-gate. For this object the following applies: 

- Inputs to the left 
- Output to the right 
- Class name is written at the top 
- The object name is written at the very bottom (can be changed by the user) 
- You can use a variable number of inputs, default is 2. 
- The inputs can be inverted, indicated by a ring on the symbol's input. 

<b>And-gate
<image> dg_fig59.gif

The attributes of the And-gate are changed with the Object Editor.

<b>Attributes of the And-Gate
<image> dg_fig60.gif

The other objects in the 'Logic' folder have similar parameters, see Proview Objects Reference 
Manual . 

<h2>Calculation Blocks 
The folder 'Analog' contains a number of objects for handling analog signals, for instance 
filters, summation blocks, and integrators. 

<b>Arithmetical Calculation Block
<image> dg_fig61.gif

In this guide we do not describe the function of the objects, but it may be expedient to 
comment on the use of arithmetic blocks. The blocks are used for calculation of user defined 
expressions. These are written in the C language. 

In the figure below the block will calculate the expression (A1 + A2 * A3) and give the output 
this value. A1, A2 and A3 are representing analog values, for instance signals supposed to be 
connected to the inputs of the object. 

The expression can contain advanced C code with arrays and pointers.
When writing these expressions it is important to use space before and after the operators, otherwise the expression may be misinterpreted at the execution. 


Här beskrivs inte funktionen hos objekten, men det kan vara lämpligt att kommentera
användningen av aritmetiska block. Blocken används för beräkning av användardefinierade
uttryck, som skrivs i programmeringsspråket C.

I figuren ovan kommer blocket att beräkna värdet (A1 + A2 * A3) och lägga detta på utgången.
A1, A2 och A3 representerar analoga värden, t ex signaler som antas vara kopplade till
ingångarna på objektet. 

Uttrycken kan innehålla avancerad C kod med arrayer och pekar. When you write these, you 
should ge aware of that indexing outside arrays, or erroneous pointers might cause the
execution of the plcprogram to terminate.

<h1>Alarm Supervision 
In Proview it is possible to supervise analog and digital signals. Supervision of analog
signals is made against a limit value. If  the supervised limit is exceeded, an alarm is sent 
to the Message Handler, who in his turn sends the alarm to the out unit, e.g. an operator 
dialog. 

See Proview Objects Reference Manual regarding the attributes of the objects. 

<h2>Supervision of Digital Signals 
For supervision of a digital signal or attribute, you use the DSup object (Digital 
supervisory), which is in the folder Logic. 

The desired signal or attribute, is fetched with a Get-object that is connected to the DSup 
object. Outputs of logical blocks can be directly connected to the DSup object.

<b>Digital Supervisory Objects
<image> dg_fig62.gif

Figure above illustrates supervision of a Dv signal and a digital attribute.

You also have an attribute in the DSup object, 'CtrlPosition', that indicates whether the 
alarm will be activated when the supervised signal/attribute becomes true or false. 

<h2>Supervision of Analog Signals 
For supervision of an analog signal or attribute, you use the ASup object (Analog supervisory),
which is in the folder 'Analog' in the palette. 

Supervision takes place in the same way as for DSup objects with the exception that you can 
choose whether the alarm will be released when the value is above or below the supervision 
limit.

<h1>Compile the plcpgm
Before starting to compile, you have to state on which platform (or platforms) the volume of
the plc should run. Open the volume attributes editor from the navigator menu: 
'File/Volume Attributes', and enter the OperatingSystem. Note, that more than one operating 
system can be choosen. The volume can at the same time be run in the production system, in a 
simulation system and in a educational system, and the systems can have different platforms.

Now, the plcgpm is compiled, by choosing 'File/Build' in the plc editor. Any waring or error 
messages will be displayed in the message window.
</topic>
</chapter>

<chapter>
<topic>ge_man
Creating Process Graphics

This chapter describes how you create process graphics.

Process graphics are drawn and configured in the Ge editor.

<h1>The Ge editor

Ge is opened from the menu in the navigator: 'Functions/Open Ge'. It consist of 

- a tool panel
- a work area
- a subgraph palette
- a color palette
- a window displaying the plant hierarchy
- a navigation window

<h2>Background picture
A background image is drawn with base objects such as rectangles, circles, lines, polylines 
and text. These are found in the tool panel. Create a base object by activating the pushbutton 
in the tool panel and dragging or clicking MB1 in the work area. If the base object should be 
filled, select the object and activate fill in the tool panel. Change the fillcolor by 
selecting the object and click on the desired color in the color palette. Change the border 
color by clicking with MB2 in the color palette, and the text color by clicking Shift/Click MB1.

<h2>Subgraphs
A subgraph is a graphic component, e.g. a valve, a motor, a pushbutton. To create a subgraph, 
select a subgraph in the subgraph palette and click MB2 in the work area. 

<h2>Groups
Base objects and subgraphs can be grouped together by selecting them and activating 
'Functions/Group' in the menu.

<h2>Dynamics
Subgraphs and groups has dynamic properties, i.e. they can be connected to signals in the 
runtime database, and change color, position or shape depending on the values of the signals. 
A subgraph often has default dynamic behaviour, for example an indicator shifts between two 
colors. You only have to connect the indicator to a digital signal to make it work. This is 
done by selecting a signal in the plant hierarchy window, and click on the valve with 
Ctrl/DoubleClick MB1. 

A pushbutton has an action property, is sets, resets or toggles a signal in the database. 
A button with a set action is created by selecting a ButtonSet in the subgraph palette and 
click MB2 in the work area. The signal that should be set is connected as above, by selecting 
the signal and click with Ctrl/DoubleClick MB1 on the button. In the object editor, a button 
text can be assigned.

<b>Connect a subgraph to a signal
<image> dg_fig63.gif

Group also has a dynamic property, i.e. they can shift color, move, or perform some action. 
They dont have any default action or default color,as the subgraphs. You have to assign this
for each group.

<h2>The Object editor
Base objects, subgraph objects and groups have properties, that is changed from the object
editor. The object editor is opened by selecting the object, and activating 
'Function/Object attributes' in the mnu. By opening the object editor for the pushbutton
mentioned above, you can for example enter the text, that is displayed in the button, in the
attribute 'Text'.

If a subgraph has more advanced dynamics, for example shift between several colors, you often
has to connect it to several signals. If you open the object editor for a valve, you see that
it can be connected to two attributes, 'DigError.Attribute' and 'DigLowColor.Attribute'.
The DigError attribute indicates that something is wrong, and if this signal is true, the
valve is colored red. The DigLowColor attribute is connected to the open switch of the valve.
If this signal is false, the valve is colored in the color stated in 'DigLowColor.Color'. Is
the signal true, it keeps the color given in the editor. The signals of the two attribute is
inserted by selecting each signal in the plant hierarchy respektively, and clicking with
Ctrl/Doubleclick MB1 on the attribute row of the attribut. The color 'DigLowColor' is stated
by opening the attribute and selecting one of the 300 colors. The colors has the same order
as in the color palette, and with a little practice they can be identified by the name.

<b>The Object Editor for a valve
<image>dg_fig64.gif

<h2>Graph borders
The drawing area in Ge is unlimited in every direction, so before saving the graph, you have 
to state the borders of the graph. Open the graph attributes with 'File/Graph' attributes  in 
the menu. Measure the coordinates of the upper right corner, and insert as x0 and y0, then 
measure the coordinates of the lower left corner and insert as x1 and y1. The measurement is 
done by placing the cursor in position and read the coordinates in the ge message row.

<b>Graph Attributes
<image>dg_fig65.gif

<h1>Configuration in the workbench
<h2>The XttGraph object
To each plant graphics belongs a XttGraph object. This object is usually a child of the 
operator place object (OpPlace) for the node, on which the graphics will be displayed. It is 
necessary to create a XttGraph object for each node, on which the graphics will be displayed. 
However, you only need to have one graph file. The following attributes in the graph object 
must be set to appropriate values:

- Action, the name of the pwg file with file type, e.g 'hydr.pwg.
- Title, the title of the graph window.
- ButtonText, text of the button in the operator window.

The XttGraph object contains other attributes which e.g. helps you to customize the position 
and size of plant graphics. These attributes are described in detail in Proview Objects 
Reference Manual .
See XttGraph in Object Reference Manual <link>xttgraph,"",$pwr_lang/pwrb_xtthelp.dat
</topic>
</chapter>

<chapter>
<topic>conf_test
Running and Testing a Proview System
In preceding chapters we have described how to configure a PROVIEW/R system, how to create 
PLC programs and how to create plant graphics. Now it is time to run and test the system. 

This chapter shows how to: 

- create load files 
- create a boot file 
- distribute

<h2>Syntax control
Before creating load files it is appropriate to make a syntax control. This is done from the 
menu in the navigator, 'File/Syntax'.

<h2>Creating Load Files 
Before starting the runtime environment you have to create a number of load files, one for each
volume in your system. You create the load files from the Navigator of each volume,
'Function/Build Volume'.

<h2>Creating Boot Files
For every node in the project you have to create a boot file. The bootfile contains mainly the 
root volume to load for the node. The bootfile is created from the configurator menu, 
'Functions/Build Node'. This command will also build the plcprogram for the node.

<b>Select node when creating a bootfile
<image> dg_fig66.gif

At this point, everything in the development environment is configured and generated, and its 
time to set up the runtime environment.

<h2>Install the Proview runtime package
...

<h2>Distribute
...
</topic>
</chapter>

<chapter>
<topic>configurator_refman
The Configurator

The configurator is used to navigate in and configure the Workbench.
The configurator displayes the object in one volume. The objects are usually separated in two
windows, a uppper and a lower, and how the separation is done depends on what type of volumes
is handled.

- For rootvolumes and subvolumes, the plant hierarchy is displayed in the upper window, and
  the node hierarchy in the lower.

- For the directory volume, volumes are displayed in the upper window and busses and nodes in
  the lower.

- For class volumes, classes are displayed in the upper window and types in the lower.

From 'View/TwoWindow' you kan choose wether to display two windows or only one. I only one
window is displayed, every second time you activate 'TwoWindow' it will be the upper window
that is displayed, else it will be the lower window.

From 'Edit/Edit mode' you enter edit mode, and a palette with varoius classes is displayed to
the left. You can now create new objects, move objects, change values of attributes etc.

<h2>Volume representation

Volumes is stored in various formats, in a database, in a loadfile or in a textfile. The
configurator can display a volume in all these formats, and it has four different 
representations of volumes:

- db, a database. Rootvolumes and subvolumes are created and edited in a database. Before you
  can start the runtime environment, loadfiles are generated from the volumes. The loadfiles
  are read at runtime startup. The db representation i editable.

- wbl, a textfile with extension .wb_load. The classvolujes are stored as wbl, and root and
  sub volumes can be dumped in a wbl-file, for example when upgrading, and later reloaded. The
  wbl representation is node editable. When editing a class volume you import the wbl
  representation to a mem-represention, and the save it as wbl again.

- dbs, a loadfile. From rootvolumes, subvolumes and classvolumes, in db and wbl representation,
  loadfiles are cerated and used in the runtime environment. The configurator also reads the
  dbs-files of the classvolumes to be able to interpret the classes, and the dbs-files of the
  root and subvolumes to be able to translate references to external objects. The dbs
  representation is not editable.

- mem, a volume the configurator keeps internally in memory. Copy/Paste buffers consist of
  mem-volumes. The classeditor imports the classvolume, which originally is a wbl, to a mem
  volume, as the mem representation is editable.

As we see above, the same volume can exist both as a database or as a loadfile. When staring
the configurator, you specify a volume as an argument. For this volume, the database i opened,
i.e. it is represented as a db, for the other volumes in the project, the loadfiles are opened,
i.e. they are represented as dbs. This makes it possible to display the other volumes in the 
project, and to solve references to them, but they are not editable. If the database of the
volume is locked, because someone else has opened it, an error message is displayed and the
loadfile is opened instead of the database.

In the figure below the volume list is displayed, which is opened from 'File/Open' in the menu.
I shows all volumes opened by the configurator. We can see that the database for the root
volume VolTrafficCross1 is opened, while the other root volume, VolOpTrafficCross1 is opened
as a loadfile. Also the class volumes are opened as loadfiles.
<image> dg_fig24.gif

If no volume is given as argument, the database of the directory volume is opened, and the
other volumes are opened as dbs-volumes.

<h1>Navigate <bookmark>wnav_navigate
The object of the current volume are displayed in the configurator. The objects are ordered
in a tree structure, and objects with chidren are displayed with a map, and objects without 
children with a leaf. For each object is displayed as default, the object name, class and
possible description (the description is fechted from the Description attribute in the object).

By clicking with MB1 on a map, the map is opened and the children of the object are displayed.
Is the map alread open, it is closed. You can also open a map with a doubleclick anywhere in
the object row.

If you want to see the content of an object, click with Shift/Click MB1 on the map or leaf,
or Shift/Doubleclick MB1 anywhere in the object row. Now the attributes of the object are
displayed, together with the value of each attribute. The attributes are marked with various
icons dependent of type.

<b>Bitmaps for different types of attributes
<image> dg_fig26.gif

- An ordinary attributs is marked with a long narrow rectangle.

- An array is marked with a map and a pile of attributes. The array is opened with Click MB1
  on the map, or Doubleclick anywhere in the attribute row. Now the elements of the array
  are displayed.
<image> dg_fig27.gif

- An attribute refering another attribute or object, i.e. of type Objid or AttrRef, is marked
  with an arrow ponting to a square.

- Enumeration types, Enum, is marked with am map and some long narrow rectangles. By clicking
  MB1 on the map the different alternatives of the enumeration are displayed. The alternatives
  are displayed with checkboxes, and the choosen alternative is marked. You can also 
  Doubleclick MB1 in the attribute row to display the alternatives.
  attributraden för att se alternativen.
<image> dg_fig28.gif

- Mask types, Mask, is marked simular to Enum, an the different bits are displayed with Click
  MB1 on the map, or Doubleclick MB1 in the attribute row.
<image> dg_fig29.gif

- Attrbute objects, i.e. attributes that contains the datastructure of an object, is marked
  with a square with a double line on the upper side. The attribute object is opened with
  Click MB1 on the square, or Doubleclick MB1 in the attribute row.

En object or attribute is selected with Click MB1 in the object/attribute row (not in the map
or leaf). With Shift/MB1 you kan select several objects. With Drag MB1 you can also select
several objects.

From an ergonomic point of view, it is often better to navigat from the keyboard. You mainly
use the arrow keys. First you have to set input focus to the window, by clicking on it. Input
focus between the upper and lower window is shifted with TAB.

With ArrowUp/ArrowDown you select an object. If the object has children, you open the children
whigh ArrowRight, and close with ArrowLeft. The content of the object, i.e the attributes, are
displayed with Shift/ArrowRight and closed with ArrowLeft.

An attribute that is an array, enum, mask or attribute object, is opened by ArrowRight and
closed by ArrowLeft.

When you feel at home in the object tree, you can set yourself as 'advanced user'. Additional
function is the placed in the arrow keys. ArrowRight on an object, displayes for example the
attributes of the object, if it has no children. If it has children, you have to use 
Shift/ArrowRight as before.

<h1>Editing
When editing a volume, you create new objects, copy objects, remove objects and change values
of attributes.

<h2>Create an object
You create an object by selecting the class of the object in the palette. The palette is
divided in the folders Plant, Node and AllClasses. Under Plant you find the most common classes
in the plant hierarchy, under node the most common in the node hierarchy. If the class is not
found here, all the classes are available under AllClasses. Here, all the class volumes are
listed, and under each volume, the classes of the volume. After that, you click with the 
middle mousebutton on the future sibling or parent to the new object. If you click on the
map/leaf in the destination object, the new object is placed as the first child, if you click
to the right of the map/leaf, it is placed as a sibling.

You can also create an object from the popup menu. Select a class i the palette and open the
popup menu by Click MB3 on the destination object. Activate 'Create Object' and choose where
to put the new object, relatively the destination, before, after or as first or last child.

<b>The Configurator in edit mode
<image> dg_fig25.gif

<h2>Delete an object
An object is deleted from the popup menu. Click MB3 on the object and activate 'Delete Object'.

<h2>Move an object
You can also move an object from the popup menu, but it is often easier to use the middle
mouse button: select the object that is to be moved and click with the middle button on the
destination object. If you click on the map/leaf on the destination object, the object is
placed as first child, else as a sibling.

Node! Avoid using Cut/Paste to move an object. This will create a copy of the object with
a new object identity, and references to the object might be lost. You can use the command
paste/keepoid to keep the identity.

<h2>Copy an object
You kan copy an object with copy/paste or from the popup menu.

- copy/paste. Select the object or objects that are to be copiedm and activate 'Edit/Copy'
  (ctrl/C) in the menu. The selected object are now copied to a paste buffer. Select a
  destination object, and activate 'Edit/Paste' (ctrl/V). The objects in the paste buffer are
  now placed as siblings to the destination objects. If you instead activate 'Edit/Paste Into'
  (shift+ctrl/V) the new objects are placed as children to the destination object. If the
  copied objects have children, the children are also copied by copy/paste.

- from the popup menu. Select the object or objects that are to be copied, open the popup
  menu from the destination object, and activate 'Copy selected object(s)'. You now have to
  choose where the new objects are to be placed, relative to the destination object, as first
  or last child, or as next or previous sibling. If the copied objects have acsendants, and
  they also are to be copied, you activate 'Copy selected Tree(s)' instead.

<h2>Change object name
The name of an object is changed by selecting the object, and activating 'Edit/Rename' 
(ctrl/N) in the menu. An input field is opened in the lower region of the configurator, where
the new name is entered. An object name kan have max 31 characters.

You can also change the name by displaying the object attributes. In edit mode, the object
name is displayed above the attributes, and is changed in the same way as an attribute.

<h2>Change an attribute value
Select the attribute to be changed, and activate 'Functions/Change value' (ctrl/Q) in the menu.
Enter the new value in the input field. If you want to terminate the input, you activate
'Change value' again.

Not all attribute are editable. It depends on the function of the attribuet, if it is to be
assigned a value in the development environment or not. Editable attributes are marked with
an arrow.

You can also change the value of an attribute from the object editor, opened from the popup
menu (Open Object). An attribute of type multiline text, can only be edited from the object
editor.

As 'advanced user' you can open the input field with 'ArrowRight', as a faster alternative to
'Change value'.

<h1>Symbol file

The symbolfile is a command-file that is executed att wtt startup.
It can contain definitions of symbols and other wtt commands.
Here is some examples of useful commands.

Shortcut to somewhere in the database hierarchy:

<c>define rb9 "show children /name=hql-rb9" <LINK> define

</topic>


<topic>objecteditor_refman
Object Editor

The quantity of data for an object is devided in attributes. The Object Editor displayes the
attributes of an object and value of each attribute. If you are in edit mode, you can also
change the values of the attributes.

The attributes are displayed in the same way as in the configurator, the main difference is
that they are displayed in a separate window.

<h2>Navigate
Navigation and assignment of values is also done in the same way as in the configurator.<link> configurator, wnav_navigate

<h2>Start
The Object Editor is opened from the Configurator or the Plc editor. Activate 'OpenObject' in 
the popup menu for an object, or select the object and activate 'Functions/Open Object' in the
menu. From the Plc editor you can also start the object editor by doubleclickning on the 
object. If the Configuration/Plc editor is in edit mode, the Object Editor is also opened in
edit mode.

<h2>Menu

File/Close <t><t>close the object editor.

Functions/Change value  <t><t>open the input field for the selected attribute.
                        <t><t>This is only allowed in edit mode.
Functions/Close change value <t><t>Close the input field.

<b>Object Editor
<image> dg_fig30.gif

The Object Editor has an input field to enter multiline texts. In this case you can not
terminate the input with 'Enter', as for singleline texts. You either click on the 'Ok' button
or activate 'Functions/Close change value' (ctrl/W) to terminate.

<b>A Multiline text
<image> dg_fig31.gif

The Object Editor for plc objects has functions to state which inputs or outputs are to be
displayed in the function block. You can also choose if digital inputs is to be inverted.
This i choosen with checkboxes for each attribute respectively ('Used' and 'Inverted'). The
checkbox for 'Used' can also be changed from the keyboard with 'Shift/ArrowRight', and the
checkbox for 'Inverted' can be changed with 'Shift/ArrowLeft'.

<b>Plc object with checkboxes
<image> dg_fig32.gif
</topic>

<topic>spreadsheeteditor_refman
The Spreadsheet Editor

The Speadsheet editor is used to view or configure, several objects of the same class
simultaneously. Objects for a certain class, below a specified object in the object tree, are
displayed in a table in the editor. In the table. also the values of an attribute in the
objects are displayed, and you can easily shift between different attributes.

The Spreadsheet Editor is opened from the configurator: 'Functions/Spreadsheet' in the menu.
If the configrator is in edit mode, also the Spreadsheet Editor i opened in edit mode.

When the spreadsheet editor is started, you first have to state which object are to be 
displayed, i.e. which class they belong to and under which hierarchy the are placed. This
is done by activating 'File/Select Class' in the menu. Enter class, hierarchy and state if
attribute objects, i.e. objects that reside as attributes in other objects, is to be displayed.

<b>Choose class and hierarchy
<image>dg_fig33.gif

After that you choose which attribut is to be displayed. Select at attribut in the attribute
list and click on 'Ok', or doubleclick on an attribute.

<b>Choose attribute
<image>dg_fig34.gif

The result is shown in the figure below. Here, the attribute 'Description' was choosen. You
can easily view the other attributes in the object by activating 'File/Next Attribute'
(Ctrl/N) and 'File/Previous Attribute' in the menu.

<b>Spreadsheet Editor
<image>dg_fig35.gif

<h2>Meny
File/Select Class     <t><t>State class and hierarchy for the objects that are to be displayed.
File/Select Attribute <t><t>State which attribute is to be displayed.
File/Next Attribute   <t><t>Display the next attribute for the object in the table.
File/Previous Attribut <t><t>Display the previous attribute for the objects in the table.
File/Print            <t><t>Print the table.
File/Close            <t><t>Close the Spreadsheet Editor.

Functions/Change value <t><t>Open an input field for the sekected object.
Functions/Close change value <t><t>Close the input field.

</topic>
</chapter>

<chapter>
<topic> helpwindow_refman
Help window

The helpwindow is used to view and navigate in help texts. The help texts can be various
manuals and guides that comes with Proview, or helptexts witten by the constructor to
describe the plant and to give assistance to the operators.
</topic>
</chapter>

<chapter>
<topic> messagewindow_refman
Message window

The message window displayes messages from Proview that are transmitted at various
operations. The messaged can have five levels of severity, that are marked with different
colors: 

S <t>Success  <t>green
I <t>Information <t>green
W <t>Warning  <t>yellow
E <t>Error    <t>red
F <t>Fatal    <t>red

If  an arrow is displayed in front of the message, the message contains a link to an object.
By clicking the arrow, the object is displayed.
</topic>
</chapter>

<chapter>
<topic> utilities_refman
Utilities

The utilities window is a graphic interface to different commands in wtt.
For more information about the commands, se chapter Commands.
</topic>
</chapter>

<chapter>
<topic> plceditor_refman
Plc Editor

In The Plc Editor you create plcprograms in a graphical programming language.

Programming with function block is made in a horizontal net of nodes and connections from left 
to right in the document. Signals or attributes are fetched on the left side of the net, and 
the values are transferred via connections from output pins to input pins of functions blocks. 
The function blocks operate on the values, and on the left side of the net, the values are 
stored in signals or attributes.
	
Grafcet sequences consist of a vertical net of nodes and connections. A state is transferred 
between the steps in the sequence via the connections. Grafcet and function block nets can 
interact with each other and be combined to one net.

<h2>Start
The Plc editor is opened from the configurator. Select an object of class PlcPgm and activate
'Functions/Open Program' (Ctrl/L) in the menu, or activate 'Open Program' in the popupmenu
for the PlcPgm object. The configurator shoude not be in edit mode.

<h2>Working mode
The Plc editor can be in four different modes: View, Edit, Trace and Simulate. The mode
is selected  under 'Mode' i the menu.

<b>View
In View you can look at the program, but not create or modify objects. The menu alternatives
for edit functions are dimmed.

<b>Edit
If you have edit privileges you can enter the edit mode. Now it is possible to create and
modify objects.

<b>Trace och Simulate
If you want to trace the program you enter the trace mode. This requires that the Proview
runtime environment is started in the development station. Simulate works as trace, but
you can also set values to signals.

Trace is nowdays easier and faster performed from Xtt. We recommend that you use PlcTrace in
Xtt instead.

<h1>Editering
The Plc editor consist of

- a working area.
- tow palettes, one for function objects and one for connections (only one palette at a time
  is visible).
- a navigation window, from which the working area can be scrolled and zoomed.

<b>The Plc editor
<image>dg_fig40.gif

<h2>The Palettes
<b>The Object Palette
When you start the Plc editor, the funktion object palette is displayed. When creating a
funktion block in the work area, you choose a class in the palette.

<b>The Connection Palette
When you create connectinos between objects, the editor chooses a suitible type of connection.
Though, in some cases the constructor has to influence the choise of connection type. This
is done in the connections palette that is displayed by activating 'View/Palette/Connection'
in the menu. When the palette is closed, by activating 'View/Palette/Object' or 
'View/Palette/Plant', the editorn is again responsible for choise of connection type.

<b>Plant Hierarchy
You can view the plant hierachy by activating 'View/Palette/Plant' in the menu. When
connecting function objects to signals, for example when fetching signal values, it is possible
to indicate which signal is to be fetched. You can also select the signal in the configurator,
which in many cases is a smoother alternative.

<h2>Navigation window
Down to the left there is a view of the program in reduced scale. The part of the working
area that is displayed in the main window, is marked with a rectangle. By moving the rectangle
(Drag MB1) you scroll the main window. You can also zoom with Drag MB2.

<h1>Function objects
<h2>Create object
To create objects the editor has to be in edit mode. Enter edit mode from 'Mode/Edit' in the
menu.

To create an object, you select a class in the palette, and click with MB2 (the middle button)
in the working area.

<h2>Modify an object
An object is created with certain default values. This applies also to which inputs and ouputs
are viewed in the plc editor and can be connected to other objects. If a value is to be changed
the object editor is opened for the object. The object editor is opened in following ways:

- doubleclick on the object
- activate 'Open Object' in the popup menu for the object.
- select the object and activate 'Functions/Open object' in the menu.


From the object editor you can change the values of various attributes. The attribute for a
plc object is separated in input attributes, internal attributes and output attributes.

<b>Inputs
The value of an input attribute is fetched from another function block, via a connection.
The attribute is displayed in the function block as an input pin. In some cases the input is
not used, an and-gate has for example 8 inputs but often only two of the are used. This is
controlled by the 'Used' checkbox in the object editor. If 'Used' is marked, the attributes is
displayed with an input pin, else it is hidden.

Some input attributes, especially of analog type, can be assigned a value in the object editor.
If 'Used' isn't marked for the attribute, the assigned value is used. However, if 'Used' is 
marked the value is fetched from the output the attribute is connected to. This is for 
example the function for the limit values 'Min' and 'Max' in a Limit object. You can choose
whether to fetch the value from another function block, or to assign a value. The assignment
works in runtime as an initial value, that later can be modified in various ways.

Some digital inputs can be inverted. To do this you mark the checkbox 'Inverted' in the object
editor. In the function block this is displayed with a circle on the input pin.

<b>Internal attributes
Internal attributes can contain configuration values that are assigned in the development
environment, or values that are calculated in runtime. The latter type is not changeable, and
maybe not even visible in the development environment.

<b>Outputs
The value of an output attributes is transfered to an input via a connection. As for an input,
you can choose whether to display an output pin or not with the 'Used' checkbox in the
object editor.

<h2>Select an object
Objects are selected in the following ways

- click with MB1 on the object.
- Shift/Click MB1 adds the  object to the list of selected objects, or removes it if the
  object already is selected.
- by Drag MB1 you can select one or several objects. Objects that has some part within the
  marked rectangle are selected.
- by pressing the Shift key and Drag MB1 you add the objects in the marked rectanglel to the
  selectlist.

Selected objects are drawn with red color.

<h2>Move objects
A single object is moved by placing the cursor on it and drat with MB1.
Several objects are moved by selecting them and dragging one ofhte objects with MB1.

<h1>Connections
<h2>Create connections
An output pin and an input pin is connected in the following way

- place the cursor on the pin, or in an area in the function object close to the pin, and
  push MB2 (the middle button).
- drag the cursor to the other pin. or to an area in the function object close to the pin,
  and release MB2.

A connections is now created between the objects.

Two inputs is connected in the same way, but som of the connected inputs has to be connected
to an output, and from this output the value is fetched to all the connected inputs.

<b>Data types
The values that is transfered between different objects via the connections can be digital,
analog, integer or string values. Inputs and outputs that are connected has to be of the same
type. If they are of different type you have to use an object that converts between the types,
e.g AtoI or ItoA. These conversion object are found under 'Signals/Conversion' in the palette.

Analog and integer connections are marked with slightly thicker lines, and digital connections
with thinner lines.

Furthermore there is a connectiontype for transfer of an object reference. These are drawn with
a thick, dashed line.

<b>Reference connections
If the editor has difficulties to find a path for the connection between the input and output
pin, because there are too many objects in the way, or because the reside in separate 
documents, the connections is drawn as a reference connection. Reference connections can also
be drawn by activating 'View/Reference connection' in the menu.

<b>Referens connection
<image> dg_fig39.gif

<bookmark>feedback_connection
<b>Execute order

Besides transfering a signal value, the connections also determine the execute order between
different function blocks. If two objects are connected trough an output and an input, 
normally the output-object is to be executed before the input-object. But sometimes a feedback
is needed in the net, and then you face a execute order loop. To determine the execute order
you have to specify the feedback with a connections of type ConFeedbackDigital or 
ConFeedbackAnalog. These are selected in the connection palette, viewed by activating 
'View/Palette/Connection' in the menu. Under the folder 'ConPlc' you can find the feedback
connections. They are drawn with dashed lines.

<b>Feedback connection
<image> dg_fig37.gif

Here you can also find the connection type 'ConExecuteOrder'. In som cases you want to control
the execute order between to function blocks, though they are not connected to each other.
Then you can draw a ConExecuteOrder between them (between which input or outpu doesn't 
matter). The connections is to be drawn from the object that is to execute first, to the object
that is to execute last. In the figure below, the storage of the attribute 'Temperaturer' is 
done before the storage of the attribute 'Tjocklek'.

<b>Execute order connection
<image> dg_fig38.gif

<h1>Fetch and store signal values
<h2>Fetch signal and attribute values
In the left side of the net of function blocks, values of signals and attributes are fetched.
The fetching is performed by objects as GetDi, GetDo, GetDv, GetIi etc. Fetching of attribute 
values is performed by GetDp, GetIp, GetAp and GetSp. These object you find under the folder
'Signals' in the palette. When an object of this type is created, you has to state which
signal, or which attribut that is to be fetched. The easiest way to do this, is to select the
signal/attribute in the configurator, and click with Ctrl/Doubleclick MB1 on the object.
The signal/attribute is then displayed in the function block, and if the signal is an input
signal, the channel of the signal is also displayed.

There is a faster way to create these objects. If you draw a connection from an input pin in
a function object, and release it in an empty space in the working area, a generic Get object
is created with the datatype of the input, i.e. a GetDgeneric, a GetIgeneric, a GetAgeneric
or a GetSgeneric. When you specify the signal or attribut the Get object is to fetch, the 
generic Get object is converted to a Get object of the the correct type for the signal or
attrbute. If you choose a Dv in the configurator, a GetDgeneric will be converted to a GetDv
when clicking with Ctrl/Doubleclick MB1 on it.

<h2>Store signal and attribute values
In the right side of the net calculated values are stord in signals and attributes. The 
storage is performed by objects as StoDo, StoDv, StoDp, StoIo etc. The method to specify the
signal or attribute to connect is the same as for Get objects, i.e. by selecting the 
signal/attribute in the configurator and click with Ctrl/Doubleclick MB1 on the object.

If you draw a connections from an output pin in a function block, a generic Sto object is 
created, that is converted to a Sto object of suitable type when connected to a signal or
attribute. If you want to store values with Set or Reset (for example SetDo or ResDo), you
can't use this method. You have to create the objects from the palette.

<b>Generic Get and Sto objects
<image> dg_fig36.gif

<h1>Subwindows
Some objects contains subwindow, e.g. CSub, SubStep, Trans, Order. An object with a subwindow
is marked with a thick gray line somewhere in the function block. A subwindow is opened in
different ways:
- by selecting the object and activate 'Function/Subwindow' in the menu.
- by activating 'Subwindow' in the popup menu for the object.
- by clicking on the object with Shift/Doubleclick MB1.

You create a new subwindow in the following way (the fact that only one editing session can
be open at a time, makes it a bit complicated)

- create the object that is going to contain the subwindow.
- save.
- open the subwindow.
- leave edit mode in the main window.
- enter edit mode in the subwindow.

<h1>Control the execute order
You normally don't have to consider the execute order of different function blocks in a
window. As signals are I/O copied, i.e. every timebase in the plc program, makes a copy of
all signal values before the execution that is not changed throughout the execution, the
storing and fetching of signal values will not be affected by the execute order between
individual storing or fetching objects. 

However, if you store and fetch the value of an attribute, that is not I/O copied, the
execute order can be of importance for the function.

The exectute order is determined by the connections between the function blocks. The common
connections are both signal tranferring and executeorder determining. If you make a feedback
you then have to choose a connectiontype that is signal transferring, but not executeorder
determining. The different feedback connections are of this type. Furthermore there is a 
connections that is executeorder determining but node signal transferring, ConExecuteOrder.
With this you can control the execute order between different function blocks without
tranferring any signals values.

The execute order for the function blocks in a plc window is displayed with
'View/Show execute order' in the menu. The number displayed for each function block states
tho order in which they are executed. The objects without a number doesn't have any
executable code.

The execute order between different PlcPgm is controled by the attriute ExecuteOrder in the
PlcPgm object. Exectute order determines the order within a thread. Lower values of 
ExecuteOrder are exectued before higher.

<h1>Compile
Before a plc window can be executed, is has to be compiled. At the same time, a syntax control
of the plc code is performed. If the syntax in not correct, a message is displayed in the
message window. The error message can be of type Error or Warning. Error is a more severe error
that has to be attended to. By clicking on the arrow in front of the message in the message
window, the erroneous object is displayed in the plc editor.

After the syntax check, c-code is generated and sent to the c compiler. If there is an object
with user defined c-code, e.g CArithm or DataArithm, the c compiler can find errors that
is written in the terminal window. Always look in the terminal window to check that the
compilation succeeded.

The compile is executed from 'File/Build' in the menu.

If you want to check the syntax witout generating any code, you activate 'File/Syntax'. The
c compiler is not activated, thus possible c code errors are not detected.

<h1>Cut and Paste
The plc editor contains a paste buffer. The paste buffer is common for all windows, which
makes it possible to copy between separate windows. With the functions 'Edit/Copy' and 
'Edit/Cut' in the menu, the selected objects are copied to the paste buffer (Cut also removes
them from the working area). The function 'Edit/Paste' copies the paste buffer to the working
area. The copied objects are now moved with the cursor, and you place them on the correct
position by clicking MB1 to lock them.

Cut, Copy and Paste can also be activate from the keyboard with Ctrl/X, Ctrl/C and Ctrl/V.

<h1>Special Plc objects
Here a number of objects that has special functions in the plc program are described.

<b>Document
The document object is used to divide the code in pages, when printing the code. When you
open a new window, it contains a document object. From the object editor you can change the
dimension of the document, and enter signature and page number. Other information in the 
document header is filled in automatically. The document object is found under the folder
'Edit' in the object palette.

<b>ShowPlcAttr
ShowPlcAttr can be used as an extension of the document header. In the object is displayed
information about volume, scantime and reset object for Grafcet sequences.

<b>Head, Title, Text och BodyText
These objects are used to write informational text in the document. Head, Title and Text
contains singleline texts of different size with max 79 characters. Bodytext contains a
multiline text with max 1023 characters. The objects is found under 'Edit' in the palette.

<b>Point
The point object is a free connection point that is used to branch a connection or to control
the layout of a connection. Point is found under 'Edit' in the menu.

<b>GRAFCET
Grafcet sequences are built with specific Grafcet objects as InitStep, Step, Trans and Order.
The connections between the objects follow specific rules. The vertical pins in a Step object
is for example connected to Trans objects, and the horizontal pin i connected to an order
object. Here is an example of how to create a Grafcet sequence.

Start by creating an InitStop object. Draw a connection from the lower pin, and release it
in the working area below the InitStep object. Now a Trans object is created, that is 
connected to the InitStep object. Draw a connection from the lower pin of the Trans object
and release it in the working space below the Trans object. A Step object is now created there.
If you draw a connection from the Step objects lower pin, another Trans object is created.
If you want a branch of the sequence, you draw an additional connection from the lower pin of
the Step object. Now a step divergens is created with specific StepDiv connections. If you in
the same manner creates a branch from a Trans object, by drawing to two connections from the
lower pin, a parellell branch, with TransDiv connections marked with double lines is created.
If you draw a connection from the horizontal pin of a Step an Order object is created, and
so on. As you can see this is a fast way to build complex sequences.

<b>ScanTime
ScanTime feches the actual scantime, i.e. the time since the last lap.

<b>FirstScan
FirstScan i true the first lap of the plc execution after Proview startup. It is also true
after a soft restart.

<h1>Menu

File/Save <t><t>Save
File/Print/Documents <t><t>Print all documents.
File/Print/Overview  <t><t>Print an overview.
File/Print/Selected documents <t><t>Print selected documents.
File/Syntax  <t><t>Perform a syntax check of the code.
File/Build <t><t>Compile the program.
File/Plc Attributes <t><t>Open the Object editor for the PlcPgm object.
File/Delete Window  <t><t>Delete the plc window.
File/Save Trace <t><t>Save trace objects.
File/Restore Trace<t><t>Restore previously saved traceobjects.
File/Close <t><t>Close the window.

Edit/Undo Delete <t><t>Undo the last delete action.
Edit/Undo Select <t><t>Reset the select list.
Edit/Cut <t><t>Cut selected objects.
Edit/Copy <t><t>Copy selected object to the paste buffer.
Edit/Paste <t><t>Copy the paste buffer to the work area.
Edit/Connect <t><t>Connect selected object to the selected signal or attribute
             <t><t>in the configurator.
Edit/Delete <t><t>Delete selected objects.
Edit/Change Text <t><t>Change text in the selected text object.
Edit/Expand Object <t><t>Expand the selected object.
Edit/Compress Object <t><t>Compress the selected object.

Search/Object <t><t>Search for an object name.
Search/String <t><t>Search for a string.
Search/Next <t><t>Search further with the same string.

View/Palette/Object <t><t>Display the functions object palette.
View/Palette/Connection <t><t>Display the connection palette.
View/Palette/Plant <t><t>Display the plant hierarchy.
View/Reference connections <t><t>Create connections as reference connections.
View/Grid Size <t><t>Set grid size.
View/Show Grid <t><t>Show the grid.
View/Zoom/In <t><t>Zoom in.
View/Zoom/Out <t><t>Zomm out.
View/Zoom/Reset <t><t>Reset to original zoom factor.
View/Show Execute Order <t><t>Show execute order for the functions objects.
View/Redraw <t><t>Redraw connections and redraw the window.

Functions/Open Object <t><t>Open the object editor for the selected object.
Functions/Subwindow <t><t>Open the subwindow for the selected object.

Mode/View <t><t>View mode.
Mode/Edit <t><t>Edit mode.
Mode/Trace <t><t>Trace mode.
Mode/Simulate <t><t>Simulate mode.

<h1>Mouse functions
<h2>Working area
Click MB1 <t><t>Select an object. Click in an empty space will reset the select list.
Shift/Click MB1 <t><t>Add object to the select list.
DoubleClick MB1 <t><t>Open object editor.
Shift+Ctrl/DoubleClick MB1 <t><t>Copy to paset buffer. Click in an object
                <t><t>copies the object, click in empty space copies selected objects.
Drag MB1 <t><t>On an object: move object or move selected objects.
         <t><t>In empty space: select objects inside the marked rectangle.
Shift/Drag MB1 <t><t>Add objects inside the marked rectangle to the select list.

Click MB2 <t><t>Create object.
DoubleClick MB2 <t><t>Delete. Click in object deletes the object, Click
          <t><t>in empty space deletes all the selected objects.
Shift+Ctrl/Click MB2 <t><t>Paste. Copy the paste buffer to the working area.
Shift+Ctrl/DoubleClick MB2 <t><t>Cut. Click in an object deletes the object, click
          <t><t>in an empty space deletes selected objects. Deletet object are put
          <t><t>in the paste buffer.

Press MB3 <t><t>Popup menu.

<h2>Navigation window
Drag MB1 <t><t>Scroll working area.
Drag MB2 <t><t>Zoom working area.
</topic>
</chapter>

<chapter>
<topic> classeditor
Class editor

<option> printdisable
Documentation of classes<link> class docblock
<option> printenable
</topic>

<headerlevel>
<topic>class docblock
Documentation of classes

For $ClassDef and $Attribute objects, there is a documentation block, that is filled in from
the object editor. The documentations block, together with the class description, is used
when classdocumentation is generatated to xtthelp or html format.

The documentation block for the $ClassDef object should contain a description of the class, 
and the documentation block for the $Attribute object a description of the attribute.

<option> printdisable
Genererate Xtt helpfiles <link> class generate xtthelp
Genererate html documentation <link> class generate html
ClassDef <link> docblock classdef
Attribute <link> docblock attribute
c- and h-files <link> docblock ccode
<option> printenable
</topic>

<headerlevel>

<topic> class generate xtthelp
Generate Xtt helpfiles

Helpfiles for xtt is generated with the command

<c>co_convert -xv -d $pwrp_exe/ $pwrp_db/userclasses.wb_load

The command generates a helpfile $pwrp_exe/'volumename'_xtthelp.dat, and it is proper to put
a link to the file in the xtt helpfile for the project $pwrp_exe/xtt_help.dat:

Example for the classvolume cvolvhxn2r

<i><topic> index

<i>...

<i>User classes<link>cvolssabtest,"",$pwrp_exe/cvolvhxn2r_xtthelp.dat

<i></topic>

...

<i><include> $pwrp_exe/cvolssabtest_xtthelp.dat
</topic>

<topic> class generate html
Generate html documentation

html files are generated by the command

<c>co_convert -wv -d $pwrp_web/ $pwrp_db/userclasses.wb_load

The command genenrates, among others, the file $pwrp_web/'volumename'_index.html that contains
the start page for the class documentation. This, together with the other files
($pwrp_web/'volumename'_*.html) should be copied to a proper directory of the web server.

A link to the documentation is made with a WebLink object pointing at the URL
'volumename'_index.html.

If you wantn to be able to show the c struct for the classes, you convert the h-file with
co_convert

<c>co_convert -cv $pwrp_web/ $pwrp_inc/'volymsnamn'classes.h

If you also want to be able to display the code of plc-objects, you have to add aref tags
in the c or h file of the code, and convert it with

<c>co_convert -sv -d $pwrp_web/ 'filnamn'
</topic>

<topic> docblock classdef
ClassDef

<h2>Example

<c>@Author Homer Simpson
<c>@Version 1.0
<c>@Code ra_plc_user.c
<c>@Summary Brief description of this class
<c>Description of
<c>this class.
<c>
<c>See also 
<c>@link Example plat.html
<c>@classlink AnotherPlate cvolvhxn2r_anotherplate.html

<h2>Tags
Author  <t>Author or the class description <link> docblock author
Version <t>Version of the class <link> docblock version
Code    <t>File that contains the code for the class <link> docblock code
Summary <t>Summary <link> docblock summary
Link    <t>Arbitrary link <link> docblock link
Classlink <t>Link to another class <link> docblock classlink
wb_load syntax <link> docblock wb_load classdef
</topic>

<headerlevel>
<topic> docblock author
@Author

Author. Optional.

<b>Syntax
<c>@Author 'name of author'
</topic>

<topic> docblock version
@Version

Version. Optional.

<b>Syntax
<c>@Version 'version number'
</topic>

<topic> docblock code
@Code

For classes with plc-code you can state the name of the c-file. Optional.
Also the c-file has to be converted by the command: co_convert -c -d $pwrp_web/'filename'

<b>Syntax
<c>@Code 'filename'
</topic>

<topic> docblock summary
@Summary

Short description in one line. Optional.
This is shown in the indexfile in the xtt helpfile. Not used in html.

<b>Syntax
<c>@Summary 'text'
</topic>

<topic> docblock link
@Link

A link to an arbitrary URL. Is only displayed in the html documentation, not in Xtt.
The link should lay after the description of the class.

<b>Syntax
<c>@Link 'URL'
</topic>

<topic> docblock classlink
@Classlink

A link to another class. This link work in both html and xtt.
The link should lay after the description of the class.

<b>Syntax
<c>@Classlink 'html-filename'
</topic>

<topic> docblock wb_load classdef
wb_load syntax

The documentation of a class i written above the $ClassDef row.

<c>!
<c>!/**
<c>!  @Author Homer Simpson
<c>!  @Version 1.0
<c>!  @Code ra_plc_user.c
<c>!  @Summary Brief description of this class
<c>!  Description of
<c>!  this class.
<c>!
<c>!  See also 
<c>!  @link Example plat.html
<c>!  @classlink AnotherPlate cvolvhxn2r_anotherplate.html
<c>!*/
<c>!
<c>Object        Plat    $ClassDef 1

<h2>!/**
Start of a documentation block.
All the text between !/** and !*/ will be written as a description of the class.

<h2>!*/
End of a documentation block.
</topic>
</headerlevel>

<topic> docblock attribute
Attribute

<h2>Example
<c>@Summary Plåtens längd
<c>En grundligare beskrivning
<c>av attributet Langd...


<h2>@Summary
Short description in one line. If there is a @Summary, this text is put into the table of
attributes in the html file. If there is no summary, the whole description is written instead.
Not used in xtt.

wb_load syntax <link>docblock wb_load attribute
</topic>

<headerlevel>
<topic> docblock wb_load attribute
wb_load syntax

Documenation of an attribute in written above the $Attribute, $Input, $Output or $Intern line.

<c>      !/**
<c>      !  @Summary Plåtens längd
<c>      !  En grundligare beskrivning
<c>      !  av attributet Langd...
<c>      !*/
<c>      Object    Langd $Attribute 3
<c>        Body             SysBody
<c>          Attr           TypeRef = "pwrs:Type-$Float32"
<c>        EndBody
<c>      EndObject

<h2>!/**
Start of a documentation block.
All the text between !/** and !*/ will be written as a description of the attribute.

<h2>!*/
End of a documentation block.
</topic>
</headerlevel>

<topic> docblock ccode
Syntax for c- and h-files
If you want to use the links to c- and h-files, these also have to be converted to html.
There is also a function to add bookmarks.

The structfile for the classes are automatically generated with bookmarks.

<c>/**
<c>   MyPlcClass
<c>
<c>   Description for the class that is not displayed anywhere but in the code.
<c>
<c>   @aref MyPlcClass MyPlcClass
<c>*/
<c>void MyPlcClass_exec(...)

<h2>@aref
@aref has to lay insice a /*_* ... */ block. Inside the block, there can also be comments
that are not handled by the converter.

<b>Syntax
<c>@aref 'bookmark' 'text' 
</topic>
</headerlevel>
</headerlevel>
</chapter>

<chapter>
<TOPIC> helpfile
Helpfile

Helptexts are displayed in the help window that can be opened from the configurator and the
operator environment. Helptext are written in a file $pwrp_exe/xtt_help.dat. The help texts
are divided in topics, and each topic has a key, that is specified when the help text for
the topic is to be displayed. Links in the helptext, that points to other topics, makes it 
possible to navigate in the helptexts.

The topic 'index' is the root topic that is displayed from different utilities

- 'Help/Project' in the configurator menu.
- 'Help/Project' in the runtime navigator.
- The 'Help' button in the operator window.

Specific help topics can be opened from Ge graphs by buttons (actiontype Help), or from the 
popup menu for an object in the operator environment (method 'Help').

<b>Syntax <link> helpfile syntax
<b>Conversion <link> helpfile conversion
</topic>

</headerlevel>
<topic> helpfile conversion
Conversion
The helptext can be converted to html, PDF and PostScript format. When converted to html, each
topic is converted to one html page. When converted to PDF and PoscScript, there are a number
of additional tags available, to create a document of the helptext with with chapters and 
headers.

The conversion is done by 'co_convert'.

<h2>Conversion to html
A helpfile is converted to html with the command

<c>co_convert -f [-d outputdirectory] 'helpfile'

<b>Example
<c>co_convert -f -d $pwrp_web $pwrp_exe/xtt_help.dat

<h2>Conversion to postscript
A helpfile is converted to PostScript with the command

<c>co_convert -n [-d outputdirectory] 'helpfile'

<b>Example
<c>co_convert -n -d $pwrp_lis $pwrp_exe/xtt_help.dat

<h2>Conversion to PDF
A helpfile is converted to PDF with the command

<c>co_convert -f [-d outputdirectory] 'helpfile'

<b>Example
<c>co_convert -f -d $pwrp_lis $pwrp_exe/xtt_help.dat
</topic>

<topic> helpfile syntax
Syntax
There are a number of different tags that influence the search
and the conversion of the helpfile.

topic     <t>Defines the helptext for a topic<link> topic
bookmark  <t>Defines a position inside a topic<link> bookmark
link      <t>Link to a topic or an URL<link> link
index     <t>List of topics<link> helpindex
h1        <t>Header 1 <link> header1
h2        <t>Header 2 <link> header2
b         <t>Bold text <link> bold
t         <t>Tab <link> helptab
hr        <t>Horizontal line<link> hr
include   <t>Include other helpfiles<link> include

<h2>PDF and PostScript tags
The following tags are used to format the helptexts when converted to PDF and PostScript

chapter   <t>Divide topics in chapters<link> chapter
headerlevel <t>Increase or decrease header level <link> headerlevel
pagebreak <t>New page<link> pagebreak
option    <t>Options<link> option
style     <t>Specific text style <link> style

<b>Example <link> helpfile example
</topic>

<headerlevel>
<topic> topic
Topic
<ib><topic>
<i><topic> begin a topic and should be placed in the first position
<i>of a line. The topic-tag should be followed by the key that
<i>the help function will search for. All the following lines untill
<i> a </topic> tag will be displayed as text for the topic.

<i><topic> 'key'


<ib></topic>
<i>End a topic. </topic> should be placed in the first position 
<i>of a line.

<b>Example
<i><topic> start engine
The engine will be started by...
<i></topic>

The command

<c>wtt> help start engine

will display the text of this topic.
</topic>

<topic> bookmark
Bookmark
<ib><bookmark>
Bookmark is a line inside a topic which can be found by a link-tag or the /bookmark qualifier
in the help command. The bookmark tag should be placed at the end of the line and should be 
followed by a name.

<i>'some text' <bookmark> 'name'

<b>Example
<i>This is a bookmark. <bookmark> first_engine

The command

<c>wtt> help start engine/bookmark=first_engine

will display the text of the topic and scroll to the bookmark.
</topic>

<topic> link
Link
<ib><link>
<i>The <link> tag is a link to another help topic. The <link> tag should be placed at the 
end of the line. When the line of the link is activated the topic of the link will be 
displayed. The link tag should be followed by the topic, and can also be followed by a 
bookmark and the helpfile where the topic reside, separated with comma. If a line contains 
a link, is will be marked with an arrow.

<i>'some text'   <link> 'topic'[,'bookmark'][,'helpfile']

<b>Example
<i>Link to first engine <link> show engine, first_engine
</topic>

<topic> helpindex
Index
<ib><index>
<i>The <index> tag is a special link that will display an index of
<i>the helpfile, that is a list of all the topics in alpabetical order.

<i>'some text' <index>
</topic>

<topic> header1
Header1
<ib><h1>
<i>The <h1> tag will display a line as a header with larger text size. 
<i>The tag should be placed at the beginning of the line. A header line 
<i>can't contain any links.

<i><h1>'header text'

<b>Example
<i><h1>This is a h1 header
will be displayed as
<h1>This is a h1 header
</topic>

<topic> header2
Header2
<ib><h2>
<i>The <h2> tag will display a line as a header with bold text surrounded
<i>by grey lines. The tag should be placed at the beginning of the line. 
<i>A header line can't contain any links.

<b>Example
<i><h2>This is a h2 header
will be displayed as
<h2>This is a h2 header
</topic>

<topic> bold
Bold
<ib><b>
<i>The <b> tag will display a line with bold text.
<i>The tag should be placed at the beginning of the line. 

<b>Example
<i><b>This is a bold line
will be displayed as
<b>This is a bold line
</topic>

<topic> helptab
Tab
<ib><t>
<i>The <t> tag makes i possible to write columns. Only three columns
<i>(two <t> tags) is allowed.

<b>Example
<i>Col1 <t> Col2 <t> Col3
will be displayed as
Col1 <t> Col2 <t> Col3
</topic>

<topic> hr
Horizontal line
<ib><hr>
<i>The <hr> tag will display a horizontal line.
<i>The tag should be placed at the beginning of the line. 

<b>Example
<i><hr>
will be displayed as
<hr>

</topic>

<topic> include
Include
<ib><include>
<i>Includes another helpfile. The <include> tag should not be placed
<i>inside a topic.

<i><include> 'filname'
</topic>

<topic> chapter
Chapter
<ib><chapter>
<i>This tag divides the topics in chapters. A chapter beginns with <chapter> and ends with
<i></chapter>. The title of the first topic in the chapter will be the header of the chapter.

<ib></chapter>
Ends a chapter.

<b>Example
<i><chapter>
<i><topic>
<i>Introduction
<i>...
<i></topic>
<i></chapter>
</topic>

<topic> headerlevel
Headerlevel
Divides the topics in a chapter in header levels. 

<ib><headerlevel>
Increases the header level

<ib></headerlevel>
Descreases the headerlevel
</topic>

<topic> pagebreak
Pagebreak
<ib><pagebreak>
Forces a pagebreak.
</topic>

<topic> option
Option
<ib><option>
Option can have the values

printdisable <t>Ignore the tags and text untill the next 'printenable' in PDF 
             <t>and PostScript files. Normally used for links that has no effect
             <t>in PDF and PostScript.
printenable  <t>Reset the 'printdisable'.

<b>Example
<i><option> disable
<i>Some text
<i>...
<i><option> enable
</topic>

<topic> style
Style
<ib><style>
Specifies that a topic should be written in e specific style.
<b>Styles
function	<t>Style used for functions and commands. Large title and pagebreak after 
                <t>each topic.

<b>Example
<i><topic> MyFunction <style> function
...
<i></topic>
</topic>

<topic> helpfile example
Helpfile example
<i><topic> helpfile_example
<i>Start and stop of engines.

<i>Engine 1 <link> helpfile_example, bm_engine_1
<i>Engine 2 <link> helpfile_example, bm_engine_2
<i>Characteristics <link> helpfile_example, bm_char

<i><h1>Engine 1 <bookmark> bm_engine_1
<i>Start engine one by pressing the start button.
<i>Stop engine one by pressing the stop button.

<i><h1>Engine 2 <bookmark> bm_engine_2
<i>Start engine two by pressing the start button.
<i>Stop engine two by pressing the stop button.

<i><h2>Characteristics <bookmark> bm_char

<i><b><t>Engine1 <t>Engine2
<i>Max speed <t> 3200 <t> 5400
<i>Max current <t> 130 <t> 120
<i></topic>

This is the outlook of this example <link>helpfile_example
</TOPIC>

<headerlevel>
<topic> helpfile_example
Start and stop of engines.

Engine 1 <link> helpfile_example, bm_engine_1
Engine 2 <link> helpfile_example, bm_engine_2
Characteristics <link> helpfile_example, bm_char

<h1>Engine 1 <bookmark> bm_engine_1
Start engine one by pressing the start button.
Stop engine one by pressing the stop button.

<h1>Engine 2 <bookmark> bm_engine_2
Start engine two by pressing the start button.
Stop engine two by pressing the stop button.

<h2>Characteristics <bookmark> bm_char

<b><t>Engine1 <t>Engine2
Max speed <t> 3200 <t> 5400
Max current <t> 130 <t> 120
</topic>
</headerlevel>
</headerlevel>
</headerlevel>
</chapter>
<chapter>
<topic>users
Users

This chapter describes how to create at user in proview, and how to grant privileges and 
access for the user.

The increasing availability of Proview system for different type of users, for example via the
itranet, has resulted in increasing demands of possibilities to limit the possibility for
various users to influence the system. Proview contains a user database, where you define
the users for different systems, and where you have the possibility to group systems with
common users. The database is designed to face the demands of increasing access control, and
att the same time keep the administration on an low level.

User database <link> userdatabase
Example <link> user example
Login <link> user login
pwr_user <link> pwr_user
</topic>

<headerlevel>
<topic>userdatabase
User database

The user database is populated by system groups and users. When a proview utility is started,
for example the opeator or development environment, there is a check that the user exist in
the database, and the privileges of the user are registred. The privileges determine what
a user is allowed to do in the system.

<h1>Systemgroup
The concept system group is introduced to not have to define every system in the database.
Instead you define system groups, and connect number of systems to each system group. These
system will share users.

The database is built of an hierarchy of system groups. The hierarchy has to functions, to
describe the connection between different system groups, and to introduce heritage between
system groups. The systemgroups lower in the hierarchy, can inherit attributes and users from
systemgroups higher in the hierarchy.

If a systemgroup will inherit users or not, is determined by the attribut UserInherit. If
the attribute is set, the systemgroup will inherit all users from its parent usergroup.
Also the users the parent has inherited from its parent, are inherited. A systemgroup can
override an inherited user by defining the username in its own systemgroup.

A systemgroup is refered to by the 'path'-name in the hierarchy, where the names are separated
by points, e.g. 'ssab.hql.se1', where ssab is the root group, and se1 the lowest level in the
hierarchy.

A Proview system is connected to a system group by stating the systemgroup in the System 
objekt. If the systemgroup is not present in the user database, though a parent or ancestor
is, it is supposed that the systemgroup inherits users from the ancestor.

<h2>Attributes
<b>Attribute <t>Description
UserInherit <t>The system group inherits users fro its parent systemgroup, also users
            <t>that the parent has inherited.

<h1>Users
A user is characterized by a username, a password and a set of privileges. A user is also
connected to a system group.

The privileges defines what a user is allowed to do in proview. Some privileges influences
the access to make changes from proview utilities, e.g. the navigator or plc-editor, some
regards the construction of operators graphics, to control which input fields and pushbuttons
a user can influence.

A username can be connected to several system groups, but from the databse point of view,
they are different users, with unic passwords and privileges. They just happen to have the
same username.

<h2>Privileges
<b>Privilege <t>Description
RtRead    <t>Read access to rtdb. Default privileges for user that is not logged in.
RtWrite   <t>Write access to rtdb. Allows user to modify rtdb from xtt and Simulate mode
          <t>in trace.
System    <t>Privilege for system manager.
Maintenance <t>Privilege for maintenance technician.
Process   <t>Privilege for process technician.
Instrument <t>Privilege for instrument technician.
Operator1 <t>Privilege for operator.
Operator2 <t>Privilege for operator.
Operator3 <t>Privilege for operator.
Operator4 <t>Privilege for operator.
Operator5 <t>Privilege for operator.
Operator6 <t>Privilege for operator.
Operator7 <t>Privilege for operator.
Operator8 <t>Privilege for operator.
Operator9 <t>Privilege for operator.
Operator10 <t>Privilege for operator.
DevRead   <t>Read access to the workbench.
DevPlc    <t>Write access in the plc editor.
DevConfig <t>Write access in the configurator.
DevClass  <t>Write access in class editor (not yet implemented)
</topic>

<topic> user example
Exempel
Proview user database V1.0.0

<c>ssab
<c>. . . . . . sysansv    System DevRead DevPlc DevConfig (14680068)
<c>. . . . . . skiftel    Maintenance DevRead (2097160)
<c>. . . . . . 55         Operator1 (64)
<c>. hql                  UserInherit
<c>. . . . . . anna       RtWrite Operator4 (514)
<c>. . bl2
<c>. . . . . . anna       Operator4 (512)
<c>. . bl1                UserInherit
<c>. . . . . . 55         Operator1 (64)
<c>. . . . . . carlgustav Operator8 (8192)
<c>. hst
<c>. . . . . . magnus     Operator1 (64)
<c>. . rlb                UserInherit     
<c>. . . . . . amanda     Operator4 (512)

Look at the example above. This is a listing of an user database. To the left, you see the
system groups, and the number of ponts marks their level in the hierarchy. In the same row
the attribute of the system group is written. Under each systemgroup, its users with
privileges is found. Thus the systemgroup ssab has the users sysansv, skiftel and 55.

The systemgroup sasb.hql.bl1 has the attribut UserInherit, which results in that it inherits
users from its parent. Also the parent ssab.hql has UserInherit, i.e. ssab.hql.bl1 also
inherits from ssab. The users of ssab.hql.bl1 is then, sysansv, skiftel, anna 55 and 
carlgustav. Here the user 55 of sasb.hql.bl1 overrides the user 55 of ssab.

The systemgroup ssab.hql.bl2 lacks UserInherit and has only the user anna.

The systemgroup ssab.hst.rlb has UserInherit and inherits from its parent ssab.hst. Though,
this has not UserInherit and has not inherited from its parent ssab. The users for 
ssab.hst.rlb is then amanda and magnus.

A system with the systemgroup sandviken.hql will be denied access because the systemgroup and
all its ancestors is missing.

A system with the systemgroup ssab.vwx.n2 will inherit users from the systemgroup ssab,
i.e. sysansv, skifel and 55. All systemgroups don't have to be present in the database, the
existance of an ancestor is enough. The ones that are not found are supposed to have the
attribute UserInherit.
</topic>

<topic> user login
Login

This sections desribes how Login and access control works in different proview environments.

<h1>Development environment
When starting the configurator, a login window is opened where you kan state username and
password. You can also give the username and password as arguments to the workbench if you
want to avoid the login procedure. To open the configurator, you need the privilege DevRead,
and to enter edit mode, you ned DevWrite. To edit in the plc editor, you ned DevPlc.

<h1>Operator environment
When the operator environment is started with an OpPlace as argument, the user is fetched from
the UserName attribute in the corresponding User object. To make modifications in the 
databas from the runtime navigator, the privilege RtWrite is required. In the process graphics
there are pushbuttons, sliders etc. from which you influence the database. These objects have
an access attribute, that determines which privileges are required to activate the object.
These privileges are matched to the users privileges, and if he isn't granted any of them,
he is denied access.

From the runtime navigator, you can with the login/logut command, login as another user and
thereby change your privileges.

<h1>Process graphics on the intranet
For process graphics on the web there is a special login frame that can be added to the
start menu of a system page. The login frame checks the username and password. 
</topic>

<topic> pwr_user
pwr_user

You use pwr_user to create systemgroups and users in the user database.
The configuration is performed with commands.

pwr_user is started from the command prompt.

Below is a description of the different command available to create, modify and list
systemgroups and users.

add group <t>Add a system group <link> pwr_user add group
add user  <t>Add a user <link> pwr_user add user
get       <t>Get a user<link> pwr_user get
list      <t>List systemgroups and users <link> pwr_user list
load      <t>Load the latest saved database <link> pwr_user load
modify group <t>Modify a system group <link> pwr_user modify group
modify user  <t>Modify a user <link> pwr_user modify user
remove group <t>Remove a system group <link> pwr_user remove group
remove user  <t>Remove a user <link> pwr_user remove user
save      <t>Save <link> pwr_user save
su        <t>Login as super user <link> pwr_user su
</topic>

<headerlevel>
<topic>pwr_user add
add

add group <link> pwr_user add group
add user <link> pwr_user add user
</topic>

<headerlevel>
<topic> pwr_user add group
add group

Create a systemgroup

<c>pwr_user> add group 'name' [/nouserinherit]

/nouserinherit <t>The attribute UserInherit is not set for the systemgroup.
        <t>As default UserInherit is set.
</topic>
<topic> pwr_user add user
add user
Create a user.

pwr_user> add user 'name' /group= /password= [/privilege=]
	[/rtread][/rtwrite][/system][/maintenance][/process]
[/instrument][/operator1][/operator2]...[oper10][/devread]
[/devplc][/devconfig][/devclass]

/group <t>Systemgroup of the user.
/password <t>Password of the user.
/privilege <t>Privileges if this is supplied as a mask, i.e an integer value.
/rtread <t>The user is granted RtRead.
/rtwrite <t>The user is granted RtWrite.
/system <t>The user is granted System.
/maintenance <t>The user is granted Maintenance.
/process <t>The user is granted Process.
/operator1 <t>The user is granted Operator1.
...
/operator9 <t>The user is granted Operator9.
/operator10 <t>The user is granted Operator10.
/devread <t>The user is granted DevRead.
/devplc <t>The user is granted DevPlc.
/devconfig <t>The user is granted DevConfig.
/devclass <t>The user is granted DevClass.
</topic>
</headerlevel>

<topic> pwr_user get
get

Fetches a user with an algorithm used in runtime.

pwr_user> get 'username' /group= /password=
</topic>

<topic> pwr_user list
list

List systemgroups and users.

pwr_user> list
</topic>

<topic> pwr_user load
load

Load the latest saved database and revert the current session.
</topic>
<topic> pwr_user modify
modify

modify group <link> pwr_user modify group
modify user <link> pwr_user modify user
</topic>

<headerlevel>
<topic> pwr_user modify group
modify group

Modify a systemgroup.

<c>pwr_user> modify group 'name' /[no]userinherit

/userinherit <t>Sets the attribute UserInherit that states that the systemgroup
             <t>inherits users form its parent in the systemgroup hierarchy.
             <t>Negated with /nouserinherit
</topic>

<topic> pwr_user modify user
modify user

Modify a user.

<c>pwr_user> modify user 'name' /group= [/password=][/privilege=]
<c>	[/rtread][/rtwrite][/system][/maintenance][/process]
<c>     [/instrument][/operator1][/operator2]...[oper10][/devread]
<c>     [/devplc][/devconfig][/devclass]

/group <t>Systemgroup of the user.
/password <t>Password of the user.
/privilege <t>Privileges if this is supplied as a mask, i.e an integer value.
/rtread <t>The user is granted RtRead.
/rtwrite <t>The user is granted RtWrite.
/system <t>The user is granted System.
/maintenance <t>The user is granted Maintenance.
/process <t>The user is granted Process.
/operator1 <t>The user is granted Operator1.
...
/operator9 <t>The user is granted Operator9.
/operator10 <t>The user is granted Operator10.
/devread <t>The user is granted DevRead.
/devplc <t>The user is granted DevPlc.
/devconfig <t>The user is granted DevConfig.
/devclass <t>The user is granted DevClass.
</topic>
</headerlevel>

<topic> pwr_user remove
remove

remove group <link> pwr_user remove group
remove user <link> pwr_user remove user
</topic>

<headerlevel>
<topic> pwr_user remove group
remove group
Remove a system group.

<c>pwr_user> remove group 'name'
</topic>

<topic> pwr_user remove user
remove user

Remove a user.

<c>pwr_user> remove user 'name' /group=
</topic>
</headerlevel>

<topic> pwr_user save
save
Save the current session.

<c>pwr_user> save
</topic>

<topic> pwr_user su
su

Login as super user. As super user you can se password for users when listing the database.
su requires password.

<c>pwr_user> su 'password' 
</topic>
</headerlevel>
</headerlevel>
</chapter>

<chapter>
<TOPIC> help command
Wtt commands

<b>exit        <t>close wtt			<LINK> exit
<b>edit        <t>set edit mode			<LINK> edit
<b>close graph <t>Close a Ge graph		<LINK> close graph
<b>compile    <t>Compile plcpgm			<LINK> compile
<b>configure card<t>Configure a card object	<LINK> configure card
<b>connect    <t>Connect signal and channel	<LINK> connect
<b>copy       <t>Copy selected object trees 	<LINK> copy
<b>copy object<t>Copy an object			<LINK> copy object
<b>create bootfiles <t>Create bootfiles		<LINK> create bootfiles
<b>create loadfiles <t>Create loadfiles		<LINK> create loadfiles
<b>create object <t>Create an object		<LINK> create object
<b>create structfiles <t>Create structfiles	<LINK> create structfiles
<b>create volume <t>Create a volume		<LINK> create volume
<b>create rttfiles <t>Create rttfiles		<LINK> create rttfiles
<b>cut		<t>Cut objects			<LINK> cut
<b>define      	<t>Define a symbol		<LINK> define
<b>delete object <t>Delete an object		<LINK> delete object
<b>delete tree	<t>Delete an object tree	<LINK> delete tree
<b>delete volume<t>Delete a volume		<LINK> delete volume
<b>disconnect 	<t>Disconnect signal and channel <LINK> disconnect
<b>display     <t>Display a window		<LINK> display
<b>help        <t>Display help			<LINK> help help
<b>generate web <t>Generate webpages		<LINK> generate web
<b>list channels<t>List channels		<LINK> list channels
<b>list descriptor<t>List from listdescriptor	<LINK> list descriptor
<b>list hierarchy<t>List hierarchy		<LINK> list hierarchy
<b>list plcpgm <t>List plcprogram		<LINK> list plcpgm
<b>list signals<t>List signals			<LINK> list signals
<b>login       <t>User login			<LINK> login
<b>logout      <t>User logout			<LINK> logout
<b>move object <t>Move an object		<LINK> move object
<b>new buffer  <t>Create a new buffer		<LINK> new buffer
<b>one         <t>One window			<LINK> one
<b>open buffer <t>Open buffer selection window	<LINK> open buffer
<b>open graph  <t>Open a Ge graph		<LINK> open graph
<b>paste       <t>Paste buffer			<LINK> paste
<b>print      <t>Print plcpgm			<LINK> print
<b>redraw     <t>Redraw plcpgm			<LINK> redraw
<b>release subwindow <t>Continue execution with graph in window object. <LINK>release subwindow
<b>revert      <t>Revert session		<LINK> revert
<b>save        <t>Save session			<LINK> save
<b>search      <t>Search 			<LINK> search
<b>set advanceduser<t>Set advanced user	<LINK> set advanceduser
<b>set alltoplevel<t>Display all toplevel objects <LINK> set alltoplevel
<b>set attribute<t>Set object attributes 	<LINK> set attribute
<b>set db      <t>Set database 			<LINK> set db
<b>set inputfocus<t>Set input focus to window 	<LINK> set inputfocus
<b>set showalias<t>Display alias name 		<LINK> set showalias
<b>set showattrref<t>Display attribute references <LINK> set showattrref
<b>set showattrxref<t>Display attribute x-references <LINK> set showattrxref
<b>set showclass<t>Display object class 	<LINK> set showclass
<b>set showdescription<t>Display description 	<LINK> set showdescription
<b>set showobjref<t>Display object references 	<LINK> set showobjref
<b>set showobjxref<t>Display object x-references <LINK> set showobjxref
<b>set subwindow <t>Open a graph in a window object <LINK>set subwindow
<b>set template<t>Set template values for objects <LINK> set template
<b>set verify  <t>Script verification	 	<LINK> set verify
<b>set window  <t>Set window width and height 	<LINK> set window
<b>set volume  <t>Set volume 			<LINK> set volume
<b>setup       <t>Wtt setup			<LINK> setup
<b>show children<t>Show the children of an object <LINK> show children
<b>show license <t>Show license terms		<LINK> show license
<b>show object  <t>Show an object		<LINK> show object
<b>show objid  <t>Show object identity		<LINK> show objid
<b>show script <t>Show scriptfiles		<LINK> show script
<b>show symbol <t>Show a symbol			<LINK> show symbol
<b>show user   <t>Show current user		<LINK> show user
<b>show version<t>Show wtt version		<LINK> show version
<b>show volumes<t>Show all volumes in the database <LINK> show volumes
<b>sort       <t>Sort the children of an object <LINK> sort
<b>two         <t>Two windows			<LINK> two
<b>wb dump    <t>Dump objects to textfile	<LINK> wb dump
<b>wb export  <t>Write objects to textfile	<LINK> wb export
<b>wb import  <t>Load exported objects from textfile <LINK> wb import
<b>wb load    <t>Load objects from textfile	<LINK> wb load

<b>Symbols <link> symbol

<H2>related subjects
script <LINK> script
</TOPIC>	


<TOPIC> exit <style> function
Command   exit

Close wtt.

<B>wtt> exit
</TOPIC>

<TOPIC> edit <style> function
Command   edit

Enter or leave edit mode.

<B>wtt> edit
<B>wtt> noedit
</TOPIC>

<TOPIC> define <style> function
Command define

Define a symbol.

<B>wtt> define 'symbolname' 'text'

<h2>related subjects
symbol <LINK> symbol
show symbol <LINK> show symbol
symbolfile <LINK> symbolfile
</TOPIC>	

<TOPIC> help help <style> function
Command   help

Display help information for a subject.
The help information will be searched for in a help file. The file can be the base helpfile, 
the project helpfile or another help file.

If no helpfile is supplied the subject will be searched for in the base and project helpfiles.

<B>wtt> help 'subject'
<B>wtt> help 'subject' /file=

/file<t>A help file that contains information of the help subject.

<H2>related subjects
helpfile <LINK> helpfile
</TOPIC>

<TOPIC> login <style> function
Command   login

Login with username an password. The privileges of the user will be
fetched from the user database, and affect the access to the system.

<B>wtt> login 'username' 'password'

If you want to create or modify a project, user or register a volume,
you login as administrator with the qualifier /administrator. You must
specify a user in the systemgroup 'administrator'. If this systemgroup
doesn't exist, usename and password is not required.

<B>wtt> login /administrator 'username' 'password'

<H2>related subjects
logout <LINK> logout
show user <LINK> show user
</TOPIC>

<TOPIC> logout <style> function
Command   logout

Logout a user, and return to the original user.

<B>wtt> logout

<H2>related subjects
login <LINK> login
</TOPIC>

<TOPIC> set advanceduser <style> function
Command   set advanceduser

Set or reset advanced user.

<B>wtt> set advanceduser
<B>wtt> set noadvanceduser

<H2>related subjects
advanced user <LINK> advanced user
</TOPIC>

<TOPIC> set alltoplevel <style> function
Command   set alltoplevel

Show all the root objects in the database, not only the
root objects defined for the plant hierarchy or the
node hierarchy.

<B>wtt> set alltoplevel
<B>wtt> set noalltoplevel

</TOPIC>

<TOPIC> set showclass <style> function
Command   set showclass

Display the class of the object in the plant and node hierarchy.

<B>wtt> set showclass
<B>wtt> set noshowclass
</TOPIC>

<TOPIC> set showalias <style> function
Command   set showalias

Display the aliasname of the objects in the plant and node hierarchy.

<B>wtt> set showalias
<B>wtt> set noshowalias
</TOPIC>

<TOPIC> set showdescription <style> function
Command   set showdescription

Display the description of the objects in the plant and node hierarchy.

<B>wtt> set showdescription
<B>wtt> set noshowdescription
</TOPIC>

<TOPIC> set showobjref <style> function
Command   set showobjref

Display the number of connected object references of the objects in the 
plant and node hierarchy.

<B>wtt> set showobjref
<B>wtt> set noshowobjref
</TOPIC>

<TOPIC> set showobjxref <style> function
Command   set showobjxref

Display the number of connected object x-references of the objects in the 
plant and node hierarchy.

<B>wtt> set showobjxref
<B>wtt> set noshowobjxref
</TOPIC>

<TOPIC> set showattrref <style> function
Command   set showattrref

Display the number of connected attribute references
of the objects in the plant and node hierarchy.

<B>wtt> set showattrref
<B>wtt> set noshowattrref
</TOPIC>

<TOPIC> set showattrxref <style> function
Command   set showattrxref

Display the number of connected attribute x-references of 
the objects in the plant and node hierarchy.

<B>wtt> set showattrxref
<B>wtt> set noshowattrxref
</TOPIC>

<TOPIC> set verify <style> function
Command   set verify

Display all executed lines when running a script.

<B>wtt> set verify
<B>wtt> set noverify
</TOPIC>

<TOPIC> set inputfocus <style> function
Command   set inputfocus

Set input focus to the plant or the node hierarchy window (w1 or w2).

<B>wtt> set inputfocus w1
<B>wtt> set inputfocus w2
</TOPIC>

<TOPIC> set window <style> function
Command   set window

Set window width and height.

<B>wtt> set window /width= /height=

/width	<t>width in pixels.
/height <t>height in pixels.
</TOPIC>

<TOPIC> two <style> function
Command   two

Display two windows. Both the plant and the node hierarchy window are
displayed.

<B>wtt> two
</TOPIC>

<TOPIC> one <style> function
Command   one

Display one window. The window which currently owns the input
focus is kept.

<B>wtt> one
</TOPIC>

<TOPIC> setup <style> function
Wtt setup
Setup of wtt properies

DefaultDirectory<t><t>Default directory for commandfiles.
SymbolFilename	<t><t>Symbolfile.		<LINK> symbolfile
Verify		<t><t>Verify commandfile execution.
AdvancedUser	<t><t>User is advanced. <LINK> advanced user
AllToplevel	<t><t>Display all toplevel objects.
Bypass		<t><t>Bypass some edit restrictions.
</TOPIC>

<TOPIC> show version <style> function
Command   show version

Show the wtt version

<B>wtt> show version
</TOPIC>

<TOPIC> show license <style> function
Command   show license

Show license terms.

<B>wtt> show license
</TOPIC>

<TOPIC> show symbol <style> function
Command   show symbol

Show one symbol, or all symbols

<B>wtt> show symbol 'symbol'<t>Show symbol 'symbol'
<B>wtt> show symbol<t>              Show all symbols

<h2>related subjects
define <LINK> define
symbol <LINK> symbol
</TOPIC>

<TOPIC> show volumes <style> function
Command   show volumes

Show all volumes in the database.

<B>wtt> show volumes
</TOPIC>

<TOPIC> show children <style> function
Command   show children

Display en object and it's children

<B>wtt> show children /name=

/name	<t>Name of the parent object.
</TOPIC>

<TOPIC> show objid <style> function
Command   show objid

Show the objid of an object.
If name is ommitted, the objid of the current selected
object is shown.

<B>wtt> show objid [/name=]

/name	<t>Object name.
</TOPIC>

<TOPIC> save <style> function
Command   save

Save session.

<B>wtt> save
</TOPIC>

<TOPIC> revert <style> function
Command   revert

Revert session.

<B>wtt> revert
</TOPIC>

<TOPIC> display <style> function
Command   display

Display plant or node hierarchy window (w1 or w2).

<B>wtt> display w1
<B>wtt> display w2
</TOPIC>

<TOPIC> search <style> function
Command   search

Search for an objectname or a string.

<B>wtt> search 'object'
<B>wtt> search /regularexpression 'expression'
<B>wtt> search /next
</TOPIC>

<TOPIC> compile <style> function
Command   compile

Compile plcprograms.

If no hierarchy, plcpgm or window is specified, the selected plcpgm
will be compiled.


<B>wtt> compile [/debug]
<B>wtt> compile /plcpgm= [/debug]
<B>wtt> compile /window= [/debug]
<B>wtt> compile /hierarchy= [/debug][/modified][/from_plcpgm=]
<B>wtt> compile /volume= [/debug][/modified][/from_plcpgm=]
<B>wtt> compile /allvolumes [/debug][/modified][/from_plcpgm=]

/plcpgm		<t>Name of plcpgm object that will be compiled.
/window		<t>Name of plcwindow object that will be compiled.
/hierarchy	<t>All plcpgm's in the hierarchy will be compiled.
/volume		<t>Volume name. All plcpgm's in the volume will be compiled.
/allvolumes	<t>All plcpgm's in all volumes in the database will be compiled.
/debug		<t>Compile with debug.
/modified	<t>Only modified plcwindows will be compiled.
</TOPIC>

<TOPIC> configure card <style> function
Command   configure card

Create a card with channels.

<B>wtt> configure card /rack= /cardname= /channelname= /chanidentity=
<B>		<t>/chandescription= /table=

/rack		<t>Name of rack object that the card will belong to.

/cardname	<t>Name of card. Last segment of name.

/channelname	<t>Name of channel. Last segment of name.
		<t>A '#' will be replaced with the channel number.
		<t>For example /chan=di33## will give the channelnames
		<t>di3301, di3302... If there is more than one channel
		<t>channelname has to contain a '#' sign.

/chanidentity	<t>Identiy of the channel. Will be inserted into the Identity-
		<t>attribute of the channel.

/chandescripton	<t>Channel description. Will be inserted into the Description-
		<t>attribute of the channel.
</TOPIC>

<TOPIC> connect <style> function
Command   connect

Connect a signal and a channel.

<B>wtt> connect /source= /destination= [/reconnect]

/source		<t>A signal or channel object.
/destination	<t>A signal or channel object.
/reconnect	<t>If the source or destination already is connected
		<t>it will first be disconnected.
</TOPIC>

<TOPIC> disconnect <style> function
Command   disconnect

Disconnect a signal or a channel.

<B>wtt> disconnect /source=

/source		<t>A signal or channel object.
</TOPIC>

<TOPIC> copy <style> function
Command   copy

Copy selected object trees to paste buffer.

<B>wtt> copy [/keepreferences]

/keepreferences	<t>Keep references to objects outside the copied trees. By default
                <t>these references will be zeroed.
</TOPIC>

<TOPIC> cut <style> function
Command   cut

Copy selected object trees to paste buffer, and remove the objects
in the current volume.

<B>wtt> cut [/keepreferences]

/keepreferences	<t>Keep references to objects outside the copied trees. By default
                <t>these references will be zeroed.
</TOPIC>

<TOPIC> paste <style> function
Command   paste

Paste object from the last copy or cut operation into the current volume.
With the buffer option, an older paste buffer can be pasted.

<B>wtt> paste [/keepoid] [/buffer=]

/keepoid	<t>Keep the object identities if possible.
/buffer		<t>Name of the buffer that should be pasted. By default
		<t>the last buffer is used.
</TOPIC>

<TOPIC> new buffer <style> function
Command   new buffer

Create a new empty buffer.

<B>wtt> new buffer /name=

/name		<t>Name of the buffer
</TOPIC>

<TOPIC> open buffer <style> function
Command   open buffer

Open the buffer selection window.

<B>wtt> open buffer
</TOPIC>

<TOPIC> copy object <style> function
Command   copy object

Copy an object or an object tree.

<B>wtt> copy object /source= /destination= /name= [/hierarchy]
<B>		<t>[/first] [/last] [/after] [/before]

/source		<t>The object that will be copied.
/destination	<t>The parent or sibling to the created object.
/name		<t>The name of the created object. Last segment.
/hierarchy	<t>If the source-object has children, the child tree
		<t>will also be copied.
/first		<t>The object will be inserted as first child to
		<t>the destination object.
/last		<t>The object will be inserted as last child to
		<t>the destination object.
/after		<t>The object will be inserted as sibling after
		<t>the destination object.
/before		<t>The object will be inserted as sibling before
		<t>the destination object.
</TOPIC>

<TOPIC> create bootfiles <style> function
Command   create bootfiles

Create new bootfiles.

<B>wtt> create bootfiles /nodeconfig= [/debug]
<B>wtt> create bootfiles /allnodes [/debug]

/nodeconfig	<t>The name of the NodeConfig-object of the
		<t>node for which nodefile will be created.

/all		<t>Create bootfiles for all nodes in the project.

/debug		<t>Link plcprogram with debug.
</TOPIC>

<TOPIC> create loadfiles <style> function
Command   create loadfiles

Create loadfiles for a volume.

<B>wtt> create loadfile /volume=
<B>wtt> create loadfile [/class] [/all]

/volume		<t>Create loadfiles for a specific volume.

/all		<t>Create loadfiles for all root volumes
		<t>in the database.

/class		<t>Create loadfiles for all classvolumes in the database.
</TOPIC>

<TOPIC> create object <style> function
Command   create object

Create an object.

<B>wtt> create object /destination= /name= /class= 
<B>		<t>[/first] [/last] [/after] [/before]

/destination	<t>The destination of the new object. The position
		<t>of the new object will be child or sibling relative
		<t>to the destination object.

/name		<t>Name of the new object. Last segment.

/class		<t>Class of new object.

/first		<t>The object will be inserted as first child to
		<t>the destination object.

/last		<t>The object will be inserted as last child to
		<t>the destination object.

/after		<t>The object will be inserted as sibling after
		<t>the destination object.

/before		<t>The object will be inserted as sibling before
		<t>the destination object.

</TOPIC>

<TOPIC> create structfiles <style> function
Command   create structfiles

Create c include-files for classes in a classvolume.

<B>wtt> create structfiles [/files=]

/files		<t>Name of wb_load-file.
		<t>Default name $pwrp_db/userclasses.wb_load
</TOPIC>

<TOPIC> create rttfiles <style> function
Command   create rttfiles

Create files for displaying crossreferences in rtt and xtt for
the current volume.

<B>wtt> create rttfiles
</TOPIC>

<TOPIC> generate web <style> function
Command   generate web

Generate html-files for webpages configured by Web-objects in the
node hierarchy of the current volume.

<B>wtt> generate web
</TOPIC>

<TOPIC> delete object <style> function
Command   delete object

Delete an object.

<B>wtt> delete object /name= [/noconfirm] [/nolog]

/name		<t>Name of object.
/noconfirm	<t>Delete without confirm.
/nolog		<t>The operation will not be logged on the output device.
</TOPIC>

<TOPIC> delete tree <style> function
Command   delete tree

Delete an object tree.

<B>wtt> delete tree /name= [/noconfirm] [/nolog]

/name		<t>The root object of the tree.
/noconfirm	<t>Delete without confirm.
/nolog		<t>The operation will not be logged on the output device.
</TOPIC>

<TOPIC> list <style> function
Command   list

Print a list of objects and attributes.

The lists will be sent to a printer queue specified by the
symbol PWR_FOE_PRINT.

<B>wtt> list descriptor /descriptor=		<link> list descriptor
<B>wtt> list channels [/node=]			<link> list channels
<B>wtt> list signals [/hierarchy=]		<link> list signals
<B>wtt> list plcpgm [/plcpgm=] [/hierarchy=]	<link> list plcpgm
<B>wtt> list hierarchy [/hierarchy=]		<link> list hierarchy
</TOPIC>

<TOPIC> list descriptor <style> function
Command   list descriptor

Print a list described by a ListDescriptor object.

<B>wtt> list descriptor /descriptor=		<link> list descriptor

/descriptor	<t>ListDescriptor object.
</TOPIC>

<TOPIC> list channels <style> function
Command   list channels

List cards and channels.

<B>wtt> list channels [/node=] [/volume=] [/allvolumes] [output=]

/node		<t>$Node object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> list signals <style> function
Command   list signals

List of signals and crossreferences to the signals.

<B>wtt> list signals [/hierarchy=] [/volume=] [/allvolumes] [output=]

/hierarchy	<t>Hierarchy object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> list hierarchy <style> function
Command   list hierarchy

List of PlantHier and NodeHier objects.

<B>wtt> list hierarchy [/hierarchy=] [/volume=] [/allvolumes] [output=]

/hierarchy	<t>Hierarchy object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> list plcpgm <style> function
Command   list plcpgm

List of PlcPgm objects.

<B>wtt> list plcpgm [/hierarchy=] [plcpgm=] [/volume=] [/allvolumes] [output=]

/plcpgm		<t>Plcpgm object.
/hierarchy	<t>Hierarchy object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> move object <style> function
Command   move object

Move an object.

<B>wtt> move object /source= /destination= [/rename=] [/first] [/last] [/after] [/before]
<B>wtt> move object /source= /rename=

/source		<t>Name of object to move.
/destination	<t>The parent or sibling to the object after the move.
/rename		<t>New object name, if the object name should be changed.
		<t>Last segment. If no destination is supplied, the object
		<t>will only be renamed, not moved.
/first		<t>The object will be inserted as first child to
		<t>the destination object.
/last		<t>The object will be inserted as last child to
		<t>the destination object.
/after		<t>The object will be inserted as sibling after
		<t>the destination object.
/before		<t>The object will be inserted as sibling before
		<t>the destination object.
</TOPIC>

<TOPIC> print <style> function
Command   print

Print plc documents.

<B>wtt> print /plcpgm= [/nodocument] [/nooverview]
<B>wtt> print /hierarchy= [/nodocument] [/nooverview]

/plcpgm		<t>Print documents in a plcpgm.
/hierarchy	<t>Hierarchy object. All plc in the hierarchy will
		<t>be printed.
/nodocument	<t>The plc-documents will not be printed.
/nooverview	<t>The overview of the plc-window will not be printed.
</TOPIC>

<TOPIC> set attribute <style> function
Command   set attribute

Set a value to an attribute.
Objects are selected by the name, class and hierarchy qualifiers.

<B>wtt> set attribute /attribute= [/value=] [/name=] [/class=] [/hierarchy=]
<B>		<t>[/noconfirm] [/nolog] [/output] [/noterminal]

/attribute	<t>Name of attribute.
/value		<t>Value to insert in the attribute. If no value is given
		<t>a question will be asked for each object.
/class		<t>Select object of this class.
/hierarchy	<t>Only successors to this object will be selected.
/noconfirm	<t>No confirm request is issued.
/nolog		<t>Operation is not logged to output device.
/output		<t>Output file.
/noterminal	<t>Operations will not be logged in terminal.
</TOPIC>

<TOPIC> search <style> function
Command   search

Search for an objectname or a string.

<B>wtt> search 'object'
<B>wtt> search /regularexpression 'expression'
<B>wtt> search /next
</TOPIC>

<TOPIC> set db <style> function
Command   set db

Connect to the database with the supplied id.
This has no affect if a database already is open.

<B>wtt> set db /dbid=

/dbid	<t>Database identity.
</TOPIC>

<TOPIC> set volume <style> function
Command   set volume

Attach a volume.

<B>wtt> set volume 'volumename'
<B>wtt> set volume /volumename=

/volumename		<t>Volume name.
</TOPIC>

<TOPIC> set template <style> function
Command   set template

Set template values for some attributes that affect the layout
in the plceditor.

<B>wtt> set template [/signalobjectseg=] [/sigchanconseg=] [/shosigchancon=]
		<t>[/shodetecttext=]

/signalobjectseg	<t>Number of segments of the signal name that will
			<t>be displayed in 'Get' and 'Set' objects in 
			<t>the plc-editor.
/sigchanconseg		<t>Number of segments of the channel name that will
			<t>be displayed in 'Get' and 'Set' objects in 
			<t>the plc-editor.
/shosigchancon		<t>Display the channel name in 'Get' and 'Set' 
			<t>objects in the plc-editor.
/shodetecttext		<t>Display the detect text in ASup and DSup 
			<t>objects in the plc-editor.
</TOPIC>

<TOPIC> show object <style> function
Command   show object

List objects.

<B>wtt> show object [/name=] [/hierarchy=] [/class=] [/volume=] [/allvolumes]
<B>		<t>[/parameter=] [/full] [/output=] [/noterminal]
<B>wtt> show object /objid=

/name		<t>Object name. Wildcard is supported.
/hierarchy	<t>Hierarchy object. Only object in the hierarchy will be
		<t>selected.
/class		<t>Only objects of this class will be selected.
/volume		<t>Name of volume.
/allvolumes	<t>Search of objects will be performed in all volumes.
/parameter	<t>List the value of an attribut for the selected objects.
/full		<t>Display the content of the objects. Attributes that
		<t>differ from template value will be displayed.
/output		<t>Output file.
/noterminal	<t>Output will not be written to terminal.
/objid		<t>Display object for a specified objid.
</TOPIC>

<TOPIC> show script <style> function
Command   show script

Provides a list of scriptfiles.
Wildcard with asterisk (*) can be used to look up files. 

<B>wtt> show script ['scriptspec']

</TOPIC>


<TOPIC> sort <style> function
Command   sort

Sort the children of an object in alpabetical order, or in class order.
If no parent is given, the children of the selected objects will be sorted.

<B>wtt> sort /parent= [/class] [/signals]

/parent		<t>Parent to the objects that will be sorted.
/class		<t>Sort in class order.
/signals	<t>Sort signal and plcpgm objects in class order,
		<t>and other objects in alpabetical order.
</TOPIC>

<TOPIC> wb dump <style> function
Command   wb dump

Dump the volume or a part of the volume to text file.

<B>wtt> wb dump /output= [/hierarchy=]

/hierarchy	<t>Hierarchy object. The object and its child tree will
		<t>be written to text file.
/output		<t>Output file.
</TOPIC>

<TOPIC> wb load <style> function
Command   wb load

Load the database or from wb_load-file or dbs-file.

<B>wtt> wb load /loadfile=

/loadfile	<t>Name of file. Can be of type .wb_load, .wb_dmp or .dbs.

</TOPIC>

<TOPIC> open graph <style> function
Command   open graph

Open a Ge graph.
If modal is selected, the execution av the script is continued
when the graph is closed.

<B>wtt> open graph /file= /modal

/file	<t>Name of the Ge graph.
/modal  <t>Modal.
</TOPIC>

<TOPIC> close graph <style> function
Command   close graph

Close a Ge graph.

<B>wtt> close graph /file=

/file	<t>Name of the Ge graph.
</TOPIC>

<TOPIC> set subwindow <style> function
Command   set subwindow

Open a graph in a window object in a previously opened graph.

<B>wtt> set subwindow 'graph' /name= /source=

/name	<t>Name of the window object.
/source	<t>Name of graph that is to be opened in the window object.
</TOPIC>

<TOPIC> release subwindow <style> function
Command   release subwindow

Continue the execution of a script that has opened a graph
in a window object by the command 'set subwindow' or the 
function 'SetSubwindow' with modal selected.
The release command should be executed from a pushbutton
in the graph with actiontype command.

<B>wtt> release subwindow 'graph'

graph	<t>Name of the main graph.
</TOPIC>

<TOPIC> symbol
Symbol

A wtt symbol can be used as a short command or as string replacement
in a command. If the symbol is used as string replacement the symbol-
name should be surrounded by quotes.

Symbols are created with the define command. <LINK> define
The define-commands can be executed by the symbolfile. <LINK> symbolfile

Example of symbol used as a short command.

<c>wtt> define p1 "show child/name=hql-hvk-pumpar-pump1"
<c>wtt> p1

Example of symbol used as string replacement

<c>wtt> define p1 hql-hvk-pumpar-StartPump1
<c>wtt> open trace 'p1'

<H2>related subjects
define <LINK> define
show symbol <LINK> show symbol
symbolfile <LINK> symbolfile
</TOPIC>

</chapter>
//
// Script
//

<chapter>
<TOPIC> script
Wtt script

execute script		<LINK> execute script
datatypes		<LINK> datatypes
datatype conversions	<LINK> datatype conversions
variable declarations	<LINK> variable declarations
operators		<LINK> operators
main-endmain		<LINK> main-endmain
function-endfunction	<LINK> function-endfunction
if-else-endif		<LINK> if-else-endif
while-endwhile		<LINK> while-endwhile
for-endfor		<LINK> for-endfor
break			<LINK> break
continue		<LINK> continue
goto			<LINK> goto
include			<LINK> include
printf()		<LINK> printf()
scanf()			<LINK> scanf()
fprintf()		<LINK> fprintf()
fgets()			<LINK> fgets()
fopen()			<LINK> fopen()
fclose()		<LINK> fclose()
exit()			<LINK> exit()
verify()		<LINK> verify()
time()			<LINK> time()
edit()			<LINK> edit()
extract()		<LINK> extract()
element()		<LINK> element()
toupper()		<LINK> toupper()
tolower()		<LINK> tolower()
translate_filename()	<LINK> translate_filename()
wtt-commands		<LINK> wtt-commands
GetAttribute()		<LINK> getattribute()
GetChild()		<LINK> getchild()
GetParent()		<LINK> getparent()
GetNextSibling()	<LINK> getnextsibling()
GetNextVolume()		<LINK> getnextvolume()
GetClassList()		<LINK> getclasslist()
GetNextObject()		<LINK> getnextobject()
GetObjectClass()	<LINK> getobjectclass()
GetNodeObject()		<LINK> getnodeobject()
GetRootList()		<LINK> getrootlist()
GetVolumeClass()	<LINK> getvolumeclass()
GetVolumeList()		<LINK> getvolumelist()
SetAttribute()		<LINK> setattribute()
GetProjectName()	<LINK> getprojectname()  
CheckSystemGroup()	<LINK> checksystemgroup()
CutObjectName()		<LINK> cutobjectname()
MessageError()		<LINK> messageerror()
MessageInfo()		<LINK> messageinfo()
GetCurrentText()	<LINK> getcurrenttext()
GetCurrentObject()	<LINK> getcurrentobject()
GetCurrentVolume()	<LINK> getcurrentvolume()
IsW1()			<LINK> isw1()
IsW2()			<LINK> isw2()
EditMode()		<LINK> editmode()
MessageDialog()		<LINK> messagedialog()
ConfirmDialog()		<LINK> confirmdialog()
ContinueDialog()	<LINK> continuedialog()
PromptDialog()		<LINK> promptdialog()
OpenGraph()		<LINK> opengraph()
CloseGraph()		<LINK> closegraph()
SetSubwindow()		<LINK> setsubwindow()
</TOPIC>

<TOPIC> execute script
Execute a script

A script-file will be executed from the command-line with the command

wtt> @'filename'

</TOPIC>

<TOPIC> datatypes
Datatypes

The datatypes are float, int and string.

int	<t>integer value.
float	<t>32-bit float value.
string	<t>80 character string (null terminated).

There are three different tables in which a variable can be declared: local, 
global and extern. A local variable is known inside a function, a global is 
known in all functions in a file (with include-files), an external is known 
for all files executed in a session.

</TOPIC>

<TOPIC> datatype conversions
Datatype conversions

If an expression consists of variables and functions of different datatypes
the variables will be converted with the precedence string, float, int. If
two operands in an expression is of type int and float, the result will be float
If two operands is of type float and string, or int and string, the result will
be string. In an assignment the value of an expression will be converted to the
type of the assignment variable, even if the result is a string and the
variable is of type float or int.

<b>Example

<c>string str;
<c>int    i = 35;
<c>str = "Luthor" + i;
The value in str will be "Luthor35".

<c>float   f;
<c>string  str = "3.14";
<c>int     i = 159;
<c>f = str + i;
The value in f will be 3.14159.
</TOPIC>

<TOPIC> variable declarations
Variable declarations

A variable must be declared before it is used.
A declaration consists of
- the table (global or extern, if local the table is suppressed)
- the datatype (int, float or string)
- the variable name (case sensitive)
- if array, number of elements
- equal mark followed by an init value, if omitted the init value is zero or
  null-string
- semicolon

An extern variable should be deleted (by the delete statement).

<b>Example

<c>int             i;
<c>float           flow = 33.4;
<c>string          str = "Hello";
<c>extern int      jakob[20];
<c>global float    ferdinand = 1234;
<c>...
<c>delete jakob[20];
</TOPIC>

<TOPIC> operators
Operators

The operators have the same function as i c, with some limitations. All
operators are not implemented. Some operators (+,=,==) can also operate on
string variables. Precedence of operators is similar to c.

Operator	<t>Description		<t>Datatypes
+		<t>plus			<t>int, float, string
-		<t>minus			<t>int, float
*		<t>times			<t>int, float
/		<t>divide			<t>int, float
++	 	<t>increment, postfix only.	<t>int, float
--	 	<t>decrement, postfix only	<t>int, float
>>	 	<t>bits right-shifted		<t>int
<<	 	<t>bits left-shifted		<t>int
<		<t>less than			<t>int, float
>		<t>greater than		<t>int, float
<=	 	<t>less equal			<t>int, float
>=	 	<t>greater equal		<t>int, float
==	 	<t>equal			<t>int, float, string
!=	 	<t>not equal			<t>int, float, string
&		<t>bitwise and		<t>int
|		<t>bitwise or			<t>int
&&	 	<t>logical and		<t>int
||	 	<t>logical or			<t>int
!		<t>logical not		<t>int
=		<t>assign			<t>int, float, string
+=	 	<t>add and assign		<t>int, float
-=	 	<t>minus and assign		<t>int, float
&=	 	<t>logical and and assign	<t>int
|=	 	<t>logical or and assign	<t>int
</TOPIC>

<TOPIC> main-endmain <style> function
main-endmain

The main and endmain statements controls where the execution starts and stops
If no main and endmain statements will be found, the execution will start
att the beginning of the file and stop at the end.

<b>Example

<c>main()
<c>  int a;

<c>  a = p1 + 5;
<c>  printf( "a = %d", a);
<c>endmain
</TOPIC>

<TOPIC> function-endfunction <style> function
function-endfunction

A function declaration consists of
- the datatype of the return value for the function
- the name of the function
- an argumentlist delimited by comma and surrounded by parenthesis. The
  argumentlist must include a typedeclaration and a name for each argument.

The arguments supplied by the caller will be converted to the type of the
to the type declared in the argument list. If an argument is changed inside
the function, the new value will be transferred to the caller. In this way
it is possible to return other values then the return value of the function.
A function can contain one or several return statements. The return will hand
over the execution to the caller and return the supplied value.

<b>Example

<c>function float calculate_flow(float a, float b)
<c>  float c;
<c>  c = a + b;
<c>  return c;
<c>endfunction

<c>...
<c>flow = korr * calculate_flow( v, 35.2);
</TOPIC>

<TOPIC> if-else-endif <style> function
if-else-endif

The lines between a if-endif statment will be executed if the expression
in the if-statment is true. The expression should be surrounded by parentheses.
If an else statement is found between the if and endif the lines between else
and endif will be executed if the if-exepression is false.

<b>Example

<c>if ( i < 10 && i > 5)
<c>  a = b + c;
<c>endif

<c>if ( i < 10)
<c>  a = b + c;
<c>else
<c>  a = b - c;
<c>endif
</TOPIC>

<TOPIC> while-endwhile <style> function
while-endwhile

The lines between a while-endwhile statment will be executed as long as the
expression in the while-statment is true. The expression should be surrounded
by parentheses.

<b>Example

<c>while ( i < 10)
<c>  i++;
<c>endwhile
</TOPIC>

<TOPIC> for-endfor <style> function
for-endfor

The lines between a for-endfor statment will be executed as long as the
middle expression in the for-statment is true. The for expression consists
of three expression, delimited by semicolon and surrounded by parentheses.
The first expression will be executed the before the first loop, the third
will be executed after every loop, the middle is executed before every loop
and if it is true, another loop is done, if false the loop is leaved.

<b>Example

<c>for ( i = 0; i < 10; i++)
<c>  a += b;
<c>endfor
</TOPIC>

<TOPIC> break <style> function
break

A break statement will search for the next endwhile or endfor statement
continue the execution at the line after.

<b>Example

<c>for ( i = 0; i < 10; i++)
<c>  a += b;
<c>  if ( a > 100)
<c>    break;
<c>endfor
</TOPIC>

<TOPIC> continue <style> function
continue

A continue statement will search for the previous while or for statement
continue the loop execution.

<b>Example

<c>for ( i = 0; i < 10; i++)
<c>  b = my_function(i);
<c>  if ( b > 100)
<c>    continue;
<c>  a += b;
<c>endfor
</TOPIC>

<TOPIC> goto <style> function
goto

A goto will cause the execution to jump to a row defined by label.
The label line is terminated with colon.

<b>Example

<c>  b = attribute("MOTOR-ON.ActualValue", sts);
<c>  if (!sts)
<c>    goto some_error; 
<c>  ...
<c>some_error:
<c>  say("Something went wrong!");
</TOPIC>

<TOPIC> include <style> function
include

An script include-file containing functions can be included with the
#include statement. The default file extention is '.pwr_com'

<b>Example

<c>#include <my_functions>
</TOPIC>

<TOPIC> printf() <style> function
printf()

int printf( string format [, (arbitrary type) arg1, (arbitrary type) arg2])

<b>Description

Formatted print. C-syntax. Format argument and non, one or two value arguments.
Returns number of printed characters.

<b>Arguments

string 			<t>format	<t>Format.
arbitrary type		<t>arg1		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.
arbitrary type		<t>arg2		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.

<b>Example

<c>  printf( "Watch out!");
<c>  printf( "a = %d", a);
<c>  printf( "a = %d och str = %s", a, str);
</TOPIC>

<TOPIC> scanf() <style> function
scanf()

int scanf( string format , (arbitrary type) arg1)

<b>Description

Formatted input. C-syntax
Returns number of read characters.

<b>Arguments

string 			<t>format	<t>Format.
arbitrary type		<t>arg1		<t>Value argument. Returned. Can be int,
			<t>		<t>float or string.

<b>Example

<c>  scanf( "%d", i);
</TOPIC>

<TOPIC> fprintf() <style> function
fprintf()

int fprintf( int file, string format [, (arbitrary type) arg1,
	(arbitrary type) arg2])

<b>Description

Formatted print on file. C-syntax. Format argument and non, one or two value
arguments.
Returns number of printed characters.

<b>Arguments

int 			<t>file		<t>File id retured by fopen.
string 			<t>format	<t>Format.
arbitrary type		<t>arg1		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.
arbitrary type		<t>arg2		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.

<b>Example

<c>  int outfile;
<c>  outfile = fopen( "my_file.txt", "w");
<c>  if (!outfile)
<c>    exit();
<c>  fprintf( outfile, "Some text");
<c>  fprintf( outfile, "a = %d", a);
<c>  fclose( outfile);
</TOPIC>

<TOPIC> fgets() <style> function
fgets()

int fgets( string str, int file)

<b>Description

Reads a line from a specified file.
Returns zero if end of file.

<b>Arguments

string 		<t>str		<t>Read line. Returned. 
int		<t>file		<t>file returned by fopen.

<b>Example

<c>  file = fopen("some_file.txt","r");
<c>  while( fgets( str, file))
<c>    say( str);
<c>  endwhile
<c>  fclose( file);
</TOPIC>

<TOPIC> fopen() <style> function
fopen()

int fopen( string filespec, string mode)

<b>Description

Opens a file for read or write.
Returns a file identifier. If the file could not be opened, zero is returned.

<b>Arguments

string 		<t>filespec	<t>Name of file. 
string		<t>mode		<t>Access mode

<b>Example

<c>  int infile;
<c>  int outfile;

<c>  infile = fopen("some_file.txt","r");
<c>  outfile = fopen("another_file.txt","w");
<c>  ...
<c>  fclose( infile);
<c>  fclose( outfile);
</TOPIC>

<TOPIC> fclose() <style> function
fclose()

int fclose( int file)

<b>Description

Closes an opened file.

<b>Arguments

int		<t>file		<t>file-id returned by fopen.

<b>Example

<c>  int infile;
<c>  infile = fopen("some_file.txt","r");
<c>  ...
<c>  fclose( infile);
</TOPIC>

<TOPIC> exit() <style> function
exit()

int exit()

<b>Description

Terminates executions of the file.

<b>Example

<c>  exit();
</TOPIC>

<TOPIC> verify() <style> function
verify()

int verify( [int mode])

<b>Description

Sets or shows verification mode. If verification is on all executed lines will
be displayed on the screen.
Returns the current verification mode.

<b>Arguments

int		<t>mode		<t>verification on (1) or off (0). Optional.

<b>Example

<c>  verify(1);
</TOPIC>

<TOPIC> time() <style> function
time()

string time()

<b>Description

Returns the current time in string format.

<b>Example

<c>  string t;
<c>  t = time();
</TOPIC>

<TOPIC> edit() <style> function
edit()

string edit( string str)

<b>Description

Removes leading and trailing spaces and tabs, and replaces multiple tabs and
spaces with a single space.
Returns the edited string.

<b>Arguments

string		<t>str		<t>string to be edited.

<b>Example

<c>  collapsed_str = edit(str);
</TOPIC>

<TOPIC> extract() <style> function
extract()

string extract( int start, int length, string str)

<b>Description

Extracts the specified characters from the specified string.
Returns the extracted characters as a string.

<b>Arguments

int		<t>start	<t>start position of the first character.
				<t><t>First character has position 1.
int		<t>length	<t>number of characters to be extracted.
string		<t>str		<t>string from which characters should be extracted.

<b>Example

<c>  extracted_str = extract( 5, 7, str);
</TOPIC>

<TOPIC> element() <style> function
element()

string element( int number, string delimiter, string str)

<b>Description

Extracts one element from a string of elements.
Returns the extracted element.

<b>Arguments

int		<t>number	<t>the number of the element.
string		<t>delimiter	<t>delimiter character.
string		<t>str		<t>string of elements.

<b>Example

<c>  string str = "mary, lisa, anna, john";
<c>  string elem1;
<c>  elem1 = elment( 1, ",", str);
</TOPIC>

<TOPIC> toupper() <style> function
toupper()

string toupper( string str)

<b>Description

Convert string to upper case.

<b>Arguments

string		<t>str		<t>string to convert.

<b>Returns
string				<t><t>string in upper case.

<b>Example

<c>  string str1 = "Buster Wilson";
<c>  string str2;
<c>  str2 = toupper( str);
</TOPIC>

<TOPIC> tolower() <style> function
toupper()

string tolower( string str)

<b>Description

Convert string to lower case.

<b>Arguments

string		<t>str		<t>string to convert.

<b>Returns
string				<t><t>string in lower case.

<b>Example

<c>  string str1 = "Buster Wilson";
<c>  string str2;
<c>  str2 = tolower( str);
</TOPIC>

<TOPIC> translate_filename() <style> function
translate_filename()

string translate_filename( string fname)

<b>Description

Replace environment variables in filename.

<b>Arguments

string		<t>fname	<t>A filename.

<b>Returns
string				<t><t>String with expanded env variables.

<b>Example

<c>  string fname1 = "$pwrp_db/a.wb_load";
<c>  string fname2;
<c>  fname2 = translate_filename( fname1);
</TOPIC>

<TOPIC> wtt-commands <style> function
Wtt commands

All the wtt-commands is available in the script code. An wtt-command line
should NOT be ended with a semicolon. Variables can be substituted in the
command line by surrounding them with apostrophes.

<b>Example
 
<c>  string name = "PUMP-VALVE-Open";
<c>  string value = "The valve is open";
<c>  set attribute/name='name'/attr="Description"/value='value'

<b>Example

<c>  string name;
<c>  string parname;
<c>  int j;
<c>  int i;
<c>  for ( i = 0; i < 3; i++)
<c>    parname = "vkv-test-obj" + (i+1);
<c>    create obj/name='parname'
<c>    for ( j = 0; j < 3; j++)
<c>      name = parname + "-obj" + (j+1);
<c>      create obj/name='name'
<c>    endfor
<c>  endfor
</TOPIC>

<TOPIC> getattribute() <style> function
GetAttribute()

(variable type) GetAttribute( string name [, int status])

<b>Description

Get the value of the specified attribute. The returned type is dependent
of the attribute type. The attribute will be converted to int, float or string.

<b>Arguments

string		<t>name		<t>name of the attribute to be fetched.
int		<t>status	<t>status of operation. Returned. If zero, the
		<t>		<t>attribute could not be fetched. Optional.

<b>Example

<c>  int alarm;
<c>  int sts;

<c>  alarm = GetAttribute("Roller-Motor-Alarm.ActualValue");
<c>  on = GetAttribute("Roller-Motor-On.ActualValue", sts);
<c>  if ( !sts)
<c>    say("Could not find motor on attribute!");
</TOPIC>

<TOPIC> getchild() <style> function
GetChild()

string GetChild( string name)

<b>Description

Get the first child of an object. The next children can be fetched with
GetNextSibling().
Returns the name of the child. If no child exists a null-string is returned

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string child;

<c>  child = GetChild("Roller-Motor");
</TOPIC>

<TOPIC> getparent() <style> function
GetParent()

string GetParent( string name)

<b>Description

Get the parent of an object.
Returns the name of the parent. If no parent exists a null-string is returned.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string parent;

<c>  parent = GetChild("Roller-Motor");
</TOPIC>

<TOPIC> getnextsibling() <style> function
GetNextSibling()

string GetNextSibling( string name)

<b>Description

Get the next sibling of an object.
Returns the name of the sibling. If no next sibling exists a null-string is
returned.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c> string name;
<c> int not_first;

<c> name = GetChild("Rt");
<c> not_first = 0;
<c> while ( name != "")
<c>   if ( !not_first)
<c>     create menu/title="The Rt objects"/text="'name'"/object="'name'"
<c>   else
<c>     add menu/text="'name'"/object="'name'"
<c>   endif
<c>   not_first = 1;
<c>   name = GetNextSibling(nname);
<c> endwhile
<c> if ( !not_first )
<c>   MessageError("No objects found");
</TOPIC>

<TOPIC> getclasslist() <style> function
GetClassList()

string GetClassList( string class)

<b>Description

Get the first object of a specified class. The next object of the class
can be fetched whith GetNextObject().
Returns the name of the first object. If no instances of the class exists a
null-string is returned.

<b>Arguments

string		<t>name		<t>name of class.

<b>Example

<c>  string name;

<c>  name = GetClassList("Dv");
</TOPIC>

<TOPIC> getnextobject() <style> function
GetNextObject()

string GetNextObject( string name)

<b>Description

Get the next object in a classlist.
Returns the name of the object. If no next object exist a null-string is
returned.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string name;

<c>  name = GetClassList("Di");
<c>  while ( name != "")
<c>    printf("Di object found: %s", name);
<c>    name = GetNextObject(name);
<c>  endwhile
</TOPIC>

<TOPIC> getobjectclass() <style> function
GetObjectClass()

string GetObjectClass( string name)

<b>Description

Get the class of an object.
Returns the name of the class.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string class;

<c>  class = GetObjectClass("Motor-Enable");
</TOPIC>

<TOPIC> getnodeobject() <style> function
GetNodeObject()

string GetNodeObject()

<b>Description

Get the node object.
Returns the name of the node object.

<b>Example

<c>  string node;
<c>  node = GetNodeObject();
</TOPIC>

<TOPIC> getrootlist() <style> function
GetRootList()

string GetRootList()

<b>Description

Get the first object in the root list.
Returns the name of the root object. The next object in the root list can be
fetched with GetNextSibling().

<b>Example

<c>  string name;

<c>  name = GetRootList();
<c>  while( name != "")
<c>    printf( "Root object found: %s", name);
<c>    name = GetNextSibling(name);
<c>  endwhile
</TOPIC>

<TOPIC> getnextvolume() <style> function
GetNextVolume()

string GetNextVolume( string name)

<b>Description

Get the next volume. The first volume is fetched widh GetVolumeList().
Returns the name of the volume. If there is no next volume, a null-string
is returned.

Argument

string          name            name of volume.
</TOPIC>

<TOPIC> getvolumeclass() <style> function
GetVolumeClass()

string GetVolumeClass( string name)

<b>Description

Get the class of a volume.
Returns the classname.

<b>Argument

string          name            volume name.

<b>Example

<c>  string class;

<c>  class = GetVolumeClass("CVolVKVDKR");
</TOPIC>

<TOPIC> getvolumelist() <style> function
GetVolumeList()

string GetVolumeList()

<b>Description

Get the first volume in the volumelist.
Returns the name of the volume. The next volume will be fetched with
GetNextVolume().

<b>Example

<c>  string name;

<c>  name = GetVolumeList();
<c>  while( name != "")
<c>    printf( "Volume found: %s", name);
<c>    name = GetNextVolume(name);
<c>  endwhile
</TOPIC>

<TOPIC> setattribute() <style> function
SetAttribute()

int SetAttribute( string name, (arbitrary type) value)

<b>Description

Set the value of an attribute.
The attribute is specified with full object and
attribute name.
Returns the status of the operation.

<b>Argument

string          name            attribute name.
arbitrary type  value		attribute value.

<b>Example

<c>  SetAttribute( "Pump-V1-Switch.Description", "Valve switch open");
</TOPIC>

<TOPIC> getprojectname() <style> function
GetProjectName()

string GetProjectName()

<b>Description

Get the project name.
Returns the name of the project.

<b>Example

<c>  string name;

<c>  name = GetProjectName();
</TOPIC>

<TOPIC> checksystemgroup() <style> function
CheckSystemGroup()

int CheckSystemGroup()

<b>Description

Check if a system group exists.
Returns 1 if the system group exist, else 0.

<b>Example

<c>  if ( !CheckSystemGroup( "MyGroup"))
<c>    return;
<c>  endif
</TOPIC>

<TOPIC> cutobjectname() <style> function
CutObjectName()

string CutObjectName( string name, int segments)

<b>Description

Cut the first segments of an object name.
Returns the last segments of an object name. The number of segments left is
specified by the second argument

<b>Arguments

string		<t>name		<t>Path name of object.
int		<t>segments	<t>Number of segments that should be left.

<b>Example

<c>  string path_name;
<c>  string object_name;

<c>  path_name = GetChild("Rt-Motor");
<c>  object_name = CutObjectName( path_name, 1);
</TOPIC>

<TOPIC> messageerror() <style> function
MessageError()

string MessageError( string message)

<b>Description

Print an error message on the screen.

<b>Example

<c>  MessageError("Something went wrong");
</TOPIC>

<TOPIC> messageinfo() <style> function
MessageInfo()

string MessageInfo( string message)

<b>Description

Print an rtt info message on the screen.

<b>Example

<c>  MessageInfo("Everything is all right so far");
</TOPIC>

<TOPIC> getcurrenttext() <style> function
GetCurrentText()

string GetCurrentText()

<b>Description

Get the text of the current menu item or update field.

<b>Example

<c>  string text;

<c>  text = GetCurrentText();
</TOPIC>

<TOPIC> getcurrentobject() <style> function
GetCurrentObject()

string GetCurrentObject()

<b>Description

Get the object associated with the current menu item.
If no object is associated, a null-string i returned.

<b>Example

<c>  string object;

<c>  object = GetCurrentObject();
</TOPIC>

<TOPIC> getcurrentvolume() <style> function
GetCurrentVolume()

string GetCurrentVolume()

<b>Description

Get the attached volume.
If no volume is attached, a null-string i returned.

<b>Example

<c>  string current_volume;

<c>  current_volume = GetCurrentVolume();
<c>  set volume/volume=SomeOtherVolume
<c>  ...
<c>  set volume/volume='current_volume'

</TOPIC>

<TOPIC> isw1() <style> function
IsW1()

int IsW1()

<b>Description

Returns 1 if the current focused window in wtt is the Plant hierarchy window.
Otherwise returns 0.
</TOPIC>

<TOPIC> isw2() <style> function
IsW2()

int IsW2()

<b>Description

Returns 1 if the current focused window in wtt is the Node hierarchy window. 
Otherwise returns 0. 
</TOPIC>

<TOPIC> editmode() <style> function
EditMode()

int EditMode()

<b>Description

Returns 1 if wtt is int edit mode.
Otherwise returns 0. 
</TOPIC>

<TOPIC> messagedialog() <style> function
MessageDialog()

MessageDialog( string title, string text)

<b>Description

Display a message dialog box.

<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Message text.

<b>Example

<c>  MessageDialog( "Message", "This is a message");
</TOPIC>

<TOPIC> confirmdialog() <style> function
ConfirmDialog()

int ConfirmDialog( string title, string text [, int cancel])

<b>Description

Display a confirm dialog box.
Returns 1 if the yes-button is pressed, 0 if the no-button i pressed. 
If the third argument (cancel) is added, a cancel-button is displayed.
If the cancel-button i pressed or if the dialogbox is closed, 
the cancel argument is set to 1.

<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Confirm text.
int		<t>cancel	<t>Optional. A cancel button is displayed.
		<t>		<t>Cancel is set to 1 if the cancel-button is 
		<t>		<t>pressed, or if the dialog-box is closed.

<b>Example 1

<c>  if ( ! ConfirmDialog( "Confirm", "Do you really want to..."))
<c>    printf( "Yes is pressed\n");
<c>  else
<c>    printf( "No is pressed\n");
<c>  endif

<b>Example 2

<c>  int cancel;
<c>  int sts;

<c>  sts =  ConfirmDialog( "Confirm", "Do you really want to...", cancel);
<c>  if ( cancel)
<c>    printf("Cancel is pressed\n);
<c>    exit();
<c>  endif

<c>  if ( sts)
<c>    printf( "Yes is pressed\n");
<c>  else
<c>    printf( "No is pressed\n");
<c>  endif
</TOPIC>

<TOPIC> continuedialog() <style> function
ContinueDialog()

ContinueDialog( string title, string text)

<b>Description

Display a message dialog box with the buttons 'Continue' and 'Quit'.
Returns 1 if continue is pressed, 0 if quit is pressed.

<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Message text.

<b>Example

<c>  if ( ! ContinueDialog( "Message", "This script will...");
<c>    exit();
<c>  endif
</TOPIC>

<TOPIC> promptdialog() <style> function
PromptDialog()

int PromptDialog( string title, string text, string value)

<b>Description

Display a prompt dialog box which promps for a input value.
Returns 1 if the yes-button is pressed, 0 if the cancel-button i pressed,
or if the dialogbox is closed.


<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Value text.
string		<t>value	<t>Contains the entered value.

<b>Example

<c>  string name;

<c>  if ( PromptDialog( "Name", "Enter name", name))
<c>    printf( "Name : '%s'\n", name);
<c>  else
<c>    printf( "Cancel...\n");
<c>  endif

</TOPIC>
<TOPIC> opengraph() <style> function
OpenGraph()

int OpenGraph( string name, int modal)

<b>Description

Open a Ge graph.
If modal is selected, the execution of the script is continued when
the graph is closed.

<b>Arguments

string		<t>name		<t>Graph name.
int		<t>modal	<t>Modal.

<b>Example

<c>  OpenGraph( "pwr_wizard_frame", 0);

</TOPIC>

<TOPIC> closegraph() <style> function
CloseGraph()

int CloseGraph( string name)

<b>Description

Close a Ge graph.

<b>Arguments

string		<t>name		<t>Graph name.

<b>Example

<c>  CloseGraph( "pwr_wizard_frame");

</TOPIC>

<TOPIC> setsubwindow() <style> function
SetSubwindow()

int SetSubwindow( string name, string windowname, string source, int modal)

<b>Description

Open a Ge graph in a window object in a previously opened graph.
If modal is selected, the execution of the script is continued when
the command 'release subwindow' is executed by a pushbutton in the graph.

<b>Argument

string		<t>name		<t>Name of the main graph.
string		<t>windowname	<t>Name of the window object in which
		<t>		<t>the source graph is to be opened.
string		<t>source	<t>Name of the graph that is to be opened
                <t>             <t>in the window object.
int		<t>modal	<t>Modal.
<b>Exempel

<c>  SetSubwindow( "pwr_wizard_frame", "Window1", "MyGraph", 1);

</TOPIC>
</chapter>





