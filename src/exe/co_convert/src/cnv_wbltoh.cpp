/* 
 * Proview   $Id: cnv_wbltoh.cpp,v 1.14 2008-10-31 12:51:30 claes Exp $
 * Copyright (C) 2005 SSAB Oxelösund AB.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with the program, if not, write to the Free Software 
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */



#include <iostream>
#include <fstream>
#include <float.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

extern "C" {
#include "pwr.h"
#include "pwr_version.h"
#include "co_dcli.h"
#include "co_cdh.h"
}
#include "cnv_ctx.h"
#include "cnv_wbltoh.h"

using namespace std;

typedef struct {
	char		name[40];
	unsigned int	id;
	} struct_tCixArray;

int CnvWblToH::init( char *first)
{
  pwr_tFileName struct_filename;
  pwr_tFileName fname;
  pwr_tFileName found_file;
  int sts;

  get_filename( ctx->rw, struct_filename, ctx->hpp);
  strcpy( fname, ctx->dir);
  strcat( fname, struct_filename);
  fp_struct.open( fname);

  if ( ctx->hpp) {
    if ( strcmp( CnvCtx::low(ctx->rw->volume_name), "pwrb") == 0)
      sprintf( fname, "pwr_%sclasses_hpp", "base");
    else if ( strcmp( CnvCtx::low(ctx->rw->volume_name), "pwrs") == 0)
      sprintf( fname, "pwr_%sclasses_hpp", "system");
    else
      sprintf( fname, "pwr_%sclasses_hpp", CnvCtx::low(ctx->rw->volume_name));
  }
  else {
    if ( strcmp( CnvCtx::low(ctx->rw->volume_name), "pwrb") == 0)
      sprintf( fname, "pwr_%sclasses_h", "base");
    else if ( strcmp( CnvCtx::low(ctx->rw->volume_name), "pwrs") == 0)
      sprintf( fname, "pwr_%sclasses_h", "system");
    else
      sprintf( fname, "pwr_%sclasses_h", CnvCtx::low(ctx->rw->volume_name));
  }

  sts = volname_to_id();
  if ( sts == 0)
  {
    // printf( "** Can't get volume id\n");
    // exit(0);
  }

  fp_struct <<
    "/*	Proview " << pwrv_cPwrVersionStr << " " << struct_filename << " */" << endl << endl <<
"/*	Generated by co_convert. */" << endl <<
"/*	Do not edit this file. */" << endl << endl <<
"#ifndef " << fname << endl <<
"#define " << fname << endl <<
endl <<
"#ifndef pwr_class_h" << endl <<
"#include \"pwr_class.h\"" << endl <<
"#endif" << endl <<
endl <<
endl;

  // If there is a template file on the source dir, insert this file here
  strcpy( fname, ctx->rw->source_dir);
  strcat( fname, "/");
  strcat( fname, struct_filename);
  strcat( fname, "_template");

  sts = dcli_search_file( fname, found_file, DCLI_DIR_SEARCH_INIT);
  if ( EVEN(sts))
    return 1;

  dcli_search_file( fname, found_file, DCLI_DIR_SEARCH_END);

  FILE *fp_template = fopen( found_file, "r");
  char c;
  while( (c = fgetc( fp_template)) != EOF)
    fp_struct.put(c);
  fclose( fp_template);

  fp_struct << endl;

  return 1;
}

int CnvWblToH::close()
{

  fp_struct <<
"#endif" << endl;

  fp_struct.close();

  return 1;
}

int CnvWblToH::class_exec()
{

  // Open class struct file
  pwr_tFileName struct_filename;
  pwr_tFileName fname;
  char volume_name_low[40];

  strcpy( volume_name_low, CnvCtx::low(ctx->rw->volume_name));

  get_filename( ctx->rw, struct_filename, ctx->hpp);
  if ( ctx->hpp)
    sprintf( fname, "%s%s_c_%s.hpp", ctx->dir, volume_name_low, 
	     CnvCtx::low(ctx->rw->class_name));
  else
    sprintf( fname, "%s%s_c_%s.h", ctx->dir, volume_name_low, 
	     CnvCtx::low(ctx->rw->class_name));
  if ( !ctx->common_structfile_only) {
    cstruc = new CnvFile();
    cstruc->f.open( fname);
  }
  struct_class_open = 1;
  sprintf( fname, "%s_c_%s_h", volume_name_low, CnvCtx::low(ctx->rw->class_name));

  if ( !ctx->common_structfile_only)
    cstruc->f <<
"/*	Generated by co_convert 		*/" << endl << endl <<
"#ifndef " << fname << endl <<
"#define " << fname << endl <<
endl <<
"#ifndef pwr_class_h" << endl <<
"#include \"pwr_class.h\"" << endl <<
"#endif" << endl <<
endl <<
endl;

  // Add into index file
  struct_cclass_written = 0;
  struct_cclass_endwritten = 0;
  struct_filler_cnt = 0;

  return 1;
}

int CnvWblToH::body_exec()
{
  int sts;
  char cclass_name[80];
  unsigned int cix;
  pwr_tClassId cid;
  char struct_name[80];

  attr_count = 0;

  if ( strcmp( CnvCtx::low( ctx->rw->body_name), "devbody") == 0) {
    if ( ctx->hpp)
      strcpy( struct_name, "pwr_dClass_");
    else
      strcpy( struct_name, "pwr_sdClass_");
  }
  else {
    if ( ctx->hpp)
      strcpy( struct_name, "pwr_Class_");
    else
      strcpy( struct_name, "pwr_sClass_");
  }
  if ( strcmp( ctx->rw->body_structname, "") == 0)
    strcat( struct_name, ctx->rw->class_name);
  else
    strcat( struct_name, ctx->rw->body_structname);

  // For systemclasses classindex is defined as a pwr_eCix...
  if ( strncmp( ctx->rw->class_id, "pwr_eCix_", strlen("pwr_eCix_")) == 0)
  {
    sts = cixstr_to_classid( ctx->rw->class_id, &cid);
    if ( EVEN(sts))
    {
      printf("Error, unknown classid %s", ctx->rw->class_id);
      return sts;
    }
  }
  else
  {
    // Classindex is a number
    sts = sscanf( ctx->rw->class_id, "%d", &cix);
    if ( sts != 1)
    {
      printf("Error, unknown classid %s", ctx->rw->class_id);
      return 0;
    }
    cix_to_classid( cix, &cid);
  }
  if ( strcmp( ctx->rw->body_structname, "") == 0)
    strcpy( cclass_name, ctx->rw->class_name);
  else
    strcpy( cclass_name, ctx->rw->body_structname);

  if ( !struct_cclass_written)
  {
    fp_struct <<
endl <<
"#ifndef pwr_cClass_" << cclass_name << endl <<
"#define pwr_cClass_" << cclass_name << " " << cid << "UL" << endl <<
endl;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
endl <<
"#ifndef pwr_cClass_" << cclass_name << endl <<
"#define pwr_cClass_" << cclass_name << " " << cid << "UL" << endl <<
endl;
    struct_cclass_written = 1;
  }

  if ( strcmp( CnvCtx::low( ctx->rw->body_name), "rtbody") == 0 &&
       ctx->rw->class_devonly)
  { 
    fp_struct <<
"/*  Class: " << ctx->rw->class_name << endl <<
"    Body:  " << ctx->rw->body_name << endl <<
"    Body is virtual" << endl <<
"*/" << endl << endl;
     return 1;
  }

  fp_struct <<
"/*_* Class: " << ctx->rw->class_name << endl <<
"    Body:  " << ctx->rw->body_name << endl <<
"    @Aref " << ctx->rw->class_name << " " << struct_name << endl <<
"*/" << endl;
  if ( !ctx->common_structfile_only)
    cstruc->f <<
"/*  Body:  " << ctx->rw->body_name << "  */" << endl;

  if ( ctx->hpp)
    fp_struct << endl <<
      "class " << struct_name << " ";
  else
    fp_struct << endl <<
      "typedef struct {" << endl;
  if ( !ctx->common_structfile_only) {
    if ( ctx->hpp)
      cstruc->f << endl <<
"class " << struct_name << " ";
    else
      cstruc->f << endl <<
"typedef struct {" << endl;
  }
  return 1;
}

int CnvWblToH::body_close()
{
  char struct_name[80];

  if ( strcmp( CnvCtx::low( ctx->rw->body_name), "rtbody") == 0 &&
       ctx->rw->class_devonly)
    return 1;

  if ( attr_count == 0)
  {
    // Write a dummy element...
    fp_struct <<
"  int dummy;" << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"  int dummy;" << endl;
  }

  if ( strcmp( CnvCtx::low( ctx->rw->body_name), "devbody") == 0)
    strcpy( struct_name, "pwr_sdClass_");
  else
    strcpy( struct_name, "pwr_sClass_");
  if ( strcmp( ctx->rw->body_structname, "") == 0)
    strcat( struct_name, ctx->rw->class_name);
  else
    strcat( struct_name, ctx->rw->body_structname);
  
  if ( ctx->hpp) {
    fp_struct <<
"};"  << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"};"  << endl;
  }
  else {
    fp_struct <<
"} " << struct_name << ";"  << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"} " << struct_name << ";"  << endl;
  }

  fp_struct << 
endl;
  if ( !ctx->common_structfile_only)
    cstruc->f << 
endl;

  return 1;
}

int CnvWblToH::class_close()
{
  if ( !struct_cclass_written)
  {
    fp_struct <<
endl <<
"#ifndef pwr_cClass_" << ctx->rw->class_name << endl <<
"#define pwr_cClass_" << ctx->rw->class_name << " " << ctx->rw->class_id << "UL" << endl <<
endl;
    if ( !ctx->common_structfile_only && struct_class_open)
      cstruc->f <<
endl <<
"#ifndef pwr_cClass_" << ctx->rw->class_name << endl <<
"#define pwr_cClass_" << ctx->rw->class_name << " " << ctx->rw->class_id << "UL" << endl <<
endl;

    struct_cclass_written = 1;
  }

  // endif pwr_cClass...
  if ( !struct_cclass_endwritten) {
    fp_struct <<
"#endif" << endl <<
endl;

    if ( !ctx->common_structfile_only && struct_class_open)
      cstruc->f <<
"#endif" << endl <<
endl;
    struct_cclass_endwritten = 1;
  }

  // Close class structfile
  if ( !ctx->common_structfile_only && struct_class_open)
    cstruc->f <<
"#endif" << endl <<
endl;
  if ( !ctx->common_structfile_only && struct_class_open) {
    cstruc->f.close();
    delete cstruc;
    struct_class_open = 0;
  }

  return 1;
}

int CnvWblToH::attribute_exec()
{
  int i;
  char type_name[80];
  char pgmname[80];
  int sts;
  char alignstr[40];

  if ( ctx->rw->attr_pointer ||
       ctx->rw->attr_isclass ||
       strcmp( CnvCtx::low(ctx->rw->attr_type), "input") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_type), "buffer") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "int64") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "uint64") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "float64") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "time") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "deltatime") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "castid") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "disableattr") == 0)
    strcpy( alignstr, " pwr_ealign_lw");
  else
    strcpy( alignstr, " pwr_ealign_w");

  if ( strcmp( CnvCtx::low( ctx->rw->body_name), "rtbody") == 0 &&
       ctx->rw->class_devonly)
    return 1;

//  if ( attr_rtvirtual)
//    return 1;

  if ( strcmp( ctx->rw->attr_pgmname, "") == 0)
    strcpy( pgmname, ctx->rw->attr_name);
  else
    strcpy( pgmname, ctx->rw->attr_pgmname);

  if ( strncmp( CnvCtx::low(ctx->rw->attr_typeref), "pwr_etype_", strlen("pwr_etype_")) == 0)
    strcpy( ctx->rw->attr_typeref, 
	    &ctx->rw->attr_typeref[strlen("pwr_etype_")]);
  else if ( strncmp( CnvCtx::low(ctx->rw->attr_typeref), 
		     "pwr_etypedef_", strlen("pwr_etypedef_")) == 0)
    strcpy( ctx->rw->attr_typeref, 
	    &ctx->rw->attr_typeref[strlen("pwr_etypedef_")]);

  if ( strcmp( CnvCtx::low(ctx->rw->attr_type), "buffer") == 0)
  {
    strcpy( type_name, "pwr_s");
    if ( ctx->rw->attr_typeref[11] == '$')
      strcat( type_name, &ctx->rw->attr_typeref[12]);
    else
      strcat( type_name, &ctx->rw->attr_typeref[11]);
  }
  else if ( strcmp( CnvCtx::low(ctx->rw->attr_typeref), "attrref") == 0)
  {
    strcpy( type_name, "pwr_s");
    strcat( type_name, ctx->rw->attr_typeref);
  }
  else if ( ctx->rw->attr_isclass)
  {
    if ( ctx->hpp)
      strcpy( type_name, "pwr_Class_");
    else
      strcpy( type_name, "pwr_sClass_");
    strcat( type_name, ctx->rw->attr_typeref);
  }
  else
  {
    strcpy( type_name, "pwr_t");
    strcat( type_name, ctx->rw->attr_typeref);
  }
  // For backward compatibility...
  if ( strcmp( type_name, "pwr_tObjId") == 0)
    strcpy( type_name, "pwr_tObjid");

  // Check type for baseclasses
  if ( strcmp( CnvCtx::low(ctx->rw->volume_name), "pwrb") == 0)
  {
    sts = check_typename( ctx->rw->attr_typeref_volume, type_name); 
    if ( EVEN(sts))
    {
      printf("Error, unknown attribute type '%s'", type_name);
      return sts;
    }
  }

  if ( ctx->hpp && attr_count == 0) {
    if ( ctx->rw->attr_isclass && strcmp( pgmname, "Super") == 0) {
      fp_struct <<
	": public " << type_name << " {" << endl <<
	" public:" << endl;
      if ( !ctx->common_structfile_only)
	cstruc->f <<
	  type_name << " {" << endl <<
	  " public:" << endl;
      attr_count++;
      return 1;
    }
    else {
      fp_struct <<
	" {" << endl <<
	" public:" << endl;
      if ( !ctx->common_structfile_only)
	cstruc->f <<
	  " {" << endl <<
	  " public:" << endl;
    }
  }

  if ( strcmp( CnvCtx::low(ctx->rw->attr_type), "input") == 0)
  {
    if ( ctx->rw->attr_array && ctx->rw->attr_pointer)
    {
      fp_struct <<
"  " << type_name;
      if ( !ctx->common_structfile_only)
        cstruc->f <<
"  " << type_name;
      for ( i = 0; i < int(35 - strlen(type_name)); i++)
      {
        fp_struct << ' ';
        if ( !ctx->common_structfile_only)
          cstruc->f << ' ';
      }
      fp_struct << " **" << pgmname << "P[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
      if ( !ctx->common_structfile_only)
        cstruc->f << " **" << pgmname << "P[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
    }
    else if ( ctx->rw->attr_array)
    {
      fp_struct <<
"  " << type_name;
      if ( !ctx->common_structfile_only)
        cstruc->f <<
"  " << type_name;
      for ( i = 0; i < int(35 - strlen(type_name)); i++)
      {
        fp_struct << ' ';
        if ( !ctx->common_structfile_only)
          cstruc->f << ' ';
      }
      fp_struct << " *" << pgmname << "P[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
      if ( !ctx->common_structfile_only)
        cstruc->f << " *" << pgmname << "P[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
    }
    else if ( ctx->rw->attr_pointer)
    {
      fp_struct <<
"  " << type_name;
      if ( !ctx->common_structfile_only)
        cstruc->f <<
"  " << type_name;
      for ( i = 0; i < int(35 - strlen(type_name)); i++)
      {
        fp_struct << ' ';
        if ( !ctx->common_structfile_only)
          cstruc->f << ' ';
      }
      fp_struct << " **" << pgmname << "P" << alignstr << ";" << endl;
      if ( !ctx->common_structfile_only)
        cstruc->f << " **" << pgmname << "P" << alignstr << ";" << endl;
    }
    else
    {
      fp_struct <<
"  " << type_name;
      if ( !ctx->common_structfile_only)
        cstruc->f <<
"  " << type_name;
      for ( i = 0; i < int(35 - strlen(type_name)); i++)
      {
        fp_struct << ' ';
        if ( !ctx->common_structfile_only)
          cstruc->f << ' ';
      }
      fp_struct << " *" << pgmname << "P" << alignstr << ";" << endl;
      if ( !ctx->common_structfile_only)
        cstruc->f << " *" << pgmname << "P" << alignstr << ";" << endl;
    }
  }

  if ( ctx->rw->attr_array && ctx->rw->attr_pointer)
  {
    fp_struct <<
"  " << type_name;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"  " << type_name;
    for ( i = 0; i < int(35 - strlen(type_name)); i++)
    {
      fp_struct << ' ';
      if ( !ctx->common_structfile_only)
        cstruc->f << ' ';
    }
    fp_struct << " *" << pgmname << "[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f << " *" << pgmname << "[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
  }
  else if ( ctx->rw->attr_array)
  {
    fp_struct <<
"  " << type_name;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"  " << type_name;
    for ( i = 0; i < int(35 - strlen(type_name)); i++)
    {
      fp_struct << ' ';
      if ( !ctx->common_structfile_only)
        cstruc->f << ' ';
    }
    fp_struct << ' ' << pgmname << "[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f << pgmname << "[" << ctx->rw->attr_elements << "]" << alignstr << ";" << endl;
  }
  else if ( ctx->rw->attr_pointer)
  {
    fp_struct <<
"  " << type_name;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"  " << type_name;
    for ( i = 0; i < int(35 - strlen(type_name)); i++)
    {
      fp_struct << ' ';
      if ( !ctx->common_structfile_only)
        cstruc->f << ' ';
    }
    fp_struct << " *" << pgmname << alignstr << ";" << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f << " *" << pgmname << alignstr << ";" << endl;
  }
  else
  {
    fp_struct <<
"  " << type_name;
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"  " << type_name;
    for ( i = 0; i < int(35 - strlen(type_name)); i++)
    {
      fp_struct << ' ';
      if ( !ctx->common_structfile_only)
        cstruc->f << ' ';
    }
    fp_struct << ' ' << pgmname << alignstr << ";" << endl;
    if ( !ctx->common_structfile_only)
      cstruc->f << pgmname << alignstr << ";" << endl;
  }

#if 0
  int fill;
  int size;
  int elements;
  char alignstr_filler[40];

  if ( ctx->rw->attr_pointer)
    size = 4;
  else if ( strcmp( CnvCtx::low(ctx->rw->attr_typeref), "uint8") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "int8") == 0 ||
       strcmp( CnvCtx::low(ctx->rw->attr_typeref), "char") == 0)
    size = 1;
  else if ( strcmp( CnvCtx::low(ctx->rw->attr_typeref), "uint16") == 0 ||
            strcmp( CnvCtx::low(ctx->rw->attr_typeref), "int16") == 0)
    size = 2;
  else
    size = 4;

  if ( ctx->rw->attr_elem == 0)
    elements = 1;
  else
    elements = ctx->rw->attr_elem;

  if ( size < 4)
  {
    fill = 4 - ((elements * size) % 4);
    if ( fill == 4)
      fill = 0;
  }
  else
    fill = 0;

  if ( fill)
  {
    fp_struct <<
"  " << "char";
    if ( !ctx->common_structfile_only)
      cstruc->f <<
"  " << "char";
    for ( i = 0; i < int(36 - strlen("char")); i++)
    {
      fp_struct << ' ';
      if ( !ctx->common_structfile_only)
        cstruc->f << ' ';
    }
    if ( fill == 1)
    {
      fp_struct << "filler_" << struct_filler_cnt << alignstr_filler << ";" << endl;
      if ( !ctx->common_structfile_only)
        cstruc->f << "filler_" << struct_filler_cnt << alignstr_filler << ";" << endl;
    }
    else  
    {
      fp_struct << "filler_" << struct_filler_cnt << "[" << fill << "]" << alignstr_filler <<";" << endl;
      if ( !ctx->common_structfile_only)
        cstruc->f << "filler_" << struct_filler_cnt << "[" << fill << "]" << alignstr_filler << ";" << endl;
    }
    struct_filler_cnt++;
  }
#endif
  attr_count++;
  return 1;
}

int CnvWblToH::typedef_exec()
{
  if ( strcmp( ctx->rw->typedef_typeref, "Mask") == 0 ||
       strcmp( ctx->rw->typedef_typeref, "Enum") == 0) {
    if ( strcmp(ctx->rw->typedef_pgmname, "") == 0)
      strcpy( ctx->rw->typedef_pgmname, ctx->rw->typedef_name);

    fp_struct << 
"/*_* " << ctx->rw->typedef_typeref << ": " << ctx->rw->typedef_name << endl <<
"    @Aref " << ctx->rw->typedef_name << " " << ctx->rw->typedef_name << endl <<
"*/" << endl << endl <<
"typedef pwr_t" << ctx->rw->typedef_typeref << " pwr_t" << ctx->rw->typedef_name << ";" << endl << endl <<
"typedef enum {" << endl;
  }
  else if ( strcmp( ctx->rw->typedef_typeref, "String") == 0) {
    if ( ctx->rw->typedef_elements > 1)
      fp_struct << 
"typedef char pwr_t" << ctx->rw->typedef_name << "[" << ctx->rw->typedef_elements << "];" << endl << endl;
    else
      fp_struct << 
"typedef char pwr_t" << ctx->rw->typedef_name << ";" << endl << endl;
  }
  else {
    if ( ctx->rw->typedef_elements > 1)
      fp_struct <<
"typedef pwr_t" << ctx->rw->typedef_typeref << " pwr_t" << ctx->rw->typedef_name << "[" << ctx->rw->typedef_elements << "];" << endl << endl;
    else
      fp_struct <<
"typedef pwr_t" << ctx->rw->typedef_typeref << " pwr_t" << ctx->rw->typedef_name << ";" << endl << endl;
  }

  struct_class_open = 1;
  return 1;
}

int CnvWblToH::typedef_close()
{
  if ( strcmp(ctx->rw->typedef_pgmname, "") == 0)
    strcpy( ctx->rw->typedef_pgmname, ctx->rw->typedef_name);

  if ( strcmp( ctx->rw->typedef_typeref, "Mask") == 0)
    fp_struct << 
"} pwr_m" << ctx->rw->typedef_pgmname << ";" << endl << endl;
  else if ( strcmp( ctx->rw->typedef_typeref, "Enum") == 0)
    fp_struct <<
"} pwr_e" << ctx->rw->typedef_pgmname << ";" << endl << endl;

  struct_class_open = 0;
  return 1;
}

int CnvWblToH::bit_exec()
{
  char pgmname[80];
  int i;

  if ( strcmp(ctx->rw->typedef_pgmname, "") == 0)
    strcpy( ctx->rw->typedef_pgmname, ctx->rw->typedef_name);

  if ( strcmp( ctx->rw->bit_pgmname, "") == 0)
    strcpy( pgmname, ctx->rw->bit_name);
  else
    strcpy( pgmname, ctx->rw->bit_pgmname);

  if ( strcmp( ctx->rw->bit_type, "Bit") == 0) {
    fp_struct <<
"  pwr_m" << ctx->rw->typedef_pgmname << "_" << pgmname;
    for ( i = 0; i < int(30 - strlen(ctx->rw->typedef_pgmname) - strlen(pgmname)); i++)
      fp_struct << ' ';
    fp_struct << " = " << ctx->rw->bit_value << "," << endl;
  }
  else if ( strcmp( ctx->rw->bit_type, "Value") == 0) {
    fp_struct <<
"  pwr_e" << ctx->rw->typedef_pgmname << "_" << pgmname;
    for ( i = 0; i < int(30 - strlen(ctx->rw->typedef_pgmname) - strlen(pgmname)); i++)
      fp_struct << ' ';
    fp_struct << " = " << ctx->rw->bit_value << "," << endl;
  }
  return 1;
}

int CnvWblToH::volname_to_id()
{
  FILE *fp;
  pwr_tFileName fname;
  char line[400];
  char	line_part[4][80];
  int nr;
  int sts;
  unsigned int vid_0, vid_1, vid_2, vid_3;

  strcpy( struct_volid, "");

  strcpy( fname, ctx->rw->source_dir);
  strcat( fname, CnvCtx::low(ctx->rw->volume_name));
  strcat( fname, "_v.wb_load");

  fp = fopen( fname, "r");
  if ( !fp) {
    strcpy( fname, ctx->rw->current_file);
    fp = fopen( fname, "r");
    if ( !fp) {
      printf( "** Unable to find Volume declaration\n");
      return 0;
    }
  }

  while( 1)
  {
    sts = CnvCtx::read_line( line, sizeof(line), fp);
    if ( !sts)
      break;
    else
    {
      CnvCtx::remove_spaces( line, line);
      if ( strcmp( line, "") == 0)
        continue;

      if ( line[0] == '!')
        continue;

      nr = dcli_parse( line, " 	=", "", (char *)line_part,
                	sizeof( line_part) / sizeof( line_part[0]), 
			sizeof( line_part[0]), 0);
      if ( strcmp( CnvCtx::low( line_part[0]), "volume") == 0)
      {
        if ( nr > 3)
        {
          strcpy( struct_volid, line_part[3]);
          break;
        }
      }
    }  
  }
  fclose( fp);

  if ( strcmp( struct_volid, "") == 0)
    return 0;

  if (sscanf( struct_volid, "%d.%d.%d.%d", &vid_3, &vid_2, &vid_1, &vid_0) != 4)
    return 0;

  struct_vid_0 = vid_0;
  struct_vid_1 = vid_1;

  return 1;
}

void CnvWblToH::cix_to_classid( unsigned int cix, pwr_tClassId *cid)
{
  cdh_uTypeId		lcid;

  lcid.pwr = pwr_cNClassId;
  lcid.c.vid_1 = struct_vid_1;
  lcid.c.vid_0 = struct_vid_0;
  lcid.c.cix = cix;

  *cid = lcid.pwr;
}

int CnvWblToH::cixstr_to_classid( char *cix_str, pwr_tClassId *cid)
{
  int found;
  struct_tCixArray	*cix_p;
  struct_tCixArray cix_array[] = {
	{ "pwr_eCix_ClassDef",		pwr_eCix_ClassDef},
	{ "pwr_eCix_Type",		pwr_eCix_Type},
	{ "pwr_eCix_TypeDef",		pwr_eCix_TypeDef},
	{ "pwr_eCix_ObjBodyDef",	pwr_eCix_ObjBodyDef},
	{ "pwr_eCix_Param",		pwr_eCix_Param},
	{ "pwr_eCix_Input",		pwr_eCix_Input},
	{ "pwr_eCix_Output",		pwr_eCix_Output},
	{ "pwr_eCix_Intern",		pwr_eCix_Intern},
	{ "pwr_eCix_Buffer",		pwr_eCix_Buffer},
	{ "pwr_eCix_ObjXRef",		pwr_eCix_ObjXRef},
	{ "pwr_eCix_Layout",		pwr_eCix_Layout},
	{ "pwr_eCix_Group",		pwr_eCix_Group},
	{ "pwr_eCix_GroupRef",		pwr_eCix_GroupRef},
	{ "pwr_eCix_TypeHier",		pwr_eCix_TypeHier},
	{ "pwr_eCix_ClassHier",		pwr_eCix_ClassHier},
	{ "pwr_eCix_ModHier",		pwr_eCix_ModHier},
	{ "pwr_eCix_PlantHier",		pwr_eCix_PlantHier},
	{ "pwr_eCix_PlcProgram",	pwr_eCix_PlcProgram},
	{ "pwr_eCix_PlcWindow",		pwr_eCix_PlcWindow},
	{ "pwr_eCix_PlcNode",		pwr_eCix_PlcNode},
	{ "pwr_eCix_PlcConnection",	pwr_eCix_PlcConnection},
	{ "pwr_eCix_Point",		pwr_eCix_Point},
	{ "pwr_eCix_GraphPlcProgram",	pwr_eCix_GraphPlcProgram},
	{ "pwr_eCix_GraphPlcWindow",	pwr_eCix_GraphPlcWindow},
	{ "pwr_eCix_GraphPlcNode",	pwr_eCix_GraphPlcNode},
	{ "pwr_eCix_GraphPlcConnection", pwr_eCix_GraphPlcConnection},
	{ "pwr_eCix_PlcPgm",		pwr_eCix_PlcPgm},
	{ "pwr_eCix_Hierarchy",		pwr_eCix_Hierarchy},
	{ "pwr_eCix_NodeHier",		pwr_eCix_NodeHier},
	{ "pwr_eCix_PgmDef",		pwr_eCix_PgmDef},
	{ "pwr_eCix_Node",		pwr_eCix_Node},
	{ "pwr_eCix_Appl",		pwr_eCix_Appl},
	{ "pwr_eCix_System",		pwr_eCix_System},
	{ "pwr_eCix_LibHier",		pwr_eCix_LibHier},
	{ "pwr_eCix_DocHier",		pwr_eCix_DocHier},
	{ "pwr_eCix_AttrXRef",		pwr_eCix_AttrXRef},
	{ "pwr_eCix_Menu",		pwr_eCix_Menu},
	{ "pwr_eCix_MenuSeparator", 	pwr_eCix_MenuSeparator},
	{ "pwr_eCix_MenuCascade",	pwr_eCix_MenuCascade},
	{ "pwr_eCix_MenuButton",	pwr_eCix_MenuButton},
	{ "pwr_eCix_Object",		pwr_eCix_Object},
	{ "pwr_eCix_DbCallBack",	pwr_eCix_DbCallBack},
	{ "pwr_eCix_Alias",		pwr_eCix_Alias},
	{ "pwr_eCix_RootVolume",	pwr_eCix_RootVolume},
	{ "pwr_eCix_SubVolume",		pwr_eCix_SubVolume},
	{ "pwr_eCix_SharedVolume",	pwr_eCix_SharedVolume},
	{ "pwr_eCix_DynamicVolume",	pwr_eCix_DynamicVolume},
	{ "pwr_eCix_SystemVolume",	pwr_eCix_SystemVolume},
	{ "pwr_eCix_ClassVolume",	pwr_eCix_ClassVolume},
	{ "pwr_eCix_DetachedClassVolume", pwr_eCix_DetachedClassVolume},
	{ "pwr_eCix_WorkBenchVolume",	pwr_eCix_WorkBenchVolume},
	{ "pwr_eCix_DirectoryVolume",	pwr_eCix_DirectoryVolume},
	{ "pwr_eCix_CreateVolume",	pwr_eCix_CreateVolume},
	{ "pwr_eCix_MountVolume",	pwr_eCix_MountVolume},
	{ "pwr_eCix_MountObject",	pwr_eCix_MountObject},
	{ "pwr_eCix_RtMenu",		pwr_eCix_RtMenu},
	{ "pwr_eCix_VolatileVolume",	pwr_eCix_VolatileVolume},
	{ "pwr_eCix_MenuRef",		pwr_eCix_MenuRef},
	{ "pwr_eCix_Bit",		pwr_eCix_Bit},
	{ "pwr_eCix_Value",		pwr_eCix_Value},
	{ "pwr_eCix_Method",		pwr_eCix_Method},
	{ "pwr_eCix_RtMethod",		pwr_eCix_RtMethod},
	{ "pwr_eCix_ExternVolume",     	pwr_eCix_ExternVolume},
	{ "pwr_eCix_Hier",     		pwr_eCix_Hier},
	{ "pwr_eCix_Security",         	pwr_eCix_Security},
	{ "", 0}};

  found = 0;
  for ( cix_p = cix_array; strcmp( cix_p->name, "") != 0; cix_p++)
  {
    if ( strcmp( cix_str, cix_p->name) == 0)
    {
      found = 1;
      break;
    }
  }
  if ( !found)
    return 0;

  cix_to_classid( cix_p->id, cid);
  return 1;
}

void CnvWblToH::get_filename( CnvReadWbl *rw, char *struct_file, int hpp)
{
  strcpy( struct_file, "pwr_");

  if ( strcmp( CnvCtx::low(rw->volume_name), "pwrb") == 0)
    strcat( struct_file, "base");
  else if ( strcmp( CnvCtx::low(rw->volume_name), "pwrs") == 0)
    // To separate from pwr_systemclasses.h 
    strcat( struct_file, "system");
  else
    strcat( struct_file, CnvCtx::low(rw->volume_name));

  if ( hpp)
    strcat( struct_file, "classes.hpp");
  else
    strcat( struct_file, "classes.h");
}

int CnvWblToH::check_typename( char *type_volume, char *type_name)
{
  // Only types in pwrs can be typechecked
  if ( strcmp( type_volume, "pwrs") == 0 || strcmp( type_volume, "") == 0) {
    char		*name;
    char		valid_names[][40] = {
	"pwr_tAddress",
	"pwr_tBit",
	"pwr_tBitMask",
	"pwr_tBoolean",
	"pwr_tFloat32",
	"pwr_tFloat64",
	"pwr_tGeneration",
	"pwr_tChar",
	"pwr_tString",
	"pwr_tText",
	"pwr_tInt8",
	"pwr_tInt16",
	"pwr_tInt32",
	"pwr_tStatus",
	"pwr_tNetStatus",
	"pwr_tInt64",
	"pwr_tUInt64",
	"pwr_tUInt8",
	"pwr_tUInt16",
	"pwr_tUInt32",
	"pwr_tVolumeId",
	"pwr_tObjectIx",
	"pwr_tMask",
	"pwr_tEnum",
	"pwr_tClassId",
	"pwr_tTypeId",
	"pwr_tVersion",
	"pwr_tPwrVersion",
	"pwr_tProjVersion",
	"pwr_tUserId",
	"pwr_tDbId",
	"pwr_tNodeId",
	"pwr_tNodeIndex",
	"pwr_tDlid",
	"pwr_tSubid",
	"pwr_tTime",
	"pwr_tDeltaTime",
	"pwr_tRefId",
	"pwr_tObjid",
	"pwr_sAttrRef",
	"pwr_sPlcNode",
	"pwr_sPlcConnection",
	"pwr_sPlcWindow",
	"pwr_sPlcProgram",
	"pwr_tString256",
	"pwr_tString132",
	"pwr_tString80",
	"pwr_tString40",
	"pwr_tString32",
	"pwr_tString16",
	"pwr_tString8",
	"pwr_tString1",
	"pwr_tText256",
	"pwr_tText1024",
	"pwr_tURL",
	"pwr_tOpSysEnum",
	"pwr_tPrivMask",
	"pwr_tProString40",
	"pwr_tDataRef",
	""};

    for ( name = valid_names[0]; strcmp(name,"") != 0; 
	  name += sizeof(valid_names[0])) {
      if ( strcmp( name, type_name) == 0)
	return 1;
    }
    return 0;
  }
  else
    return 1;
}
