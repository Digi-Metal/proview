/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* cnv_xtthelptohtml.cpp --
   Convert xtt help file to html. */

/*_Include files_________________________________________________________*/

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

extern "C" {
#include "co_cdh.h"
#include "co_dcli.h"
}

#include "co_lng.h"
#include "co_nav_help.h"
#include "cnv_ctx.h"
#include "co_math.h"
#include "cnv_readxtthelp.h"
#include "cnv_xtthelptohtml.h"

#define CNV_TAB 18

static int replace_url_symbols( const pwr_tURL in, pwr_tURL out);
static int find_symbol( char *name, char *value);

void CnvXtthelpToHtml::subject_to_fname( char *fname, const char *subject, int path)
{
  char *s, *t;

  if ( path) {
    strcpy( fname, ctx->dir);
    strcat( fname, ctx->rx->name);
  }
  else
    strcpy( fname, ctx->rx->name);
  strcat( fname, "_");
  t = fname + strlen(fname);
  for ( s = (char *)subject; *s; s++,t++) {
    if ( *s == ' ' || *s == '(' || *s == ')')
      *t = '_';
    else
      *t = *s;
  }
  *t = 0;
  strcat( fname, ".html");
}

void *CnvXtthelpToHtml::insert( navh_eItemType item_type, const char *text1,
				const char *text2, const char *text3, const char *link, 
				const char *link_bookmark, const char *file_name,
				navh_eHelpFile file_type, int help_index, 
				const char *bookmark, int coding)
{
  int i;
  static int in_table = 0;

  if ( (text2 && strcmp(text2, "") != 0) || 
       (text3 && strcmp(text3, "") != 0) ) {
    if ( !in_table && cf) {
      cf->f << "<TABLE>" << endl;
      in_table = 1;
    }
  }
  else {
    if ( in_table && cf) {
      // Close table (keep if empty line) 
      if ( !( text1 && strcmp( text1, "") == 0 && 
	      (item_type == navh_eItemType_Help || 
	       item_type == navh_eItemType_HelpCode || 
	       item_type == navh_eItemType_HelpBold))) {
        cf->f << "</TABLE>" << endl;
        in_table = 0;
      }
    }
  }
  switch ( item_type) {
    case navh_eItemType_Topic:
    {
      pwr_tFileName fname;
      char codingstr[40] = "ISO-8859-1";

      if ( coding == lng_eCoding_UTF_8)
	strcpy( codingstr, "UTF-8");
      

      subject_to_fname( fname, text1, 1);
      cf = new CnvFile();
      cf->f.open( fname);
      cf->f <<
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"\"http://www.w3.org/TR/REC-html40/loose.dtd>" << endl <<
"<!--NewPage-->" << endl <<
"<HTML>" << endl <<
"<HEAD>" << endl <<
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=" << codingstr << "\">" << endl <<
"<!-- Generated by co_convert.-->" << endl <<
"<TITLE>" << endl <<
"Help topic: " << text1 << endl <<
"</TITLE>" << endl <<
"<LINK REL =\"stylesheet\" TYPE=\"text/css\" HREF=\"../pcss.css\" TITLE=\"Style\">" << endl <<
"</HEAD>" << endl <<
	//"<H2>" << text1 << "</H2><BR>" << endl <<
"<P>" << endl;
      return NULL;
    } 
    case navh_eItemType_EndTopic:
    {
      if ( !cf) 
	break;

      cf->f.close();
      delete cf;
      cf = 0;
      return NULL;
    }
    case navh_eItemType_Help:
    case navh_eItemType_HelpCode:
    {      
      if ( !cf) 
	break;

      if ( item_type == navh_eItemType_HelpCode && !in_table) {
        cf->f << "<CODE>";
	for ( const char *s = text1; s && *s == ' '; s++)
	  cf->f << "&nbsp;";
      }

      pwr_tFileName fname;
      if ( strcmp( link, "") != 0) {

	if ( strncmp( link, "$web:", 5) == 0) {
	  replace_url_symbols( &link[5], fname);
	  // if ( strncmp( &link[5], "$pwrp_web/", 10) == 0)
	  //   strcpy( fname, &link[15]);
	  // else
	  //   strcpy( fname, &link[5]);
	} 
	else if ( strncmp( link, "$class:", 7) == 0) {
	  char *s;

	  // Get prefix from file
	  strcpy( fname, "./orm/");
	  s = (char *)strrchr( file_name, '/');
	  if ( s)
	    strcat( fname, s+1);
	  s = strchr( fname, '_');
	  if ( s)
	    *(s+1) = 0;
	  strcat( fname, &link[7]);
	  strcat( fname, ".html");
	} 
        else if ( (strstr( link, ".htm") != 0) || 
		  (strstr( link, ".pdf") != 0)) {
          strcpy( fname, link);
        }
        else {
          subject_to_fname( fname, link, 0);
        
          if ( strcmp( link_bookmark, "") != 0) {
	    strcat( fname, "#");
	    strcat( fname, link_bookmark);
          }
	  else if ( file_name && strcmp( file_name, "") != 0) {
	    char *s = (char *)strrchr( file_name, '/');
	    if ( s)
	      strcpy( fname, s+1);
	    else
	      strcpy( fname, file_name);
	    s = strchr( fname, '.');
	    if ( s)
	      *s = 0;
	    strcat( fname, "_");
	    strcat( fname, link);
	    strcat( fname, ".html");
	  }
        }
	if ( !in_table)
	  cf->f << "<A HREF=\"" <<  fname << "\">";
      }
      else if ( bookmark) {
	if ( in_table) {
	  cf->f << "</TABLE>" << endl;
	  in_table = 0;
	}
        cf->f << "<A NAME=\"" << bookmark << "\">";
      }

      if ( ! in_table) {
        cf->f << text1;
        if ( strcmp( link, "") != 0 || bookmark)
          cf->f << "<BR></A>" << endl;
        else
          cf->f << "<BR>" << endl;
	if ( item_type == navh_eItemType_HelpCode)
	  cf->f << "</CODE>";
      }
      else {
	cf->f << "<TR><TD>";
        if ( strcmp( link, "") != 0)
          cf->f << "<A HREF=\"" <<  fname << "\">";
        else if ( bookmark != 0)
          cf->f << "<A NAME=\"" <<  bookmark << "\">";
	cf->f << text1;
        if ( strcmp( text2, "") != 0 || strcmp( text3, "") != 0) {
          for ( i = 0; i < (int)(CNV_TAB - strlen(text1)); i++)
            cf->f << "&nbsp;";
          cf->f << "&nbsp;&nbsp;</TD><TD>" << text2;
          if ( strcmp( text3, "") != 0) {
            for ( i = 0; i < (int)(CNV_TAB - strlen(text2)); i++)
              cf->f << "&nbsp;";
            cf->f << "&nbsp;&nbsp;</TD><TD>" << text3;
          }
        }
        if ( strcmp( link, "") != 0 || bookmark)
          cf->f << "</A>" << endl;
        else
          cf->f << endl;
        cf->f << "</TD></TR>";
      }
      return NULL;
    }
    case navh_eItemType_HelpBold:
    {
      if ( !cf) 
	break;

      pwr_tFileName fname;
      if ( strcmp( link, "") != 0) {
	if ( strncmp( link, "$web:", 5) == 0) {
	  replace_url_symbols( &link[5], fname);
	  //if ( strncmp( &link[5], "$pwrp_web/", 10) == 0)
	  //  strcpy( fname, &link[15]);
	  //else
	  //  strcpy( fname, &link[5]);
	} 
	else if ( strncmp( link, "$class:", 7) == 0) {
	  char *s;

	  // Get prefix from file
	  strcpy( fname, "./orm/");
	  s = (char *)strrchr( file_name, '/');
	  if ( s)
	    strcat( fname, s+1);
	  s = strchr( fname, '_');
	  if ( s)
	    *(s+1) = 0;
	  strcat( fname, &link[7]);
	  strcat( fname, ".html");
	} 
        else if ( (strstr( link, ".htm") != 0) || 
		  (strstr( link, ".pdf") != 0)) {
          strcpy( fname, link);
        }
        else {
          subject_to_fname( fname, link, 0);
          if ( strcmp( link_bookmark, "") != 0) {
	    strcat( fname, "#");
	    strcat( fname, link_bookmark);
          }
        }
        if ( !in_table)
          cf->f << "<A HREF=\"" <<  fname << "\">";
      }
      else if ( bookmark) {
	if ( !in_table)
          cf->f << "<A NAME=\"" << bookmark << "\">";
      }

      if ( ! in_table) {
        cf->f << "<B>" << text1 << "</B>"; 
        if ( strcmp( link, "") != 0 || bookmark)
          cf->f<< "<BR></A>" << endl;
        else
          cf->f<< "<BR>" << endl;
      }
      else {
	cf->f << "<TR><TD><B>";
        if ( strcmp( link, "") != 0)
          cf->f << "<A HREF=\"" <<  fname << "\">";
        else if ( bookmark != 0)
          cf->f << "<A NAME=\"" <<  bookmark << "\">";
        cf->f << text1;
        if ( strcmp( link, "") != 0 || bookmark)
	  cf->f << "</A>";
        if ( strcmp( text2, "") != 0 || strcmp( text3, "") != 0) {
          for ( i = 0; i < (int)(CNV_TAB - strlen(text1)); i++)
            cf->f << "&nbsp;";
          cf->f << "&nbsp;&nbsp;</B></TD><TD><B>" << text2;
          if ( strcmp( text3, "") != 0) {
            for ( i = 0; i < (int)(CNV_TAB - strlen(text2)); i++)
              cf->f << "&nbsp;";
            cf->f << "&nbsp;&nbsp;</B></TD><TD><B>" << text3;
          }
        }
        if ( strcmp( link, "") != 0 || bookmark)
          cf->f << "</A>" << endl;
        else
          cf->f << endl;
        cf->f << "</B></TD></TR>";
      }
      return NULL;
    }
    case navh_eItemType_HelpHeader:
    {
      if ( !cf) 
	break;

      cf->f << "<H1>" << text1 << "</H1>" << endl;
      return NULL;
    }
    case navh_eItemType_Header:
    {      
      if ( !cf) 
	break;

      if ( bookmark != 0)
	cf->f << "<A NAME=\"" <<  bookmark << "\">";
      cf->f << "<H3>" << text1 << "</H3>";
      if ( bookmark != 0)
	cf->f << "</A>";
      cf->f << endl;
      return NULL;
    }
    case navh_eItemType_HeaderLarge:
    {      
      if ( !cf) 
	break;

      if ( bookmark != 0)
	cf->f << "<A NAME=\"" <<  bookmark << "\">";
      cf->f << "<H2>" << text1 << "</H2>";
      if ( bookmark != 0)
	cf->f << "</A>";
      cf->f << endl;
      return NULL;
    }
    case navh_eItemType_HorizontalLine:
    {      
      if ( !cf) 
	break;

      cf->f << "<HR>" << endl;
      return NULL;
    }
    case navh_eItemType_Image:
    {      
      if ( !cf) 
	break;

      cf->f << "<IMG SRC=\"" << text1 << "\"><BR>" << endl;
      return NULL;
    }
    default:
      return 0;
  }
  return 0;
}


static int replace_url_symbols( const pwr_tURL in, pwr_tURL out)
{
  char *s, *t;
  char *sym_start;
  char sym_value[80];
  char sym_name[80];
  pwr_tURL tmp;
  int skip_sym = 0;
  pwr_tURL url;
     
  strncpy( url, in, sizeof(pwr_tURL));

  sym_start = 0;
  t = tmp;
  for ( s = url; *s; s++) {
    if ( *s == '\\' && *(s+1) == '$')
      skip_sym = 1;
    if ( *s == '$' && !skip_sym) {
      if ( sym_start) {
        strncpy( sym_name, sym_start+1, s - (sym_start + 1));
        sym_name[s - sym_start - 1] = 0;
        if ( find_symbol( sym_name, sym_value)) {
          strcpy( t, sym_value);
          t += strlen(sym_value);
        }
        else {
          strncpy( t, sym_start, s - sym_start);
          t += s - sym_start;
        }
      }
      sym_start = s;
    }
    else if ( *s == '$' && skip_sym) {
      skip_sym = 0;
      *t++ = *s;
    }
    else if ( sym_start) {
      if ( !(isdigit(*s) || isalpha(*s) || *s == '_')) {
        // End of symbol
        strncpy( sym_name, sym_start+1, s - (sym_start + 1));
        sym_name[s - sym_start - 1] = 0;
        if ( find_symbol( sym_name, sym_value)) {
          strcpy( t, sym_value);
          t += strlen(sym_value);
        }
        else {
          strncpy( t, sym_start, s - sym_start);
          t += s - sym_start;
        }
        sym_start = 0;
        *t++ = *s;
      }
    }
    else
      *t++ = *s;
  }
  if ( sym_start) {
    strcpy( sym_name, sym_start+1);
    if ( find_symbol( sym_name, sym_value))
      strcpy( t, sym_value);
    else
      strcpy( t, sym_start);
  }
  else
    *t = 0;

  strcpy( out, tmp);
  return 1;
}

#define MAXSYMBOLS 100

static int find_symbol( char *name, char *value)
{
  static int loaded = 0;
  static char sym_vect[MAXSYMBOLS][80];
  static char value_vect[MAXSYMBOLS][80];
  static int vect_cnt;
  int nr;
  char elemv[3][80];
  int j;
  int		found;

  // Read the file
  if ( !loaded) {
    FILE *fp;
    char line[200];
    pwr_tFileName fname;

    vect_cnt = 0;

    sprintf( fname, "$pwrp_db/pwrp_cnf_websymbols.dat");
    dcli_translate_filename( fname, fname);

    fp = fopen( fname, "r");
    if ( !fp)
      return 0;


    while ( dcli_read_line( line, sizeof( line), fp)) {
      nr = dcli_parse( line, " ", "", (char *)elemv, sizeof( elemv) / sizeof( elemv[0]), 
		       sizeof( elemv[0]), 0);
      if ( nr != 3)
	continue;
      strcpy( sym_vect[vect_cnt], elemv[1]);
      strcpy( value_vect[vect_cnt], elemv[2]);
      vect_cnt++;
    }
    fclose( fp);
    loaded = 1;
  }

  if ( !vect_cnt)
    return 0;

  for ( j = 0; j < vect_cnt; j++) {
    if ( cdh_NoCaseStrcmp( name, sym_vect[j]) == 0) {
      strcpy( value, value_vect[j]);
      found = 1;
      break;
    }
  }
  if ( !found) 
    return 0;

  return 1;
}





