/** 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2011 SSAB Oxelosund AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* co_dcli_file.c -- File handling in dcli */

# include <string.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <sys/stat.h>
# include <sys/types.h>

#include "co_cdh.h"
#include "co_dcli_msg.h"
#include "co_dcli.h"


typedef enum {
  dcli_eTrans_EnvVar,
  dcli_eTrans_Dir,
  dcli_eTrans_File
} dcli_eTrans;


static char dcli_default_directory[200] = "";

void 	dcli_set_default_directory( char *dir)
{
  strcpy( dcli_default_directory, dir);
}

int	dcli_get_defaultfilename(
			const char	*inname,
			char		*outname,
			const char	*ext)
{
  char	filename[80];
  char 	*s, *s2;

#if defined(OS_VMS)
  if ( strchr( inname, '<') || strchr( inname, '[') || 
       strchr( inname, ':'))
    strcpy( outname, inname);
  else
  {
    strcpy( filename, dcli_default_directory);
    strcat( filename, inname);
    strcpy( outname, filename);
  }
#elif defined(OS_LYNX) || defined(OS_LINUX) || defined(OS_MACOS) || defined OS_FREEBSD
  if ( strchr( inname, '/'))
    cdh_Strcpy( outname, inname);
  else if ( ( s = strchr( inname, ':')))
  {
    /* Replace VMS disp to env variable */
    strcpy( filename, "$");
    strncat( filename, inname, s - inname);
    filename[ s - inname + 1] = 0;
    strcat( filename, "/");
    strcat( filename, s + 1);
    dcli_replace_env( filename, outname);
  }
  else
  {
    if ( strcmp( dcli_default_directory, "") == 0)
    {
      char cwd[200];

      if ( getcwd( cwd, sizeof(cwd)) != NULL)
      {
        strcpy( filename, cwd);
        strcat( filename, "/");
      }
      else
        strcpy( filename, "");
      strcat( filename, inname);
      dcli_replace_env( filename, outname);
    }
    else
    {
      strcpy( filename, dcli_default_directory);
      if ( (filename[strlen(filename)-1] != '/') &&
         (inname[0] != '/'))
        strcat( filename, "/");
      strcat( filename, inname);
      dcli_replace_env( filename, outname);
    }
  }
#endif

  /* Look for extention in filename */
  if ( ext != NULL)
  {
    s = strrchr( inname, ':');
    if ( s == 0)
      s = (char *)inname;
  
    s2 = strrchr( s, '>');
    if ( s2 == 0)
    {
      s2 = strrchr( s, ']');
      if ( s2 == 0)
        s2 = s;
    }

    s = strrchr( s2, '.');
    if ( s == 0)
    {
      /* No extention found, add extention */
      strcat( outname, ext);
    }
  }

#if defined(OS_LYNX) || defined(OS_LINUX) || defined(OS_MACOS) || defined OS_FREEBSD
  // cdh_ToLower( outname, outname);
#endif
  return DCLI__SUCCESS;
}

#if defined(OS_LYNX) || defined(OS_LINUX) || defined(OS_MACOS) || defined OS_FREEBSD

/*************************************************************************
*
* Name:		dcli_replace_env()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Replace env variables in UNIX filenames.
*	A string that starts with $ and ends with . or / will replaced 
*	if then string is found by getenv. Only lower case variables 
*	will be detected.
*
**************************************************************************/
int     dcli_replace_env( const char *str, char *newstr)
{
  char    *s;
  char    *t;
  char    *u;
  int     symbolmode;
  long int size;
  char    *value;
  char    symbol[80];
  char    lower_symbol[80];
  char    new[160];

  symbolmode = 0;
  s = (char *)str;
  t = new;

  while ( *s != 0) {
    if (*s == '$') {
      if ( *(s+1) == '$') {
	/* '$$: insert pid */
	char pid[20];
	sprintf( pid, "%d", getpid());
	strncpy( t, pid, strlen(pid));
	t += strlen(pid);
	s ++;
      }
      else {
	symbolmode = 1;
	u = s + 1;
	*t = *s;
	t++;
      }
    }
    else if (symbolmode && (*s == '/' || *s == '.')) {
      /* End of potential symbol */
      size = (long int) s - (long int) u;
      strncpy( symbol, u, size);
      symbol[size] = 0;
      if ( strcmp( symbol, "HOME") == 0)
	strcpy( lower_symbol, symbol);
      else
	cdh_ToLower( lower_symbol, symbol);
      if ( (value = getenv( lower_symbol)) == NULL) {
        /* It was no symbol */
        *t = *s;
        t++;
      }
      else {
        /* Symbol found */
        t -= strlen(symbol) + 1;
        strcpy( t, value);
        t += strlen(value);
        *t = *s;
        t++;
      }
      symbolmode = 0;
    }
    else {
      *t = *s;
      t++;
    }
    s++;
  }

  if ( symbolmode) {
    /* End of potential symbol */
    size = (long int) s - (long int) u;
    strncpy( symbol, u, size);
    symbol[size] = 0;
    if ( strcmp( symbol, "HOME") == 0)
      strcpy( lower_symbol, symbol);
    else
      cdh_ToLower( lower_symbol, symbol);
    if ( (value = getenv( lower_symbol)) == NULL) {
      /* It was no symbol */
      *t = 0;
    }
    else {
      /* Symbol found */
      t -= strlen(symbol) + 1;
      strcpy( t, value);
      t += strlen(value);
      *t = 0;
    }
  }
  else
    *t = 0;

  strcpy( newstr, new);
  return 1;
}
#endif

/*************************************************************************
*
* Name:		dcli_fgetname()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get filename for a filedescriptor.
*	This function is not implementet on all os, therefor a defaultname
*	should be supplied which is returned for this os.
*
**************************************************************************/
char	*dcli_fgetname( FILE *fp, char *name, char *def_name)
{
#if defined(OS_VMS) || defined(OS_ELN)
	return fgetname( fp, name);
#else
	dcli_translate_filename( name, def_name);
	return name;
#endif	
}


/*************************************************************************
*
* Name:		dcli_translate_filename()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Translate VMS or unix filename to the current platform.
*
**************************************************************************/

int dcli_translate_filename( char *out, const char *in)
{
  char out_name[200];
  const char *s;
  char *t;
  int i;
  int state;

#if defined OS_VMS
  if ( strchr( in, '/') != 0)
  {
    // Convert from unix to VMS
    for ( i = 0, s = in, t = out_name; *s; i++, s++)
    {
      if ( i == 0)
      {
        if ( *s == '$') 
          state = dcli_eTrans_EnvVar;
        else if ( *s == '/')
        {
          if ( strchr( s+1, '/') == 0)
            state = dcli_eTrans_File;
          else
          {
            state = dcli_eTrans_Dir;
            *t++ = '[';
          }
        }
        else
        {
          if ( strchr( s, '/') == 0)
          {
            state = dcli_eTrans_File;
            *t++ = *s;
          }
          else
          {
            state = dcli_eTrans_Dir;
            *t++ = '[';
            *t++ = '.';
            *t++ = *s;
          }
        }
        continue;
      }
      switch ( state)
      {
        case dcli_eTrans_EnvVar:
          if ( *s == '/')
          {
            if ( strchr( s+1, '/') != 0)
            {
              *t++ = ':';
              *t++ = '[';
              state = dcli_eTrans_Dir;
            }
            else
            {
              state = dcli_eTrans_File;
              *t++ = ':';
            }
          }
          else
            *t++ = *s;
          break;
        case dcli_eTrans_Dir:
          if ( *s == '/')
          {
            if ( strchr( s+1, '/') == 0)
            {
              *t++ = ']';
              state = dcli_eTrans_File;
            }
            else
              *t++ = '.';
          }
          else
            *t++ = *s;
          break;
        case dcli_eTrans_File:
          *t++ = *s;
          break;
      }
    }
    *t = 0;
    strcpy( out, out_name);
  }
  else
  {
    // Already VMS syntax
    strcpy( out_name, in);
    strcpy( out, out_name);
  }
  return DCLI__SUCCESS;
#elif defined OS_ELN
  if ( (s = strrchr( in, ']')) != 0 ||
       (s = strrchr( in, '>')) != 0 ||
       (s = strrchr( in, ':')) != 0 ||
       (s = strrchr( in, '/')) != 0)
  {
    strcpy( out_name, "[sys0.sysexe]");
    strcat( out_name, s+1);
    strcpy( out, out_name);
  }
  else
  {
    strcpy( out_name, "[sys0.sysexe]");
    strcat( out_name, in);
    strcpy( out, out_name);
  }
  return DCLI__SUCCESS;
#else
  int sts;

  if ( strchr( in, ':') != 0 ||
       strchr( in, '[') != 0 ||
       strchr( in, '<') != 0)
  {
    // Convert from VMS to unix
    for ( i = 0, s = in, t = out_name; *s; i++, s++)
    {
      if ( i == 0)
      {
        if ( strchr( in, ':') != 0) 
        {
          state = dcli_eTrans_EnvVar;
          *t++ = '$';
          *t++ = *s;
        }
        else if ( *s == '[' ||
                  *s == '<')
        {
          if ( *(s+1) == '.')
            s++;
          else
            *t++ = '/';
          state = dcli_eTrans_Dir;
        }
        else
        {
          state = dcli_eTrans_File;
          *t++ = *s;
        }
        continue;
      }
      switch ( state)
      {
        case dcli_eTrans_EnvVar:
          if ( *s == ':')
          {
            *t++ = '/';
            if ( *(s+1) == '[' ||
                 *(s+1) == '<')
            {
              state = dcli_eTrans_Dir;
              s++;
            }
            else
              state = dcli_eTrans_File;
          }
          else
            *t++ = *s;
          break;
        case dcli_eTrans_Dir:
          if ( *s == '.')
          {
            *t++ = '/';
          }
          else if ( *s == ']' ||
                    *s == '>')
          {
            *t++ = '/';
            state = dcli_eTrans_File;
          }
          else
            *t++ = *s;
          break;
        case dcli_eTrans_File:
          *t++ = *s;
          break;
      }
    }
    *t = 0;
    sts = dcli_replace_env( out_name, out);
    return sts;
  }
  else
  {
    // Already unix syntax
    if ( in[0] == '~') {
      strcpy( out_name, "$HOME");
      strcat( &out_name[5], &in[1]);
    }
    else
      strcpy( out_name, in);

    sts = dcli_replace_env( out_name, out);
    return sts;
  }
#endif
}


pwr_tStatus dcli_file_time( char *filename, pwr_tTime *time)
{
  struct stat info;

  if ( stat( filename, &info) != -1) {
    time->tv_sec = info.st_mtime;
    time->tv_nsec = 0;
    return DCLI__SUCCESS;
  }
  return DCLI__NOFILE;
}

pwr_tStatus dcli_file_ctime( char *filename, pwr_tTime *time)
{
  struct stat info;

  if ( stat( filename, &info) != -1) {
    time->tv_sec = info.st_ctime;
    time->tv_nsec = 0;
    return DCLI__SUCCESS;
  }
  return DCLI__NOFILE;
}

