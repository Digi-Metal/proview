/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2011 SSAB Oxelosund AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* plc_thread.c -- Run a PLC thread
   Run a PLC thread.  */

#if defined(OS_ELN)
# include $vaxelnc
#else
# include <string.h>
#endif

#if defined OS_LINUX
# include <pwd.h>
# include <signal.h>
# include <linux/capability.h>
# include <sys/types.h>
#endif

#if defined OS_MACOS || defined OS_FREEBSD || defined OS_OPENBSD || defined OS_CYGWIN
# include <pwd.h>
# include <signal.h>
# include <sys/types.h>
#endif

#include "pwr.h"
#include "pwr_class.h"
#include "pwr_baseclasses.h"
#include "co_time.h"
#include "co_time_msg.h"
#include "rt_errh.h"
#include "rt_gdh.h"
#include "rt_plc_msg.h"
#include "rt_plc_rt.h"
#include "rt_plc.h"
#include "rt_thread.h"
#include "rt_thread_msg.h"
#include "rt_que.h"
#include "rt_io_base.h"
#include "rt_csup.h"
#if 0
#include "rt_io_supervise.h"
#endif
#include "rt_plc_loop.h"
#include "rt_c_plcthread.h"
#include "rt_c_node.h"

#define max(Dragon,Eagle) ((Dragon) > (Eagle) ? (Dragon) : (Eagle))
#define min(Dragon,Eagle) ((Dragon) < (Eagle) ? (Dragon) : (Eagle))
#define MIN_SCANTIME 1e-9

/* When you use pthread_cond_timedwait is the shortest timeout always > 1 CLK_TCK
 * So if you want to run a PLC-program with the same frequency as the scheduler
 * you need to use a rt-timer. In this version there is no slip detection if
 * you use a rt-timer. You need to set USE_RT_TIMER to 1 in rt_plc_thread.c
 * and rt_plc_process.c
 */
#define USE_RT_TIMER 0

static void scan (plc_sThread*);



void
plc_thread (
  plc_sThread *tp
)
{
  pwr_tStatus sts;
  int rel_vec;
  long int phase;
  uid_t ruid;
  plc_sProcess *pp = tp->pp;

  /* Phase 1.  */
  
  tp->init(1, tp);

  sts = thread_SetPrio(&tp->tid, tp->prio);
  if (EVEN(sts)) {
    errh_Error("Failed to set priority, plc thread %d ms, prio %d",
    			(int) (tp->PlcThread->ScanTime * 1000), tp->prio);
  }
  else {
    errh_Info("Priority set, plc thread %d ms, prio %d",
    			(int) (tp->PlcThread->ScanTime * 1000), tp->prio);
  }
  
  que_Put(&sts, &tp->q_out, &tp->event, (void *)1);
  phase = (long int)que_Get(&sts, &tp->q_in, NULL, NULL);
  pwr_Assert(phase == 2);

  /* Phase 2.  */

  tp->init(2, tp);

  que_Put(&sts, &tp->q_out, &tp->event, (void *)2);
  phase = (long int)que_Get(&sts, &tp->q_in, NULL, NULL);
  pwr_Assert(phase == 3);

  /* Phase 3.  */

  rel_vec = ((tp->pp->PlcProcess->ChgCount - 1) % 2) + 1;
  sts = io_init(tp->PlcThread->IoProcess, tp->aref.Objid, &tp->plc_io_ctx, rel_vec, tp->f_scan_time);
  if (EVEN(sts)) {
    pp->IOHandler->IOReadWriteFlag = FALSE;
    errh_Error("Failed to inititalize io, %m", sts);
    errh_SetStatus( PLC__ERRINITIO);
  }

  /* Once thread's has set it's priority don't run as root */

#if defined OS_POSIX
  struct passwd *pwd;
  
  ruid = getuid();
  
  if (ruid == 0) {
    pwd = getpwnam("pwrp");
    if (pwd != NULL) {
      setreuid(pwd->pw_uid, pwd->pw_uid);
    }
  }
  else 
    setreuid(ruid, ruid);
#endif


  tp->init(0, tp);
  
  if (tp->pp->IOHandler->IOReadWriteFlag) {
    sts = io_read(tp->plc_io_ctx);
    if (EVEN(sts)) {
      tp->pp->IOHandler->IOReadWriteFlag = FALSE;
      errh_Error("IO read, %m", sts);
      errh_SetStatus( PLC__IOREAD);
    }
  }

  thread_MutexLock(&tp->pp->io_copy_mutex);

  memcpy(tp->copy.ai_a.p, tp->pp->base.ai_a.p, tp->copy.ai_a.size);
  memcpy(tp->copy.ao_a.p, tp->pp->base.ao_a.p, tp->copy.ao_a.size);
  memcpy(tp->copy.av_a.p, tp->pp->base.av_a.p, tp->copy.av_a.size);
  memcpy(tp->copy.ca_a.p, tp->pp->base.ca_a.p, tp->copy.ca_a.size);
  memcpy(tp->copy.co_a.p, tp->pp->base.co_a.p, tp->copy.co_a.size);
  memcpy(tp->copy.di_a.p, tp->pp->base.di_a.p, tp->copy.di_a.size);
  memcpy(tp->copy.do_a.p, tp->pp->base.do_a.p, tp->copy.do_a.size);
  memcpy(tp->copy.dv_a.p, tp->pp->base.dv_a.p, tp->copy.dv_a.size);
  memcpy(tp->copy.ii_a.p, tp->pp->base.ii_a.p, tp->copy.ii_a.size);
  memcpy(tp->copy.io_a.p, tp->pp->base.io_a.p, tp->copy.io_a.size);
  memcpy(tp->copy.iv_a.p, tp->pp->base.iv_a.p, tp->copy.iv_a.size);

  thread_MutexUnlock(&tp->pp->io_copy_mutex);
  
  que_Put(&sts, &tp->q_out, &tp->event, (void *)3);
  phase = (long int)que_Get(&sts, &tp->q_in, NULL, NULL);
  pwr_Assert(phase == 4);
  
  /* Phase 4.  */

  que_Put(&sts, &tp->q_out, &tp->event, (void *)4);

  pwrb_PlcThread_Zero(tp);

  time_GetTimeMonotonic(&tp->sync_time);

  tp->ActualScanTime = tp->f_scan_time;

  while (!tp->exit) {
    scan(tp);
  }
#if 0 /*defined(OS_ELN)*/
  if (wfp) {
    /* We have exited the PLC loop. Clean up watchdog object */
    wfp->delete(&sts, wp);
    if (EVEN(sts))
      errh_Error("Cleaning up watchdog, %m", sts);
  }
#endif

//  sts = io_close(tp->plc_io_ctx);

  /* Tell main we are done.  */
  que_Put(&sts, &tp->q_out, &tp->event, (void *)5);
}

static void
scan (
  plc_sThread	*tp
)
{
  pwr_tStatus	sts;
  plc_sProcess	*pp = tp->pp;
  int		delay_action = 0;
  
//  time_Uptime(&sts, &tp->before_scan, NULL);  
  time_GetTimeMonotonic(&tp->before_scan);
  time_GetTime(&tp->before_scan_abs);
  pp->Node->SystemTime = tp->before_scan_abs;

  if (tp->loops > 0) {
/*    if (sts == TIME__CLKCHANGE) {
      time_Dadd(&tp->before_scan, &tp->one_before_scan, &tp->scan_time);
    } */
    time_Adiff(&tp->delta_scan, &tp->before_scan, &tp->one_before_scan);
    time_DToFloat(&tp->ActualScanTime, &tp->delta_scan);
    if (tp->ActualScanTime < MIN_SCANTIME)
      tp->ActualScanTime = MIN_SCANTIME;
  }

  if (pp->IOHandler->IOReadWriteFlag) {
    sts = io_read(tp->plc_io_ctx);
    if (EVEN(sts)) {
      pp->IOHandler->IOReadWriteFlag = FALSE;
      errh_Error("IO read, %m", sts);
      errh_SetStatus( PLC__IOREAD);
    }
  }
  if ( pp->Node->EmergBreakTrue && !tp->emergency_break_old)
    io_swap(tp->plc_io_ctx, io_eEvent_EmergencyBreak);
  tp->emergency_break_old = pp->Node->EmergBreakTrue;

  thread_MutexLock(&pp->io_copy_mutex);

  memcpy(tp->copy.ai_a.p, pp->base.ai_a.p, tp->copy.ai_a.size);
  memcpy(tp->copy.ao_a.p, pp->base.ao_a.p, tp->copy.ao_a.size);
  memcpy(tp->copy.av_a.p, pp->base.av_a.p, tp->copy.av_a.size);
  memcpy(tp->copy.ca_a.p, pp->base.ca_a.p, tp->copy.ca_a.size);
  memcpy(tp->copy.co_a.p, pp->base.co_a.p, tp->copy.co_a.size);
  memcpy(tp->copy.di_a.p, pp->base.di_a.p, tp->copy.di_a.size);
  memcpy(tp->copy.do_a.p, pp->base.do_a.p, tp->copy.do_a.size);
  memcpy(tp->copy.dv_a.p, pp->base.dv_a.p, tp->copy.dv_a.size);
  memcpy(tp->copy.ii_a.p, pp->base.ii_a.p, tp->copy.ii_a.size);
  memcpy(tp->copy.io_a.p, pp->base.io_a.p, tp->copy.io_a.size);
  memcpy(tp->copy.iv_a.p, pp->base.iv_a.p, tp->copy.iv_a.size);

  thread_MutexUnlock(&pp->io_copy_mutex);

  /* Execute all the PLC code */
  tp->exec(0, tp);

  if (pp->IOHandler->IOReadWriteFlag) {
    sts = io_write(tp->plc_io_ctx);
    if (EVEN(sts)) {
      pp->IOHandler->IOReadWriteFlag = FALSE;
      errh_Error("IO write, %m", sts);
      errh_SetStatus( PLC__IOWRITE);
    }
  }

  if ( tp->first_scan)
    tp->first_scan = 0;

  time_GetTimeMonotonic(&tp->after_scan);
/*  if (sts == TIME__CLKCHANGE) {
    tp->after_scan = tp->before_scan;
  }*/
  time_GetTime(&tp->after_scan_abs);
  if (tp->log)
    pwrb_PlcThread_Exec(tp);

  do {
    pwr_tDeltaTime delta;

    plc_timerhandler(tp); 
    time_Aadd(NULL, &tp->sync_time, &tp->scan_time);
    time_Adiff(&delta, &tp->sync_time, &tp->after_scan);
    if (time_Dcomp(&delta, NULL) > 0) {
      pwr_tStatus sts;
      int phase = 0;
      tp->skip_count = 0;

      if (tp->csup_lh != NULL) {
	pwr_tTime now;
	time_GetTime(&now);
	delay_action = csup_Exec(&sts, tp->csup_lh, (pwr_tDeltaTime *) &tp->sync_time, (pwr_tDeltaTime *) &tp->after_scan, &now);
	if (delay_action == 2) {
	  pp->IOHandler->IOReadWriteFlag = FALSE;
	  pp->Node->EmergBreakTrue = TRUE;
	  errh_SetStatus( PLC__IOSTALLED);
	}
      }

#if defined OS_LYNX && USE_RT_TIMER
      sem_wait(&tp->ScanSem);
#elif defined OS_MACOS || defined OS_FREEBSD || OS_OPENBSD || OS_CYGWIN
      struct timespec ts;
      ts.tv_sec = delta.tv_sec;
      ts.tv_nsec = delta.tv_nsec;
      nanosleep(&ts, NULL);
#else
      /* REMARK 
       * que_Get makes use of pthread_cond_timedwait.
       * At this point it is not possible to set the clock-attribute of a condition variable.
       * It should be set with pthread_condattr_setclock() to CLOCK_MONOTONIC, default
       * is always CLOCK_REALTIME which might change. Instead we use clock_nanosleep()
       * and don't have a controlled stop, in most cases we are sleeping anyway.
       * The controlled stop is only needed for warm restart.
       * END REMARK
       */
//      phase = (int)que_Get(&sts, &tp->q_in, &delta, NULL);
      struct timespec ts;
      ts.tv_sec = tp->sync_time.tv_sec;
      ts.tv_nsec = tp->sync_time.tv_nsec;
      clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &ts, NULL);
      
#endif
      if (phase > 0) {
	tp->exit = TRUE;
      }
      break;

    } else {
      tp->sliped++;
      if ( tp->PlcThread->Options & pwr_mThreadOptionsMask_OverExecScanSingle &&
	   tp->skip_count < 10) {
	tp->skip_count++;
	break;
      }
      else if ( tp->PlcThread->Options & pwr_mThreadOptionsMask_OverExecScanAlways)
	break;
    }

  } while (!tp->exit);

  tp->one_before_scan = tp->before_scan;
  tp->one_before_scan_abs = tp->before_scan_abs;

  if (++tp->loops == 2)
    tp->log = TRUE;

  if ( tp->loops % max( 1, (int)(1.0 / tp->PlcThread->ScanTime)) == 0)
    pwrs_Node_SupEmon();
}


