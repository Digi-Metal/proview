/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#if	defined(OS_LYNX)
# include <errno.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <sys/mman.h>    // for shared memory
# include <sys/types.h>   // for "mode_t"
# include <sys/stat.h>    // for "S_IRWXU" etc.
# include <semaphore.h>
#elif defined OS_POSIX
# include <errno.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>
# include <sys/types.h>   // for "mode_t"
# include <sys/ipc.h>     // for shared memory and semaphores
# include <sys/shm.h>     // for shared memory
# include <sys/sem.h>     // for semaphores
# include <sys/stat.h>    // for "S_IRWXU" etc.
# include <sys/file.h>
#endif

#include "pwr.h"
#include "rt_sect.h"
#include "rt_errh.h"


#if defined OS_POSIX
 pwr_tBoolean sect_must_create = 0;
#endif

static void
segName (
  sect_sHead		*shp,
  char			*name
);

/* Construct the name of a section.
   It does not access the database! */

static void
segName (
  sect_sHead		*shp,
  char			*name
)
{
#if defined OS_POSIX
  static int doinit = 1;
  static char buf[4];
  if (doinit) {
    char *str = getenv(pwr_dEnvBusId);
    strncpy(buf, (str ? str : "XXX"), 3);
    buf[3] = '\0';
  }
  sprintf(shp->name, "%.*s_%.3s", (int) sizeof(shp->name) - 4 - 1, name, buf);
#endif
}


/* Map (and optionally create) a shared memory section.
   Name must not be more than 15 characters because of $ASCEFC.
   Returns the virtual address of the newly mapped (created) section.  */

sect_sHead *
sect_Alloc (
  pwr_tStatus		*sts,
  pwr_tBoolean		*created,
  sect_sHead		*shp,
  size_t		size,
  char			*name,
  unsigned int		flags
)
{
  pwr_tStatus		lsts = 1;
  sect_sHead		*lshp = NULL;

  if (shp == NULL) shp = lshp = (sect_sHead *) calloc(1, sizeof(*lshp));
  if (shp == NULL) pwr_Return(NULL, sts, 2/*SECT__VIRMEM*/);
  
  do {
    if (shp->flags.b.mapped) {
      lsts = 2/*SECT__WASMAPPED*/;
      break;
    }

    shp->base = NULL;
    segName(shp, name);

#if defined(OS_LYNX)
    {
      int    shm_fd;                                              
      int    shMemFlags = O_RDWR;              
      mode_t shMemMode  = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP; 

      *created = 0;
      /* This is the only way I know to find out if the memory is created */
      shm_fd = shm_open(shp->name, shMemFlags, shMemMode); 

      if (sect_must_create && shm_fd != -1) { /* Do we need to check errno ? */
       // printf("sect_Alloc: %s already exists. It will be unlinked and created\n", shp->name); 
        if (shm_unlink(shp->name) == -1) {
          lsts = 2;             
	  perror("sect_Alloc: shm_unlink");                
          break;
	}

        shMemFlags |= O_CREAT | O_EXCL; 
        shm_fd = shm_open(shp->name, shMemFlags, shMemMode); 
        if(shm_fd == -1) {
          lsts = 2;             
	  perror("sect_Alloc: shm_open, O_CREATE");                
          break;
	}
	*created = 1;
      }
      else if(shm_fd == -1) {
	if (errno == ENOENT) { /* It didn't exist */
          shMemFlags |= O_CREAT | O_EXCL; 
        shm_fd = shm_open(shp->name, shMemFlags, shMemMode); 

          if(shm_fd == -1) {
            lsts = 2;             
	    perror("sect_Alloc: shm_open, O_CREATE ");                
            break;
	  } else
	    *created = 1;
	} else {
          lsts = 2;             
	  perror("sect_Alloc: shm_open ");                
          break;
	}
      } 
      
      /* Set size */
      if (ftruncate(shm_fd, size) != 0) {
	close(shm_fd);
	if (*created)
	  shm_unlink(shp->name);
        lsts = 2;
	perror("sect_Alloc: ftruncate ");                
	break;
      }

      shp->base = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
      if (shp->base == MAP_FAILED) {
	close(shm_fd);
	if (*created)
	  shm_unlink(shp->name);
        lsts = 2;
	perror("sect_Alloc: mmap ");                
        break;
      }
     
      close(shm_fd);

      shp->size		    = size;
      shp->flags.b.mapped   = 1;
      lsts = 1; 
    }
#elif defined OS_POSIX
    {
      int    shm_fd;                                              
      int    shMemFlags = O_RDWR;              
      mode_t shMemMode  = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP; 
      key_t  shm_key;
      int    shm_id;

      *created = 0;
      /* Create unique key */
      shm_fd = open(shp->name, shMemFlags, shMemMode); 

      if (sect_must_create && shm_fd != -1) { /* Do we need to check errno ? */
        errh_Info("sect_Alloc: %s already exists. It will be unlinked and created\n", shp->name); 
        if (unlink(shp->name) == -1) {
          lsts = 2;             
          errh_Error("sect_Alloc: unlink failed on !%s! errno: %d", shp->name, errno);
          break;
        }
        shMemFlags |= O_CREAT | O_EXCL; 
        shm_fd = open(shp->name, shMemFlags, shMemMode); 
        if(shm_fd == -1) {
          lsts = 2;             
          errh_Error("sect_Alloc: open O_CREATE failed errno: %d", errno);
          break;
        }
        *created = 1;
      } else if(shm_fd == -1) {
        if (errno == ENOENT) { /* It didn't exist */
	  if ( !(flags & sect_mFlags_Create)) {
	    lsts = 2;
	    errh_Error("sect_Alloc: Couldn't attach shm section size");
	    break;
	  }
          shMemFlags |= O_CREAT | O_EXCL; 
          shm_fd = open(shp->name, shMemFlags, shMemMode); 
          if(shm_fd == -1) {
            lsts = 2;             
            errh_Error("sect_Alloc: open O_CREATE | O_EXCL failed errno: %d",
                      errno);
            break;
          } else {
            *created = 1;
          }
        } else {
          lsts = 2;             
          errh_Error("sect_Alloc: open failed errno: %d", errno);
          break;
        }
      } 

      /* Get shm key */
      shm_key = ftok(shp->name, 'P');
      close(shm_fd);

      /* Create shm section */
      shm_id = shmget(shm_key, size, IPC_CREAT | 0660);
      if (shm_id == -1) {
        lsts = 2;
        errh_Error("sect_Alloc: Couldn't attach/create shm section size: %d. Check shmmax.", size);
        break;
      }

      shp->base = shmat(shm_id, (void *)NULL, 0);
      if (shp->base == (void *)-1) {
        if (*created)
          unlink(shp->name);
        lsts = 2;
        errh_Error("sect_Alloc: shmat failed");
        break;
      }
     
      shp->size		    = size;
      shp->flags.b.mapped   = 1;
      lsts = 1; 
    }
#endif

    if (*created) errh_Info("Mapped %s, base: %x, size: %d", shp->name, shp->base, shp->size);

    pwr_Return(shp, sts, lsts);
  } while (0);

  /* Something went wrong, clean up!  */

  if (lshp != NULL) free(lshp);
  pwr_Return(NULL, sts, lsts);
}

/* Unmap a shared memory section.  */

pwr_tBoolean
sect_Free (
  pwr_tStatus		*sts,
  sect_sHead		*shp
)
{
  pwr_tStatus		lsts;

  if (!shp->flags.b.mapped)
    pwr_Return(FALSE, sts, 4/*SECT__NOTMAPPED*/);

#if defined OS_POSIX
  lsts = 1; /* TODO ? */
#endif

  if (ODD(lsts))
    shp->flags.b.mapped = 0;

  pwr_Return(ODD(lsts), sts, lsts);
}

/* Initialize a shared memory lock.  */

pwr_tBoolean
sect_InitLock (
  pwr_tStatus		*sts,
  sect_sHead		*shp,
  sect_sMutex		*mp
)
{
  pwr_tStatus		lsts = 1;

#if defined(OS_LYNX)
  if (sem_init(mp, 1, 1) != 0) {
    errh_Error("sect_InitLock: sem_init, errno: %d", errno);
    lsts = 2;
  }
#elif defined OS_POSIX
  if (posix_sem_init_shared(mp, ftok(shp->name, 'P'), 1) != 0) {
    errh_Error("sect_InitLock: sem_init(%s), errno: %d", shp->name, errno);
    lsts = 2;
  }  
#endif

  errh_ReturnOrBugcheck(ODD(lsts), sts, lsts, "");
}

/* Lock a shared memory section.  */

pwr_tBoolean
sect_Lock (
  pwr_tStatus		*sts,
  sect_sHead		*shp,
  sect_sMutex		*mp
)
{
  pwr_tStatus		lsts = 1;

#if defined(OS_LYNX)
  while (sem_wait(mp) != 0) {
    if (errno != EINTR) {
      perror("sect_Lock: sem_wait ");
      lsts = 2;
      break;
    }
  }
#elif defined OS_POSIX
  while (posix_sem_wait(mp) != 0) {
    if (errno != EINTR) {
      perror("sect_Lock: sem_wait ");
      lsts = 2;
      break;
    }
  }
#endif

  errh_ReturnOrBugcheck(ODD(lsts), sts, lsts, "");
}

/* Unlock a shared memory section.  */

pwr_tBoolean
sect_Unlock (
  pwr_tStatus		*sts,
  sect_sHead		*shp,
  sect_sMutex		*mp
)
{
  pwr_tStatus		lsts = 1;

#if defined(OS_LYNX)
  if (sem_post(mp) != 0) {
    perror("sect_Unlock: sem_signal ");
    lsts = 2;
  }
#elif defined OS_POSIX
  if (posix_sem_post(mp) != 0) {
    perror("sect_Unlock: sem_signal ");
    lsts = 2;
  }
#endif

  errh_ReturnOrBugcheck(ODD(lsts), sts, lsts, "");

}

