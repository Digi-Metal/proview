/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

#ifdef OS_LYNX
# include <signal.h>
#endif

#include "pwr.h"
#include "co_errno.h"
#include "co_time.h"
#include "rt_errh.h"
#include "rt_thread.h"
#include "rt_thread_msg.h"

pwr_tStatus
thread_CondInit (
  thread_sCond	*cp
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  return errno_Pstatus(pthread_cond_init(&cp->c, 0));
#elif defined OS_POSIX
  pthread_condattr_t attr;
  pthread_condattr_init(&attr);
  pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
  return errno_Status(pthread_cond_init(&cp->c, &attr));
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_MutexInit (
  thread_sMutex		*mp
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  return errno_Pstatus(pthread_mutex_init(mp, NULL));
#elif defined OS_POSIX
  return errno_Status(pthread_mutex_init(mp, NULL));
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_MutexLock (
  thread_sMutex		*mp
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  return errno_Pstatus(pthread_mutex_lock(mp));
#elif defined OS_POSIX
  return errno_Status(pthread_mutex_lock(mp));
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_MutexUnlock (
  thread_sMutex		*mp
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  return errno_Pstatus(pthread_mutex_unlock(mp));
#elif defined OS_POSIX
  return errno_Status(pthread_mutex_unlock(mp));
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_Cancel (
  thread_s	*tp
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
    return errno_Pstatus(pthread_cancel(*tp));
#elif defined OS_POSIX
    return errno_Status(pthread_cancel(*tp));
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_Create (
  thread_s	*tp,
  char		*name,
  void		*(*routine)(),
  void		*arg
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  return errno_Pstatus(pthread_create(tp, pthread_attr_default, routine, arg));
#elif defined OS_POSIX
  pthread_attr_t  attr;
  
  pthread_attr_init(&attr);
  pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);

  return errno_Status(pthread_create(tp, &attr, routine, arg));
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_CondWait (
  thread_sCond		*cp,
  thread_sMutex		*mp
)
{
#if defined OS_POSIX
  pwr_tStatus sts = THREAD__SUCCESS;

  cp->f = 0;

  while (!cp->f) {
# if defined OS_LYNX && defined PWR_LYNX_30
    sts = errno_Pstatus(pthread_cond_wait(&cp->c, mp));
# else
    sts = errno_Status(pthread_cond_wait(&cp->c, mp));
# endif
    if (sts != ERRNO__INTR)
      break; 
  }
  return cp->f ? THREAD__SUCCESS : sts;
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_CondTimedWait (
  thread_sCond		*cp,
  thread_sMutex		*mp,
  pwr_tDeltaTime	*time
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  {
    pwr_tStatus sts;

    cp->f = 0;

    if (time == NULL)
      return thread_CondWait(cp, mp);

    sts = errno_Pstatus(pthread_cond_timedwait(&cp->c, mp, (pwr_tTime *)time));
    if (sts == ERRNO__INTR)
      return THREAD__TIMEDOUT;
    else 
      return sts;

  }
#elif defined OS_POSIX
  {
    pwr_tTime now;
    pwr_tTime then;
    struct timespec then_ts;

    cp->f = 0;

    if (time == NULL || time->tv_sec > 100000000)
      return thread_CondWait(cp, mp);

    time_GetTimeMonotonic(&now);
    time_Aadd(&then, &now, time);
    then_ts.tv_sec = then.tv_sec;
    then_ts.tv_nsec = then.tv_nsec;

    return errno_Status(pthread_cond_timedwait(&cp->c, mp, &then_ts));

  }
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_CondSignal (
  thread_sCond	*cp
)
{
#if defined OS_POSIX
  cp->f = 1;

# if defined OS_LYNX && defined PWR_LYNX_30
  return errno_Pstatus(pthread_cond_signal(&cp->c));
# else
  return errno_Status(pthread_cond_signal(&cp->c));
# endif
#else
# error Not defined for this platform !
#endif
}

pwr_tStatus
thread_Wait (
  pwr_tDeltaTime *tp
)
{
  pwr_tStatus sts = THREAD__SUCCESS;
  pwr_tDeltaTime time = {999999999, 0};

  if (tp == NULL)
    tp = &time;

  if ((int)tp->tv_sec > 0 || ((int)tp->tv_sec == 0 && tp->tv_nsec > 0)) {
#if defined OS_POSIX
    struct timespec rmt;
    struct timespec ttime = {9999999, 0};
    struct timespec ts;

    if (tp == &time) {
      int i;
      for ( i = 0; i < 100; i++)
        sts = errno_Pstatus(nanosleep(&ttime, &rmt));
    }
    else {
      ts.tv_sec = tp->tv_sec;
      ts.tv_nsec = tp->tv_nsec;
      sts = errno_Pstatus(nanosleep(&ts, &rmt));
    }
#else
# error Not defined for this platform
#endif
  }

  return sts;
}


pwr_tStatus
thread_SetPrio (
  thread_s	*tp,
  int		prio
)
{
#if defined OS_LYNX && defined PWR_LYNX_30
  {
    pthread_t id;
    int sts;

    prio = MIN(PRIO_FIFO_MAX, PRIO_FIFO_MIN + prio);

    if (tp == NULL)
      id = pthread_self();
    else
      id = *tp;
	

    sts = pthread_setscheduler(id, SCHED_FIFO, prio);
    if ( sts == -1 )
      return errno_Pstatus(sts);
    else
      return ERRNO__SUCCESS;

  }
#elif defined OS_LYNX
  {
    struct sched_param par;
    pthread_t id;

    par.sched_priority = MIN(sched_get_priority_max(SCHED_FIFO), 
	       sched_get_priority_min(SCHED_FIFO) + prio);

    if (tp == NULL)
      id = pthread_self();
    else
      id = *tp;

    return errno_Status(pthread_setschedparam(id, SCHED_FIFO, &par));
  }
#elif defined OS_POSIX
  {
    pthread_t tid;
    struct sched_param par;

    /* Set priority and scheduling mechanism for thread. */
    tid = pthread_self();
    prio = MIN(sched_get_priority_max(SCHED_FIFO), 
	       sched_get_priority_min(SCHED_FIFO) + prio);
    par.sched_priority = prio;
    return errno_Status(pthread_setschedparam(tid, SCHED_FIFO, &par));
  }
#else
# error Not defined for this platform !
#endif
}

#if defined OS_LYNX
pwr_tStatus	
thread_Signal (
  thread_s	*tp, 
  int		signo
)
{
  union sigval	value;
  int		ok;
  pwr_tStatus	sts = THREAD__SUCCESS;
  pthread_t 	tid;
  pid_t		pid;

  value.sival_int = BUILDPID(getpid(), pthread_self());

  if (tp == NULL)
    tid = pthread_self();
  else
    tid = *tp;
  pid = BUILDPID(getpid(), tid );

  ok = sigqueue(pid, signo, value);

  if (ok == -1) {
    sts = errno_Status(errno);
  }

  return sts;
}

pwr_tBoolean
thread_SigTimedWait (
  thread_s*	tp,
  int		signo, 
  pwr_tDeltaTime* tmo
)
{
  sigset_t		newset;
  sigset_t		oldset;
  siginfo_t		info;
  int			ok;
  pwr_tBoolean		signal = FALSE;

  sigemptyset(&newset);
  sigaddset(&newset, signo);
  sigprocmask(SIG_BLOCK, &newset, &oldset);

  if (tmo != NULL) {
    ok = sigtimedwait(&newset, &info, (pwr_tTime *)tmo);  
  } else {
    ok = sigwaitinfo(&newset, &info);
  }
    
  if (ok == -1) {
    if ( errno != EAGAIN) {
      errh_Error("thread_SigTimedWait (%d) %s", errno, strerror(errno));
    }
  } else
   signal = TRUE;

  sigprocmask(SIG_SETMASK, &oldset, NULL);

  return signal;
}
#endif
