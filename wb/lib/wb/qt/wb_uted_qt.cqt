/*
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/* wb_uted_qt.cpp */

#include <stdlib.h>
#include <string.h>

#include "co_dcli.h"

#include "cow_qt_helpers.h"
#include "cow_wow_qt.h"
#include "cow_xhelp.h"

#include "wb_foe_msg.h"
#include "wb_uted_qt.h"

#include <QMenu>
#include <QMenuBar>
#include <QPushButton>
#include <QVBoxLayout>

#define UTED_INDEX_NOCOMMAND -1
#define UTED_TEXT_NOCOMMAND "No command selected"

void WUtedQt::clock_cursor()
{
  toplevel->window()->setCursor(Qt::WaitCursor);
}

void WUtedQt::reset_cursor()
{
  toplevel->window()->unsetCursor();
}

void WUtedQt::remove_command_window()
{
}

void WUtedQtWidget::closeEvent(QCloseEvent* event)
{
  delete uted;
  QWidget::closeEvent(event);
}

void WUtedQtWidget::activate_command()
{
  uted->message("");

  for (int j = 0; uted->optmenubuttons[j]; j++) {
    if (sender() == uted->optmenubuttons[j]) {
      uted->configure_quals(qPrintable(uted->optmenubuttons[j]->text()));
    }
  }
}

void WUtedQtWidget::activate_helputils()
{
  CoXHelp::dhelp("utilities_refman", 0, navh_eHelpFile_Other,
      "$pwr_lang/man_dg.dat", true);
}

void WUtedQtWidget::activate_helppwr_plc()
{
  CoXHelp::dhelp(
      "help command", 0, navh_eHelpFile_Other, "$pwr_lang/man_dg.dat", true);
}

void WUtedQtWidget::activate_batch()
{
}

void WUtedQtWidget::activate_currsess()
{
}

//
//	Callback from the menu.
//
void WUtedQtWidget::activate_ok()
{
  uted->message("");
  uted->clock_cursor();
  uted->execute(0);
  uted->reset_cursor();
}

void WUtedQtWidget::activate_show_cmd()
{
  uted->clock_cursor();
  uted->execute(1);
  uted->reset_cursor();
}

void WUtedQtWidget::activate_cmd_wind()
{
}

void WUtedQtWidget::commandchanged()
{
}

void WUtedQtWidget::activate_present(bool set)
{
  uted->message("");
  int idx = ((QAction*)sender())->data().toInt();
  uted->present_sts[idx] = set;
}

void WUtedQt::update_title(int editmode)
{
  CoWowQt::update_title(toplevel, editmode);
}

WUtedQt::WUtedQt(void* wu_parent_ctx, QWidget* wu_parent_wid,
    const char* wu_name, const char* wu_iconname, ldh_tWBContext wu_ldhwb,
    ldh_tSesContext wu_ldhses, int wu_editmode, void (*wu_quit_cb)(void*),
    pwr_tStatus* status)
    : WUted(wu_parent_ctx, wu_name, wu_iconname, wu_ldhwb, wu_ldhses,
          wu_editmode, wu_quit_cb, status)
{
  toplevel = new WUtedQtWidget(this, wu_parent_wid);
  toplevel->setToolTip(fl("wb_uted widget"));
  toplevel->setMinimumSize(800, 400);
  toplevel->setWindowTitle(fl("Wb Utilities"));
  toplevel->setAttribute(Qt::WA_DeleteOnClose);

  CoWowQt::SetWindowIcon(toplevel);

  QMenuBar* menu_bar = new QMenuBar();

  // File Entry
  QMenu* file = menu_bar->addMenu(translate_utf8("&File"));
  addMenuItem(
      toplevel, file, "&Close", SLOT(close()), "CTRL+W", "window-close");

  // View Entry
  QMenu* view = menu_bar->addMenu(translate_utf8("&View"));
  addMenuItem(
      toplevel, view, "&Show Current Command", SLOT(activate_show_cmd()));

  // Commands entry
  QMenu* commands_menu = menu_bar->addMenu(translate_utf8("&Commands"));

  QMenu* current_menu = commands_menu;

  int j = 0;
  int in_submenu = 0;
  uted_sCommand* next_cmd;
  for (uted_sCommand* command_ptr = commands; command_ptr->command[0];
       command_ptr++) {
    // Build submenu if first command verb is equal to next
    char cmd_verb[5][80];
    int num;
    char next_cmd_verb[5][80];
    int next_num;
    num = dcli_parse(command_ptr->command, " ", "", (char*)cmd_verb,
        sizeof(cmd_verb) / sizeof(cmd_verb[0]), sizeof(cmd_verb[0]), 0);

    next_cmd = command_ptr + 1;
    int close_submenu = 0;
    if (next_cmd->command[0]) {
      next_num = dcli_parse(next_cmd->command, " ", "", (char*)next_cmd_verb,
          sizeof(next_cmd_verb) / sizeof(next_cmd_verb[0]),
          sizeof(next_cmd_verb[0]), 0);

      if (in_submenu) {
        // Check if time to close menu
        if (strcmp(cmd_verb[0], next_cmd_verb[0]) != 0) {
          // Close submenu
          close_submenu = 1;
        }
      } else if (strcmp(cmd_verb[0], next_cmd_verb[0]) == 0) {
        // Open submenu
        QMenu* submenu = commands_menu->addMenu(cmd_verb[0]);
        current_menu = submenu;
        in_submenu = 1;
      }
    } else if (in_submenu) {
      // Last command
      close_submenu = 1;
    }

    optmenubuttons[j] = addMenuItem(
        toplevel, current_menu, command_ptr->command, SLOT(activate_command()));

    if (close_submenu) {
      current_menu = commands_menu;
      in_submenu = 0;
    }

    j++;
  }

  // Menu Help
  QMenu* help = menu_bar->addMenu(translate_utf8("&Help"));
  addMenuItem(toplevel, help, "&On Window", SLOT(activate_helputils()),
      "CTRL+H", "system-help");
  addMenuItem(toplevel, help, "On &Commands", SLOT(activate_helppwr_plc()));

  // Qualifier labels, entries and checkboxes
  QVBoxLayout* qual_box_qual = new QVBoxLayout();
  QVBoxLayout* qual_box_value = new QVBoxLayout();
  for (j = 0; j < 10; j++) {
    qualifier[j] = new QLabel("Qual");
    qualifier[j]->setFixedSize(120, 20);
    qual_box_qual->addWidget(qualifier[j]);
    QHBoxLayout* box = new QHBoxLayout();
    value[j] = new QLineEdit();
    value[j]->setFixedHeight(20);
    add_expanding(box, value[j]);
    present[j] = new QCheckBox();
    present[j]->setFixedHeight(20);
    QObject::connect(present[j], SIGNAL(toggled(bool)), toplevel,
        SLOT(activate_present(bool)));
    box->addWidget(present[j]);
    qual_box_value->addLayout(box);
  }

  // Command label
  QLabel* cmdlabel = new QLabel("Command");
  commandlabel = new QLabel("No command selected");
  commandlabel->setFixedWidth(140);

  QHBoxLayout* hbox_command = new QHBoxLayout();
  hbox_command->addWidget(cmdlabel);
  hbox_command->addWidget(commandlabel);

  // Apply button
  QPushButton* applybutton = new QPushButton("Apply");
  applybutton->setFixedSize(70, 25);
  QObject::connect(
      applybutton, SIGNAL(clicked()), toplevel, SLOT(activate_ok()));

  QVBoxLayout* left_box = new QVBoxLayout();
  left_box->addLayout(hbox_command);

  QHBoxLayout* button_box = new QHBoxLayout();
  button_box->addWidget(applybutton);

  QHBoxLayout* qual_box = new QHBoxLayout();
  qual_box->addLayout(left_box);
  qual_box->addWidget(separator(QFrame::VLine));
  qual_box->addLayout(qual_box_qual);
  add_expanding(qual_box, qual_box_value);

  // Statusbar
  QStatusBar* statusbar = new QStatusBar();
  label = new QLabel("");
  statusbar->addWidget(label);

  QVBoxLayout* vbox = new QVBoxLayout(toplevel);
  vbox->setMenuBar(menu_bar);
  add_expanding(vbox, qual_box);
  vbox->addWidget(separator(QFrame::HLine));
  vbox->addLayout(button_box);
  vbox->addWidget(statusbar);

  toplevel->setLayout(vbox);
  toplevel->show();

  batch_sts = UTED_BATCH_CURRSESS;
  reset_qual();
  enable_entries(wu_editmode);
  update_title(wu_editmode);

  *status = FOE__SUCCESS;
}

// Destroys a ute instance.
// Destroys the widget and frees allocated memory for the context.
WUtedQt::~WUtedQt()
{
  if (quit_cb) {
    (quit_cb)(parent_ctx);
  }
}

// Get value from textentry with specified index
void WUtedQt::get_value(int idx, char* str, int len)
{
  QByteArray ba = value[idx]->text().toLatin1();
  strncpy(str, ba.data(), len);
}

// Hide all qualifiers.
void WUtedQt::reset_qual()
{
  int i;

  for (i = 0; i < UTED_QUALS; i++) {
    qualifier[i]->setVisible(false);
    value[i]->setVisible(false);
    present[i]->setVisible(false);
    present_sts[i] = 0;
    present[i]->setChecked(false);
    value[i]->setText("");
  }

  commandlabel->setText(fl(UTED_TEXT_NOCOMMAND));

  current_index = UTED_INDEX_NOCOMMAND;
}

//	Displays a message in the ute window.
//	Changes the label of a label widget which id is stored in the context.
void WUtedQt::message(const char* new_label)
{
  label->setText(fl(new_label));
}

void WUtedQt::set_command_window(char* cmd)
{
}

void WUtedQt::configure_quals(const char* label)
{
  int i;
  int index;
  uted_sQual* qual_ptr;

  /* Reset the picture */
  reset_qual();

  get_command_index(label, &index);
  current_index = index;

  /* Check the qualifiers and view the corresponding widgets */
  i = 0;
  qual_ptr = &commands[index].qualifier[0];
  while (qual_ptr->qual[0] != 0) {
    if (qual_ptr->type == UTED_QUAL_DEFQUAL) {
      qualifier[i]->setText(fl("Select an object in the Navigator"));
      qualifier[i]->setVisible(true);
    } else {
      qualifier[i]->setText(fl(qual_ptr->qual));
      qualifier[i]->setVisible(true);
      if (qual_ptr->present) {
        present[i]->setVisible(true);
      }
      if (qual_ptr->value) {
        value[i]->setVisible(true);
      }
    }
    qual_ptr++;
    i++;
  }
  commandlabel->setText(fl(label));
}

void WUtedQt::enable_entries(int enable)
{
  int j;
  uted_sCommand* command_ptr;

  mode = enable ? UTED_MODE_EDIT : UTED_MODE_VIEW;

  command_ptr = commands;
  j = 0;
  while (command_ptr->command[0] != 0) {
    if (!command_ptr->view_sensitivity) {
      optmenubuttons[j]->setEnabled(true);
    }
    j++;
    command_ptr++;
  }

  /* If view and current command is not sensitiv, change to first command */
  if (!enable) {
    if (current_index != UTED_INDEX_NOCOMMAND
        && !commands[current_index].view_sensitivity) {
      reset_qual();
    }
  }
}

/*************************************************************************
*
* Name:		void uted_questionbox()
*
* Type		void
*
* Type		Parameter	IOGF	Description
* uted_ctx	ute		I	ute context.
* char 		*question_title I	title of the question box.
* char 		*question_text	I	question to be displayed.
* voidp         yes_procedure   I       procedure called when yes is activated
* voidp         no_procedure   	I       procedure called when no is activated
*
* Description:
* 	Displays a question box.
*	When the yes-button in the box is pressed the yes_procedure is
*	called. When the no-button is pressed the no_procedure is called.
*	yes_procedure and no_procedure can be NULL.
*	Declaration of the yes and no procedures:
*		void yes_or_no_answer( uted_ctx ute)
*
**************************************************************************/
void WUtedQt::questionbox(char* question_title, char* question_text,
    void (*yes_procedure)(WUted*), void (*no_procedure)(WUted*),
    void (*cancel_procedure)(WUted*), pwr_tBoolean cancel)
{
}

void WUtedQt::raise_window()
{
  pop(toplevel);
}