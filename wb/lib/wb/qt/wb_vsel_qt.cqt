/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_vsel_qt.cpp -- select volume */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "co_login_msg.h"

#include "cow_qt_helpers.h"
#include "cow_wow_qt.h"

#include "wb_foe.h"
#include "wb_ldh_msg.h"
#include "wb_vsel_qt.h"

#include <QDialogButtonBox>
#include <QHeaderView>
#include <QMenuBar>
#include <QPushButton>
#include <QScrollArea>
#include <QVBoxLayout>

/*  Local function prototypes.	*/

static void vsel_exit_qb_yes(void* ctx, void* cbdata)
{
  WVselQt* vsel = (WVselQt*)ctx;

  if (vsel->vsel_bc_cancel != NULL) {
    (vsel->vsel_bc_cancel)();
  }
  vsel->toplevel->close();
}

/*************************************************************************
* Name:		void	vsel_activate_ok()
*
* Description:
*	Callback from the pushbutton.
**************************************************************************/

void WVselQtWidget::activate_ok()
{
  char selected_text[80];
  QList<QTreeWidgetItem*> selection = sel->volumelist->selectedItems();
  if (selection.size() > 0) {
    strcpy(selected_text, qPrintable(selection[0]->text(0)));
  }

  pwr_tVid vid;
  int sts = ldh_VolumeNameToId(sel->wbctx, selected_text, &vid);
  if (EVEN(sts)) {
    return;
  }

  pwr_tVid* volume_ptr
      = (pwr_tVolumeId*)calloc(sel->volume_count, sizeof(pwr_tVolumeId));
  *volume_ptr = vid;

  if (sel->vsel_bc_success != NULL) {
    sts = (sel->vsel_bc_success)(sel, volume_ptr, 1);
  }
  free((char*)volume_ptr);

  if (ODD(sts)) {
    if (sel->vsel_bc_cancel != NULL) {
      (sel->vsel_bc_cancel)();
    }
    close();
  } else if (sts == LDH__VOLALRATT || LDH__VOLIDALREXI) {
    sel->wow->DisplayError("Error", "Volume is already open");
  }
}

/*************************************************************************
* Name:		void	vsel_activate_cancel()
*
* Description:
*	Callback from the pushbutton.
**************************************************************************/

void WVselQtWidget::activate_cancel()
{
  if (sel->vsel_bc_cancel != NULL)
    (sel->vsel_bc_cancel)();
  close();
}

/*************************************************************************
* Name:		void	vsel_activate_close()
*
* Description:
*	Callback from the pushbutton.
**************************************************************************/

void WVselQtWidget::activate_close()
{
  if ((sel->vsel_bc_time_to_exit)(sel->parent_ctx)) {
    sel->wow->DisplayQuestion(this, "Pwr exit", "Do you really want to exit ?",
        vsel_exit_qb_yes, NULL, NULL);
  } else {
    activate_cancel();
  }
}

/*************************************************************************
* Name:		void	vsel_activate_showall()
*
* Description:
*	Callback from the pushbutton.
**************************************************************************/

void WVselQtWidget::activate_showall(bool set)
{
  sel->all = set;

  pwr_tStatus sts = sel->load_volumelist();
  WFoe::error_msg(sts);
}

/*************************************************************************
*
* Name:		int	vsel_new()
*
* Type		int
*
* Type		Parameter	IOGF	Description
* void 		*parent_ctx	I	Parent context adress
* Widget	parent_wid	I	Parent Widget adress
* char *	name		I	Name of the created object
*
* Description:
*	Create a new login window
**************************************************************************/

WVselQt::WVselQt(pwr_tStatus* status, void* wv_parent_ctx,
    QWidget* wv_parent_wid, const char* wv_name, ldh_tWBContext wv_wbctx,
    char* volumename, int (*bc_success)(void*, pwr_tVolumeId*, int),
    void (*bc_cancel)(), int (*bc_time_to_exit)(void*), int show_volumes,
    wb_eType wv_wb_type)
    : WVsel(status, wv_parent_ctx, wv_name, wv_wbctx, volumename, bc_success,
          bc_cancel, bc_time_to_exit, show_volumes, wv_wb_type)
{
  int sts;
  pwr_tVolumeId volid;
  pwr_tVolumeId volume;
  pwr_tClassId classid;
  char volname[80];
  int size;
  int volume_count;
  int display_window = 0;

  strcpy(volname, "");
  if (volumename != NULL && *volumename != 0 && !show_volumes) {
    /* Start the navigater for this volume */
    strcpy(volname, volumename);
  } else if (!show_volumes && wb_type != wb_eType_Buffer) {
    /* If there is only one volume in the db, select this volume */
    volume_count = 0;

    sts = ldh_GetVolumeList(wbctx, &volume);
    while (ODD(sts)) {
      sts = ldh_GetVolumeClass(wbctx, volume, &classid);
      if (EVEN(sts)) {
        *status = sts;
        return;
      }

      if (cdh_isClassVolumeClass(classid)
          || classid == pwr_eClass_WorkBenchVolume || volume == ldh_cRtVolume) {
        sts = ldh_GetNextVolume(wbctx, volume, &volume);
        continue;
      }
      sts = ldh_VolumeIdToName(wbctx, volume, volname, sizeof(volname), &size);
      if (EVEN(sts)) {
        *status = sts;
        return;
      }
      volume_count++;

      sts = ldh_GetNextVolume(wbctx, volume, &volume);
    }
    if (volume_count != 1) {
      strcpy(volname, "");
    }
  }

  //  If volume name is supplied, find this volume and open the navigator.
  if (strcmp(volname, "") && wb_type != wb_eType_Buffer) {
    /* Check syntax, if new volumes is found, show the window */
    sts = check_volumelist(1, &display_window);
  }

  if (strcmp(volname, "") && !display_window) {
    sts = ldh_VolumeNameToId(wbctx, volname, &volid);
    WFoe::error_msg(sts);
    if (ODD(sts)) {
      (vsel_bc_success)((void*)this, &volid, 1);
      if (vsel_bc_cancel != NULL) {
        (vsel_bc_cancel)();
      }

      *status = LOGIN__SUCCESS;
      return;
    } else {
      printf("-- Unable to open volume '%s', volume doesn't exist\n", volname);
    }
  }

  // Create the window
  toplevel = new WVselQtWidget(this, wv_parent_wid);
  toplevel->setMinimumSize(500, 400);
  toplevel->setWindowTitle(fl(name));
  toplevel->setAttribute(Qt::WA_DeleteOnClose);

  CoWowQt::SetWindowIcon(toplevel);

  // Menu
  QMenuBar* menu_bar = new QMenuBar();

  // File Entry
  QMenu* file = menu_bar->addMenu(translate_utf8("&File"));
  addMenuItem(toplevel, file, "&Close", SLOT(activate_close()), "CTRL+W",
      "window-close");

  // Functions Entry
  QMenu* functions = menu_bar->addMenu(translate_utf8("F&unctions"));
  addCheckableMenuItem(toplevel, functions, "&Show All Volumes",
      SLOT(activate_showall(bool)), "CTRL+A");

  // List widget
  volumelist = new QTreeWidget();
  volumelist->setSelectionMode(QAbstractItemView::SingleSelection);

  volumelist->setColumnCount(3);
  volumelist->header()->close();

  QDialogButtonBox* buttons = new QDialogButtonBox();
  buttons->addButton(QDialogButtonBox::Ok);
  buttons->addButton(QDialogButtonBox::Cancel);
  QObject::connect(buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()),
      toplevel, SLOT(activate_ok()));
  QObject::connect(buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()),
      toplevel, SLOT(activate_cancel()));

  QScrollArea* scrolled_window = new QScrollArea();
  scrolled_window->setWidgetResizable(true);
  scrolled_window->setWidget(volumelist);

  QVBoxLayout* vbox = new QVBoxLayout(toplevel);
  vbox->setMenuBar(menu_bar);
  add_expanding(vbox, scrolled_window);
  vbox->addWidget(buttons);

  toplevel->setLayout(vbox);
  toplevel->show();

  sts = load_volumelist();
  WFoe::error_msg(sts);

  // Set input focus to the scrolled list widget
  volumelist->setFocus();

  wow = new CoWowQt(toplevel);

  if (wb_type != wb_eType_Buffer) {
    sts = check_volumelist(0, &display_window);
  }

  *status = LOGIN__SUCCESS;
}

void WVselQt::list_clear()
{
  volumelist->clear();
}

void WVselQt::list_add_item(char* str)
{
  QTreeWidgetItem* item = new QTreeWidgetItem(volumelist);
  QStringList items = QString::fromLatin1(str).split(
      QRegExp("\\s+"), QString::SkipEmptyParts);
  for (int i = 0; i < items.size(); ++i) {
    item->setText(i, items.at(i));
  }
  volumelist->addTopLevelItem(item);
}