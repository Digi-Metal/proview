/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_wnav_qt.cpp -- Display plant and node hiererachy */

#include <stdlib.h>

#include "cow_login_qt.h"
#include "cow_logw_qt.h"
#include "cow_qt_helpers.h"
#include "cow_wow_qt.h"

#include "flow_browwidget_qt.h"

#include "ge_qt.h"

#include "wb_bckw_qt.h"
#include "wb_expw_qt.h"
#include "wb_foe_qt.h"
#include "wb_utl_qt.h"
#include "wb_watttext_qt.h"
#include "wb_wda_qt.h"
#include "wb_wge_qt.h"
#include "wb_wnav_item.h"
#include "wb_wnav_qt.h"
#include "wb_wrev_qt.h"
#include "wb_xcrr_qt.h"

#include <QApplication>
#include <QColor>
#include <QInputDialog>
#include <QLayout>
#include <QMessageBox>
#include <QScrollArea>

#include <qlocalsocket.h>

void WNavQt::pop()
{
  ::pop(form_widget);
}

WNavQt::WNavQt(void* xn_parent_ctx, QWidget* xn_parent_wid, const char* xn_name,
    const char* xn_layout, QWidget** w, ldh_tSesContext xn_ldhses,
    wnav_sStartMenu* root_menu, wnav_eWindowType xn_type, pwr_tStatus* status)
    : WNav(xn_parent_ctx, xn_name, xn_layout, xn_ldhses, root_menu, xn_type,
          status),
      parent_wid(xn_parent_wid)
{
  if (window_type == wnav_eWindowType_No) {
    return;
  }

  trace_obj = new WNavQtTraceObject(this);

  QScrollArea* scrolledbrow = ((QScrollArea*)scrolledbrowwidgetqt_new(
      WNav::init_brow_base_cb, this, &brow_widget));

  form_widget = wrapInFrame(scrolledbrow);

  // Create the root item
  *w = form_widget;

  serverString = new QLocalServer(trace_obj);
  serverString->listen("STRING");
  QObject::connect(
      serverString, SIGNAL(newConnection()), trace_obj, SLOT(sel_convert_cb()));
  serverGraph = new QLocalServer(trace_obj);
  serverGraph->listen("PWR_GRAPH");
  QObject::connect(
      serverGraph, SIGNAL(newConnection()), trace_obj, SLOT(sel_convert_cb()));
  serverObjId = new QLocalServer(trace_obj);
  serverObjId->listen("PWR_OBJID");
  QObject::connect(
      serverObjId, SIGNAL(newConnection()), trace_obj, SLOT(sel_convert_cb()));
  serverAttrRef = new QLocalServer(trace_obj);
  serverAttrRef->listen("PWR_ATTRREF");
  QObject::connect(serverAttrRef, SIGNAL(newConnection()), trace_obj,
      SLOT(sel_convert_cb()));

  gbl.load_config(this);

  if (root_menu && !ldhses) {
    menu_tree_build(root_menu);
  }

  wow = new CoWowQt(parent_wid);

  *status = 1;
}

WNavQt::~WNavQt()
{
  closing_down = 1;

  delete trace_obj;

  menu_tree_free();
  PalFile::config_tree_free(menu);
  for (int i = 1; i < brow_cnt; i++) {
    brow_DeleteSecondaryCtx(brow_stack[brow_cnt]->ctx);
    brow_stack[brow_cnt]->free_pixmaps();
    delete brow_stack[i];
  }
  delete brow;
  delete wow;
  form_widget->close();
}

static void modifyBackground(QWidget* widget, QColor color)
{
  QPalette pal;
  pal.setColor(QPalette::Background, color);
  widget->setAutoFillBackground(true);
  widget->setPalette(pal);
}

void WNavQt::set_inputfocus(int focus)
{
  if (focus) {
    modifyBackground(form_widget, QColor("Black"));
    brow_widget->setFocus();
  } else {
    modifyBackground(form_widget, QColor("White"));
  }
}

void WNavQt::trace_start()
{
  trace_obj->trace_scan();
}

WNavQtTraceObject::WNavQtTraceObject(WNavQt* parent) : QObject(), wnav(parent)
{
  trace_timerid = new QTimer(this);
}

void WNavQtTraceObject::trace_scan()
{
  if (wnav->trace_started) {
    brow_TraceScan(wnav->brow->ctx);
    initOneShotTimer(trace_timerid, SLOT(trace_scan()), 1000);
  }
}

void WNavQt::print(const char* title)
{
  CoWowQt::CreateBrowPrintDialogQt(title, brow->ctx, brow_widget);
}

int WNavQt::get_selection(char* str, int len)
{
  int sts;

  sts = CoWowQt::GetSelection(str, len, "PWR_OBJID");
  if (EVEN(sts)) {
    sts = CoWowQt::GetSelection(str, len, "STRING");
  }

  return sts;
}

void WNavQt::set_selection_owner()
{
  selection_owner = 1;
}

void WNavQt::create_popup_menu(pwr_tAttrRef aref, int x, int y)
{
  (create_popup_menu_cb)(parent_ctx, aref, x, y);
}

Ge* WNavQt::ge_new(char* graph_name, int nojournal)
{
  unsigned int options = 0;

  if (gbl.enable_comment) {
    options |= ge_mOption_EnableComment;
  }
  if (nojournal) {
    options |= ge_mOption_IgnoreJournal;
  }

  return new GeQt(NULL, form_widget, ldhses, 0, options, graph_name);
}

WGe* WNavQt::wge_new(char* name, char* filename, char* object_name, int modal)
{
  return new WGeQt(parent_wid, this, name, filename, 0, 1, 1, 0, 0, 0, 0,
      object_name, modal);
}

wb_utl* WNavQt::utl_new()
{
  return new wb_utl_qt(parent_wid);
}

WRev* WNavQt::rev_new()
{
  return new WRevQt(parent_wid, this, ldhses);
}

void WNavQt::logw_new(char* item, wlog_eCategory* categories, int show_item)
{
  char categories_str[10][20];
  char title[300];
  pwr_tStatus sts;

  if (categories) {
    for (unsigned int i = 0;
         i < sizeof(categories_str) / sizeof(categories_str[0]); i++) {
      if (categories[i] == wlog_eCategory_) {
        strcpy(categories_str[i], "");
        break;
      } else {
        wb_log::category_to_string(categories[i], categories_str[i]);
      }
    }
  }

  strcpy(title, "History ");
  if (item) {
    strcat(title, item);
  }
  if (title[strlen(title) - 1] == '*') {
    title[strlen(title) - 1] = 0;
  }

  CoLogWQt* logw = new CoLogWQt(this, parent_wid, title, show_item, &sts);
  if (categories) {
    logw->CoLogW::show(categories_str, item);
  } else {
    logw->CoLogW::show(0, item);
  }
}

static void selection_data_set(
    WNavQt* wnav, QLocalServer* server, const char* data)
{
  QByteArray block;
  QDataStream out(&block, QIODevice::WriteOnly);
  out.writeRawData(data, strlen(data));

  QLocalSocket* clientConnection = server->nextPendingConnection();
  clientConnection->write(block);
  clientConnection->flush();
  clientConnection->disconnectFromServer();

  brow_SelectClear(wnav->brow->ctx);
  wnav->selection_owner = 0;
}

void WNavQtTraceObject::sel_convert_cb()
{
  pwr_sAttrRef attrref;
  char* buffp;

  QLocalServer* server = ((QLocalServer*)sender());

  wnav_eSelectionFormat format;
  if (server == wnav->serverGraph) {
    format = wnav_eSelectionFormat_Graph;
  } else if (server == wnav->serverObjId) {
    format = wnav_eSelectionFormat_Objid;
  } else if (server == wnav->serverAttrRef) {
    format = wnav_eSelectionFormat_Attrref;
  } else {
    format = wnav_eSelectionFormat_User;
  }

  int node_count;
  brow_tNode* node_list;
  brow_GetSelectedNodes(wnav->brow->ctx, &node_list, &node_count);
  if (!node_count) {
    return;
  }

  WItem* item;
  brow_GetUserData(node_list[0], (void**)&item);

  switch (item->type) {
  case wnav_eItemType_Attr:
  case wnav_eItemType_AttrInput:
  case wnav_eItemType_AttrInputInv:
  case wnav_eItemType_AttrInputF:
  case wnav_eItemType_AttrOutput:
  case wnav_eItemType_AttrArray:
  case wnav_eItemType_AttrArrayOutput:
  case wnav_eItemType_AttrArrayElem:
  case wnav_eItemType_AttrObject: {
    WItemBaseAttr* aitem = (WItemBaseAttr*)item;

    int size;
    pwr_tAName attr_str;
    int sts = ldh_ObjidToName(wnav->ldhses, item->objid, ldh_eName_Hierarchy,
        attr_str, sizeof(attr_str), &size);
    if (EVEN(sts)) {
      break;
    }

    strcat(attr_str, ".");
    strcat(attr_str, aitem->name);
    sts = ldh_NameToAttrRef(wnav->ldhses, attr_str, &attrref);
    if (EVEN(sts)) {
      break;
    }
    sts = (wnav->format_selection_cb)(
        wnav->parent_ctx, attrref, &buffp, 0, 1, format);
    if (sts) {
      selection_data_set(wnav, server, buffp);
      free(node_list);
      return;
    }
    break;
  }
  case wnav_eItemType_Object: {
    memset(&attrref, 0, sizeof(attrref));
    attrref.Objid = item->objid;
    int sts = (wnav->format_selection_cb)(
        wnav->parent_ctx, attrref, &buffp, 0, 0, format);
    if (sts) {
      selection_data_set(wnav, server, buffp);
      free(node_list);
      return;
    }
  }
  default: {
    char name[200];
    brow_GetAnnotation(node_list[0], 0, name, sizeof(name));
    selection_data_set(wnav, server, name);
    free(node_list);
    return;
  }
  }
  free(node_list);
}

int WNavQt::open_foe(const char* name, pwr_tOid plcpgm, void** foectx,
    int map_window, ldh_eAccess access, pwr_tOid oid)
{
  pwr_tStatus sts = 0;
  WFoe* foe;
  unsigned int options;

  if (gbl.enable_comment) {
    options = foe_mOption_EnableComment;
  } else {
    options = 0;
  }

  foe = WFoe::get(plcpgm);
  if (foe) {
    foe->pop();
  } else {
    foe = new WFoeQt((void*)this, parent_wid, name, plcpgm, wbctx, ldhses,
        map_window, access, options, &sts);
    if (EVEN(sts)) {
      return sts;
    }
    foe->get_build_options_cb = foe_get_build_options_cb;
  }
  if (cdh_ObjidIsNotNull(oid)) {
    foe->center_object(oid);
  }
  *foectx = foe;
  return sts;
}

void WNavQt::wda_new(pwr_tOid oid, pwr_tCid cid, char* attribute, int edit_mode,
    int advuser, int display_objectname)
{
  new WdaQt(parent_wid, this, ldhses, oid, cid, attribute, edit_mode, advuser,
      display_objectname);
}

CoLogin* WNavQt::login_new(const char* name, const char* groupname,
    void (*bc_success)(void*), void (*bc_cancel)(void*), pwr_tStatus* status)
{
  return new CoLoginQt(
      this, parent_wid, name, groupname, bc_success, bc_cancel, 0, status);
}

WCrr* WNavQt::wcrr_new(pwr_tAttrRef* aref, pwr_tStatus* status)
{
  return new WCrrQt(parent_wid, this, ldhses, aref, gbl.advanced_user, status);
}

WbBckW* WNavQt::bckw_new(char* name, wb_bck_list* list, pwr_tStatus* status)
{
  return new WbBckWQt(this, parent_wid, ldhses, name, list, editmode, status);
}

WbExpW* WNavQt::expw_new(char* name, int type, pwr_tStatus* status)
{
  return new WbExpWQt(this, parent_wid, ldhses, name, type, 1, status);
}

WAttText* WNavQt::watttext_new(
    pwr_tAttrRef aref, int editmode, pwr_tStatus* status)
{
  return new WAttTextQt(parent_wid, this, ldhses, aref, editmode, status);
}

void WNavQt::wge_subwindow_loop(WGe* wge)
{
  debug_print(" before wge_subwindow_loop\n");
  QApplication::exec();
  debug_print(" after wge_subwindow_loop\n");
}

void WNavQt::wge_modal_loop(WGe* wge)
{
  debug_print(" before wge_modal_loop\n");
  QApplication::exec();
  debug_print(" after wge_modal_loop\n");
}

void WNavQt::message_dialog(char* title, char* text)
{
  QMessageBox::critical(
      form_widget->window(), translate_utf8(title), translate_utf8(text));
}

int WNavQt::confirm_dialog(
    char* title, char* text, int display_cancel, int* cancel)
{
  QMessageBox::StandardButton reply
      = QMessageBox::question(form_widget, translate_utf8(title),
          translate_utf8(text), QMessageBox::Yes | QMessageBox::No);

  if (reply == QMessageBox::Yes) {
    return 1;
  } else {
    *cancel = 0;
    return 0;
  }
}

int WNavQt::continue_dialog(char* title, char* text)
{
  // Create a question window
  QMessageBox::StandardButton reply = QMessageBox::question(
      form_widget, fl(title), fl(text), QMessageBox::Ok | QMessageBox::Cancel);
  if (reply == QMessageBox::Ok) {
    return 1;
  } else {
    return 0;
  }
}

int WNavQt::prompt_dialog(char* title, char* text, char** value)
{
  bool ok;
  QString str = QInputDialog::getText(form_widget, translate_utf8(title),
      translate_utf8(text), QLineEdit::Normal, "", &ok);
  if (ok) {
    strcpy(*value, qPrintableLatin1(str));
  } else {
    strcpy(*value, "");
  }
  return ok;
}