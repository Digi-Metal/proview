/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include <vector>

#ifndef wb_lfu_h
#define wb_lfu_h

#ifndef wb_ldh_h
#include "wb_ldh.h"
#endif

#ifndef cow_wow_h
#include "cow_wow.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
	lfu_mDistrOpt_NoRootVolume 	= 1 << 0,
	lfu_mDistrOpt_RSH 		= 1 << 1
} lfu_mDistrOpt;

typedef enum {
	lfu_eAccessType_StdLgi 		= 0,
	lfu_eAccessType_Proxy 		= 1,
	lfu_eAccessType_Local 		= 2
} lfu_eAccessType;

typedef struct {
	pwr_tString40	volume_name;
	pwr_tVolumeId	volume_id;
	pwr_tString40	p1;
	pwr_tString40	p2;
	pwr_tString40	p3;
	pwr_tString40	p4;
	pwr_tString40	p5;
	pwr_tString40	p6;
	} lfu_t_volumelist;

typedef struct {
	pwr_tVid	vid;
	pwr_tTime      	version;
        char		name[80];
	} lfu_t_volref;

class lfu_volume_info
{
 public:
  pwr_tObjName name;
  pwr_tVid vid;
  pwr_tCid cid;
  ldh_eVolRep volrep;
  char server[80];

  lfu_volume_info() : vid(0), cid(0), volrep(ldh_eVolRep_Db) {
    strcpy( name, "");
    strcpy( server, "");
  }
  lfu_volume_info( const lfu_volume_info& x) : vid(x.vid), cid(x.cid), volrep(x.volrep) {
    strncpy( name, x.name, sizeof(name));
    strncpy( server, x.server, sizeof(server));
  }
};    

class lfu_boot_info
{
 public:
  pwr_tObjName node_name;
  pwr_tString80 node_text;
  pwr_tObjName volume_name;
  pwr_tVid vid;
  pwr_tUInt32 bus;
  pwr_tOpSysEnum opsys;
  int number;

  lfu_boot_info() : vid(0), bus(0), opsys(0), number(0) {
    strcpy( node_name, "");
    strcpy( node_text, "");
    strcpy( volume_name, "");
  }
    lfu_boot_info( const lfu_boot_info& x) : vid(x.vid), bus(x.bus), opsys(x.opsys), number(x.number) {
    strncpy( node_name, x.node_name, sizeof(node_name));
    strncpy( node_text, x.node_text, sizeof(node_text));
    strncpy( volume_name, x.volume_name, sizeof(volume_name));
  }
};    

pwr_tStatus lfu_volumelist_load( const char *filename, 
				 lfu_t_volumelist **vollist,
				 int *volcount);

pwr_tStatus lfu_create_loadfile( ldh_tSesContext ldhses);

pwr_tStatus lfu_create_bootfile( char *nodeconfigname,
				 lfu_t_volumelist *volumelist,
				 int volumecount,
				 int debug);

pwr_tStatus lfu_GetFileVersion( char *pattern, 
				int number_of_digits,
				int *version, 
				pwr_tTime *date);

pwr_tStatus lfu_GetPlcFileVersion( pwr_tVolumeId volumeid, 
				   int *version, 
				   pwr_tTime *date);

pwr_tStatus lfu_IncrementAndGetVersion( char *filename,
					unsigned long *current_version);

pwr_tStatus lfu_SaveDirectoryVolume( ldh_tSesContext ldhses,
				     CoWow *wow,
				     int quiet);

int lfu_create_bootfiles( char *nodestr,
			  int debug,
			  int allnodes);

pwr_tStatus lfu_ReadBootFile( char *filename,
			      pwr_tTime	*date,
			      char *systemname,
			      char *systemgroup,
			      pwr_tVolumeId **vollist,
			      pwr_tString40 **volnamelist,
			      int *volcount,
			      pwr_tString80 **plclist,
			      int *plccount);

pwr_tStatus lfu_ReadSysObjectFile( char	*SystemName,
				   char	*SystemGroup);

pwr_tStatus lfu_WriteSysObjectFile( ldh_tSesContext	ldhses);

pwr_tStatus lfu_GetVolRef( char *filename,
			   lfu_t_volref **volref,
			   int *volref_count);
pwr_tStatus lfu_GetVolume( char *filename,
			   char *name,
			   pwr_tVid *vid,
			   pwr_tCid *cid,
			   pwr_tTime *time,
			   pwr_tUInt32 *dvversion);
pwr_tStatus lfu_GetVolumeCnf( char *name, pwr_tVid *vid, pwr_tCid *cid, ldh_eVolRep *volrep,
			      char *server);

pwr_tStatus lfu_ParseDbmsServer( char *server, char *user, char *passw, 
				 unsigned int *port, char *host);

pwr_tStatus lfu_check_appl_file( ldh_tSesContext ldhses,
				 char *nodename, int bus_number);
pwr_tStatus lfu_check_opt_file( ldh_tSesContext ldhses, char *nodename, int bus_number, pwr_mOpSys opsys);

pwr_tStatus lfu_GetVolumeCnfAll( vector<lfu_volume_info>& vect);

pwr_tStatus lfu_GetBootList( vector<lfu_boot_info>& vect, int *nodes);

#ifdef __cplusplus
}
#endif

#endif





















