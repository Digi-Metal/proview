/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#ifndef wb_pkg_h
#define wb_pkg_h

#include <iostream>
#include <vector>
#include <string>
#include "pwr.h"
#include "pwr_class.h"
#include "cow_wow.h"
#include "wb_lfu.h"

using namespace std;

class pkg_node;

class pkg_file {
  friend class pkg_node;

 private:
  char m_source[200];
  char m_target[200];
  char m_arname[80];
  pwr_tTime m_date;

 public:
  pkg_file( char *source, char *target);
  char *source() { return m_source;}
  char *target() { return m_target;}
  pwr_tTime date() { return m_date;}

};

class pkg_pattern {
  friend class pkg_node;

 private:
  char m_source[200];
  char m_target[200];  
  vector<pkg_file> m_filelist;
  pkg_node *m_node;
  char m_severity;

 public:
  pkg_pattern( const char *source, const char *target, char severity = 'W') 
    : m_node(0), m_severity(severity) {
    strcpy( m_source, source);
    strcpy( m_target, target);
  }
  pkg_pattern( const char *source) : m_node(0), m_severity('W') {
    strcpy( m_source, source);
    strcpy( m_target, "");
  }
  pkg_pattern( const pkg_pattern& x) : m_filelist(x.m_filelist), m_node(x.m_node),
    m_severity(x.m_severity) {
    strcpy( m_source, x.m_source);
    strcpy( m_target, x.m_target);
  }
  char *source() { return m_source;}
  char *target() { return m_target;}
  bool hasTarget() { return m_target[0] != 0;}
  void fetchFiles();
  void node( pkg_node *node) { m_node = node;}
};

class pkg_volume {
  friend class pkg_node;

 private:
  char m_name[80];
  char m_filename[200];  
  pwr_tVid m_vid;
  pwr_tTime m_time;
  bool m_isSystem;

 public:
  pkg_volume( char *name, char *filename, pwr_tVid vid, pwr_tTime time) :
    m_vid(vid), m_time(time), m_isSystem(false)
  {
    strcpy( m_name, name);
    strcpy( m_filename, filename);
    if ( strncmp( m_filename, "$pwr_load/", 10) == 0)
      m_isSystem = true;
  }
};

class pkg_node {
 private:
  vector<pkg_pattern> m_pattern;
  vector<pkg_file> m_filelist;
  vector<pkg_volume> m_volumelist;
  char m_name[80];
  char m_bootnode[80];
  pwr_mOpSys m_opsys;
  int m_bus;
  pwr_tMask m_dstatus;
  bool m_valid;
  int m_errors;
  int m_warnings;
  char m_user[80];
  char m_custom_platform[80];
  char m_tmpdir[80];
  char m_blddir[80];

 public:
  pkg_node( char *name): m_opsys(pwr_mOpSys__), m_bus(0),
    m_dstatus(0), m_valid(false), m_errors(0), m_warnings(0)
    { 
      strncpy( m_name, name, sizeof(m_name));
      strcpy( m_user, "pwrp");
      strcpy( m_bootnode, "-");
      strcpy( m_custom_platform, "-");
    }
  pkg_node( char *name, pwr_mOpSys opsys, int bus, 
	    pwr_tMask dstatus, char *bootnode, char *custom_platform) :
    m_opsys(opsys), m_bus(bus), m_dstatus(dstatus),
    m_valid(true), m_errors(0), m_warnings(0)
    { 
      char *s;
      strncpy( m_user, bootnode, sizeof(m_user));
      if ( (s = strchr( m_user, '@'))) {
	*s = 0;
	strncpy( m_bootnode, s+1, sizeof(m_bootnode));
      }
      else {
	strcpy( m_user, "pwrp");
	strcpy( m_bootnode, bootnode);
      }
      strncpy( m_name, name, sizeof(m_name));
      strncpy( m_custom_platform, custom_platform, sizeof(m_custom_platform));
    }
  char *name() { return m_name;}
  pwr_mOpSys opsys() { return m_opsys;}
  int bus() { return m_bus;}
  pwr_tMask dstatus() { return m_dstatus;}
  char *bootnode() { return m_bootnode;}
  char *customPlatform() { return m_custom_platform;}
  bool valid() { return m_valid;}
  void setOpsys( pwr_mOpSys opsys) { m_opsys = opsys;}
  void setBus( int bus) { m_bus = bus;}
  void setDStatus( pwr_tMask dstatus) { m_dstatus = dstatus;} 
  void setBootnode( char *bootnode) { 
    char *s;
    strncpy( m_user, bootnode, sizeof(m_user));
    if ( (s = strchr( m_user, '@'))) {
      *s = 0;
      strncpy( m_bootnode, s+1, sizeof(m_bootnode));
    }
    else {
      strcpy( m_user, "pwrp");
      strcpy( m_bootnode, bootnode);
    }
  } 
  void setCustomPlatform( char *custom_platform) {
    strncpy( m_custom_platform, custom_platform, sizeof(m_custom_platform));
  }
  void setValid() { m_valid = true;}
  void push_back( pkg_pattern& pattern) { 
    pattern.node( this);
    m_pattern.push_back( pattern);
  }
  void checkVolume( char *filename);
  void fetchFiles( bool distribute);
  void copyPackage( char *pkg_name);
  void incrWarnings() { m_warnings++;}
  void incrErrors() { m_errors++;}
};

class wb_pkg {
 private:
  vector<pkg_node> m_nodelist;
  bool m_allnodes;

  void readConfig();

 public:
  wb_pkg( char *nodelist, bool distribute = true, bool config_only = false);
  pkg_node& getNode( char *name);
  void fetchFiles( bool distribute) {
    for ( int i = 0; i < (int)m_nodelist.size(); i++) m_nodelist[i].fetchFiles( distribute);
  }

  static void copyPackage( char *pkg_name);
};

#endif




