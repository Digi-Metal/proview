/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/


#include <vector>
#include "pwr.h"
#include "co_time.h"
#include "wb_revision.h"
#include "wb_lfu.h"
#include "wb_log.h"
#include "wb_utl_api.h"
#include "wb_rev_msg.h"
#include "pwr_version.h"
#include "pwr_baseclasses.h"


wb_revision::wb_revision( void *parent_ctx, wb_session *ses): 
  m_parent_ctx(parent_ctx), m_session(ses), m_manager(0), m_manager_enum(pwr_eVersionManagerEnum_None),
  m_read(false), m_current_idx(-1), m_current_main_idx(-1), m_current_sub_idx(-1), m_command_cb(0) 
{
  char current[80];

  m_manager = new wb_version_manager_git();

  read_file();

  switch ( m_manager_enum) {
  case pwr_eVersionManagerEnum_Git:
    m_manager = new wb_version_manager_git();
    break;
  default: ;
  }

  if ( m_manager) {
    m_sts = m_manager->check( m_vect);

    bool found = false;
    m_sts = m_manager->get_current( current);
    if ( ODD(m_sts)) {
      for ( unsigned int i = 0; i < m_vect.size(); i++) {
	if ( cdh_NoCaseStrcmp( current, m_vect[i].name) == 0) {
	  m_current_idx = m_vect[i].idx;
	  m_current_main_idx = i;
	  m_current_sub_idx = -1;
	  m_vect[i].current = true;
	  found = true;
	  break;
	}
	for ( unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
	  if ( cdh_NoCaseStrcmp( current, m_vect[i].vect[j].name) == 0) {
	    m_current_idx = m_vect[i].vect[j].idx;
	    m_current_main_idx = i;
	    m_current_sub_idx = j;
	    m_vect[i].vect[j].current = true;
	    m_vect[i].current_branch = true;
	    found = true;
	    break;
	  }
	}
	if ( found)
	  break;
      }
    }
  }
}

char *wb_revision::branch_name( char *name)
{
  static char bname[80];

  strcpy( bname, "B_");
  strncat( bname, name, sizeof(bname));
  return bname;
}

pwr_tStatus wb_revision::create_check()
{
  // Create is allowed only if current revision is of an end of a branch
  if ( m_current_sub_idx == -1 && m_current_main_idx == -1)
    // No revision stored yet
    return REV__SUCCESS;
  if (m_current_sub_idx == -1 && m_current_main_idx == (int) m_vect.size() - 1)
    // Last revision on main
    return REV__SUCCESS;
  if (m_current_sub_idx == -1 && m_vect[m_current_main_idx].vect.size() == 0)
    // Revision on main without any branch yet
    return REV__SUCCESS;
  if (m_current_sub_idx != -1 && m_current_sub_idx == (int) m_vect[m_current_main_idx].vect.size()-1)
    // Last revision on a branch
    return REV__SUCCESS;

  // Create not allowed
  return REV__CREATEPOS;
}

pwr_tStatus wb_revision::create( int all, char *name, char *descr)
{

  if ( all) {
    // Get current volume
    ldh_sVolumeInfo info;
    pwr_tObjName current_volume;
    int has_current_volume = 0;
    int size;
    pwr_tFileName proot;
    pwr_tCmd cmd;
    bool in_main = false;
    int main_idx;
    
    // Create is allowed only if revision is an end node
    if ( m_current_sub_idx == -1 && m_current_main_idx == -1) {
      in_main = true;
    }
    else if (m_current_sub_idx == -1 && m_current_main_idx == (int) m_vect.size() - 1) {
      in_main = true;
    }
    else if (m_current_sub_idx == -1 && m_vect[m_current_main_idx].vect.size() == 0) {
      main_idx = m_current_main_idx;
    }
    else if (m_current_sub_idx != -1 && m_current_sub_idx == (int) m_vect[m_current_main_idx].vect.size()-1) {
      main_idx = m_current_main_idx;
    }
    else
      return REV__CREATEPOS;

    dcli_translate_filename( proot, "$pwrp_root");

    m_sts = ldh_GetVolumeInfo( ldh_SessionToVol( (ldh_tSession)m_session), &info);
    if ( EVEN(m_sts)) return m_sts;

    if ( info.Class == pwr_eClass_RootVolume || 
	 info.Class == pwr_eClass_SubVolume || 
	 info.Class == pwr_eClass_SharedVolume) {
      m_sts = ldh_VolumeIdToName( ldh_SessionToWB( (ldh_tSession)m_session), info.Volume,
				  current_volume, sizeof(current_volume), &size);
      has_current_volume = 1;
    }
    if ( !has_current_volume)
      sprintf( cmd, "wb_revision.sh create %s", proot);
    else
      sprintf( cmd, "wb_revision.sh create %s %s", proot, current_volume); 
    m_sts = system( cmd);
    if ( m_sts != 0) {
      if ( m_sts >> 8 == 1)
	return REV__VOLLOCK;
      else
	return REV__CREATE;
    }
    if ( has_current_volume) {
      // Create revision file for current volume
      sprintf( cmd, "wb dump/nofo/out=\"$pwrp_db/%s.wb_rev\"", cdh_Low(current_volume));
      if ( m_command_cb)
	m_sts = (m_command_cb)( this, cmd);
    }

    // Commit revision
    if ( m_manager) {
      m_sts = m_manager->store_revision( name, descr, in_main);
      if ( EVEN(m_sts)) return m_sts;
    }

    // Add to revision file
    add( name, descr, (char *)pwrv_cPwrVersionStr, 0, in_main, main_idx);
    write_file();    

    wb_log::log( wlog_eCategory_NewRevision, name, descr);
  }
  else {
    // Create revision for for current volume
    ldh_sVolumeInfo info;
    pwr_tObjName current_volume;
    int size;
    pwr_tCmd cmd;

    m_sts = ldh_GetVolumeInfo( ldh_SessionToVol( (ldh_tSession)m_session), &info);
    if ( EVEN(m_sts)) return m_sts;

    if ( !(info.Class == pwr_eClass_RootVolume || 
	   info.Class == pwr_eClass_SubVolume || 
	   info.Class == pwr_eClass_SharedVolume)) {
      return REV__VOLTYPE;
    }
	
    m_sts = ldh_VolumeIdToName( ldh_SessionToWB( (ldh_tSession)m_session), info.Volume,
				current_volume, sizeof(current_volume), &size);
    sprintf( cmd, "wb dump/nofo/out=\"$pwrp_db/%s.wb_rev\"", cdh_Low(current_volume));
    if ( m_command_cb)
      m_sts = (m_command_cb)( this, cmd);
  }
    
  return REV__SUCCESS;
}

pwr_tStatus wb_revision::restore( char *name) 
{
  pwr_tFileName db_dir, fname;
  int sts;
  pwr_tTime t;
  pwr_tCmd cmd;
  char project_name[80];    
  vector<lfu_volume_info> vol;
  int main_idx;
  int sub_idx;
  int checkout_master = 0;
  int checkout_branch = 0;
  char branch[80];
  bool no_branch = false;

  // Find revision in table
  bool found = false;
  for ( unsigned int i = 0; i < m_vect.size(); i++) {
    if ( cdh_NoCaseStrcmp( m_vect[i].name, name) == 0) {
      main_idx = i;
      sub_idx = -1;
      found = true;
      break;
    }
    for ( unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
      if ( cdh_NoCaseStrcmp( m_vect[i].vect[j].name, name) == 0) {
	main_idx = i;
	sub_idx = j;
	found = true;
	break;
      }
    }
    if ( found)
      break;
  }

  if ( main_idx == (int)m_vect.size() - 1)
    checkout_master = 1;
  else if (sub_idx == -1 && m_vect[main_idx].vect.size() == 0) {
    // Main revision without any branch revisions
    checkout_branch = 1;
    strcpy( branch, branch_name(name));
  }
  else if (sub_idx == (int)m_vect[main_idx].vect.size() - 1) {
    // End revision on a branch
    checkout_branch = 1;
    strcpy( branch, branch_name(m_vect[main_idx].name));
  }
  else {
    // A tag is restored
    no_branch = true;
  }

  if ( !found)
    return REV__NOSUCHREV;

  // Checkout requested revision
  if ( m_manager) {
    m_sts = m_manager->restore_revision( name, branch, checkout_master, checkout_branch);
    if ( EVEN(m_sts))
      return m_sts;
  }

  dcli_translate_filename( db_dir, "$pwrp_db");
  utl_get_projectname( project_name);

  sts = lfu_GetVolumeCnfAll( vol);

  // Check that no volume is locked
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      if ( vol[i].volrep == ldh_eVolRep_Dbms)
	sprintf( fname, "%s/%s.dbms.lock", db_dir, cdh_Low(vol[i].name));
      else if ( vol[i].volrep == ldh_eVolRep_Wbl)
	sprintf( fname, "%s/%s.wb_load.lock", db_dir, cdh_Low(vol[i].name));
      else
	sprintf( fname, "%s/%s.db.lock", db_dir, cdh_Low(vol[i].name));	
      
      if ( ODD( dcli_file_time( fname, &t))) {
	printf( "** Volume is locked, %s", vol[i].name);
	return REV__VOLLOCK;
      }
      break;
    default: ;
    }
  }

  // Check that revision files exist for root, sub and shared volumes
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      sprintf( fname, "%s/%s.wb_rev", db_dir, cdh_Low(vol[i].name));	
      
      if ( EVEN( dcli_file_time( fname, &t))) {
	printf( "** Snapshot file is missing, %s, %s", vol[i].name, fname);
	return REV__REVFILE;
      }
      break;
    default: ;
    }
  }

  // Build class volumes
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      sprintf( cmd, "create snapshot/file=\"$pwrp_db/%s.wb_load\"/out=\"$pwrp_load/%s.dbs\"", 
	       cdh_Low(vol[i].name), cdh_Low(vol[i].name));	
      if ( m_command_cb)
	sts = (m_command_cb)( this, cmd);
      break;
    default: ;
    }
  }

  // Rename old databases
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      if ( vol[i].volrep == ldh_eVolRep_Dbms) {
	sprintf( cmd, "mysqldump -h %s -upwrp pwrp_%s_%s > $pwrp_db/%s.dbms/pwrp_%s_%s.mysqldump", vol[i].server, 
		 project_name, cdh_Low(vol[i].name), cdh_Low(vol[i].name), project_name, cdh_Low(vol[i].name));
	system( cmd);
	
	sprintf( cmd, "mysqladmin -h %s -upwrp drop -f pwrp_%s_%s", vol[i].server, project_name, cdh_Low(vol[i].name));
	system( cmd);
	
	sprintf( cmd, "pwrp_env.sh save file %s/%s.dbms", db_dir, cdh_Low(vol[i].name));	
	system( cmd);
      }
      else {
	sprintf( cmd, "pwrp_env.sh save file %s/%s.db", db_dir, cdh_Low(vol[i].name));	
	system( cmd);
      }
      break;
    default: ;
    }
  }

  // Load wbl revision files
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      sprintf( cmd, "wb load/nofocode/load=\"$pwrp_db/%s.wb_rev\"/out=\"$pwrp_db/%s.lis",
	       cdh_Low(vol[i].name), cdh_Low(vol[i].name));
      if ( m_command_cb)
	(m_command_cb)( this, cmd);
      break;
    default: ;
    }
  }

  wb_log::log( wlog_eCategory_RevisionRestore, name, 0);

  if ( no_branch)
    return REV__NOBRANCH;

  return REV__SUCCESS;
}

pwr_tStatus wb_revision::build_all() 
{
  pwr_tFileName db_dir, fname;
  int sts;
  pwr_tTime t;
  pwr_tCmd cmd;
  char project_name[80];    
  vector<lfu_volume_info> vol;

  dcli_translate_filename( db_dir, "$pwrp_db");
  utl_get_projectname( project_name);

  sts = lfu_GetVolumeCnfAll( vol);

  // Check that no volume is locked
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      if ( vol[i].volrep == ldh_eVolRep_Dbms)
	sprintf( fname, "%s/%s.dbms.lock", db_dir, cdh_Low(vol[i].name));
      else if ( vol[i].volrep == ldh_eVolRep_Wbl)
	sprintf( fname, "%s/%s.wb_load.lock", db_dir, cdh_Low(vol[i].name));
      else
	sprintf( fname, "%s/%s.db.lock", db_dir, cdh_Low(vol[i].name));	
      
      if ( ODD( dcli_file_time( fname, &t))) {
	printf( "** Volume is locked, %s", vol[i].name);
	return REV__VOLLOCK;
      }
      break;
    default: ;
    }
  }

  // Build class volumes
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      sprintf( cmd, "create snapshot/file=\"$pwrp_db/%s.wb_load\"/out=\"$pwrp_load/%s.dbs\"", 
	       cdh_Low(vol[i].name), cdh_Low(vol[i].name));	
      if ( m_command_cb)
	sts = (m_command_cb)( this, cmd);
      break;
    default: ;
    }
  }

  // Build root, sub and shared volumes
  for ( unsigned int i = 0; i < vol.size(); i++) {
    switch ( vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      sprintf( cmd, "wb_cmd -v %s build volume/name=%s/force", cdh_Low(vol[i].name), vol[i].name);
      system( cmd);
      break;
    default: ;
    }
  }

  // Build nodes

  return REV__SUCCESS;
}

pwr_tStatus wb_revision::remove( char *name) 
{
  if ( !m_read)
    read_file();

  bool found = false;
  for ( unsigned int i = 0; i < m_vect.size(); i++) {
    if ( cdh_NoCaseStrcmp( m_vect[i].name, name) == 0) {
      m_vect.erase(m_vect.begin() + i);
      found = true;
      break;
    }
  }
  
  if ( found) {
    write_file();
    return 1;
  }
  return 0;
}

void wb_revision::read_file()
{
  pwr_tFileName fname;
  char line[200];
  char item_array[6][80];
  int sts;
  int idx = 0;

  dcli_translate_filename( fname, "$pwrp_db/pwrp_cnf_revision.dat");
  ifstream fp( fname, ios::in);
  if ( !fp) {
    m_read = true;
    return;
  }
 
  while ( fp.getline( line, sizeof(line))) {
    wb_rev_item item;
    int nr;

    nr = dcli_parse( line, " ", "", (char *)item_array,
		     sizeof(item_array)/sizeof(item_array[0]),
		     sizeof(item_array[0]), 0);

    if ( nr == 3 && strcmp( item_array[0], "#!") == 0 && strcmp( item_array[1], "RevisionManager") == 0) {
      if ( strcmp( item_array[2], "1") == 0)
	m_manager_enum = pwr_eVersionManagerEnum_Git;
      else
	m_manager_enum = pwr_eVersionManagerEnum_None;
      continue;
    }
    if ( nr != 5) {
      m_sts = 0;
      return;
    }
    
    sts = sscanf( item_array[0], "%d", &item.level);
    if ( sts != 1) 
      printf( "** Syntax error in configuration file\n");
    strncpy( item.name, item_array[1], sizeof(item.name));
    strncpy( item.description, item_array[2], sizeof(item.description));
    strncpy( item.version, item_array[3], sizeof(item.version));
    time_AsciiToA( item_array[4], &item.date);
    item.idx = idx++;

    if ( item.level == 0)
      m_vect.push_back( item);
    else if ( m_vect.size() > 0)
      m_vect[m_vect.size()-1].vect.push_back(item);
  }
  fp.close();

  m_read = true;
}

void wb_revision::write_file()
{
  pwr_tFileName fname;
  char timestr[40];

  if ( !m_read)
    return;

  dcli_translate_filename( fname, "$pwrp_db/pwrp_cnf_revision.dat");
  ofstream fp( fname, ios::out);
  if ( !fp) {
    m_sts = 0;
    return;
  }
 
  fp << "#! RevisionManager " << m_manager_enum << endl;
  for ( unsigned int i = 0; i < m_vect.size(); i++) {
    time_AtoAscii( &m_vect[i].date, time_eFormat_DateAndTime, timestr, sizeof(timestr));

    fp << m_vect[i].level << " " << m_vect[i].name << " " << " \"" << m_vect[i].description << "\" " << m_vect[i].version << " \"" << timestr << "\"" << endl;

    for ( unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
      time_AtoAscii( &m_vect[i].vect[j].date, time_eFormat_DateAndTime, timestr, sizeof(timestr));
      fp << m_vect[i].vect[j].level << " " << m_vect[i].vect[j].name << " " << " \"" << m_vect[i].vect[j].description << "\" " << m_vect[i].vect[j].version << " \"" << timestr << "\"" << endl;
    }
  }
  fp.close();
}

int wb_revision::add( char *name, char *description, char *version, pwr_tTime *date, bool in_main,
		      int sub_idx)
{
  wb_rev_item item;

  if ( !m_read)
    read_file();

  // Check the name is unique
  for ( unsigned int i = 0; i < m_vect.size(); i++) {
    if ( cdh_NoCaseStrcmp( name, m_vect[i].name) == 0) {
      return 0;
    }
  }

  strncpy( item.name, name, sizeof(item.name));  
  strncpy( item.description, description, sizeof(item.description));
  strncpy( item.version, version, sizeof(item.version));
  if ( date)
    item.date = *date;
  else
    time_GetTime( &item.date);

  if ( in_main) {
    item.level = 0;
    m_vect.push_back( item);
  }
  else {
    item.level = 1;
    m_vect[sub_idx].vect.push_back(item);
  }
  return 1;
}

void wb_revision::list()
{
  char timestr[40];

  if ( !m_read)
    read_file();


  cout << endl;
  for ( unsigned int i = 0; i < m_vect.size(); i++) {
    time_AtoAscii( &m_vect[i].date, time_eFormat_DateAndTime, timestr, sizeof(timestr));  
    if ( m_current_idx == (int) i)
      cout << "** ";
    else if ( !m_vect[i].in_manager)
      cout << "!! ";
    else
      cout << "   ";
    for ( int j = 0; j < m_vect[i].level; j++)
      cout << " ";
    cout << " " << m_vect[i].name << "  " << " " << m_vect[i].description << "  " << m_vect[i].version << "  " << timestr << endl;
  }
  cout << endl;
}

wb_rev_item *wb_revision::current() 
{ 
  if ( m_current_main_idx == -1 && m_current_sub_idx == -1)
    return 0;
  if ( m_current_sub_idx == -1)
    return &m_vect[m_current_main_idx];
  return &m_vect[m_current_main_idx].vect[m_current_sub_idx];
}

void wb_revision::get_info( wb_rev_info *info) 
{
  info->in_master = false;
  info->in_end_of_branch = false;

  if ( m_current_main_idx == -1) {
    strcpy( info->name, "");
    info->in_end_of_branch = true;
    info->in_master = true;
  }
  else if ( m_current_sub_idx == -1) {
    strcpy( info->name, m_vect[m_current_main_idx].name);
    if ( m_vect[m_current_main_idx].vect.size() == 0)
      info->in_end_of_branch = true;
    if ( m_current_main_idx == (int)m_vect.size() - 1) {
      info->in_end_of_branch = true;
      info->in_master = true;
    }
  }
  else {
    strcpy( info->name, m_vect[m_current_main_idx].vect[m_current_sub_idx].name);
    if ( m_current_sub_idx == (int)m_vect[m_current_main_idx].vect.size() - 1)
      info->in_end_of_branch = true;
  }
}

void wb_revision::info( wb_rev_info *info)
{
  wb_revision *rev = new wb_revision( 0, 0);
  rev->get_info( info);
  delete rev;
}

//
// Suggest next revision name
//
void wb_revision::next_name( char *name)
{
  char str[80];
  int num;
  int sts;

  if ( m_vect.size() == 0) {
    // First version
    strcpy( name, "V1.0.0");
    return;
  }

  if ( m_current_sub_idx == -1 && m_current_main_idx != (int)m_vect.size() -1) {
    // New branch, add '-1'
    sprintf( name, "%s-1", m_vect[m_current_main_idx].name);
    return;
  }

  // Increment last number
  if ( m_current_sub_idx == -1)
    strcpy( str, m_vect[m_current_main_idx].name);
  else
    strcpy( str, m_vect[m_current_main_idx].vect[m_current_sub_idx].name);
  for ( char *s = &str[strlen(str)-1]; s >= str; s--) {
    switch ( *s) {
    case '.':
    case '-':
      sts = sscanf( s+1, "%d", &num);
      if ( sts == 1) {
	*(s+1) = 0;
	sprintf( &str[strlen(str)], "%d", num+1);
	strcpy( name, str);
	return;
      }
    default: ;
    }
  }
  strcpy( name, "");
}

void wb_version_manager_git::init()
{
  pwr_tFileName fname;
  pwr_tCmd cmd;
  pwr_tTime t;
  bool new_git = false;

  dcli_translate_filename( fname, "$pwrp_root/src/.git");
  if ( EVEN(dcli_file_time( fname, &t))) {
    // No git repository found, init git

    strcpy( cmd, "git init $pwrp_root/src");
    system( cmd);
    new_git = true;
  }
  dcli_translate_filename( fname, "$pwrp_root/src/.gitignore");
  if ( EVEN(dcli_file_time( fname, &t))) {
    ofstream fp( fname, ios::out);
    if ( !fp)
      return;
 
    fp << "\
# Ignore editor journal files\n\
*~\n\
*#*\n\
# Ignore databases\n\
t.*\n\
*.t\n\
*.out\n\
*.db\n\
*.db.*\n\
*.db.lock\n\
*.db/*\n\
# Other temporary files\n\
*.gc\n\
*.gjl\n\
*.o\n\
plc_*_[0-9][0-9]]0-9][0-9]_*\n\
*.a\n\
pwrp_cnf_*.dat\n\
ld_appl_*.txt\n\
ld_boot_*.dat\n\
ld_node_*.dat\n\
*.dbs\n\
*.wb_dmp\n\
*.wb_load.*\n\
*.wb_dmp.*\n\
plc_*.opt_template\n\
plc_v*.dat\n\
*.log\n\
*.bck\n\
initdir.pwr_com\n\
initvol.pwr_com\n\
db/rt_eventlog_info.txt" << endl;
  }

  if ( new_git) {
    strcpy( cmd, "cd $pwrp_root/src; git add .");
    system( cmd);

    strcpy( cmd, "cd $pwrp_root/src; git commit -m \"Initial commit\" -a");
    system( cmd);
  }

}

int wb_version_manager_git::store_revision( char *name, char *descr, bool new_branch)
{
  pwr_tCmd cmd;
  int sts;

  // Commit all changes
  snprintf( cmd, sizeof(cmd), "git commit -m \"%s\" -a", descr);

  sts = system( cmd);
  if ( sts != 0) {
    printf( "** Error from git commit %d\n", sts >> 8);
    return REV__GITERROR;
  }

  // Tag last commit
  snprintf( cmd, sizeof(cmd), "git tag \"%s\"\n", name);

  sts = system( cmd);
  if ( sts != 0) {
    printf( "** Error from git tag %d\n", sts >> 8);
    return REV__GITERROR;
  }

  if ( new_branch) {
    // Create branch on last commit
    snprintf( cmd, sizeof(cmd), "git branch \"%s\"\n", wb_revision::branch_name( name));

    sts = system( cmd);
    if ( sts != 0) {
      printf( "** Error from git branch %d\n", sts >> 8);
      return REV__GITERROR;
    }
  }

  return REV__SUCCESS;
}


int wb_version_manager_git::restore_revision( char *name, char *branch, int checkout_master, int checkout_branch)
{
  pwr_tCmd cmd;
  int sts;

  if ( checkout_master) {
    // Checkout master branch
    strcpy( cmd, "git checkout master");
  }
  else if ( checkout_branch) {
    // Checkout supplied branch
    snprintf( cmd, sizeof(cmd), "git checkout \"%s\"", branch); 
  }
  else {
    // Checkout supplied tag
    snprintf( cmd, sizeof(cmd), "git checkout \"%s\"", name);
  }

  sts = system( cmd);
  if ( sts != 0) {
    printf( "** Error from git checkout %d\n", sts >> 8);
    return REV__GITERROR;
  }
  return REV__SUCCESS;
}

int wb_version_manager_git::get_current( char *name)
{
  pwr_tCmd cmd;
  int sts;
  pwr_tFileName fname = "$pwrp_tmp/current_tag.dat";
  char line[80];

  dcli_translate_filename( fname, fname);

  // Get current tag
  snprintf( cmd, sizeof(cmd), "git describe --tags --abbrev=0 > %s", fname);
  sts = system( cmd);
  if ( sts != 0) {
    printf( "** Error from git describe %d\n", sts >> 8);
    return REV__GITERROR;
  }

  ifstream fp( fname, ios::in);
  if ( !fp)
    return 0;
 
  if ( !fp.getline( line, sizeof(line)))
    return 0;
       
  strcpy( name, line);
  fp.close();
  
  snprintf( cmd, sizeof(cmd), "rm -f %s", fname);
  system( cmd);
	 
  return REV__SUCCESS;
}

int wb_version_manager_git::check( vector<wb_rev_item>& v)
{
  pwr_tCmd cmd;
  int sts;
  pwr_tFileName fname = "$pwrp_tmp/git_tags.dat";
  char line[80];

  dcli_translate_filename( fname, fname);

  // Get current tag
  snprintf( cmd, sizeof(cmd), "git tag > %s", fname);
  sts = system( cmd);
  if ( sts != 0) {
    printf( "** Error from git describe %d\n", sts >> 8);
    return REV__GITERROR;
  }

  ifstream fp( fname, ios::in);
  if ( !fp)
    return 0;
 
  for ( unsigned int i = 0; i < v.size(); i++) {
    v[i].in_manager = false;
    for ( unsigned int j = 0; j < v[i].vect.size(); j++)
      v[i].vect[j].in_manager = false;
  }

  while ( fp.getline( line, sizeof(line))) {
    for ( unsigned int i = 0; i < v.size(); i++) {
       
      if ( cdh_NoCaseStrcmp( v[i].name, line) == 0) {
	v[i].in_manager = true;
	break;
      }
      for ( unsigned int j = 0; j < v[i].vect.size(); j++) {
	if ( cdh_NoCaseStrcmp( v[i].vect[j].name, line) == 0) {
	  v[i].vect[j].in_manager = true;
	  break;
	}
      }
    }
  }
  fp.close();
  
  snprintf( cmd, sizeof(cmd), "rm -f %s", fname);
  system( cmd);
	 
  return REV__SUCCESS;
}
