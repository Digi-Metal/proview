/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_time.h"
#include "pwr_names.h"
#include "wb_rev_msg.h"

#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "wb_wrev.h"
#include "wb_wrevnav.h"
#include "wb_wnav.h"
#include "wb_wnav_brow.h"
#include "wb_wnav_item.h"
#include "wb_lfu.h"
#include "wb_error.h"

#include "xnav_bitmap_leaf8.h"
#include "xnav_bitmap_leaf10.h"
#include "xnav_bitmap_leaf12.h"
#include "xnav_bitmap_leaf14.h"
#include "xnav_bitmap_leaf16.h"
#include "xnav_bitmap_leaf18.h"
#include "xnav_bitmap_leaf20.h"
#include "xnav_bitmap_leaf24.h"
#include "xnav_bitmap_map8.h"
#include "xnav_bitmap_map10.h"
#include "xnav_bitmap_map12.h"
#include "xnav_bitmap_map14.h"
#include "xnav_bitmap_map16.h"
#include "xnav_bitmap_map18.h"
#include "xnav_bitmap_map20.h"
#include "xnav_bitmap_map24.h"
#include "xnav_bitmap_openmap8.h"
#include "xnav_bitmap_openmap10.h"
#include "xnav_bitmap_openmap12.h"
#include "xnav_bitmap_openmap14.h"
#include "xnav_bitmap_openmap16.h"
#include "xnav_bitmap_openmap18.h"
#include "xnav_bitmap_openmap20.h"
#include "xnav_bitmap_openmap24.h"
#include "xnav_bitmap_attr8.h"
#include "xnav_bitmap_attr10.h"
#include "xnav_bitmap_attr12.h"
#include "xnav_bitmap_attr14.h"
#include "xnav_bitmap_attr16.h"
#include "xnav_bitmap_attr18.h"
#include "xnav_bitmap_attr20.h"
#include "xnav_bitmap_attr24.h"
#include "xnav_bitmap_current8.h"
#include "xnav_bitmap_current10.h"
#include "xnav_bitmap_current12.h"
#include "xnav_bitmap_current14.h"
#include "xnav_bitmap_current16.h"
#include "xnav_bitmap_current18.h"
#include "xnav_bitmap_current20.h"
#include "xnav_bitmap_current24.h"
#include "xnav_bitmap_warning8.h"
#include "xnav_bitmap_warning10.h"
#include "xnav_bitmap_warning12.h"
#include "xnav_bitmap_warning14.h"
#include "xnav_bitmap_warning16.h"
#include "xnav_bitmap_warning18.h"
#include "xnav_bitmap_warning20.h"
#include "xnav_bitmap_warning24.h"
#include "xnav_bitmap_morehelp8.h"
#include "xnav_bitmap_morehelp10.h"
#include "xnav_bitmap_morehelp12.h"
#include "xnav_bitmap_morehelp14.h"
#include "xnav_bitmap_morehelp16.h"
#include "xnav_bitmap_morehelp18.h"
#include "xnav_bitmap_morehelp20.h"
#include "xnav_bitmap_morehelp24.h"
//
//  Free pixmaps
//
void WRevNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap( ctx, pixmap_map);
  brow_FreeAnnotPixmap( ctx, pixmap_openmap);
  brow_FreeAnnotPixmap( ctx, pixmap_attr);
  brow_FreeAnnotPixmap( ctx, pixmap_current);
  brow_FreeAnnotPixmap( ctx, pixmap_warning);
  brow_FreeAnnotPixmap( ctx, pixmap_currentbranch);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void WRevNavBrow::allocate_pixmaps()
{
  flow_sPixmapData pixmap_data;
  int i;

  i = 0;
  pixmap_data[i].width =xnav_bitmap_leaf8_width;
  pixmap_data[i].height =xnav_bitmap_leaf8_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf8_bits;
  pixmap_data[i].width =xnav_bitmap_leaf10_width;
  pixmap_data[i].height =xnav_bitmap_leaf10_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf10_bits;
  pixmap_data[i].width =xnav_bitmap_leaf12_width;
  pixmap_data[i].height =xnav_bitmap_leaf12_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf12_bits;
  pixmap_data[i].width =xnav_bitmap_leaf14_width;
  pixmap_data[i].height =xnav_bitmap_leaf14_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf14_bits;
  pixmap_data[i].width =xnav_bitmap_leaf16_width;
  pixmap_data[i].height =xnav_bitmap_leaf16_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf16_bits;
  pixmap_data[i].width =xnav_bitmap_leaf18_width;
  pixmap_data[i].height =xnav_bitmap_leaf18_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf18_bits;
  pixmap_data[i].width =xnav_bitmap_leaf20_width;
  pixmap_data[i].height =xnav_bitmap_leaf20_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf20_bits;
  pixmap_data[i].width =xnav_bitmap_leaf20_width;
  pixmap_data[i].height =xnav_bitmap_leaf20_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf20_bits;
  pixmap_data[i].width =xnav_bitmap_leaf24_width;
  pixmap_data[i].height =xnav_bitmap_leaf24_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_leaf);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_map8_width;
  pixmap_data[i].height =xnav_bitmap_map8_height;
  pixmap_data[i++].bits = xnav_bitmap_map8_bits;
  pixmap_data[i].width =xnav_bitmap_map10_width;
  pixmap_data[i].height =xnav_bitmap_map10_height;
  pixmap_data[i++].bits = xnav_bitmap_map10_bits;
  pixmap_data[i].width =xnav_bitmap_map12_width;
  pixmap_data[i].height =xnav_bitmap_map12_height;
  pixmap_data[i++].bits = xnav_bitmap_map12_bits;
  pixmap_data[i].width =xnav_bitmap_map14_width;
  pixmap_data[i].height =xnav_bitmap_map14_height;
  pixmap_data[i++].bits = xnav_bitmap_map14_bits;
  pixmap_data[i].width =xnav_bitmap_map16_width;
  pixmap_data[i].height =xnav_bitmap_map16_height;
  pixmap_data[i++].bits = xnav_bitmap_map16_bits;
  pixmap_data[i].width =xnav_bitmap_map18_width;
  pixmap_data[i].height =xnav_bitmap_map18_height;
  pixmap_data[i++].bits = xnav_bitmap_map18_bits;
  pixmap_data[i].width =xnav_bitmap_map20_width;
  pixmap_data[i].height =xnav_bitmap_map20_height;
  pixmap_data[i++].bits = xnav_bitmap_map20_bits;
  pixmap_data[i].width =xnav_bitmap_map20_width;
  pixmap_data[i].height =xnav_bitmap_map20_height;
  pixmap_data[i++].bits = xnav_bitmap_map20_bits;
  pixmap_data[i].width =xnav_bitmap_map24_width;
  pixmap_data[i].height =xnav_bitmap_map24_height;
  pixmap_data[i++].bits = xnav_bitmap_map24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_map);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_openmap8_width;
  pixmap_data[i].height =xnav_bitmap_openmap8_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap8_bits;
  pixmap_data[i].width =xnav_bitmap_openmap10_width;
  pixmap_data[i].height =xnav_bitmap_openmap10_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap10_bits;
  pixmap_data[i].width =xnav_bitmap_openmap12_width;
  pixmap_data[i].height =xnav_bitmap_openmap12_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap12_bits;
  pixmap_data[i].width =xnav_bitmap_openmap14_width;
  pixmap_data[i].height =xnav_bitmap_openmap14_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap14_bits;
  pixmap_data[i].width =xnav_bitmap_openmap16_width;
  pixmap_data[i].height =xnav_bitmap_openmap16_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap16_bits;
  pixmap_data[i].width =xnav_bitmap_openmap18_width;
  pixmap_data[i].height =xnav_bitmap_openmap18_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap18_bits;
  pixmap_data[i].width =xnav_bitmap_openmap20_width;
  pixmap_data[i].height =xnav_bitmap_openmap20_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap20_bits;
  pixmap_data[i].width =xnav_bitmap_openmap20_width;
  pixmap_data[i].height =xnav_bitmap_openmap20_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap20_bits;
  pixmap_data[i].width =xnav_bitmap_openmap24_width;
  pixmap_data[i].height =xnav_bitmap_openmap24_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_openmap);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_attr8_width;
  pixmap_data[i].height =xnav_bitmap_attr8_height;
  pixmap_data[i++].bits = xnav_bitmap_attr8_bits;
  pixmap_data[i].width =xnav_bitmap_attr10_width;
  pixmap_data[i].height =xnav_bitmap_attr10_height;
  pixmap_data[i++].bits = xnav_bitmap_attr10_bits;
  pixmap_data[i].width =xnav_bitmap_attr12_width;
  pixmap_data[i].height =xnav_bitmap_attr12_height;
  pixmap_data[i++].bits = xnav_bitmap_attr12_bits;
  pixmap_data[i].width =xnav_bitmap_attr14_width;
  pixmap_data[i].height =xnav_bitmap_attr14_height;
  pixmap_data[i++].bits = xnav_bitmap_attr14_bits;
  pixmap_data[i].width =xnav_bitmap_attr16_width;
  pixmap_data[i].height =xnav_bitmap_attr16_height;
  pixmap_data[i++].bits = xnav_bitmap_attr16_bits;
  pixmap_data[i].width =xnav_bitmap_attr18_width;
  pixmap_data[i].height =xnav_bitmap_attr18_height;
  pixmap_data[i++].bits = xnav_bitmap_attr18_bits;
  pixmap_data[i].width =xnav_bitmap_attr20_width;
  pixmap_data[i].height =xnav_bitmap_attr20_height;
  pixmap_data[i++].bits = xnav_bitmap_attr20_bits;
  pixmap_data[i].width =xnav_bitmap_attr20_width;
  pixmap_data[i].height =xnav_bitmap_attr20_height;
  pixmap_data[i++].bits = xnav_bitmap_attr20_bits;
  pixmap_data[i].width =xnav_bitmap_attr24_width;
  pixmap_data[i].height =xnav_bitmap_attr24_height;
  pixmap_data[i++].bits = xnav_bitmap_attr24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_attr);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_current8_width;
  pixmap_data[i].height =xnav_bitmap_current8_height;
  pixmap_data[i++].bits = xnav_bitmap_current8_bits;
  pixmap_data[i].width =xnav_bitmap_current10_width;
  pixmap_data[i].height =xnav_bitmap_current10_height;
  pixmap_data[i++].bits = xnav_bitmap_current10_bits;
  pixmap_data[i].width =xnav_bitmap_current12_width;
  pixmap_data[i].height =xnav_bitmap_current12_height;
  pixmap_data[i++].bits = xnav_bitmap_current12_bits;
  pixmap_data[i].width =xnav_bitmap_current14_width;
  pixmap_data[i].height =xnav_bitmap_current14_height;
  pixmap_data[i++].bits = xnav_bitmap_current14_bits;
  pixmap_data[i].width =xnav_bitmap_current16_width;
  pixmap_data[i].height =xnav_bitmap_current16_height;
  pixmap_data[i++].bits = xnav_bitmap_current16_bits;
  pixmap_data[i].width =xnav_bitmap_current18_width;
  pixmap_data[i].height =xnav_bitmap_current18_height;
  pixmap_data[i++].bits = xnav_bitmap_current18_bits;
  pixmap_data[i].width =xnav_bitmap_current20_width;
  pixmap_data[i].height =xnav_bitmap_current20_height;
  pixmap_data[i++].bits = xnav_bitmap_current20_bits;
  pixmap_data[i].width =xnav_bitmap_current20_width;
  pixmap_data[i].height =xnav_bitmap_current20_height;
  pixmap_data[i++].bits = xnav_bitmap_current20_bits;
  pixmap_data[i].width =xnav_bitmap_current24_width;
  pixmap_data[i].height =xnav_bitmap_current24_height;
  pixmap_data[i++].bits = xnav_bitmap_current24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_current);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_warning8_width;
  pixmap_data[i].height =xnav_bitmap_warning8_height;
  pixmap_data[i++].bits = xnav_bitmap_warning8_bits;
  pixmap_data[i].width =xnav_bitmap_warning10_width;
  pixmap_data[i].height =xnav_bitmap_warning10_height;
  pixmap_data[i++].bits = xnav_bitmap_warning10_bits;
  pixmap_data[i].width =xnav_bitmap_warning12_width;
  pixmap_data[i].height =xnav_bitmap_warning12_height;
  pixmap_data[i++].bits = xnav_bitmap_warning12_bits;
  pixmap_data[i].width =xnav_bitmap_warning14_width;
  pixmap_data[i].height =xnav_bitmap_warning14_height;
  pixmap_data[i++].bits = xnav_bitmap_warning14_bits;
  pixmap_data[i].width =xnav_bitmap_warning16_width;
  pixmap_data[i].height =xnav_bitmap_warning16_height;
  pixmap_data[i++].bits = xnav_bitmap_warning16_bits;
  pixmap_data[i].width =xnav_bitmap_warning18_width;
  pixmap_data[i].height =xnav_bitmap_warning18_height;
  pixmap_data[i++].bits = xnav_bitmap_warning18_bits;
  pixmap_data[i].width =xnav_bitmap_warning20_width;
  pixmap_data[i].height =xnav_bitmap_warning20_height;
  pixmap_data[i++].bits = xnav_bitmap_warning20_bits;
  pixmap_data[i].width =xnav_bitmap_warning20_width;
  pixmap_data[i].height =xnav_bitmap_warning20_height;
  pixmap_data[i++].bits = xnav_bitmap_warning20_bits;
  pixmap_data[i].width =xnav_bitmap_warning24_width;
  pixmap_data[i].height =xnav_bitmap_warning24_height;
  pixmap_data[i++].bits = xnav_bitmap_warning24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_warning);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_morehelp8_width;
  pixmap_data[i].height =xnav_bitmap_morehelp8_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp8_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp10_width;
  pixmap_data[i].height =xnav_bitmap_morehelp10_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp10_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp12_width;
  pixmap_data[i].height =xnav_bitmap_morehelp12_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp12_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp14_width;
  pixmap_data[i].height =xnav_bitmap_morehelp14_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp14_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp16_width;
  pixmap_data[i].height =xnav_bitmap_morehelp16_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp16_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp18_width;
  pixmap_data[i].height =xnav_bitmap_morehelp18_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp18_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp20_width;
  pixmap_data[i].height =xnav_bitmap_morehelp20_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp20_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp20_width;
  pixmap_data[i].height =xnav_bitmap_morehelp20_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp20_bits;
  pixmap_data[i].width =xnav_bitmap_morehelp24_width;
  pixmap_data[i].height =xnav_bitmap_morehelp24_height;
  pixmap_data[i++].bits = xnav_bitmap_morehelp24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_currentbranch);

}

void WRevNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes( ctx, &brow_attr, mask); 
  brow_SetCtxUserData( ctx, wrevnav);
}

//
// Create nodeclasses
//
void WRevNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass( ctx, "NavigatorDefault", 
		flow_eNodeGroup_Common, &nc_object);
  brow_AddAnnotPixmap( nc_object, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_object, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_object, 2, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_object, 7, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_object, 11, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddFrame( nc_object, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create table nodeclass

  brow_CreateNodeClass( ctx, "NavigatorTable", 
		flow_eNodeGroup_Common, &nc_table);
  brow_AddAnnotPixmap( nc_table, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_table, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_table, 2, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_table, 8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 12, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 16, 0.6, 3,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 20, 0.6, 4,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 24, 0.6, 5,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 28, 0.6, 6,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 32, 0.6, 7,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 35, 0.6, 8,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_table, 38, 0.6, 9,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddFrame( nc_table, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);
}

void WRevNav::message( char sev, const char *text)
{
  (message_cb)( parent_ctx, sev, text);
}
//
//  Get current zoom factor
//
void WRevNav::get_zoom( double *zoom_factor)
{
  brow_GetZoom( brow->ctx, zoom_factor);
}

//
//  Zoom
//
void WRevNav::zoom( double zoom_factor)
{
  brow_Zoom( brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void WRevNav::unzoom()
{
  brow_UnZoom( brow->ctx);
}



//
// Create the navigator widget
//
WRevNav::WRevNav(
	void 		*wa_parent_ctx,
	ldh_tSession	wa_ldhses,
	const char     	*wa_name,
	wb_eUtility	wa_utility,
	pwr_tStatus 	*status) :
  parent_ctx(wa_parent_ctx), ldhses(wa_ldhses),
  message_cb(0), set_clock_cursor_cb(0), reset_cursor_cb(0), 
  utility(wa_utility), displayed(0), rev(0)
{
  strcpy( name, wa_name);
  *status = 1;
}

//
//  Delete a nav context
//
WRevNav::~WRevNav()
{
}

//
// Callbacks from brow
//
int WRevNav::brow_cb( FlowCtx *ctx, flow_tEvent event)
{
  WRevNav		*wrevnav;
  WItemRev	       	*item;

  if ( event->event == flow_eEvent_ObjectDeleted)
  {
    brow_GetUserData( event->object.object, (void **)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData( (BrowCtx *)ctx, (void **) &wrevnav);
  wrevnav->message( ' ', "");
  switch ( event->event) {
    case flow_eEvent_Key_Up: {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( wrevnav->brow->ctx, &node_list, &node_count);
      if ( !node_count) {
        sts = brow_GetLast( wrevnav->brow->ctx, &object);
        if ( EVEN(sts)) return 1;
      }
      else {
        sts = brow_GetPrevious( wrevnav->brow->ctx, node_list[0], &object);
        if ( EVEN(sts)) {
	  if ( node_count)
	    free( node_list);
	  return 1;
        }
      }
      brow_SelectClear( wrevnav->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( wrevnav->brow->ctx, object);
      if ( !brow_IsVisible( wrevnav->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( wrevnav->brow->ctx, object, 0.25);
      if ( node_count)
        free( node_list);
      break;
    }
    case flow_eEvent_Key_Down: {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( wrevnav->brow->ctx, &node_list, &node_count);
      if ( !node_count) {
        sts = brow_GetFirst( wrevnav->brow->ctx, &object);
        if ( EVEN(sts)) return 1;
      }
      else {
        sts = brow_GetNext( wrevnav->brow->ctx, node_list[0], &object);
        if ( EVEN(sts)) {
	  if ( node_count)
	    free( node_list);
	  return 1;
        }
      }
      brow_SelectClear( wrevnav->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( wrevnav->brow->ctx, object);
      if ( !brow_IsVisible( wrevnav->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( wrevnav->brow->ctx, object, 0.75);
      if ( node_count)
        free( node_list);
      break;
    }
    case flow_eEvent_SelectClear:
      brow_ResetSelectInverse( wrevnav->brow->ctx);
      break;
    case flow_eEvent_MB1Click: {
      // Select
      double ll_x, ll_y, ur_x, ur_y;
      int		sts;

      switch ( event->object.object_type) {
        case flow_eObjectType_Node:
          brow_MeasureNode( event->object.object, &ll_x, &ll_y,
			&ur_x, &ur_y);
	  if ( event->object.x < ll_x + 1.0) {
            // Simulate doubleclick
            flow_tEvent doubleclick_event;

            doubleclick_event = (flow_tEvent) calloc( 1, sizeof(*doubleclick_event));
            memcpy( doubleclick_event, event, sizeof(*doubleclick_event));
            doubleclick_event->event = flow_eEvent_MB1DoubleClick;
            sts = brow_cb( ctx, doubleclick_event);
            free( (char *) doubleclick_event);
            return sts;
          }

          if ( brow_FindSelectedObject( wrevnav->brow->ctx, event->object.object)) {
            brow_SelectClear( wrevnav->brow->ctx);
          }
          else {
            brow_SelectClear( wrevnav->brow->ctx);
            brow_SetInverse( event->object.object, 1);
            brow_SelectInsert( wrevnav->brow->ctx, event->object.object);
          }
          break;
        default:
          brow_SelectClear( wrevnav->brow->ctx);
      }
      break;
    }
    case flow_eEvent_Key_Left: {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( wrevnav->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        return 1;

      if ( brow_IsOpen( node_list[0]))
        // Close this node
        object = node_list[0];
      else {
        // Close parent
        sts = brow_GetParent( wrevnav->brow->ctx, node_list[0], &object);
        if ( EVEN(sts))
        {
          free( node_list);
          return 1;
        }
      }
      brow_GetUserData( object, (void **)&item);
      item->close( wrevnav->brow, 0, 0);
      brow_SelectClear( wrevnav->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( wrevnav->brow->ctx, object);
      if ( !brow_IsVisible( wrevnav->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( wrevnav->brow->ctx, object, 0.25);
      free( node_list);
      break;
    }
    case flow_eEvent_Key_Right: {
      brow_tNode	*node_list;
      int		node_count;
      int		sts;

      brow_GetSelectedNodes( wrevnav->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        return 1;

      brow_GetUserData( node_list[0], (void **)&item);
      (wrevnav->set_clock_cursor_cb)( wrevnav->parent_ctx);
      sts = item->open_children( wrevnav->brow, wrevnav->rev, 0, 0);
      (wrevnav->reset_cursor_cb)( wrevnav->parent_ctx);

      free( node_list);
      break;
    }
    case flow_eEvent_Key_ShiftRight: {
      brow_tNode	*node_list;
      int		node_count;
      int		sts;

      brow_GetSelectedNodes( wrevnav->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        return 1;

      brow_GetUserData( node_list[0], (void **)&item);
      (wrevnav->set_clock_cursor_cb)( wrevnav->parent_ctx);
      sts = item->open_attributes( wrevnav->brow, 0, 0);
      (wrevnav->reset_cursor_cb)( wrevnav->parent_ctx);

      free( node_list);
      break;
    }
    case flow_eEvent_MB1DoubleClick:
      switch ( event->object.object_type) {
        case flow_eObjectType_Node:
          brow_GetUserData( event->object.object, (void **)&item);
	  (wrevnav->set_clock_cursor_cb)( wrevnav->parent_ctx);
	  item->open_children( wrevnav->brow, wrevnav->rev, event->object.x, event->object.y);
	  (wrevnav->reset_cursor_cb)( wrevnav->parent_ctx);
          break;
        default:
          ;
      }
      break;
    case flow_eEvent_MB1ClickShift: {
      // Add elect
      switch ( event->object.object_type) {
      case flow_eObjectType_Node:
	if ( brow_FindSelectedObject( wrevnav->brow->ctx, event->object.object)) {
	  brow_SetInverse( event->object.object, 0);
	  brow_SelectRemove( wrevnav->brow->ctx, event->object.object);
	}
	else {
	  brow_SetInverse( event->object.object, 1);
	  brow_SelectInsert( wrevnav->brow->ctx, event->object.object);
	}
	break;
      default:
	;
      }
      break;
    }
    case flow_eEvent_MB1Press:
      // Select region
      brow_SetSelectInverse( wrevnav->brow->ctx);
      break;
    case flow_eEvent_MB1PressShift:
      // Add select region
      brow_SetSelectInverse( wrevnav->brow->ctx);
      break;
    case flow_eEvent_Key_PageDown: {
      brow_Page( wrevnav->brow->ctx, 0.8);
      break;
    }
    case flow_eEvent_Key_PageUp: {
      brow_Page( wrevnav->brow->ctx, -0.8);
      break;
    }
    case flow_eEvent_ScrollDown: {
      brow_Page( wrevnav->brow->ctx, 0.1);
      break;
    }
    case flow_eEvent_ScrollUp: {
      brow_Page( wrevnav->brow->ctx, -0.1);
      break;
    }
    case flow_eEvent_Map: {
      wrevnav->displayed = 1;
      break;
    }

    default:
      ;
  }
  return 1;
}

int	WRevNav::root_objects()
{
  brow_tObject 	*object_list;
  int		object_cnt;

  brow_SetNodraw( brow->ctx);

  brow_DeleteAll( brow->ctx);
  if ( rev)
    delete rev;

  rev = new wb_revision( this, (wb_session *)ldhses);
  rev->command_cb( rev_command_cb);

  for ( int i = 0; i < rev->size(); i++) {
    wb_rev_item *rev_item = rev->vect(i);
    WItemRevision *item = new WItemRevision( brow, rev_item->name, rev_item->description,
					     rev_item->date, rev_item->version,
					     rev_item->current, rev_item->current_branch, 
					     rev_item->in_manager, rev_item->vect.size(), 
					     0, flow_eDest_IntoLast);
    if ( rev_item->current_branch)
      item->open_children( brow, rev, 0, 0);
  }


  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);

  brow_GetObjectList( brow->ctx, &object_list, &object_cnt);
  for ( int i = 0; i < object_cnt; i++) {
    WItemRevision *item;

    brow_GetUserData( object_list[i], (void **)&item);
    if ( item->current) {
      brow_CenterObject( brow->ctx, object_list[i], 0.75);
      break;
    }
  }
  return REV__SUCCESS;
}

void WRevNav::enable_events()
{
  brow_EnableEvent( brow->ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_MB1Press, flow_eEventType_RegionSelect, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_MB1PressShift, flow_eEventType_RegionAddSelect, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_MB1ClickShift, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_ShiftRight, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, 
	brow_cb);
  brow_EnableEvent( brow->ctx, flow_eEvent_Map, flow_eEventType_CallBack, 
	brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int WRevNav::init_brow_cb( FlowCtx *fctx, void *client_data)
{
  WRevNav *wrevnav = (WRevNav *) client_data;
  BrowCtx *ctx = (BrowCtx *)fctx;

  wrevnav->brow = new WRevNavBrow( ctx, (void *)wrevnav);

  wrevnav->brow->brow_setup();
  wrevnav->brow->create_nodeclasses();
  wrevnav->enable_events();

  // Create the root item
  wrevnav->root_objects();

  return 1;
}

void WRevNav::redraw()
{
    brow_Redraw( brow->ctx, 0);
}

void WRevNav::refresh_node( WItemRev *item)
{
  if ( brow_IsOpen( item->node)) {
    item->close( brow, 0, 0);
    item->open_children( brow, rev, 0, 0);
  }
}

WItemRev *WRevNav::get_parent( WItemRev *item)
{
  brow_tObject parent_node;
  WItemRev *parent;
  int sts;

  sts = brow_GetParent( brow->ctx, item->node, &parent_node);
  if ( EVEN(sts))
    return 0;
  brow_GetUserData( parent_node, (void **)&parent);

  return parent;
}

int WRevNav::get_select( WItemRev ***items, int *item_cnt)
{
  brow_tNode	*node_list;
  int		node_count;
  WItemRev	*item, **itemlist;

  brow_GetSelectedNodes( brow->ctx, &node_list, &node_count);
  if ( node_count == 0) {
    *items = 0;
    return REV__NOSELECT;
  }
  itemlist = (WItemRev **) calloc( node_count, sizeof( WItemRev *));
  for ( int i = 0; i < node_count; i++) {
    brow_GetUserData( node_list[i], (void **)&item);
    itemlist[i] = item;
  }
  *item_cnt = node_count;
  *items = itemlist;
  return REV__SUCCESS;
}

int WRevNav::rev_command_cb( void *ctx, char *cmd)
{
  WRevNav *revnav = (WRevNav *)((wb_revision *)ctx)->parent_ctx();

  if ( revnav->command_cb)
    return (revnav->command_cb)( revnav, cmd);
  return 0;
}

int WItemRev::close( WRevNavBrow *brow, double x, double y)
{
  double	node_x, node_y;

  if ( brow_IsOpen( node)) {
    // Close
    brow_GetNodePosition( node, &node_x, &node_y);
    brow_SetNodraw( brow->ctx);
    brow_CloseNode( brow->ctx, node);
    if ( brow_IsOpen( node) & wnav_mOpen_Children) {
      if ( children)
	brow_SetAnnotPixmap( node, 0, brow->pixmap_map);
      else
	brow_SetAnnotPixmap( node, 0, brow->pixmap_leaf);
    }
    brow_ResetOpen( node, wnav_mOpen_All);
    brow_ResetNodraw( brow->ctx);
    brow_Redraw( brow->ctx, node_y);
  }
  return 1;
}

WItemRevision::WItemRevision( WRevNavBrow *brow, char *item_name,
			      char *item_description, pwr_tTime item_date, char *item_version, 
			      bool item_current, bool item_current_branch, bool item_in_manager, 
			      int item_children,
			      brow_tNode dest, flow_eDest dest_code) 
  : current(item_current), current_branch(item_current_branch), in_manager(item_in_manager)
{
  strcpy( name, item_name);  
  strcpy( description, item_description);
  time_AtoAscii( &item_date, time_eFormat_DateAndTime, time, sizeof(time));
  time[20] = 0;
  strcpy( version, item_version);
  children = item_children;

  brow_CreateNode( brow->ctx, name, brow->nc_table,
		dest, dest_code, (void *)this, 1, &node);
  if ( children)
    brow_SetAnnotPixmap( node, 0, brow->pixmap_map);
  else
    brow_SetAnnotPixmap( node, 0, brow->pixmap_leaf);
  brow_SetAnnotation( node, 0, name, strlen(name));
  brow_SetAnnotation( node, 1, time, strlen(time));
  brow_SetAnnotation( node, 3, description, strlen(description));
  if ( current)
    brow_SetAnnotPixmap( node, 1, brow->pixmap_current);
  if ( current_branch)
    brow_SetAnnotPixmap( node, 1, brow->pixmap_currentbranch);
  else if ( !in_manager)
    brow_SetAnnotPixmap( node, 1, brow->pixmap_warning);
}

int WItemRevision::open_children( WRevNavBrow *brow, wb_revision *rev, double x, double y)
{
  WItemRevision    *item;

  if ( brow_IsOpen( node)) {
    close( brow, 0, 0);
    return 1;
  }

  if ( !children)
    return 1;

  // Find in revision 
  wb_rev_item *rev_item;
  bool found = false;
  for ( int i = 0; i < rev->size(); i++) {
    rev_item = rev->vect(i);
    if ( strcmp( rev_item->name, name) == 0) {
      found = true;
      break;
    }
  }
  if ( !found)
    return 1;

  brow_SetNodraw( brow->ctx);

  for ( unsigned int i = 0; i < rev_item->vect.size(); i++) {
    item = new WItemRevision( brow, rev_item->vect[i].name, rev_item->vect[i].description, 
			      rev_item->vect[i].date, 
			      rev_item->vect[i].version, rev_item->vect[i].current, 
			      rev_item->vect[i].current_branch, 
			      rev_item->vect[i].in_manager, rev_item->vect[i].vect.size(),
			      node, flow_eDest_IntoLast);
  }
  brow_SetOpen( node, wnav_mOpen_Children);
  brow_SetAnnotPixmap( node, 0, brow->pixmap_openmap);

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  return 1;
}

int WItemRevision::open_attributes( WRevNavBrow *brow, double x, double y)
{
  WItemRevAttr    *item;
  char status[80];

  if ( brow_IsOpen( node)) {
    close( brow, 0, 0);
    return 1;
  }

  brow_SetNodraw( brow->ctx);

  item = new WItemRevAttr( brow, "Description", description,
			   node, flow_eDest_IntoLast);
  item = new WItemRevAttr( brow, "Time", time,
			   node, flow_eDest_IntoLast);
  if ( current)
    strcpy( status, "Current");
  else if ( !in_manager)
    strcpy( status, "Not found in repository");
  else
    strcpy( status, "");

  item = new WItemRevAttr( brow, "Status", status,
			   node, flow_eDest_IntoLast);
  item = new WItemRevAttr( brow, "Version", version,
			   node, flow_eDest_IntoLast);
  brow_SetOpen( node, wnav_mOpen_Attributes);

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  return 1;
}

WItemRevAttr::WItemRevAttr( WRevNavBrow *brow, const char *item_name,
			    char *item_value, brow_tNode dest, flow_eDest dest_code) 
{
  strcpy( name, item_name);
  strcpy( value, item_value);

  brow_CreateNode( brow->ctx, name, brow->nc_object,
		dest, dest_code, (void *)this, 1, &node);
  brow_SetAnnotPixmap( node, 0, brow->pixmap_attr);
  brow_SetAnnotation( node, 0, name, strlen(name));
  brow_SetAnnotation( node, 1, value, strlen(value));
}
















