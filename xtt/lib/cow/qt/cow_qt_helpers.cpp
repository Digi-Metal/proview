/**
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

#include "cow_qt_helpers.h"

#include "co_dcli.h"
#include "co_lng.h"

#include <QApplication>
#include <QLayout>
#include <QMenu>
#include <QShowEvent>
#include <QTimer>
#include <QToolButton>

void print_time(FILE* stream, int fulldate)
{
  time_t t;
  struct tm* tm;
  char Date[11], Time[11];
  time(&t);
  tm = localtime(&t);
  if (fulldate) {
    strftime(Date, 11, "%Y-%m-%d", tm);
    fprintf(stream, "%s ", Date);
  }
  strftime(Time, 11, "%H:%M:%S", tm);
  fprintf(stream, "%s", Time);
}

void dbg_print(const char* file, int line, const char* fmt, ...)
{
  if (DEBUG) {
    // 1. print timestamp
    print_time(stderr);
    // 2. print filename only, without path
    const char* file2 = strrchr(file, '/');
    file2 = file2 ? (file2 + 1) : file;
    fprintf(stderr, " %s:%d: ", file2, line);
    // 3. print the actual debug message
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
  }
}

void dbg_print(const char* file, int line, QString str)
{
  if (DEBUG) {
    // 1. print timestamp
    print_time(stderr);
    // 2. print filename only, without path
    const char* file2 = strrchr(file, '/');
    file2 = file2 ? (file2 + 1) : file;
    fprintf(stderr, " %s:%d: ", file2, line);
    // 3. print the actual debug message
    fprintf(stderr, "%s\n", qPrintable(str));
  }
}

QString fl(const char* text)
{
  return QString::fromLocal8Bit(text);
}

QString convert_utf8(const char* str)
{
  if (Lng::translatefile_coding() == lng_eCoding_UTF_8) {
    return QString::fromUtf8(str);
  } else {
    return QString::fromLatin1(str);
  }
}

QString translate_utf8(const char* str)
{
  return convert_utf8(Lng::translate(str));
}

void pop(QWidget* w)
{
  w->show();
  w->raise();
  w->activateWindow();
}

void showNow(QWidget* w)
{
  QApplication::sendEvent(w, new QShowEvent());
}

QIcon get_icon(const char* iconName)
{
  if (strcmp(iconName, "")) {
    // iconName is not equal to ""
    QIcon icon;

    // First check if this is a standard gnome icon, e.g. "zoom-in"
    QIcon::setThemeName("gnome");
    if (QIcon::hasThemeIcon(fl(iconName))) {
      icon = QIcon::fromTheme(fl(iconName));
      if (icon.isNull() || icon.pixmap(16).isNull()) {
        printf("Warning! Could not find theme icon: %s\n", iconName);
      }
      return icon;
    }

    if (strchr(iconName, '$')) {
      // iconName is a relative path to a local icon, e.g. "xtt_close"
      pwr_tFileName fname;
      dcli_translate_filename(fname, iconName);
      icon = QIcon(fl(fname));
      if (icon.isNull() || icon.pixmap(16).isNull()) {
        printf("Warning! Could not find proview icon: %s, path: %s\n", iconName,
            fname);
      }
    } else {
      // iconName is an absolute path to a local icon
      icon = QIcon(fl(iconName));
      if (icon.isNull() || icon.pixmap(16).isNull()) {
        printf("Warning! Could not find icon: %s\n", iconName);
      }
    }
    return icon;
  } else {
    return QIcon();
  }
}

QAction* addMenuItem(QObject* parent, QMenu* menu, const char* text,
    const char* callback, const char* shortcut, const char* iconName)
{
  QAction* action
      = new QAction(get_icon(iconName), translate_utf8(text), parent);
  if (strcmp(shortcut, "")) {
    action->setShortcut(fl(shortcut));
  }
  QObject::connect(action, SIGNAL(triggered()), parent, callback);

  menu->addAction(action);
  return action;
}

QAction* addMenuItemMapped(QObject* parent, QMenu* menu, const char* text,
    const char* callback, const char* signal, const char* shortcut,
    const char* iconName)
{
  QAction* action
      = new QAction(get_icon(iconName), translate_utf8(text), parent);
  if (strcmp(shortcut, "")) {
    action->setShortcut(fl(shortcut));
  }
  QObject::connect(action, signal, parent, callback);

  menu->addAction(action);
  return action;
}

QAction* addCheckableMenuItem(QObject* parent, QMenu* menu, const char* text,
    const char* callback, const char* shortcut, const char* iconName)
{
  QAction* action
      = new QAction(get_icon(iconName), translate_utf8(text), parent);
  if (strcmp(shortcut, "")) {
    action->setShortcut(fl(shortcut));
  }
  action->setCheckable(true);
  QObject::connect(action, SIGNAL(triggered(bool)), parent, callback);

  menu->addAction(action);
  return action;
}

QAction* addMenuRadioItem(QObject* parent, QMenu* menu, const char* text,
    const char* callback, QActionGroup* group, const char* shortcut)
{
  QAction* action = new QAction(translate_utf8(text), parent);
  if (strcmp(shortcut, "")) {
    action->setShortcut(fl(shortcut));
  }
  QObject::connect(action, SIGNAL(triggered()), parent, callback);
  action->setCheckable(true);
  action->setActionGroup(group);
  menu->addAction(action);
  return action;
}

QAction* addToolItem(QObject* parent, QToolBar* tools, const char* text,
    const char* callback, const char* iconName)
{
  QAction* action
      = new QAction(get_icon(iconName), translate_utf8(text), parent);
  QObject::connect(action, SIGNAL(triggered()), parent, callback);

  tools->addAction(action);
  return action;
}

QAction* addToolItemMapped(QObject* parent, QToolBar* tools, const char* text,
    const char* callback, const char* signal, const char* iconName)
{
  QAction* action
      = new QAction(get_icon(iconName), translate_utf8(text), parent);
  QObject::connect(action, signal, parent, callback);

  tools->addAction(action);
  return action;
}

QAction* addToolRadioItem(QObject* parent, QToolBar* tools, const char* text,
    const char* callback, QActionGroup* group)
{
  QAction* action = new QAction(translate_utf8(text), parent);
  QObject::connect(action, SIGNAL(triggered()), parent, callback);
  action->setCheckable(true);
  action->setActionGroup(group);
  tools->addAction(action);
  return action;
}

QAction* addCheckableToolItem(QObject* parent, QToolBar* tools,
    const char* text, const char* callback, const char* iconName)
{
  QAction* action
      = new QAction(get_icon(iconName), translate_utf8(text), parent);
  action->setCheckable(true);
  QObject::connect(action, SIGNAL(triggered(bool)), parent, callback);

  tools->addAction(action);
  return action;
}

QMenu* addToolMenu(QWidget* parent, QToolBar* tools, const char* text)
{
  QToolButton* button = new QToolButton(parent);
  button->setText(translate_utf8(text));
  button->setPopupMode(QToolButton::InstantPopup);
  QMenu* menu = new QMenu(button);
  button->setMenu(menu);
  tools->addWidget(button);
  return menu;
}

QWidget* layout_to_widget(QLayout* layout)
{
  QWidget* container = new QWidget();
  container->setLayout(layout);
  return container;
}

void set_pane_position(QSplitter* pane, int right)
{
  QList<int> sizes;
  int total;
  if (pane->orientation() == Qt::Horizontal) {
    total = pane->window()->size().width();
  } else {
    total = pane->window()->size().height();
  }

  if (right > 0) {
    sizes << right << total - right;
  } else {
    sizes << total - right << right;
  }
  pane->setSizes(sizes);
}

QFrame* separator(QFrame::Shape shape)
{
  QFrame* line = new QFrame();
  line->setFrameShape(shape);
  line->setFrameShadow(QFrame::Sunken);
  return line;
}

QLabel* new_image_label(QWidget* parent, const char* fname)
{
  QLabel* label = new QLabel(parent);
  label->setPixmap(QPixmap(fl(fname)));
  return label;
}

void fixed_put(QWidget* parent, QWidget* widget, int x, int y)
{
  widget->setParent(parent);
  widget->move(x, y);
}

void add_expanding(QStatusBar* statusbar, QWidget* widget)
{
  widget->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  statusbar->addWidget(widget);
}

void add_expanding(QSplitter* splitter, QWidget* widget)
{
  widget->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  splitter->addWidget(widget);
}

void add_expanding(QSplitter* splitter, QLayout* widget)
{
  add_expanding(splitter, layout_to_widget(widget));
}

void add_expanding(QLayout* layout, QWidget* widget)
{
  widget->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  layout->addWidget(widget);
}

void add_expanding(QLayout* layout, QLayout* widget)
{
  add_expanding(layout, layout_to_widget(widget));
}

QFrame* wrapInFrame(QFrame* widget)
{
  widget->setFrameStyle(QFrame::NoFrame);
  QFrame *frame = new QFrame();
  frame->setFrameStyle(QFrame::StyledPanel | QFrame::Sunken);
  QVBoxLayout *layout = new QVBoxLayout();
  layout->setContentsMargins(3, 3, 3, 3);
  layout->addWidget(widget);
  frame->setLayout(layout);
  return frame;
}

void initOneShotTimer(QTimer* timer, const char* slot, int time)
{
  QObject::disconnect(timer, 0, 0, 0);
  timer->setSingleShot(true);
  QObject::connect(timer, SIGNAL(timeout()), timer->parent(), slot);
  timer->start(time);
}
