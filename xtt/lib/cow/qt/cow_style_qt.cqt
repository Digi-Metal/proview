/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_dcli.h"

#include "cow_style_qt.h"

#include <QApplication>
#include <QDialogButtonBox>
#include <QFile>
#include <QTextStream>

PwrStyle::PwrStyle() : QGtkStyle() {
  loadPalette("$HOME/.pwr_style");
}

PwrStyle::~PwrStyle() {
  if (pal) {
    delete pal;
  }
}

int PwrStyle::pixelMetric(PixelMetric which, const QStyleOption* option,
    const QWidget* widget) const {
  switch (which) {
  case PM_LayoutLeftMargin:
  case PM_LayoutTopMargin:
  case PM_LayoutRightMargin:
  case PM_LayoutBottomMargin:
  case PM_LayoutHorizontalSpacing:
  case PM_LayoutVerticalSpacing:
  case PM_ToolBarItemMargin:
  case PM_ToolBarItemSpacing:
    return 0;
  default:
    return QGtkStyle::pixelMetric(which, option, widget);
  }
}

int PwrStyle::styleHint(StyleHint hint, const QStyleOption* option,
    const QWidget* widget, QStyleHintReturn* returnData) const {
  if (hint == SH_DialogButtonLayout) {
    return QDialogButtonBox::WinLayout;
  }

  return QGtkStyle::styleHint(hint, option, widget, returnData);
}

void PwrStyle::loadPalette(const char* path) {
  char fname[200];
  dcli_translate_filename(fname, path);
  QFile f(fname);
  if (!f.open(QFile::ReadOnly | QFile::Text)) {
    return;
  }
  pal = new QPalette();
  QTextStream in(&f);
  QStringList lines = in.readAll().split('\n', QString::SkipEmptyParts);
  for (int i = 0; i < lines.size(); i++) {
    QStringList line = lines[i].split(' ', QString::SkipEmptyParts);
    if (line.size() < 4) {
      fprintf(stderr, "Error parsing line %d in file %s\n", (i+1), fname);
      continue;
    }
    QPalette::ColorRole role = QPalette::ColorRole(atoi(qPrintable(line[0])));
    pal->setBrush(QPalette::ColorGroup(0), role, QColor(line[1]));
    pal->setBrush(QPalette::ColorGroup(1), role, QColor(line[2]));
    pal->setBrush(QPalette::ColorGroup(2), role, QColor(line[3]));
  }
  QApplication::setPalette(*pal);
}

void PwrStyle::drawPrimitive(PrimitiveElement element,
    const QStyleOption *option, QPainter *painter, const QWidget *widget) const {
  if (pal) {
    if (element == PE_PanelButtonCommand) {
      QWindowsStyle::drawPrimitive(element, option, painter, widget);
      return;
    }
    QCleanlooksStyle::drawPrimitive(element, option, painter, widget);
  } else {
    QGtkStyle::drawPrimitive(element, option, painter, widget);
  }
}

void PwrStyle::drawControl(ControlElement control, const QStyleOption *option,
    QPainter *painter, const QWidget *widget) const {
  if (pal) {
    QCleanlooksStyle::drawControl(control, option, painter, widget);
  } else {
    QGtkStyle::drawControl(control, option, painter, widget);
  }
}

void PwrStyle::drawComplexControl(ComplexControl control,
    const QStyleOptionComplex *option, QPainter *painter, const QWidget *widget)
    const {
  if (pal) {
    QCleanlooksStyle::drawComplexControl(control, option, painter, widget);
  } else {
    QGtkStyle::drawComplexControl(control, option, painter, widget);
  }
}

void PwrStyle::polish(QApplication *app) {
  if (pal) {
    QCleanlooksStyle::polish(app);
  } else {
    QGtkStyle::polish(app);
  }
}

void PwrStyle::unpolish(QApplication *app) {
  if (pal) {
    QCleanlooksStyle::unpolish(app);
  } else {
    QGtkStyle::unpolish(app);
  }
}