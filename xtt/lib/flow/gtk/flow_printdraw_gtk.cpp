/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include "flow_std.h"


#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <gtk/gtk.h>

#include "flow_ctx.h"
#include "flow_printdraw_gtk.h"

FlowPrintDrawGtk::FlowPrintDrawGtk( void *context, const char *t, int p, void *flow_ctx, int page_border,
				    int *sts) :
  print_ctx((GtkPrintContext *)context), border(page_border), ctx((FlowCtx *)flow_ctx), show_red(1), page(p)
{
  strncpy( title, t, sizeof(title));
  *sts = 1;
}

FlowPrintDrawGtk::~FlowPrintDrawGtk() 
{
}

int FlowPrintDrawGtk::print_page( double ll_x, double ll_y, double ur_x, double ur_y)
{
  PangoLayout *layout;
  gdouble width, text_height;
  gint layout_height, layout_width;
  PangoFontDescription *desc;
  char page_str[40];
          

  if ( ur_x - ll_x > ur_y - ll_y)
    ctx->print_zoom_factor = 730 / (ur_x - ll_x);
  else
    ctx->print_zoom_factor = 730 / (ur_y - ll_y);
  ctx->print_zoom();
  page_x = ll_x * ctx->print_zoom_factor;
  page_y = ll_y * ctx->print_zoom_factor;

  cairo = gtk_print_context_get_cairo_context (print_ctx);
  width = gtk_print_context_get_width (print_ctx);
          
  cairo_move_to( cairo, print_margin_x, print_margin_y);
  cairo_line_to( cairo, print_margin_x + width, print_margin_y);
  cairo_set_source_rgb( cairo, 0, 0, 0);
  cairo_set_line_width( cairo, 0.5);
  cairo_stroke( cairo);

  layout = gtk_print_context_create_pango_layout( print_ctx);
          
  desc = pango_font_description_from_string( "Lucida Sans 9");
  pango_layout_set_font_description( layout, desc);
  pango_font_description_free( desc);
  
  sprintf( page_str, "Page %d", page + 1);
  pango_layout_set_width( layout, -1);
  pango_layout_set_text( layout, page_str, -1);
  pango_layout_set_alignment( layout, PANGO_ALIGN_LEFT);
  
  pango_layout_get_size( layout, NULL, &layout_height);
  text_height = (gdouble)layout_height / PANGO_SCALE;
          
  cairo_move_to( cairo, print_margin_x + width - 90, print_margin_y - text_height);
  cairo_set_source_rgb( cairo, 0, 0, 0);
  pango_cairo_show_layout( cairo, layout);
          
  g_object_unref( layout);

  layout = gtk_print_context_create_pango_layout (print_ctx);
          
  desc = pango_font_description_from_string( "Lucida Sans 9");
  pango_layout_set_font_description( layout, desc);
  pango_font_description_free( desc);
  
  pango_layout_set_width( layout, -1);
  pango_layout_set_alignment( layout, PANGO_ALIGN_CENTER);
  pango_layout_set_text( layout, title, -1);
  
  pango_layout_get_size( layout, &layout_width, &layout_height);
  text_height = (gdouble)layout_height / PANGO_SCALE;
          
  cairo_move_to (cairo, print_margin_x + width/2 - (gdouble)layout_width/PANGO_SCALE/2, 
		 print_margin_y - text_height);
  cairo_set_source_rgb( cairo, 0, 0, 0);
  pango_cairo_show_layout( cairo, layout);
          
  g_object_unref( layout);

  cairo_rectangle( cairo, print_margin_x, print_margin_y, (ur_x - ll_x) * ctx->print_zoom_factor, 
		   (ur_y - ll_y) * ctx->print_zoom_factor);
          
  //cairo_stroke(cairo);
  cairo_clip( cairo);

  ((FlowCtx *)ctx)->current_print = this;
  ((FlowCtx *)ctx)->print( ll_x, ll_y, ur_x, ur_y);

  cairo_reset_clip( cairo);
  return 1;
}

int FlowPrintDrawGtk::rect( double x, double y, double width, double height, flow_eDrawType type, 
	double idx, int highlight)
{
  switch( type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb( cairo, 1, 0, 0);
    break;
  default:
    cairo_set_source_rgb( cairo, 0, 0, 0);
  }  
  cairo_set_line_width( cairo, 0.5 * idx);
  cairo_rectangle( cairo, x - page_x, y - page_y, width, height);
  cairo_stroke( cairo);

  return 1;
}

int FlowPrintDrawGtk::filled_rect( double x, double y, double width, double height, flow_eDrawType type, 
	double idx)
{
  switch( type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb( cairo, 1, 0, 0);
    break;
  case flow_eDrawType_Green:
    cairo_set_source_rgb( cairo, 0, 1, 0);
    break;
  case flow_eDrawType_Yellow:
    cairo_set_source_rgb( cairo, 1, 1, 0);
    break;
  case flow_eDrawType_DarkGray:
    cairo_set_source_rgb( cairo, 0.3, 0.3, 0.3);
    break;
  default:
    cairo_set_source_rgb( cairo, 0, 0, 0);
  }  
  cairo_rectangle( cairo, print_margin_x + x - page_x, print_margin_y + y - page_y, width, height);
  cairo_fill( cairo);

  cairo_set_source_rgb( cairo, 0, 0, 0);
  cairo_set_line_width( cairo, 0.5 * idx);
  cairo_rectangle( cairo, print_margin_x + x - page_x, print_margin_y + y - page_y, width, height);
  cairo_stroke( cairo);

  return 1;
}

int FlowPrintDrawGtk::arc( double x, double y, double width, double height, int angle1, int angle2,
		flow_eDrawType type, double idx, int highlight)
{
  return 1;
}

int FlowPrintDrawGtk::line( double x1, double y1, double x2, double y2, flow_eDrawType type, 
	double idx, int highlight)
{
  return 1;
}

int FlowPrintDrawGtk::text( double x, double y, char *text, int len, flow_eDrawType type, 
	double size)
{
  char font[40];
  PangoLayout *layout;
  PangoFontDescription *desc;
  int w, h;

  switch( type) {
  case flow_eDrawType_TextHelvetica:
    sprintf( font, "Lucida Sans %3.1f", 1.0 * size);
    break;
  case flow_eDrawType_TextHelveticaBold:
    sprintf( font, "Lucida Sans Bold %3.1f", 1.0 * size);
    break;
  default:
    ;
  }  

  layout = gtk_print_context_create_pango_layout( print_ctx);
          
  desc = pango_font_description_from_string( font);
  pango_layout_set_font_description( layout, desc);
  pango_font_description_free( desc);
  
  char *textutf8 = g_convert( text, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
  pango_layout_set_text( layout, textutf8, -1);
  pango_layout_set_alignment( layout, PANGO_ALIGN_LEFT);
  pango_layout_get_size( layout, &w, &h);
  cairo_move_to( cairo, print_margin_x + x - page_x,  print_margin_y + y - page_y - 0.8 / PANGO_SCALE * h);
  cairo_set_source_rgb( cairo, 0, 0, 0);
  pango_cairo_show_layout( cairo, layout);
  g_free( textutf8);

  return 1;
}

int FlowPrintDrawGtk::pixmap( double x, double y, flow_sPixmapDataElem *data,
	flow_eDrawType type)
{
  int stride;
  cairo_surface_t *surface;
  unsigned char *sdata;
  unsigned char *data_p, *sdata_p;
  int bit_cnt;
  int i, j;
  float scale = 0.7;

  // Do do, set color
  switch( type) {
  case flow_eDrawType_LineRed:
    break;
  default: ;
  }  

  stride = cairo_format_stride_for_width( CAIRO_FORMAT_A1, data->width);
  sdata = (unsigned char *) calloc( 1, stride * data->height);
  data_p = (unsigned char *)data->bits;
  for ( i = 0; i < data->height; i++) {
    bit_cnt = 0;
    sdata_p = sdata + i * stride;
    for ( j = 0; j < data->width; j++) {
      if ( bit_cnt == 8) {
        bit_cnt = 0;
        data_p++;
	sdata_p++;
      }
      if ( *data_p & ( 1 << bit_cnt))
	*sdata_p |= 1 << bit_cnt;
      bit_cnt++;
    }
    data_p++;
  }

  surface = cairo_image_surface_create_for_data( sdata, CAIRO_FORMAT_A1, data->width,
						 data->height, stride);
  cairo_scale( cairo, scale, scale);
  //cairo_mask_surface( cairo, surface, (x - page_x)/scale, (y - page_y)/scale);
  cairo_set_source_surface( cairo, surface, (print_margin_x + x - page_x)/scale, (print_margin_y + y - page_y)/scale);
  cairo_paint( cairo);
  cairo_scale( cairo, 1.0 / scale, 1.0 / scale);

  cairo_surface_destroy( surface);
  // free( sdata);
  return 1;
}

int FlowPrintDrawGtk::arrow( double x1, double y1, double x2, double y2, 
	double x3, double y3, flow_eDrawType type, double idx)
{
  return 1;
}


