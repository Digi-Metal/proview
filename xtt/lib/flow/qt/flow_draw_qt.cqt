/*
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

#include <assert.h>
#include <stdlib.h>

#include "co_dcli.h"

#include "cow_qt_helpers.h"

#include "flow_browctx.h"
#include "flow_browwidget_qt.h"
#include "flow_draw_qt.h"
#include "flow_msg.h"
#include "flow_printdraw_qt.h"
#include "flow_scroll_widget_qt.h"
#include "flow_widget_qt.h"

#include <QApplication>
#include <QBitmap>
#include <QKeyEvent>

#define DRAW_PRESS_PIX 9

#define roundi(x) ((x) >= 0 ? (int)((x) + 0.5) : (int)((x)-0.5))

typedef struct {
  QWidget* w;
  int x;
  int y;
  int width;
  int height;
  FlowArrayElem* node;
  int number;
  FlowCtx* ctx;
} draw_sAnnotData;

typedef struct {
  QPixmap pixmap[DRAW_PIXMAP_SIZE];
} draw_sPixmap;

static char font_names[draw_eFont__][DRAW_FONT_SIZE][80]
    = { { "-*-Helvetica-Bold-R-Normal--8-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--10-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--12-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--14-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--14-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--18-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--18-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--18-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Bold-R-Normal--24-*-*-*-P-*-ISO8859-1" },
        { "-*-Helvetica-Medium-R-Normal--8-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--10-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--12-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--14-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--14-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--18-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--18-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--18-*-*-*-P-*-ISO8859-1",
            "-*-Helvetica-Medium-R-Normal--24-*-*-*-P-*-ISO8859-1" } };

static QMouseEvent *last_event;

static QColor flow_allocate_color(
    FlowDrawQt* draw_ctx, const char* named_color);

static QColor draw_type_to_color(FlowDrawQt* draw_ctx, int painter_type)
{
  switch (painter_type) {
  case flow_eDrawType_Line:
  case flow_eDrawType_LineDashed:
  case flow_eDrawType_TextHelvetica:
  case flow_eDrawType_TextHelveticaBold:
    return draw_ctx->foreground;
  case flow_eDrawType_LineErase:
  case flow_eDrawType_TextHelveticaErase:
  case flow_eDrawType_TextHelveticaEraseBold:
    return draw_ctx->background;
  case flow_eDrawType_LineRed:
  case flow_eDrawType_LineDashedRed:
    return flow_allocate_color(draw_ctx, "red");
  case flow_eDrawType_LineGray:
    return flow_allocate_color(draw_ctx, "gray");
  case flow_eDrawType_Green:
    return flow_allocate_color(draw_ctx, "green");
  case flow_eDrawType_Yellow:
    return flow_allocate_color(draw_ctx, "yellow");
  case flow_eDrawType_DarkGray:
    return flow_allocate_color(draw_ctx, "gray28");
  default:
    return flow_allocate_color(draw_ctx, "black");
  }
}

static QPainter* get_painter(
    QPaintDevice* window, FlowDrawQt* draw_ctx, int painter_type, int size)
{
  QPainter* painter = new QPainter(window);
  switch (painter_type) {
  case flow_eDrawType_LineDashed:
  case flow_eDrawType_LineDashedRed: {
    painter->setBrush(QBrush(draw_type_to_color(draw_ctx, painter_type)));
    painter->setBackground(QBrush(draw_ctx->background));
    QPen pen = QPen(painter->brush(), size + 1, Qt::DashLine);
    QVector<double> dashes;
    dashes << 7 + size << 7 + size;
    pen.setDashPattern(dashes);
    painter->setPen(pen);
    return painter;
  }
  case flow_eDrawType_TextHelvetica:
  case flow_eDrawType_TextHelveticaBold:
  case flow_eDrawType_TextHelveticaErase:
  case flow_eDrawType_TextHelveticaEraseBold: {
    painter->setBrush(QBrush(draw_type_to_color(draw_ctx, painter_type)));
    painter->setPen(QPen(painter->brush(), size + 1));
    painter->setBackground(QBrush(draw_ctx->background));
    QFont font = QFont("Helvetica");
    if (painter_type == flow_eDrawType_TextHelveticaBold
        || painter_type == flow_eDrawType_TextHelveticaEraseBold) {
      font.setBold(true);
    }
    font.setPixelSize(size);
    painter->setFont(font);
    return painter;
  }
  case flow_eDrawType_Green:
  case flow_eDrawType_Yellow:
  case flow_eDrawType_DarkGray:
  case flow_eDrawType_Line:
  case flow_eDrawType_LineErase:
  case flow_eDrawType_LineRed:
  case flow_eDrawType_LineGray:
  default:
    painter->setBrush(QBrush(draw_type_to_color(draw_ctx, painter_type)));
    painter->setBackground(QBrush(draw_ctx->background));
    painter->setPen(QPen(painter->brush(), size + 1));
    return painter;
  }
}

static QColor flow_allocate_color(FlowDrawQt* draw_ctx, const char* named_color)
{
  QColor color;

  color = QColor(named_color);
  if (!color.isValid()) {
    color = Qt::black;
  }

  return color;
}

FlowDrawQt::~FlowDrawQt()
{
  debug_print("FlowDrawQt::~FlowDrawQt\n");
  closing_down = 1;

  basectx->set_nodraw();
  delete basectx;

  if (timer_id) {
    delete timer_id;
  }
}

int FlowDrawQt::create_secondary_ctx(FlowCtx* flow_ctx,
    void** secondary_flow_ctx,
    int (*init_proc)(FlowCtx* ctx, void* client_data), void* client_data,
    flow_eCtxType type)
{
  FlowCtx* ctx;
  if (type == flow_eCtxType_Brow) {
    ctx = (FlowCtx*)new BrowCtx("Claes context", 20);
  } else {
    ctx = new FlowCtx("Claes context", 20);
  }

  ctx->fdraw = this;
  ctx->set_nodraw();
  ctx->trace_connect_func = flow_ctx->trace_connect_func;
  ctx->trace_disconnect_func = flow_ctx->trace_disconnect_func;
  ctx->trace_scan_func = flow_ctx->trace_scan_func;
  ctx->trace_started = flow_ctx->trace_started;
  ctx->zoom_factor = flow_ctx->zoom_factor;
  if (type == flow_eCtxType_Brow) {
    ((BrowCtx*)ctx)->scroll_callback = ((BrowCtx*)flow_ctx)->scroll_callback;
    ((BrowCtx*)ctx)->scroll_data = ((BrowCtx*)flow_ctx)->scroll_data;
  }

  init_proc(ctx, client_data);
  *secondary_flow_ctx = (void*)ctx;
  return 1;
}

int FlowDrawQt::change_ctx(FlowCtx* from_ctx, FlowCtx* to_ctx)
{
  if (from_ctx->type() == flow_eCtxType_Brow) {
    browwidgetqt_modify_ctx(toplevel, to_ctx);
  } else {
    flowwidgetqt_modify_ctx(toplevel, to_ctx);
  }

  to_ctx->window_width = from_ctx->window_width;
  to_ctx->window_height = from_ctx->window_height;
  from_ctx->set_nodraw();
  to_ctx->reset_nodraw();
  if (from_ctx->type() == flow_eCtxType_Brow) {
    to_ctx->zoom_factor = from_ctx->zoom_factor;
    ((BrowCtx*)to_ctx)->configure(0);
  } else {
    to_ctx->redraw();
  }
  return 1;
}

void FlowDrawQt::delete_secondary_ctx(FlowCtx* ctx)
{
  ctx->set_nodraw();
  delete ctx;
}

FlowDrawQt::FlowDrawQt(QWidget* x_toplevel, void** flow_ctx,
    int (*init_proc)(QWidget* w, FlowCtx* ctx, void* client_data),
    void* client_data, flow_eCtxType type)
    : toplevel(x_toplevel), nav_toplevel(0), window(0), nav_window(0),
      timer_id(0), closing_down(0)
{
  if (type == flow_eCtxType_Brow) {
    basectx = (FlowCtx*)new BrowCtx("Claes context", 20);
  } else {
    basectx = new FlowCtx("Claes context", 20);
  }
  *flow_ctx = (void*)basectx;

  basectx->fdraw = this;

  assert(dynamic_cast<QtScrollWidgetFlow*>(toplevel) != NULL);
  window = dynamic_cast<QtScrollWidgetFlow*>(toplevel);
  window_canvas = &(((QtScrollWidgetFlow*)window)->image);

  foreground = flow_allocate_color(this, "black");

  set_white_background(basectx);

  init_proc(toplevel, basectx, client_data);
}

int FlowDrawQt::init_nav(QWidget* nav_widget, void* flow_ctx)
{
  // debug_print("init_nav\n");
  nav_toplevel = nav_widget;
  nav_window = nav_toplevel->window();
  nav_window_canvas = &(((QtScrollWidgetFlow*)nav_window)->image);

  QPalette pal;
  pal.setColor(QPalette::Background, background);
  nav_widget->setAutoFillBackground(true);
  nav_widget->setPalette(pal);

  ((FlowCtx*)flow_ctx)->no_nav = 0;

  return 1;
}

int FlowDrawQt::event_handler(QEvent* event)
{
  static int button_pressed = 0;
  static int button_clicked = 0;
  static int button_clicked_and_pressed = 0;
  static int button1_pressed = 0;
  static int button2_pressed = 0;
  static int button3_pressed = 0;
  static int last_press_x = 0;
  static int last_press_y = 0;
  int sts = 1;

  if (closing_down) {
    return 1;
  }

  QObject* windowParent = window;
  QObject* navWindowParent = nav_window;
  bool windowEvent = false;
  bool navWindowEvent = false;
  if (QApplication::focusWidget() != NULL) {
    while (!(windowParent == NULL && navWindowParent == NULL)) {
      windowEvent = (QApplication::focusWidget() == windowParent);
      navWindowEvent = (QApplication::focusWidget() == navWindowParent);
      if (windowEvent || navWindowEvent) {
        break;
      }
      windowParent = (windowParent == NULL) ? NULL : windowParent->parent();
      navWindowParent
          = (navWindowParent == NULL) ? NULL : navWindowParent->parent();
    }
  }

  if (windowEvent || event->type() == QEvent::KeyPress) {
    switch (event->type()) {
    case QEvent::KeyPress: {
      QKeyEvent* keyEvent = ((QKeyEvent*)event);
      debug_print("event_handler: KeyPress key=%s\n",
          QKeySequence(keyEvent->key()).toString().toAscii().data());

      switch (keyEvent->key()) {
      case Qt::Key_Return:
        sts = basectx->event_handler(flow_eEvent_Key_Return, 0, 0, 0, 0);
        break;
      case Qt::Key_Up:
        if (keyEvent->modifiers() & Qt::ShiftModifier) {
          sts = basectx->event_handler(flow_eEvent_Key_ShiftUp, 0, 0, 0, 0);
        } else {
          sts = basectx->event_handler(flow_eEvent_Key_Up, 0, 0, 0, 0);
        }
        break;
      case Qt::Key_Down:
        if (keyEvent->modifiers() & Qt::ShiftModifier) {
          sts = basectx->event_handler(flow_eEvent_Key_ShiftDown, 0, 0, 0, 0);
        } else {
          sts = basectx->event_handler(flow_eEvent_Key_Down, 0, 0, 0, 0);
        }
        break;
      case Qt::Key_Right:
        if (keyEvent->modifiers() & Qt::ShiftModifier) {
          sts = basectx->event_handler(flow_eEvent_Key_ShiftRight, 0, 0, 0, 0);
        } else {
          sts = basectx->event_handler(flow_eEvent_Key_Right, 0, 0, 0, 0);
        }
        break;
      case Qt::Key_Left:
        if (keyEvent->modifiers() & Qt::ShiftModifier) {
          sts = basectx->event_handler(flow_eEvent_Key_ShiftLeft, 0, 0, 0, 0);
        } else {
          sts = basectx->event_handler(flow_eEvent_Key_Left, 0, 0, 0, 0);
        }
        break;
      case Qt::Key_PageUp:
        sts = basectx->event_handler(flow_eEvent_Key_PageUp, 0, 0, 0, 0);
        break;
      case Qt::Key_PageDown:
        sts = basectx->event_handler(flow_eEvent_Key_PageDown, 0, 0, 0, 0);
        break;
      case Qt::Key_Backspace:
        sts = basectx->event_handler(flow_eEvent_Key_BackSpace, 0, 0, 0, 0);
        break;
      case Qt::Key_F1:
        sts = basectx->event_handler(flow_eEvent_Key_PF1, 0, 0, 0, 0);
        break;
      case Qt::Key_F2:
        sts = basectx->event_handler(flow_eEvent_Key_PF2, 0, 0, 0, 0);
        break;
      case Qt::Key_F3:
        sts = basectx->event_handler(flow_eEvent_Key_PF3, 0, 0, 0, 0);
        break;
      case Qt::Key_F4:
        sts = basectx->event_handler(flow_eEvent_Key_PF4, 0, 0, 0, 0);
        break;
      case Qt::Key_Tab:
        sts = basectx->event_handler(flow_eEvent_Key_Tab, 0, 0, 0, 0);
        break;
      default:;
      }
      break;
    }
    case QEvent::MouseButtonPress: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      debug_print("event_handler: MouseButtonPress button=%d, x=%d, y=%d, "
                  "globalX=%d, globalY=%d\n",
          mouseEvent->button(), mouseEvent->x(), mouseEvent->y(),
          mouseEvent->globalX(), mouseEvent->globalY());
      switch (mouseEvent->button()) {
      case Qt::LeftButton:
        basectx->event_handler(
            flow_eEvent_MB1Down, mouseEvent->x(), mouseEvent->y(), 0, 0);
        if (click_sensitivity & flow_mSensitivity_MB1Click
            && !(click_sensitivity & flow_mSensitivity_MB1DoubleClick)
            && !(click_sensitivity & flow_mSensitivity_MB1Press)) {
          button_pressed = 0;
          button_clicked = 1;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
          return 1;
        } else if (!(click_sensitivity & flow_mSensitivity_MB1Click)
            && !(click_sensitivity & flow_mSensitivity_MB1DoubleClick)
            && click_sensitivity & flow_mSensitivity_MB1Press) {
          button_pressed = 1;
          button_clicked = 0;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
        }
        break;
      case Qt::MidButton:
        basectx->event_handler(
            flow_eEvent_MB2Down, mouseEvent->x(), mouseEvent->y(), 0, 0);
        if (click_sensitivity & flow_mSensitivity_MB2Click
            && !(click_sensitivity & flow_mSensitivity_MB2DoubleClick)
            && !(click_sensitivity & flow_mSensitivity_MB2Press)) {
          button_pressed = 0;
          button_clicked = 1;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
          return 1;
        } else if (!(click_sensitivity & flow_mSensitivity_MB2Click)
            && !(click_sensitivity & flow_mSensitivity_MB2DoubleClick)
            && click_sensitivity & flow_mSensitivity_MB2Press) {
          button_pressed = 1;
          button_clicked = 0;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
        }
        break;
      case Qt::RightButton:
        basectx->event_handler(
            flow_eEvent_MB3Down, mouseEvent->x(), mouseEvent->y(), 0, 0);
        if (click_sensitivity & flow_mSensitivity_MB3Press
            && !(click_sensitivity & flow_mSensitivity_MB3DoubleClick)
            && !(click_sensitivity & flow_mSensitivity_MB3Click)) {
          basectx->event_handler(
              flow_eEvent_MB3Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          click_sensitivity = 0;
          return 1;
        }
        break;
      default:;
      }
      /* Detect press or click event */
      if (button_clicked) {
        /* Wait for release */
        button_clicked_and_pressed = 1;
        cancel_event_timer();
        button_clicked = 0;
        button_pressed = mouseEvent->button();
        last_press_x = mouseEvent->x();
        last_press_y = mouseEvent->y();
        event_timer(mouseEvent);
        return 1;
      }
      if (!button_pressed) {
        button_pressed = mouseEvent->button();
        last_press_x = mouseEvent->x();
        last_press_y = mouseEvent->y();
        event_timer(mouseEvent);
        return 1;
      } else {
        debug_print("event_handler: MouseButtonPress from timer\n");
        /* Press event, callback from timer */
        button_pressed = 0;
        button_clicked_and_pressed = 0;
        switch (mouseEvent->button()) {
        case Qt::LeftButton: // Button1
          button1_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(flow_eEvent_MB1PressShift,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(flow_eEvent_MB1PressCtrl,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(flow_eEvent_MB1PressShiftCtrl,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else {
            basectx->event_handler(
                flow_eEvent_MB1Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          }
          click_sensitivity = 0;
          break;
        case Qt::MidButton: // Button2
          button2_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(flow_eEvent_MB2PressShift,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(flow_eEvent_MB2PressShift,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(flow_eEvent_MB2PressShiftCtrl,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else {
            sts = basectx->event_handler(
                flow_eEvent_MB2Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          }
          click_sensitivity = 0;
          break;
        case Qt::RightButton: // Button3
          button3_pressed = 1;
          sts = basectx->event_handler(
              flow_eEvent_MB3Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          click_sensitivity = 0;
          break;
        default:
          break;
        }
      }
      break;
    }
    case QEvent::MouseButtonRelease: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      debug_print("event_handler: MouseButtonRelease button=%d\n",
          mouseEvent->button());
      button1_pressed = 0;
      button2_pressed = 0;
      button3_pressed = 0;

      if (!button_pressed) {
        if (button_clicked) {
          /* Button click, callback from timer */
          button_clicked = 0;
          switch (mouseEvent->button()) {
          case Qt::LeftButton: // Button1
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB1ClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB1ClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB1ClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = basectx->event_handler(
                  flow_eEvent_MB1Click, mouseEvent->x(), mouseEvent->y(), 0, 0);
            }
            click_sensitivity = 0;
            break;
          case Qt::MidButton: // Button2
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB2ClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB2ClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB2ClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = basectx->event_handler(
                  flow_eEvent_MB2Click, mouseEvent->x(), mouseEvent->y(), 0, 0);
            }
            click_sensitivity = 0;
            break;
          case Qt::RightButton: // Button3
            sts = basectx->event_handler(
                flow_eEvent_MB3Click, mouseEvent->x(), mouseEvent->y(), 0, 0);
            click_sensitivity = 0;
            break;
          default:
            break;
          }
        } else {
          /* Button release */
          sts = basectx->event_handler(flow_eEvent_ButtonRelease,
              mouseEvent->x(), mouseEvent->y(), 0, 0);
        }
      } else {
        /* Button click */
        cancel_event_timer();
        if (!button_clicked_and_pressed) {
          /* wait for button double click */
          button_clicked = 1;
          event_timer(mouseEvent);
          button_pressed = 0;
          return 1;
        } else {
          /* Button double click */
          cancel_event_timer();
          button_clicked = 0;
          button_pressed = 0;
          button_clicked_and_pressed = 0;
          switch (mouseEvent->button()) {
          case Qt::LeftButton: // Button1
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB1DoubleClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB1DoubleClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB1DoubleClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = basectx->event_handler(flow_eEvent_MB1DoubleClick,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            }
            if (sts == FLOW__TERMINATED) {
              return sts;
            }
            click_sensitivity = 0;

            break;
          case Qt::MidButton: // Button2
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB2DoubleClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB2DoubleClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = basectx->event_handler(flow_eEvent_MB2DoubleClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = basectx->event_handler(flow_eEvent_MB2DoubleClick,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            }
            click_sensitivity = 0;
            break;
          case Qt::RightButton: // Button3
            click_sensitivity = 0;
            break;
          default:
            break;
          }
        }
      }
      break;
    }
    case QEvent::Paint:
    case QEvent::UpdateRequest: {
      QPaintEvent* paintEvent = ((QPaintEvent*)event);
      sts = basectx->event_handler(flow_eEvent_Exposure, paintEvent->rect().x(),
          paintEvent->rect().y(), paintEvent->rect().width(),
          paintEvent->rect().height());
      break;
    }
    case QEvent::WindowUnblocked: {
      sts = basectx->event_handler(
          flow_eEvent_VisibilityUnobscured, 0, 0, 0, 0);
      break;
    }
    case QEvent::WindowBlocked: {
      sts = basectx->event_handler(flow_eEvent_VisibilityObscured, 0, 0, 0, 0);
      break;
    }
    case QEvent::MouseMove: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      QPoint pos = mouseEvent->pos();

      if (button3_pressed) {
        button3_pressed = 0;
        button_pressed = 0;
        button_clicked_and_pressed = 0;
      }

      if (button_pressed
          && (ABS(pos.x() - last_press_x) > DRAW_PRESS_PIX
                 || ABS(pos.y() - last_press_y) > DRAW_PRESS_PIX)) {
        pos.setX(last_press_x);
        pos.setY(last_press_y);

        /* Button press */
        cancel_event_timer();
        switch (button_pressed) {
        case Qt::LeftButton: // Button1
          button1_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(
                flow_eEvent_MB1PressShift, pos.x(), pos.y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(
                flow_eEvent_MB1PressCtrl, pos.x(), pos.y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(
                flow_eEvent_MB1PressShiftCtrl, pos.x(), pos.y(), 0, 0);
          } else {
            basectx->event_handler(
                flow_eEvent_MB1Press, pos.x(), pos.y(), 0, 0);
          }
          break;
        case Qt::MidButton: // Button2
          button2_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(
                flow_eEvent_MB2PressShift, pos.x(), pos.y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(
                flow_eEvent_MB2PressShift, pos.x(), pos.y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = basectx->event_handler(
                flow_eEvent_MB2PressShiftCtrl, pos.x(), pos.y(), 0, 0);
          } else {
            sts = basectx->event_handler(
                flow_eEvent_MB2Press, pos.x(), pos.y(), 0, 0);
          }
          break;
        case Qt::RightButton: // Button3
          button3_pressed = 1;
          sts = basectx->event_handler(
              flow_eEvent_MB3Press, pos.x(), pos.y(), 0, 0);
          break;
        }
        button_pressed = 0;
        button_clicked_and_pressed = 0;
      }
      if (button1_pressed || button2_pressed || button3_pressed) {
        sts = basectx->event_handler(
            flow_eEvent_ButtonMotion, pos.x(), pos.y(), 0, 0);
      } else {
        sts = basectx->event_handler(
            flow_eEvent_CursorMotion, pos.x(), pos.y(), 0, 0);
      }
      break;
    }
    case QEvent::Enter: {
      QPoint pos = QCursor::pos();
      sts = basectx->event_handler(flow_eEvent_Enter, pos.x(), pos.y(), 0, 0);
      break;
    }
    case QEvent::Leave: {
      QPoint pos = QCursor::pos();
      sts = basectx->event_handler(flow_eEvent_Leave, pos.x(), pos.y(), 0, 0);
      break;
    }
    case QEvent::Show: {
      sts = basectx->event_handler(flow_eEvent_Map, 0, 0, 0, 0);
      break;
    }
    case QEvent::Hide: {
      sts = basectx->event_handler(flow_eEvent_Unmap, 0, 0, 0, 0);
      break;
    }
    case QEvent::FocusIn:
    case QEvent::FocusOut:
      break;
    case QEvent::Wheel: {
      debug_print("event_handler: Wheel\n");
      QWheelEvent* wheelEvent = ((QWheelEvent*)event);
      if (wheelEvent->delta() > 0) {
        sts = basectx->event_handler(flow_eEvent_ScrollUp, 0, 0, 0, 0);
      } else if (wheelEvent->delta() < 0) {
        sts = basectx->event_handler(flow_eEvent_ScrollDown, 0, 0, 0, 0);
      }
      break;
    }
    default:
      break;
    }
  } else if (navWindowEvent) {
    switch (event->type()) {
    case QEvent::MouseButtonPress: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      debug_print(
          "event_handler: MouseButtonPress button=%d\n", mouseEvent->button());
      switch (mouseEvent->button()) {
      case Qt::LeftButton: // Button1
        button1_pressed = 1;
        sts = basectx->event_handler_nav(
            flow_eEvent_MB1Press, mouseEvent->x(), mouseEvent->y());
        break;
      case Qt::MidButton: // Button2
        button2_pressed = 1;
        sts = basectx->event_handler_nav(
            flow_eEvent_MB2Press, mouseEvent->x(), mouseEvent->y());
        break;
      case Qt::RightButton: // Button3
        button3_pressed = 1;
        break;
      default:
        break;
      }
      break;
    }
    case QEvent::MouseButtonRelease: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      debug_print("event_handler: MouseButtonRelease button=%d\n",
          mouseEvent->button());
      switch (mouseEvent->button()) {
      case Qt::LeftButton: // Button1
        button1_pressed = 0;
        break;
      case Qt::MidButton: // Button2
        button2_pressed = 0;
        break;
      case Qt::RightButton: // Button3
        button3_pressed = 0;
        break;
      default:
        break;
      }
      if (mouseEvent->button() == Qt::LeftButton
          && (mouseEvent->modifiers() & Qt::ShiftModifier)
          && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
        sts = basectx->event_handler_nav(
            flow_eEvent_MB1ClickShift, mouseEvent->x(), mouseEvent->y());
      } else {
        sts = basectx->event_handler_nav(
            flow_eEvent_ButtonRelease, mouseEvent->x(), mouseEvent->y());
      }
      break;
    }
    case QEvent::Show: {
      sts = basectx->event_handler_nav(flow_eEvent_Map, 0, 0);
      break;
    }
    case QEvent::MouseMove: {
      debug_print("event_handler: MouseMove\n");
      QPoint pos = QCursor::pos();
      if (button1_pressed || button2_pressed || button3_pressed) {
        sts = basectx->event_handler_nav(
            flow_eEvent_ButtonMotion, pos.x(), pos.y());
      } else {
        sts = basectx->event_handler_nav(
            flow_eEvent_CursorMotion, pos.x(), pos.y());
      }
      break;
    }
    default:;
    }
  }

  if (sts == FLOW__DESTROYED) {
    return 1;
  }

  toplevel->update();
  return 1;
}

void FlowDrawQt::enable_event(FlowCtx* ctx, flow_eEvent event,
    flow_eEventType event_type,
    int (*event_cb)(FlowCtx* ctx, flow_tEvent event))
{
  ctx->enable_event(event, event_type, event_cb);
}

QPainter* FlowDrawQt::get_painter(int painter_type, int size, bool nav)
{
  if (nav) {
    return ::get_painter(nav_window_canvas, this, painter_type, size);
  } else {
    return ::get_painter(window_canvas, this, painter_type, size);
  }
}

int FlowDrawQt::rect_helper(FlowCtx* ctx, int painter_type, int size, int x,
    int y, int width, int height, bool nav, bool fill)
{
  if (ctx->nodraw) {
    return 1;
  }

  if (nav && ctx->no_nav) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, size, nav);

  if (fill) {
    // debug_print("fillRect [%d, %d, %d, %d]\n", x, y, width, height);
    painter->fillRect(x, y, width, height, painter->brush());
  } else {
    // debug_print("drawRect [%d, %d, %d, %d]\n", x, y, width, height);
    painter->setBrush(Qt::NoBrush);
    painter->drawRect(x, y, width, height);
  }

  delete painter;

  return 1;
}

int FlowDrawQt::rect(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType painter_type, int idx, int highlight, int dimmed)
{
  if (dimmed) {
    painter_type = flow_eDrawType_LineGray;
  } else if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  } else if (highlight) {
    painter_type = flow_eDrawType(painter_type + 1);
  }

  return rect_helper(ctx, painter_type, idx, x, y, width, height);
}

int FlowDrawQt::rect_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  return rect_helper(ctx, flow_eDrawType_LineErase, idx, x, y, width, height);
}

int FlowDrawQt::nav_rect(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return rect_helper(
      ctx, painter_type + highlight, idx, x, y, width, height, true);
}

int FlowDrawQt::nav_rect_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  return rect_helper(
      ctx, flow_eDrawType_LineErase, idx, x, y, width, height, true);
}

int FlowDrawQt::triangle_helper(FlowCtx* ctx, int painter_type, int size, int x,
    int y, int width, int height, bool nav, bool fill)
{
  if (ctx->nodraw) {
    return 1;
  }

  if (nav && ctx->no_nav) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, size, nav);

  QPolygon poly(4);
  poly[0] = QPoint(x, y + height);
  poly[1] = QPoint(x + width / 2, y);
  poly[2] = QPoint(x + width, y + height);
  poly[3] = QPoint(x, y + height);

  if (fill) {
    // debug_print("fillTriangle (%d, %d) (%d, %d) (%d, %d)\n", x, y + height, x
    // + width / 2, y, x + width, y + height);
    QPainterPath path;
    path.addPolygon(poly);
    painter->fillPath(path, painter->brush());
  } else {
    // debug_print("drawTriangle (%d, %d) (%d, %d) (%d, %d)\n", x, y + height, x
    // + width / 2, y, x + width, y + height);
    painter->setBrush(Qt::NoBrush);
    painter->drawPolygon(poly);
  }

  delete painter;

  return 1;
}

int FlowDrawQt::triangle(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType painter_type, int idx, int highlight, int dimmed)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return triangle_helper(
      ctx, painter_type + highlight, idx, x, y, width, height);
}

int FlowDrawQt::triangle_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  return triangle_helper(
      ctx, flow_eDrawType_LineErase, idx, x, y, width, height);
}

int FlowDrawQt::nav_triangle(FlowCtx* ctx, int x, int y, int width, int height,
    flow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return triangle_helper(
      ctx, painter_type + highlight, idx, x, y, width, height, true);
}

int FlowDrawQt::nav_fill_triangle(FlowCtx* ctx, int x, int y, int width,
    int height, flow_eDrawType painter_type)
{
  if (painter_type != flow_eDrawType_LineRed) {
    return 1;
  }

  return triangle_helper(ctx, painter_type, 0, x, y, width, height, true, true);
}

int FlowDrawQt::nav_triangle_erase(
    FlowCtx* ctx, int x, int y, int width, int height, int idx)
{
  return triangle_helper(
      ctx, flow_eDrawType_LineErase, idx, x, y, width, height, true);
}

int FlowDrawQt::arrow_helper(FlowCtx* ctx, int painter_type, int size, int x1,
    int y1, int x2, int y2, int x3, int y3, bool nav)
{
  if (ctx->nodraw) {
    return 1;
  }

  if (nav && ctx->no_nav) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, size, nav);

  QPolygon poly(4);
  poly[0] = QPoint(x1, y1);
  poly[1] = QPoint(x2, y2);
  poly[2] = QPoint(x3, y3);
  poly[3] = QPoint(x1, y1);

  QPainterPath path;
  path.addPolygon(poly);
  // debug_print("arrow (%d, %d) (%d, %d) (%d, %d)\n", x1, y1, x2, y2, x3, y3);
  painter->fillPath(path, painter->brush());

  delete painter;

  return 1;
}

int FlowDrawQt::arrow(FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3,
    int y3, flow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return arrow_helper(
      ctx, painter_type + highlight, idx, x1, y1, x2, y2, x3, y3);
}

int FlowDrawQt::arrow_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3, int y3, int idx)
{
  return arrow_helper(
      ctx, flow_eDrawType_LineErase, idx, x1, y1, x2, y2, x3, y3);
}

int FlowDrawQt::nav_arrow(FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3,
    int y3, flow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return arrow_helper(
      ctx, painter_type + highlight, idx, x1, y1, x2, y2, x3, y3, true);
}

int FlowDrawQt::nav_arrow_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int x3, int y3, int idx)
{
  return arrow_helper(
      ctx, flow_eDrawType_LineErase, idx, x1, y1, x2, y2, x3, y3, true);
}

int FlowDrawQt::arc_helper(FlowCtx* ctx, int painter_type, int size, int x,
    int y, int width, int height, int angle1, int angle2, bool nav)
{
  if (ctx->nodraw) {
    return 1;
  }

  if (nav && ctx->no_nav) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, size, nav);
  painter->setBrush(Qt::NoBrush);
  // debug_print("arrow [%d, %d, %d, %d], %d, %d\n", x, y, width, height, angle1
  // * 64, angle2 * 64);
  painter->drawArc(x, y, width, height, angle1 * 64, angle2 * 64);
  delete painter;

  return 1;
}

int FlowDrawQt::arc(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, flow_eDrawType painter_type, int idx, int highlight,
    int dimmed)
{
  if (dimmed) {
    painter_type = flow_eDrawType_LineGray;
  } else if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  } else if (highlight) {
    painter_type = flow_eDrawType(painter_type + 1);
  }

  return arc_helper(
      ctx, painter_type, idx, x, y, width, height, angle1, angle2);
}

int FlowDrawQt::arc_erase(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, int idx)
{
  return arc_helper(
      ctx, flow_eDrawType_LineErase, idx, x, y, width, height, angle1, angle2);
}

int FlowDrawQt::nav_arc(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, flow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return arc_helper(ctx, painter_type + highlight, idx, x, y, width, height,
      angle1, angle2, true);
}

int FlowDrawQt::nav_arc_erase(FlowCtx* ctx, int x, int y, int width, int height,
    int angle1, int angle2, int idx)
{
  return arc_helper(ctx, flow_eDrawType_LineErase, idx, x, y, width, height,
      angle1, angle2, true);
}

int FlowDrawQt::line_helper(FlowCtx* ctx, int painter_type, int size, int x1,
    int y1, int x2, int y2, bool nav)
{
  if (ctx->nodraw) {
    return 1;
  }

  if (nav && ctx->no_nav) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, size, nav);
  // debug_print("line (%d, %d) (%d, %d)\n", x1, y1, x2, y2);
  painter->drawLine(x1, y1, x2, y2);
  delete painter;

  return 1;
}

int FlowDrawQt::line(FlowCtx* ctx, int x1, int y1, int x2, int y2,
    flow_eDrawType painter_type, int idx, int highlight, int dimmed)
{
  if (dimmed) {
    painter_type = flow_eDrawType_LineGray;
  } else if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  } else if (highlight) {
    painter_type = flow_eDrawType(painter_type + 1);
  }

  return line_helper(ctx, painter_type, idx, x1, y1, x2, y2);
}

int FlowDrawQt::line_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int idx)
{
  return line_helper(ctx, flow_eDrawType_LineErase, idx, x1, y1, x2, y2);
}

int FlowDrawQt::nav_line(FlowCtx* ctx, int x1, int y1, int x2, int y2,
    flow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == flow_eDrawType_LineGray && highlight) {
    painter_type = flow_eDrawType_Line;
  }

  return line_helper(ctx, painter_type + highlight, idx, x1, y1, x2, y2, true);
}

int FlowDrawQt::nav_line_erase(
    FlowCtx* ctx, int x1, int y1, int x2, int y2, int idx)
{
  return line_helper(ctx, flow_eDrawType_LineErase, idx, x1, y1, x2, y2, true);
}

#define FONTSTR "Lucida Sans"
#define FONT_SCALE 0.7

static QFont font(flow_eDrawType painter_type, double size)
{
  QFont res(FONTSTR);
  res.setPointSizeF(FONT_SCALE * size);
  if (painter_type == flow_eDrawType_TextHelveticaBold || painter_type == flow_eDrawType_TextHelveticaEraseBold) {
    res.setWeight(QFont::Bold);
  }
  return res;
}

int FlowDrawQt::text_pango_helper(FlowCtx* ctx, int x, int y, char* text,
    int len, flow_eDrawType painter_type, int idx, double size, int dimmed,
    int erase_rect)
{
  if (ctx->nodraw) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, idx);
  if (dimmed) {
    painter->setBrush(QBrush(flow_allocate_color(this, "gray")));
    painter->setPen(QPen(painter->brush(), size + 1));
  }

  QString str;
  if (ctx->text_coding != flow_eTextCoding_UTF_8) {
    str = QString::fromLatin1(text);
  } else {
    str = QString::fromUtf8(text);
  }

  painter->setFont(font(painter_type, size));

  QRect rect = painter->fontMetrics().boundingRect(str);
  int height = rect.height();

  if (erase_rect > 0) {
    // debug_print("eraseRect [%d, %d, %d, %d], color=%s\n", x, roundi(y - 0.8 *
    // height), rect.width(), roundi(height * (erase_rect / 10.0)),
    // painter->background().color().name().toAscii().data());
    painter->eraseRect(x, roundi(y - 0.8 * height), rect.width(),
        roundi(height * (erase_rect / 10.0)));
  }

  if (erase_rect < 12) {
    // debug_print("drawText %s at (%d, %d), painter_type=%d, brush=%s, pen=%s,
    // background=%s\n", text, x, roundi(y - 0.8 * height), painter_type,
    // painter->brush().color().name().toAscii().data(),
    // painter->pen().color().name().toAscii().data(),
    // background.name().toAscii().data());
    painter->drawText(x, roundi(y - 0.8 * height), rect.width(), height,
        Qt::TextDontClip, str);
  }

  delete painter;

  return 1;
}

int FlowDrawQt::text_pango(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType painter_type, int idx, int highlight, int dimmed, int line,
    double size)
{
  return text_pango_helper(
      ctx, x, y, text, len, painter_type, idx, size, dimmed, 10);
}

int FlowDrawQt::text_inverse_pango(FlowCtx* ctx, int x, int y, char* text,
    int len, flow_eDrawType painter_type, int idx, int line, double size)
{
  if (painter_type == flow_eDrawType_TextHelvetica) {
    painter_type = flow_eDrawType_TextHelveticaErase;
  } else if (painter_type == flow_eDrawType_TextHelveticaBold) {
    painter_type = flow_eDrawType_TextHelveticaEraseBold;
  }
  return text_pango_helper(
      ctx, x, y, text, len, painter_type, idx, size, false);
}

int FlowDrawQt::text_erase_pango(FlowCtx* ctx, int x, int y, char* text,
    int len, flow_eDrawType painter_type, int idx, int line, double size)
{
  if (painter_type == flow_eDrawType_TextHelvetica) {
    painter_type = flow_eDrawType_TextHelveticaErase;
  } else if (painter_type == flow_eDrawType_TextHelveticaBold) {
    painter_type = flow_eDrawType_TextHelveticaEraseBold;
  }
  return text_pango_helper(
      ctx, x, y, text, len, painter_type, idx, size, false, 12);
}

int FlowDrawQt::text(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType painter_type, int idx, int highlight, int dimmed, int line,
    double size)
{
  return text_pango(
      ctx, x, y, text, len, painter_type, idx, highlight, dimmed, line, size);
}

int FlowDrawQt::text_inverse(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType painter_type, int idx, int line, double size)
{
  return text_inverse_pango(
      ctx, x, y, text, len, painter_type, idx, line, size);
}

int FlowDrawQt::text_erase(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType painter_type, int idx, int line, double size)
{
  return text_erase_pango(ctx, x, y, text, len, painter_type, idx, line, size);
}

int FlowDrawQt::nav_text_helper(FlowCtx* ctx, flow_eDrawType painter_type,
    int size, int x, int y, char* text, int len)
{
  if (ctx->no_nav || ctx->nodraw) {
    return 1;
  }

  int font_idx = get_font_idx(painter_type);

  QPainter* painter = get_painter(painter_type, size, true);
  painter->setFont(QFont(font_names[font_idx][size]));
  // debug_print("drawText %s at (%d, %d)\n", text, x, y);
  painter->drawText(x, y, QString::fromLocal8Bit(text, len));

  delete painter;

  return 1;
}

int FlowDrawQt::nav_text(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType painter_type, int idx, int highlight, int line, double size)
{
  return nav_text_helper(ctx, painter_type, idx, x, y, text, len);
}

int FlowDrawQt::nav_text_erase(FlowCtx* ctx, int x, int y, char* text, int len,
    flow_eDrawType painter_type, int idx, int line, double size)
{
  if (painter_type == flow_eDrawType_TextHelvetica) {
    painter_type = flow_eDrawType_TextHelveticaErase;
  } else if (painter_type == flow_eDrawType_TextHelveticaBold) {
    painter_type = flow_eDrawType_TextHelveticaEraseBold;
  }

  return nav_text_helper(ctx, painter_type, idx, x, y, text, len);
}

int FlowDrawQt::pixmaps_create(
    FlowCtx* ctx, flow_sPixmapData* pixmap_data, void** pixmaps)
{
  draw_sPixmap* pms;
  flow_sPixmapDataElem *prev_pdata = NULL,
      *pdata = (flow_sPixmapDataElem *)pixmap_data;
  int i;

  pms = new draw_sPixmap();
  for (i = 0; i < DRAW_PIXMAP_SIZE; i++) {
    if (i == 0 || (i > 0 && pdata->bits != prev_pdata->bits)) {
      pms->pixmap[i] = QBitmap::fromData(QSize(pdata->width, pdata->height),
          (uchar*)pdata->bits, QImage::Format_MonoLSB);
    } else {
      pms->pixmap[i] = pms->pixmap[i - 1];
    }
    prev_pdata = pdata;
    pdata++;
  }
  *pixmaps = (void*)pms;
  return 1;
}

void FlowDrawQt::pixmaps_delete(FlowCtx* ctx, void* pixmaps)
{
  delete ((draw_sPixmap*)pixmaps);
}

int FlowDrawQt::pixmap(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType painter_type,
    int idx, int highlight, int line)
{
  draw_sPixmap* pms;
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  if (ctx->nodraw) {
    return 1;
  }

  pms = (draw_sPixmap*)pixmaps;

  QPainter* painter = get_painter(painter_type, idx);

  painter->fillRect(x, y, pdata->width, pdata->height, painter->brush());
  delete painter;

  painter = get_painter(flow_eDrawType_LineErase, idx);

  QRegion clipRegion = QRegion(pms->pixmap[idx].createMaskFromColor(Qt::black));
  painter->setClipRegion(clipRegion.translated(x, y));
  painter->setClipping(true);

  painter->fillRect(x, y, pdata->width, pdata->height, painter->brush());

  delete painter;

  return 1;
}

int FlowDrawQt::pixmap_inverse(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType painter_type,
    int idx, int line)
{
  draw_sPixmap* pms;
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  if (ctx->nodraw) {
    return 1;
  }

  pms = (draw_sPixmap*)pixmaps;

  QPainter* painter = get_painter(flow_eDrawType_LineErase, idx);
  // debug_print("pixmap_inverse fillRect [%d, %d, %d, %d] with color %s\n", x,
  // y, pdata->width, pdata->height,
  // painter->brush().color().name().toAscii().data());
  painter->fillRect(x, y, pdata->width, pdata->height, painter->brush());
  delete painter;

  painter = get_painter(painter_type, idx);

  QRegion clipRegion = QRegion(pms->pixmap[idx].createMaskFromColor(Qt::black));
  painter->setClipRegion(clipRegion.translated(x, y));
  painter->setClipping(true);

  // debug_print("pixmap_inverse fillRect [%d, %d, %d, %d] with color %s using
  // mask\n", x, y, pdata->width, pdata->height,
  // painter->brush().color().name().toAscii().data());
  painter->fillRect(x, y, pdata->width, pdata->height, painter->brush());

  delete painter;

  return 1;
}

int FlowDrawQt::pixmap_erase(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType painter_type,
    int idx, int line)
{
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;
  if (ctx->nodraw) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, idx);
  // debug_print("pixmap_erase [%d, %d, %d, %d]\n", x, y, pdata->width,
  // pdata->height);
  painter->eraseRect(x, y, pdata->width, pdata->height);
  delete painter;

  return 1;
}

int FlowDrawQt::nav_pixmap(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType painter_type,
    int idx, int highlight, int line)
{
  draw_sPixmap* pms;
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;

  if (ctx->no_nav || ctx->nodraw) {
    return 1;
  }

  pms = (draw_sPixmap*)pixmaps;

  QPainter* painter = get_painter(painter_type, idx);
  // debug_print("nav_pixmap [%d, %d, %d, %d]\n", x, y, pdata->width,
  // pdata->height);
  painter->drawPixmap(x, y, pdata->width, pdata->height, pms->pixmap[idx]);
  delete painter;

  return 1;
}

int FlowDrawQt::nav_pixmap_erase(FlowCtx* ctx, int x, int y,
    flow_sPixmapData* pixmap_data, void* pixmaps, flow_eDrawType painter_type,
    int idx, int line)
{
  flow_sPixmapDataElem* pdata = (flow_sPixmapDataElem*)pixmap_data + idx;
  if (ctx->no_nav || ctx->nodraw) {
    return 1;
  }

  QPainter* painter = get_painter(painter_type, idx);
  // debug_print("nav_pixmap_erase [%d, %d, %d, %d]\n", x, y, pdata->width,
  // pdata->height);
  painter->eraseRect(x, y, pdata->width, pdata->height);
  delete painter;

  return 1;
}

int FlowDrawQt::fill_rect(
    FlowCtx* ctx, int x, int y, int w, int h, flow_eDrawType painter_type)
{
  return rect_helper(ctx, painter_type, 0, x, y, w, h, false, true);
}

int FlowDrawQt::fill_triangle(
    FlowCtx* ctx, int x, int y, int w, int h, flow_eDrawType painter_type)
{
  return triangle_helper(ctx, painter_type, 0, x, y, w, h, false, true);
}

int FlowDrawQt::image(FlowCtx* ctx, int x, int y, int width, int height,
    flow_tImImage image, flow_tPixmap pixmap, flow_tPixmap clip_mask)
{
  if (ctx->nodraw) {
    return 1;
  }

  if (width == 0 || height == 0) {
    return 1;
  }

  QPainter* painter = get_painter(flow_eDrawType_Line, 0);

  if (clip_mask) {
    set_image_clip_mask(painter, clip_mask, x, y);
  }

  // debug_print("image [%d, %d, %d, %d]\n", x, y, width, height);
  painter->drawImage(QRect(x, y, width, height), *((QImage*)image));

  delete painter;

  return 1;
}

void FlowDrawQt::clear(FlowCtx* ctx)
{
  if (ctx->nodraw) {
    return;
  }

  QPainter* painter = new QPainter(window_canvas);
  painter->setBackground(QBrush(background));

  // debug_print("clear color=%s\n",
  // painter->background().color().name().toAscii().data());
  painter->eraseRect(window_canvas->rect());

  delete painter;
}

void FlowDrawQt::nav_clear(FlowCtx* ctx)
{
  if (ctx->no_nav || ctx->nodraw) {
    return;
  }

  QPainter* painter = new QPainter(nav_window_canvas);
  painter->setBackground(QBrush(background));

  // debug_print("nav_clear color=%s\n",
  // painter->background().color().name().toAscii().data());
  painter->eraseRect(nav_window_canvas->rect());

  delete painter;
}

void FlowDrawQt::get_window_size(FlowCtx* ctx, int* width, int* height)
{
  *width = window->width();
  *height = window->height();
}

void FlowDrawQt::get_nav_window_size(FlowCtx* ctx, int* width, int* height)
{
  debug_print(
      "get_nav_window_size, nav_window == NULL ? %d\n", (nav_window == NULL));
  *width = nav_window->width();
  *height = nav_window->height();
}

void FlowDrawQt::set_nav_window_size(FlowCtx* ctx, int width, int height)
{
  nav_window->resize(width, height);
}

bool FlowDrawQt::draw_timer_cb()
{
  FlowDrawQt* draw_ctx = (FlowDrawQt*)timer_cb->ctx->fdraw;

  (timer_cb->callback_func)(timer_cb->ctx);

  draw_ctx->toplevel->update();
  delete timer_cb;
  return FALSE;
}

bool FlowDrawQt::event_timer_cb()
{
  delete timer_id;
  timer_id = 0;
  event_handler(last_event);
  return FALSE;
}

void FlowDrawQt::cancel_event_timer()
{
  if (timer_id) {
    delete timer_id;
    timer_id = 0;
  }
}

void FlowDrawQt::event_timer(QMouseEvent *event)
{
  if (last_event) {
    delete last_event;
  }
  last_event = new QMouseEvent(event->type(), event->pos(), event->globalPos(), event->button(), event->buttons(), event->modifiers());

  timer_id = new QTimer();
  timer_id->setSingleShot(true);
  connect(timer_id, SIGNAL(timeout()), this, SLOT(event_timer_cb()));
  timer_id->start(200);
}

void FlowDrawQt::set_timer(
    FlowCtx* ctx, int time_ms, void (*callback_func)(FlowCtx* ctx), void** id)
{
  timer_cb = new flow_draw_sTimerCb();
  timer_cb->ctx = ctx;
  timer_cb->callback_func = callback_func;

  timer_cb->timer_id = new QTimer();
  timer_cb->timer_id->setSingleShot(true);
  connect(timer_cb->timer_id, SIGNAL(timeout()), this, SLOT(draw_timer_cb()));
  timer_cb->timer_id->start(time_ms);

  *id = (void*)timer_cb;
}

void FlowDrawQt::cancel_timer(FlowCtx* ctx, void* id)
{
  delete (((flow_draw_sTimerCb*)id)->timer_id);

  delete ((char*)id);
}

void FlowDrawQt::cursor_helper(FlowCtx* ctx, draw_eCursor cursor, bool nav)
{
  QWidget* target;
  if (nav) {
    if (ctx->no_nav) {
      return;
    }

    target = nav_window;
  } else {
    target = window;
  }

  if (cursor == draw_eCursor_Normal) {
    window->unsetCursor();
  } else {
    switch (cursor) {
    case draw_eCursor_CrossHair:
      window->setCursor(QCursor(Qt::CrossCursor));
      break;
    case draw_eCursor_DiamondCross:
      window->setCursor(QCursor(Qt::SizeAllCursor));
      break;
    case draw_eCursor_Hand:
      window->setCursor(QCursor(Qt::PointingHandCursor));
      break;
    default:
      break;
    }
  }
}

void FlowDrawQt::set_cursor(FlowCtx* ctx, draw_eCursor cursor)
{
  cursor_helper(ctx, cursor);
}

void FlowDrawQt::set_nav_cursor(FlowCtx* ctx, draw_eCursor cursor)
{
  cursor_helper(ctx, cursor, true);
}

int FlowDrawQt::get_text_extent(FlowCtx* ctx, const char* text, int len,
    flow_eDrawType painter_type, int idx, int* width, int* height, double size)
{
  return get_text_extent_pango(
      ctx, text, len, painter_type, idx, size, width, height);
}

int FlowDrawQt::get_text_extent_pango(FlowCtx* ctx, const char* text, int len,
    flow_eDrawType painter_type, int idx, double size, int* width, int* height)
{
  QPainter* painter = get_painter(painter_type, idx);

  QString str;
  if (ctx->text_coding != flow_eTextCoding_UTF_8) {
    str = QString::fromLatin1(text);
  } else {
    str = QString::fromUtf8(text);
  }

  painter->setFont(font(painter_type, size));

  QRect boundingRect = painter->fontMetrics().boundingRect(str);

  *width = boundingRect.width();
  *height = boundingRect.height();

  delete painter;

  return 1;
}

void FlowDrawQt::copy_area(FlowCtx* ctx, int x, int y)
{
  if (ctx->nodraw) {
    return;
  }

  debug_print("copy_area: x=%d, y=%d\n", x, y);

  QPixmap screenShot = QPixmap::grabWidget(window);
  QPainter* painter = get_painter(flow_eDrawType_Line, 3);
  if (x >= 0 && y >= 0) {
    painter->drawPixmap(
        x, y, screenShot, 0, 0, ctx->window_width - x, ctx->window_height - y);
    if (x) {
      painter->eraseRect(0, 0, x, ctx->window_height);
    }
    if (y) {
      painter->eraseRect(x, 0, ctx->window_width, y);
    }
  } else if (x <= 0 && y <= 0) {
    painter->drawPixmap(0, 0, screenShot, -x, -y, ctx->window_width + x,
        ctx->window_height + y);
    if (x) {
      painter->eraseRect(
          ctx->window_width + x, 0, ctx->window_width, ctx->window_height);
    }
    if (y) {
      painter->eraseRect(
          0, ctx->window_height + y, ctx->window_width + x, ctx->window_height);
    }
  } else if (x <= 0 && y >= 0) {
    painter->drawPixmap(
        0, y, screenShot, -x, 0, ctx->window_width + x, ctx->window_height - y);
    if (x) {
      painter->eraseRect(
          ctx->window_width + x, 0, ctx->window_width, ctx->window_height);
    }
    if (y) {
      painter->eraseRect(0, 0, ctx->window_width + x, y);
    }
  } else {
    painter->drawPixmap(
        x, 0, screenShot, 0, -y, ctx->window_width - x, ctx->window_height + y);
    if (x) {
      painter->eraseRect(0, 0, x, ctx->window_height);
    }
    if (y) {
      painter->eraseRect(
          x, ctx->window_height + y, ctx->window_width, ctx->window_height);
    }
  }
  delete painter;
}

void FlowDrawQt::clear_area(
    FlowCtx* ctx, int ll_x, int ur_x, int ll_y, int ur_y)
{
  if (ctx->nodraw) {
    return;
  }

  QPainter* painter = new QPainter(window_canvas);
  painter->setBackground(QBrush(background));

  // debug_print("clear_area [%d, %d, %d, %d], color=%s\n", ll_x, ll_y, ur_x -
  // ll_x, ur_y - ll_y, painter->background().color().name().toAscii().data());
  painter->eraseRect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y);

  delete painter;
}

void FlowDrawQt::set_inputfocus(FlowCtx* ctx)
{
  debug_print("set_inputfocus\n");
  window->setFocus(Qt::OtherFocusReason);
}

void FlowDrawQt::set_click_sensitivity(FlowCtx* ctx, int value)
{
  click_sensitivity = value;
}

void FlowDrawQt::set_image_clip_mask(
    QPainter* painter, flow_tPixmap pixmap, int x, int y)
{
  QRegion clipRegion
      = QRegion(((QPixmap*)pixmap)->createMaskFromColor(Qt::black));
  painter->setClipRegion(clipRegion.translated(x, y));
  painter->setClipping(true);
}

void FlowDrawQt::set_white_background(FlowCtx* ctx)
{
  background = flow_allocate_color(this, "white");

  // debug_print("set_white_background\n");

  QPalette pal;
  pal.setColor(QPalette::Background, background);
  toplevel->setAutoFillBackground(true);
  toplevel->setPalette(pal);
}

int FlowDrawQt::get_font_idx(int painter_type)
{
  if (painter_type == flow_eDrawType_TextHelveticaBold
      || painter_type == flow_eDrawType_TextHelveticaEraseBold) {
    return draw_eFont_HelveticaBold;
  } else {
    return draw_eFont_Helvetica;
  }
}

int FlowDrawQt::image_get_width(flow_tImImage image)
{
  return ((QImage*)image)->width();
}

int FlowDrawQt::image_get_height(flow_tImImage image)
{
  return ((QImage*)image)->height();
}

void FlowDrawQt::image_scale(float scale, flow_tImImage orig_im,
    flow_tImImage* im, flow_tPixmap* im_pixmap, flow_tPixmap* im_mask)
{
  int width = int(scale * image_get_width(orig_im));
  int height = int(scale * image_get_height(orig_im));

  if (*im) {
    delete ((QImage*)*im);
  }
  *im = new QImage(((QImage*)orig_im)->scaled(width, height));
}

int FlowDrawQt::image_load(const char* imagefile, float scale, float nav_scale,
    flow_tImImage* orig_im, flow_tImImage* im, flow_tPixmap* im_pixmap,
    flow_tPixmap* im_mask, flow_tPixmap* im_nav_pixmap,
    flow_tPixmap* im_nav_mask)
{
  pwr_tFileName filename;
  bool found = false;

  strcpy(filename, imagefile);

  debug_print("image_load %s\n", imagefile);

  // Look for file in $pwrp_exe, $pwr_doc/en_us/orm and $pwr_exe
  for (int i = 0; i < 3; i++) {
    switch (i) {
    case 0:
      strcpy(filename, "$pwrp_exe/");
      break;
    case 1:
      strcpy(filename, "$pwr_doc/en_us/orm/");
      break;
    case 2:
      strcpy(filename, "$pwr_exe/");
      break;
    }
    strcat(filename, imagefile);
    dcli_translate_filename(filename, filename);
    FILE* fp = fopen(filename, "r");
    if (!fp) {
      continue;
    }
    fclose(fp);
    found = true;
    break;
  }
  if (!found) {
    return 0;
  }

  if (*orig_im) {
    delete ((QImage*)*orig_im);
  }
  *orig_im = (flow_tImImage*)new QImage(filename);

  image_scale(scale, *orig_im, im, im_pixmap, im_mask);

  return 1;
}

FlowPrintDraw* FlowDrawQt::print_draw_new(void* context, const char* title,
    int page, void* flow_ctx, int page_border, int* sts)
{
  FlowPrintDrawQt* pd
      = new FlowPrintDrawQt(context, title, page, flow_ctx, page_border, sts);
  return (FlowPrintDraw*)pd;
}