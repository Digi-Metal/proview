/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/**
 * WARNING! This file is a mirrored version of glow_scroll_widget_qt.
 * If you modify it, you must modify flow_scroll_widget_qt in the same way!
 */

#include <assert.h>

#include "cow_qt_helpers.h"

#include "flow_scroll_widget_qt.h"

#include <QTimer>

void QtScrollWidgetFlow::createBuffer(QSize size)
{
  if (size.isEmpty()) {
    return;
  }
  this->image = QImage(size, QImage::Format_RGB32);
  QPainter imPainter(&image);
  imPainter.fillRect(image.rect(), palette().color(QPalette::Background));
}

void QtScrollWidgetFlow::init(unsigned int eCtxType,
    int (*init_proc)(FlowCtx* ctx, void* client_data), void* client_data,
    int (*init_proc2)(QWidget* w, FlowCtx* ctx, void* client_data))
{
  createBuffer(size());
  setFocusPolicy(Qt::StrongFocus);
  setMouseTracking(true);
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
  this->scroll_timerid = new QTimer(this);
}

QWidget* QtScrollWidgetFlow::initScroll(unsigned int eCtxType,
    int (*init_proc)(FlowCtx* ctx, void* client_data), void* client_data,
    int (*init_proc2)(QWidget* w, FlowCtx* ctx, void* client_data))
{
  createBuffer(size());
  setFocusPolicy(Qt::StrongFocus);
  setMouseTracking(true);
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
  this->scroll_timerid = new QTimer(this);
  QScrollArea* form = new QScrollArea();
  scroll_h = form->horizontalScrollBar();
  scroll_v = form->verticalScrollBar();
  /*
  TODO: this callback resets the scrollbar to 0.
  QObject::connect(
      scroll_h, SIGNAL(valueChanged(int)), this, SLOT(scroll_h_action(int)));
  QObject::connect(
      scroll_v, SIGNAL(valueChanged(int)), this, SLOT(scroll_v_action(int)));
  */

  form->setWidget(this);
  form->setWidgetResizable(true);
  return form;
}

void QtScrollWidgetFlow::init(unsigned int eCtxType, QWidget* main)
{
  createBuffer(size());
  setFocusPolicy(Qt::StrongFocus);
  setMouseTracking(true);
  this->ctxType = eCtxType;
  this->scroll_timerid = new QTimer(this);
  is_navigator = 1;
  main_widget = main;
}

void QtScrollWidgetFlow::scroll_callback_cb()
{
  flow_sScroll* data = &this->scroll_data;
  widget_sScroll* scroll_data = (widget_sScroll*)data->scroll_data;

  scroll_timerid->stop();

  if (data->total_width <= data->window_width) {
    if (data->offset_x == 0) {
      data->total_width = data->window_width;
    }
    if (scroll_data->scroll_h_managed) {
      // Remove horizontal scrollbar
    }
  } else {
    if (!scroll_data->scroll_h_managed) {
      // Insert horizontal scrollbar
    }
  }

  if (data->total_height <= data->window_height) {
    if (data->offset_y == 0) {
      data->total_height = data->window_height;
    }
    if (scroll_data->scroll_v_managed) {
      // Remove vertical scrollbar
    }
  } else {
    if (!scroll_data->scroll_v_managed) {
      // Insert vertical scrollbar
    }
  }
  if (data->offset_x < 0) {
    data->total_width += -data->offset_x;
    data->offset_x = 0;
  }
  if (data->offset_y < 0) {
    data->total_height += -data->offset_y;
    data->offset_y = 0;
  }
  if (data->total_height < data->window_height + data->offset_y) {
    data->total_height = data->window_height + data->offset_y;
  }
  if (data->total_width < data->window_width + data->offset_x) {
    data->total_width = data->window_width + data->offset_x;
  }
  if (data->window_width < 1) {
    data->window_width = 1;
  }
  if (data->window_height < 1) {
    data->window_height = 1;
  }

  if (scroll_data->scroll_h_managed) {
    scroll_h_ignore = 1;
    if (data->window_width != scroll_h_pagesize
        || data->total_width != scroll_h_upper || scroll_configure) {
      scroll_data->scroll_h->setMaximum(data->total_width);
      scroll_data->scroll_h->setPageStep(data->window_width);
    }
    scroll_data->scroll_h->setSliderPosition(data->offset_x);
    scroll_h_value = data->offset_x;
    scroll_h_pagesize = data->window_width;
    scroll_h_upper = data->total_width;
  }

  if (scroll_data->scroll_v_managed) {
    scroll_v_ignore = 1;
    if (data->window_height != scroll_v_pagesize
        || data->total_height != scroll_v_upper || scroll_configure) {
      scroll_data->scroll_v->setMaximum(data->total_height);
      scroll_data->scroll_v->setPageStep(data->window_height);
    }
    scroll_data->scroll_v->setSliderPosition(data->offset_y);
    scroll_v_value = data->offset_y;
    scroll_v_pagesize = data->window_height;
    scroll_v_upper = data->total_height;
  }
  scroll_configure = 0;
}

void QtScrollWidgetFlow::scroll_h_action(int value)
{
  if (scroll_h_ignore) {
    scroll_h_ignore = 0;
    return;
  }

  scroll_h_value = value;
  FlowCtx* ctx = (FlowCtx*)parent_ctx;
  flow_scroll_horizontal(ctx, value, 0);
}

void QtScrollWidgetFlow::scroll_v_action(int value)
{
  if (scroll_v_ignore) {
    scroll_v_ignore = 0;
    return;
  }

  scroll_v_value = value;
  FlowCtx* ctx = (FlowCtx*)parent_ctx;
  flow_scroll_vertical(ctx, value, 0);
}

void QtScrollWidgetFlow::paintEvent(QPaintEvent* event)
{
  QPainter painter(this);
  QRect dirtyRect = event->rect();
  painter.drawImage(dirtyRect, image, dirtyRect);
  QWidget::paintEvent(event);
}

void QtScrollWidgetFlow::closeEvent(QCloseEvent* event)
{
  debug_print("QtScrollWidgetFlow::closeEvent\n");
  if (!destroyed) {
    destroyed = 1;
    if (is_navigator && parent_ctx) {
      if (!((QtScrollWidgetFlow*)main_widget)->destroyed) {
        ((FlowCtx*)parent_ctx)->no_nav = 1;
      }
    }
  }
  QWidget::closeEvent(event);
}

void QtScrollWidgetFlow::handleEvent(QEvent* event)
{
  if (!destroyed) {
    if (event->type() == QEvent::Resize || event->type() == QEvent::Move) {
      scroll_configure = 1;
    }
    if (parent_ctx) {
      FlowCtx* ctx = (FlowCtx*)parent_ctx;
      FlowDrawQt* drawer = ((FlowDrawQt*)ctx->fdraw);
      if (event->type() == QEvent::MouseMove) {
        drawer->window->update();
      }
      drawer->event_handler(event, this);
    }
  }
}

bool QtScrollWidgetFlow::event(QEvent* event)
{
  if (event->type() == QEvent::Resize) {
    createBuffer(((QResizeEvent*)event)->size());
  }
  if (!is_realized && event->type() == QEvent::Show) {
    realize();
    is_realized = true;
  }
  handleEvent(event);
  return QWidget::event(event);
}

void QtScrollWidgetFlow::realize()
{
  if (!parent_ctx) {
    if (is_navigator) {
      QtScrollWidgetFlow* main
          = dynamic_cast<QtScrollWidgetFlow*>(this->main_widget);

      if (main && !main->is_realized) {
        main->realize();
        main->is_realized = true;
      }

      assert(main->parent_ctx != NULL);
      assert(main->draw_ctx != NULL);

      parent_ctx = main->parent_ctx;
      draw_ctx = main->draw_ctx;
      draw_ctx->init_nav(this, parent_ctx);
    } else {
      draw_ctx = new FlowDrawQt(this, &parent_ctx, init_widget_proc,
          client_data, static_cast<flow_eCtxType>(ctxType));
    }
  }
}