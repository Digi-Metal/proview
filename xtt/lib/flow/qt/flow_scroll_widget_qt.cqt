/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/**
 * WARNING! This file is a mirrored version of glow_scroll_widget_qt.
 * If you modify it, you must modify flow_scroll_widget_qt in the same way!
 */

#include <assert.h>

#include "cow_qt_helpers.h"

#include "flow_scroll_widget_qt.h"

#include <QTimer>

void QtScrollWidgetFlow::init(unsigned int eCtxType,
    int (*init_proc)(FlowCtx* ctx, void* client_data), void* client_data,
    int (*init_proc2)(QWidget* w, FlowCtx* ctx, void* client_data))
{
  setFocusPolicy(Qt::ClickFocus);
  setMouseTracking(true);
  if (getenv("DISPLAY")[0] != ':') {
    setAttribute(Qt::WA_PaintOnScreen, true);
  }
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
  this->scroll_timerid = new QTimer(this);
}

bool QtScrollWidgetFlow::eventFilter(QObject *object, QEvent *event)
{
  return (event->type() == QEvent::KeyPress);
}

QWidget* QtScrollWidgetFlow::initScroll(unsigned int eCtxType,
    int (*init_proc)(FlowCtx* ctx, void* client_data), void* client_data,
    int (*init_proc2)(QWidget* w, FlowCtx* ctx, void* client_data))
{
  setFocusPolicy(Qt::ClickFocus);
  setMouseTracking(true);
  if (getenv("DISPLAY")[0] != ':') {
    setAttribute(Qt::WA_PaintOnScreen, true);
  }
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
  this->scroll_timerid = new QTimer(this);
  form = new QScrollArea();
  form->setFocusPolicy(Qt::NoFocus);
  form->installEventFilter(this);
  scroll_h = form->horizontalScrollBar();
  scroll_v = form->verticalScrollBar();
  scroll_h->setTracking(false);
  scroll_v->setTracking(false);
  QObject::connect(
      scroll_h, SIGNAL(sliderMoved(int)), this, SLOT(scroll_h_action(int)));
  QObject::connect(
      scroll_v, SIGNAL(sliderMoved(int)), this, SLOT(scroll_v_action(int)));

  // These are needed to prevent QT from scrolling the ScrollArea.
  QObject::connect(
      scroll_h, SIGNAL(valueChanged(int)), this, SLOT(scroll_h_released(int)));
  QObject::connect(
      scroll_v, SIGNAL(valueChanged(int)), this, SLOT(scroll_v_released(int)));

  form->setWidget(this);
  form->setWidgetResizable(true);
  return form;
}

void QtScrollWidgetFlow::init(unsigned int eCtxType, QWidget* main)
{
  setFocusPolicy(Qt::ClickFocus);
  setMouseTracking(true);
  if (getenv("DISPLAY")[0] != ':') {
    setAttribute(Qt::WA_PaintOnScreen, true);
  }
  this->ctxType = eCtxType;
  this->scroll_timerid = new QTimer(this);
  is_navigator = 1;
  main_widget = main;
}

void QtScrollWidgetFlow::scroll_callback_cb()
{
  flow_sScroll* data = &this->scroll_data;
  widget_sScroll* scroll_data = (widget_sScroll*)data->scroll_data;

  scroll_timerid->stop();

  if (data->offset_x == 0 && data->total_width <= data->window_width) {
    data->total_width = data->window_width;
    if (scroll_data->scroll_h_managed) {
      form->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    }
  } else {
    if (scroll_data->scroll_h_managed) {
      form->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    }
  }

  if (data->offset_y == 0 && data->total_height <= data->window_height) {
    data->total_height = data->window_height;
    if (scroll_data->scroll_v_managed) {
      form->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    }
  } else {
    if (scroll_data->scroll_v_managed) {
      form->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    }
  }

  if (data->offset_x < 0) {
    data->total_width += -data->offset_x;
    data->offset_x = 0;
  }
  if (data->offset_y < 0) {
    data->total_height += -data->offset_y;
    data->offset_y = 0;
  }
  if (data->total_height < data->window_height + data->offset_y) {
    data->total_height = data->window_height + data->offset_y;
  }
  if (data->total_width < data->window_width + data->offset_x) {
    data->total_width = data->window_width + data->offset_x;
  }
  if (data->window_width < 1) {
    data->window_width = 1;
  }
  if (data->window_height < 1) {
    data->window_height = 1;
  }

  if (scroll_data->scroll_h_managed) {
    if (data->window_width != scroll_h->pageStep()
        || data->total_width != scroll_h->maximum() || scroll_configure) {
      scroll_h->setMaximum(data->total_width - data->window_width);
      scroll_h->setPageStep(data->window_width);
    }
    scroll_h->setSliderPosition(data->offset_x);
  }

  if (scroll_data->scroll_v_managed) {
    if (data->window_height != scroll_v->pageStep()
        || data->total_height != scroll_v->maximum() || scroll_configure) {
      scroll_v->setMaximum(data->total_height - data->window_height);
      scroll_v->setPageStep(data->window_height);
    }
    scroll_v->setSliderPosition(data->offset_y);
  }
  scroll_configure = 0;
}

void QtScrollWidgetFlow::scroll_h_action(int value)
{
  FlowCtx* ctx = (FlowCtx*)parent_ctx;
  flow_scroll_horizontal(ctx, value, 0);
}

void QtScrollWidgetFlow::scroll_h_released(int value)
{
  // Prevent QT from scrolling the ScrollArea by setting the value to 0.
  scroll_h->setValue(0);
  scroll_h->setSliderPosition(value);
}

void QtScrollWidgetFlow::scroll_v_action(int value)
{
  FlowCtx* ctx = (FlowCtx*)parent_ctx;
  flow_scroll_vertical(ctx, value, 0);
}

void QtScrollWidgetFlow::scroll_v_released(int value)
{
  // Prevent QT from scrolling the ScrollArea by setting the value to 0.
  scroll_v->setValue(0);
  scroll_v->setSliderPosition(value);
}

void QtScrollWidgetFlow::paintEvent(QPaintEvent* event)
{
  FlowCtx* ctx = (FlowCtx*)parent_ctx;
  draw_ctx->begin(this);
  if (ctx->mw == this) {
    ctx->draw(0, 0, width(), height());
  } else if (ctx->navw == this) {
    ctx->nav_draw(0, 0, width(), height());
  }
  draw_ctx->end();
  ctx->is_dirty = 0;
}

void QtScrollWidgetFlow::closeEvent(QCloseEvent* event)
{
  if (!destroyed) {
    destroyed = 1;
    if (is_navigator && parent_ctx) {
      if (!((QtScrollWidgetFlow*)main_widget)->destroyed) {
        ((FlowCtx*)parent_ctx)->no_nav = 1;
      }
    }
  }
  QWidget::closeEvent(event);
}

void QtScrollWidgetFlow::handleEvent(QEvent* event)
{
  if (!destroyed) {
    if (event->type() == QEvent::Resize || event->type() == QEvent::Move) {
      scroll_configure = 1;
    }
    if (parent_ctx) {
      FlowCtx* ctx = (FlowCtx*)parent_ctx;
      FlowDrawQt* drawer = ((FlowDrawQt*)ctx->fdraw);
      if (event->type() == QEvent::Resize || event->type() == QEvent::Show) {
        ctx->set_dirty();
      }
      drawer->event_handler(ctx, event, this);
    }
  }
}

bool QtScrollWidgetFlow::event(QEvent* event)
{
  if (!is_realized && event->type() == QEvent::Show) {
    realize();
    is_realized = true;
  }
  handleEvent(event);
  return QWidget::event(event);
}

void QtScrollWidgetFlow::realize()
{
  if (!parent_ctx) {
    if (is_navigator) {
      QtScrollWidgetFlow* main
          = dynamic_cast<QtScrollWidgetFlow*>(this->main_widget);

      if (main && !main->is_realized) {
        main->realize();
        main->is_realized = true;
      }

      assert(main->parent_ctx != NULL);
      assert(main->draw_ctx != NULL);

      parent_ctx = main->parent_ctx;
      draw_ctx = main->draw_ctx;
      draw_ctx->init_nav(this, parent_ctx);
    } else {
      draw_ctx = new FlowDrawQt(this, &parent_ctx, init_widget_proc,
          client_data, static_cast<flow_eCtxType>(ctxType));
      setFocus();
    }
  }
}
