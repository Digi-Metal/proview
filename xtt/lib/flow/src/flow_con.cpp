/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_string.h"

#include "flow_con.h"
#include "flow_conpoint.h"
#include "flow_draw.h"
#include "flow_text.h"
#include "flow_msg.h"

#define LINE_TABLE_SIZE 500
#define HV_LINE_ARRAY_SIZE 500
#define CON__ROUTE_FOUND 111
#define ROUTE_LOOP_MAX 10000
#define CON_EPSILON 1e-4

typedef enum {
  eState_No,
  eState_RightToLeft,
  eState_UpToLeft,
  eState_UpToRight,
  eState_LeftToLeft,
  eState_RightToRight,
  eState_DownToLeft,
  eState_DownToRight,
  eState_LeftToRight,
  eState_RightToUp,
  eState_RightToDown,
  eState_LeftToUp,
  eState_LeftToDown,
  eState_Success,
  eState_Failure,
  eState_Exit
} route_eState;

typedef enum {
  eCorner_RightToUp,
  eCorner_RightToDown,
  eCorner_UpToLeft,
  eCorner_UpToRight,
  eCorner_DownToLeft,
  eCorner_DownToRight,
  eCorner_LeftToUp,
  eCorner_LeftToDown,
  eCorner_Sharp
} con_eCorner;

typedef enum { eLineType_Vert, eLineType_Horiz } con_eLineType;

typedef struct {
  con_eLineType start_type;
  con_tVertLines* vert[MAX_HVLINE];
  con_tHorizLines* horiz[MAX_HVLINE];
  double vert_x[MAX_HVLINE];
  double vert_y[MAX_HVLINE];
  double horiz_x[MAX_HVLINE];
  double horiz_y[MAX_HVLINE];
  int vert_cnt;
  int horiz_cnt;
  int complete;
} con_tRouteLine;

static con_tVertLines vert_line[HV_LINE_ARRAY_SIZE + 1];
static con_tHorizLines horiz_line[HV_LINE_ARRAY_SIZE + 1];
static int vert_line_cnt;
static int horiz_line_cnt;
static con_tRouteLine line_table[LINE_TABLE_SIZE + 1];
static int line_table_cnt;
static double sort_dest_x;
static double sort_dest_y;
static FlowNode* sort_source;
static FlowNode* sort_dest;

FlowCon::FlowCon(FlowCtx* flow_ctx, const char* name, FlowConClass* con_class,
    FlowNode* source, FlowNode* dest, int source_cp, int dest_cp, int* rsts,
    int nodraw, int point_num, double* x_vect, double* y_vect)
    : ctx(flow_ctx), cc(con_class), dest_node(dest), source_node(source),
      dest_conpoint(dest_cp), source_conpoint(source_cp), p_num(point_num),
      l_num(0), a_num(0), arrow_num(0), ref_num(0), line_a(10, 10),
      arc_a(10, 10), arrow_a(1, 1), ref_a(4, 4), temporary_ref(0), hot(0),
      highlight(0), dimmed(0), movement_type(flow_eMoveType_Route),
      trace_attr_type(flow_eTraceType_Boolean), trace_p(NULL)
{
  if (!cc)
    return;

  strcpy(trace_object, "");
  strcpy(trace_attribute, "");
  if (x_vect && y_vect) {
    for (int i = 0; i < point_num; i++) {
      point_x[i] = x_vect[i];
      point_y[i] = y_vect[i];
    }
  }

  double src_x, src_y, dest_x, dest_y;
  *rsts = source->get_conpoint(source_cp, &src_x, &src_y, &source_direction);
  if (EVEN(*rsts))
    return;
  *rsts = dest->get_conpoint(dest_cp, &dest_x, &dest_y, &dest_direction);
  if (EVEN(*rsts))
    return;

  switch (cc->con_type) {
  case flow_eConType_Straight: {
    FlowLine* l1 = new FlowLine(
        ctx, src_x, src_y, dest_x, dest_y, cc->draw_type, cc->line_width);
    line_a.insert(l1);
    l_num = 1;
    nav_zoom();
    break;
  }
  case flow_eConType_StraightOneArrow: {
    FlowLine* l1 = new FlowLine(
        ctx, src_x, src_y, dest_x, dest_y, cc->draw_type, cc->line_width);
    line_a.insert(l1);
    l_num = 1;
    FlowArrow* arrow = new FlowArrow(ctx, src_x, src_y, dest_x, dest_y, cc->arrow_width,
        cc->arrow_length, cc->draw_type);
    arrow_a.insert(arrow);
    arrow_num = 1;
    nav_zoom();
    break;
  }
  case flow_eConType_StepDiv:
  case flow_eConType_StepConv:
  case flow_eConType_TransDiv:
  case flow_eConType_TransConv: {
    for (int i = 0; i < MAX_POINT - 1; i++) {
      FlowLine* l1 = new FlowLine(ctx, 0, 0, 0, 0, cc->draw_type,
          cc->line_width);
      line_a.insert(l1);
    }
    break;
  }
  case flow_eConType_Fixed: {
    int i;
    if (!point_num) {
      FlowLine* l1 = new FlowLine(
          ctx, src_x, src_y, dest_x, dest_y, cc->draw_type, cc->line_width);
      line_a.insert(l1);
      i = 1;
      l_num = 1;
    } else {
      FlowLine* l1 = new FlowLine(ctx, src_x, src_y, point_x[0], point_y[0],
          cc->draw_type, cc->line_width);
      line_a.insert(l1);
      for (i = 0; i < point_num; i++) {
        if (i != point_num - 1)
          l1 = new FlowLine(ctx, point_x[i], point_y[i], point_x[i + 1],
              point_y[i + 1], cc->draw_type, cc->line_width);
        else
          l1 = new FlowLine(ctx, point_x[i], point_y[i], dest_x, dest_y,
              cc->draw_type, cc->line_width);
        line_a.insert(l1);
      }
      l_num = p_num - 1;
    }
    for (; i < 8; i++) {
      FlowLine* l1 = new FlowLine(ctx, 0, 0, 0, 0, cc->draw_type,
          cc->line_width);
      line_a.insert(l1);
    }
    if (!nodraw) {
      if (cc->corner == flow_eCorner_Rounded)
        draw_routed_roundcorner(p_num, point_x, point_y);
      else
        draw_routed(p_num, point_x, point_y);
    }
    break;
  }
  case flow_eConType_AllFixed:
    if (!nodraw) {
      if (cc->corner == flow_eCorner_Rounded)
        draw_routed_roundcorner(p_num, point_x, point_y);
      else
        draw_routed(p_num, point_x, point_y);
    }
    break;
  case flow_eConType_Routed: {
    for (int i = 0; i < MAX_POINT - 1; i++) {
      FlowLine* l1 = new FlowLine(ctx, 0, 0, 0, 0, cc->draw_type, cc->line_width);
      line_a.insert(l1);
    }
    if (cc->corner == flow_eCorner_Rounded) {
      for (int i = 0; i < MAX_POINT - 2; i++) {
        FlowArc* a1 = new FlowArc(ctx, 0, 0, 0, 0, 0, 0, cc->draw_type, cc->line_width);
        arc_a.insert(a1);
      }
    }
    l_num = 0;
    a_num = 0;
    if (!nodraw) {
      if (p_num && x_vect && y_vect) {
        if (cc->corner == flow_eCorner_Rounded)
          draw_routed_roundcorner(p_num, point_x, point_y);
        else
          draw_routed(p_num, point_x, point_y);
      } else {
        *rsts = con_route(
            src_x, src_y, source_direction, dest_x, dest_y, dest_direction);
        if (EVEN(*rsts) && *rsts != 0)
          return;
        temporary_ref = (*rsts == 0);
      }
    }
    break;
  }
  case flow_eConType_Reference:
    break;
  }

  if (temporary_ref || cc->con_type == flow_eConType_Reference) {
    FlowText *t1, *t2;
    FlowRect *r1, *r2;
    double text_x, text_y, rect_x, rect_y;
    char reftext[20];

    sprintf(reftext, "R%d", ctx->refcon_cnt++);
    switch (source_direction) {
    case flow_eDirection_Center:
      rect_x = src_x - ctx->refcon_width / 2;
      rect_y
          = src_y - (source->refcon_cnt[source_cp] - 0.5) * ctx->refcon_height;
      break;
    case flow_eDirection_Right:
      rect_x = src_x + source->refcon_cnt[source_cp] * ctx->refcon_width;
      rect_y = src_y - ctx->refcon_height / 2;
      break;
    case flow_eDirection_Left:
      rect_x = src_x - (source->refcon_cnt[source_cp] + 1) * ctx->refcon_width;
      rect_y = src_y - ctx->refcon_height / 2;
      break;
    case flow_eDirection_Up:
      rect_x = src_x - ctx->refcon_width / 2;
      rect_y = src_y + source->refcon_cnt[source_cp] * ctx->refcon_height;
      break;
    case flow_eDirection_Down:
      rect_x = src_x - ctx->refcon_width / 2;
      rect_y = src_y - (source->refcon_cnt[source_cp] + 1) * ctx->refcon_height;
      break;
    }
    text_x = rect_x + 0.2 * ctx->refcon_width;
    text_y = rect_y + 0.8 * ctx->refcon_height;
    r1 = new FlowRect(ctx, rect_x, rect_y, ctx->refcon_width,
        ctx->refcon_height, flow_eDrawType_Line, ctx->refcon_linewidth);
    t1 = new FlowText(ctx, reftext, text_x, text_y,
        flow_eDrawType_TextHelveticaBold, ctx->refcon_textsize);
    ref_a.insert(r1);
    ref_a.insert(t1);

    switch (dest_direction) {
    case flow_eDirection_Center:
      rect_x = dest_x - ctx->refcon_width / 2;
      rect_y = dest_y - (dest->refcon_cnt[dest_cp] - 0.5) * ctx->refcon_height;
      break;
    case flow_eDirection_Right:
      rect_x = dest_x + dest->refcon_cnt[dest_cp] * ctx->refcon_width;
      rect_y = dest_y - ctx->refcon_height / 2;
      break;
    case flow_eDirection_Left:
      rect_x = dest_x - (dest->refcon_cnt[dest_cp] + 1) * ctx->refcon_width;
      rect_y = dest_y - ctx->refcon_height / 2;
      break;
    case flow_eDirection_Up:
      rect_x = dest_x - ctx->refcon_width / 2;
      rect_y = dest_y + dest->refcon_cnt[dest_cp] * ctx->refcon_height;
      break;
    case flow_eDirection_Down:
      rect_x = dest_x - ctx->refcon_width / 2;
      rect_y = dest_y - (dest->refcon_cnt[dest_cp] + 1) * ctx->refcon_height;
      break;
    }
    text_x = rect_x + 0.2 * ctx->refcon_width;
    text_y = rect_y + 0.8 * ctx->refcon_height;
    r2 = new FlowRect(ctx, rect_x, rect_y, ctx->refcon_width,
        ctx->refcon_height, flow_eDrawType_Line, ctx->refcon_linewidth);
    t2 = new FlowText(ctx, reftext, text_x, text_y,
        flow_eDrawType_TextHelveticaBold, ctx->refcon_textsize);
    ref_a.insert(r2);
    ref_a.insert(t2);
    ref_num = 4;
    source_ref_cnt = source->refcon_cnt[source_cp]++;
    dest_ref_cnt = dest->refcon_cnt[dest_cp]++;
    nav_zoom();
  }

  strcpy(c_name, name);
  get_con_borders();
  *rsts = FLOW__SUCCESS;

  if (!nodraw)
    ctx->set_dirty(x_left, y_low, x_right, y_high);
}

FlowCon::~FlowCon()
{
  ctx->object_deleted(this);

  ctx->remove(this);
  ctx->select_remove(this);

  if (temporary_ref || cc->con_type == flow_eConType_Reference) {
    source_node->conpoint_refcon_reconfig(source_conpoint);
    dest_node->conpoint_refcon_reconfig(dest_conpoint);
  }

  if (!ctx->nodraw)
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  if (hot)
    ctx->fdraw->set_cursor(ctx->mw, draw_eCursor_Normal);
}

FlowCon::FlowCon(const FlowCon& c, FlowNode* source, FlowNode* dest)
{
  memcpy((void *)this, (void *)&c, sizeof(c));
  source_node = source;
  dest_node = dest;

  line_a.new_array(c.line_a);
  arc_a.new_array(c.arc_a);
  arrow_a.new_array(c.arrow_a);
  ref_a.new_array(c.ref_a);
  line_a.copy_from(c.line_a);
  arc_a.copy_from(c.arc_a);
  arrow_a.copy_from(c.arrow_a);
  ref_a.copy_from(c.ref_a);
  if (ref_a.size() > 0) {
    sprintf(((FlowText*)ref_a[1])->text, "R%d", ctx->refcon_cnt);
    sprintf(((FlowText*)ref_a[3])->text, "R%d", ctx->refcon_cnt++);
  }
}

void FlowCon::set_highlight(int on)
{
  if (highlight != on) {
    highlight = on;
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::set_hot(int on)
{
  if (hot != on) {
    hot = on;
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::select_region_insert(
    double ll_x, double ll_y, double ur_x, double ur_y)
{
  if (temporary_ref || cc->con_type == flow_eConType_Reference) {
    // Allways surround
    if (x_left > ll_x && x_right < ur_x && y_high < ur_y && y_low > ll_y)
      ctx->select_insert(this);
  } else {
    if (ctx->select_policy == flow_eSelectPolicy_Surround) {
      if (x_left > ll_x && x_right < ur_x && y_high < ur_y && y_low > ll_y)
        ctx->select_insert(this);
    } else {
      if (x_right > ll_x && x_left < ur_x && y_low < ur_y && y_high > ll_y)
        ctx->select_insert(this);
    }
  }
}

void FlowCon::zoom()
{
  for (int i = 0; i < l_num; i++)
    ((FlowLine*)line_a[i])->zoom();
  for (int i = 0; i < a_num; i++)
    ((FlowLine*)arc_a[i])->zoom();
  arrow_a.zoom();
  ref_a.zoom();
}

void FlowCon::nav_zoom()
{
  for (int i = 0; i < l_num; i++)
    ((FlowLine*)line_a[i])->nav_zoom();
  for (int i = 0; i < a_num; i++)
    ((FlowLine*)arc_a[i])->nav_zoom();
  arrow_a.nav_zoom();
  ref_a.nav_zoom();
}

void FlowCon::print_zoom()
{
  for (int i = 0; i < l_num; i++)
    ((FlowLine*)line_a[i])->print_zoom();
  for (int i = 0; i < a_num; i++)
    ((FlowLine*)arc_a[i])->print_zoom();
  arrow_a.print_zoom();
  ref_a.print_zoom();
}

void FlowCon::redraw_node_cons(void* node)
{
  if (source_node == (FlowNode*)node || dest_node == (FlowNode*)node)
    reconfigure();
}

int FlowCon::delete_node_cons(void* node)
{
  if (source_node == (FlowNode*)node || dest_node == (FlowNode*)node) {
    delete this;
    return 1;
  }
  return 0;
}

void FlowCon::get_con_borders()
{
  x_right = -1e10;
  x_left = 1e10;
  y_high = -1e10;
  y_low = 1e10;
  if (temporary_ref || cc->con_type == flow_eConType_Reference)
    ref_a.get_borders(0, 0, &x_right, &x_left, &y_high, &y_low, NULL);
  else {
    for (int i = 0; i < l_num; i++)
      line_a[i]->get_borders(0, 0, &x_right, &x_left, &y_high, &y_low, NULL);
    for (int i = 0; i < a_num; i++)
      arc_a[i]->get_borders(0, 0, &x_right, &x_left, &y_high, &y_low, NULL);
  }
}

void FlowCon::move(int delta_x, int delta_y, int grid)
{
  double x = delta_x / ctx->zoom_factor;
  double y = delta_y / ctx->zoom_factor;

  if (movement_type == flow_eMoveType_Route || grid)
    reconfigure();
  else {
    ctx->set_dirty(x_left, y_low, x_right, y_high);
    for (int i = 0; i < p_num; i++) {
      point_x[i] += x;
      point_y[i] += y;
    }
    if (temporary_ref || cc->con_type == flow_eConType_Reference)
      ref_a.shift(&cc->zero, x, y, highlight, dimmed, hot);
    else {
      for (int i = 0; i < l_num; i++)
        ((FlowLine*)line_a[i])->shift(&cc->zero, x, y, highlight, dimmed, hot);
      for (int i = 0; i < a_num; i++)
        ((FlowArc*)arc_a[i])->shift(&cc->zero, x, y, highlight, dimmed, hot);
      arrow_a.shift(&cc->zero, x, y, highlight, dimmed, hot);
    }
    get_con_borders();
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::move_noerase(int delta_x, int delta_y, int grid)
{
  double x = delta_x / ctx->zoom_factor;
  double y = delta_y / ctx->zoom_factor;

  if (cc->con_type != flow_eConType_Routed
      || movement_type == flow_eMoveType_Route || grid || p_num == 0) {
    ctx->set_nodraw();
    reconfigure();
    ctx->reset_nodraw();
  } else {
    ctx->set_dirty(x_left, y_low, x_right, y_high);
    for (int i = 0; i < p_num; i++) {
      point_x[i] += x;
      point_y[i] += y;
    }
    l_num = a_num = 0;
    if (cc->corner == flow_eCorner_Rounded)
      draw_routed_roundcorner(p_num, point_x, point_y);
    else
      draw_routed(p_num, point_x, point_y);
    get_con_borders();
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::reconfigure()
{
  double x1, y1, x2, y2;
  flow_eDirection dir1, dir2;
  int sts = source_node->get_conpoint(source_conpoint, &x1, &y1, &dir1);
  if (EVEN(sts)) {
    std::cout << "FlowCon:no such conpoint\n";
    return;
  }
  sts = dest_node->get_conpoint(dest_conpoint, &x2, &y2, &dir2);
  if (EVEN(sts)) {
    std::cout << "FlowCon:no such conpoint\n";
    return;
  }

  switch (cc->con_type) {
  case flow_eConType_Straight: {
    FlowLine* l1 = (FlowLine *) line_a[0];
    l1->move(&cc->zero, x1, y1, x2, y2, highlight, dimmed, hot);
    break;
  }
  case flow_eConType_Reference: {
    move_ref(x1, y1, x2, y2);
    break;
  }
  case flow_eConType_StraightOneArrow: {
    FlowLine* l1 = (FlowLine *) line_a[0];
    l1->move(&cc->zero, x1, y1, x2, y2, highlight, dimmed, hot);
    FlowArrow* arrow = (FlowArrow *) arrow_a[0];
    arrow->move(&cc->zero, x1, y1, x2, y2, highlight, dimmed, hot);
    break;
  }
  case flow_eConType_StepDiv:
  case flow_eConType_StepConv:
  case flow_eConType_TransDiv:
  case flow_eConType_TransConv:
    con_route_grafcet(cc->con_type, x1, y1, x2, y2);
    break;
  case flow_eConType_Fixed:
    if (!p_num) {
      FlowLine* l1 = (FlowLine*)line_a[0];
      l1->move(&cc->zero, x1, y1, x2, y2, highlight, dimmed, hot);
    } else {
      FlowLine* l1 = (FlowLine*)line_a[0];
      l1->move(
          &cc->zero, x1, y1, point_x[0], point_y[0], highlight, dimmed, hot);
      l1 = (FlowLine*)line_a[p_num];
      l1->move(&cc->zero, point_x[p_num - 1], point_y[p_num - 1], x2, y2,
          highlight, dimmed, hot);
    }
    break;
  case flow_eConType_AllFixed:
    break;
  case flow_eConType_Routed:
    sts = con_route(x1, y1, dir1, x2, y2, dir2);
    if (sts == 0) {
      if (!temporary_ref) {
        temporary_ref = 1;
        a_num = l_num = p_num = 0;
        source_ref_cnt = source_node->refcon_cnt[source_conpoint]++;
        dest_ref_cnt = dest_node->refcon_cnt[dest_conpoint]++;
      }
      move_ref(x1, y1, x2, y2);
    } else if (temporary_ref) {
      temporary_ref = 0;
      source_node->conpoint_refcon_reconfig(source_conpoint);
      dest_node->conpoint_refcon_reconfig(dest_conpoint);
    }
    break;
  }
  get_con_borders();
}

void FlowCon::print(double ll_x, double ll_y, double ur_x, double ur_y)
{
  double tmp;
  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right >= ll_x && x_left <= ur_x && y_high >= ll_y && y_low <= ur_y) {
    if (temporary_ref || cc->con_type == flow_eConType_Reference)
      ref_a.print(&cc->zero, NULL, highlight);
    else {
      for (int i = 0; i < l_num; i++)
        ((FlowLine*)line_a[i])->print(&cc->zero, NULL, highlight);
      for (int i = 0; i < a_num; i++)
        ((FlowArc*)arc_a[i])->print(&cc->zero, NULL, highlight);
      arrow_a.print(&cc->zero, NULL, highlight);
    }
  }
}

void FlowCon::save(std::ofstream& fp, flow_eSaveMode mode)
{
  if ((mode == flow_eSaveMode_Trace && cc->group != flow_eConGroup_Trace)
      || (mode == flow_eSaveMode_Edit && cc->group == flow_eConGroup_Trace))
    return;

  fp << int(flow_eSave_Con) << '\n';
  fp << int(flow_eSave_Con_x_right) << FSPACE << x_right << '\n';
  fp << int(flow_eSave_Con_x_left) << FSPACE << x_left << '\n';
  fp << int(flow_eSave_Con_y_high) << FSPACE << y_high << '\n';
  fp << int(flow_eSave_Con_y_low) << FSPACE << y_low << '\n';
  fp << int(flow_eSave_Con_cc) << FSPACE << cc->cc_name << '\n';
  fp << int(flow_eSave_Con_dest_node) << FSPACE << dest_node->n_name << '\n';
  fp << int(flow_eSave_Con_source_node) << FSPACE << source_node->n_name
     << '\n';
  fp << int(flow_eSave_Con_dest_conpoint) << FSPACE << dest_conpoint << '\n';
  fp << int(flow_eSave_Con_source_conpoint) << FSPACE << source_conpoint
     << '\n';
  fp << int(flow_eSave_Con_dest_direction) << FSPACE << int(dest_direction)
     << '\n';
  fp << int(flow_eSave_Con_source_direction) << FSPACE << int(source_direction)
     << '\n';
  fp << int(flow_eSave_Con_line_a) << '\n';
  line_a.save(fp, mode);
  fp << int(flow_eSave_Con_arc_a) << '\n';
  arc_a.save(fp, mode);
  fp << int(flow_eSave_Con_arrow_a) << '\n';
  arrow_a.save(fp, mode);
  fp << int(flow_eSave_Con_ref_a) << '\n';
  ref_a.save(fp, mode);
  fp << int(flow_eSave_Con_p_num) << FSPACE << p_num << '\n';
  fp << int(flow_eSave_Con_l_num) << FSPACE << l_num << '\n';
  fp << int(flow_eSave_Con_a_num) << FSPACE << a_num << '\n';
  fp << int(flow_eSave_Con_arrow_num) << FSPACE << arrow_num << '\n';
  fp << int(flow_eSave_Con_ref_num) << FSPACE << ref_num << '\n';
  fp << int(flow_eSave_Con_point_x) << '\n';
  for (int i = 0; i < p_num; i++)
    fp << point_x[i] << '\n';
  fp << int(flow_eSave_Con_point_y) << '\n';
  for (int i = 0; i < p_num; i++)
    fp << point_y[i] << '\n';
  fp << int(flow_eSave_Con_source_ref_cnt) << FSPACE << source_ref_cnt << '\n';
  fp << int(flow_eSave_Con_dest_ref_cnt) << FSPACE << dest_ref_cnt << '\n';
  fp << int(flow_eSave_Con_c_name) << FSPACE << c_name << '\n';
  fp << int(flow_eSave_Con_trace_object) << FSPACE << trace_object << '\n';
  fp << int(flow_eSave_Con_trace_attribute) << FSPACE << trace_attribute
     << '\n';
  fp << int(flow_eSave_Con_trace_attr_type) << FSPACE << int(trace_attr_type)
     << '\n';
  fp << int(flow_eSave_Con_temporary_ref) << FSPACE << temporary_ref << '\n';
  fp << int(flow_eSave_End) << '\n';
}

void FlowCon::open(std::ifstream& fp)
{
  int end_found = 0;
  char dummy[40];
  char name[80];
  int tmp;

  for (;;) {
    int type;
    fp >> type;
    switch (type) {
    case flow_eSave_Con:
      break;
    case flow_eSave_Con_cc:
      fp.get();
      fp.getline(name, sizeof(name));
      cc = (FlowConClass*)ctx->get_conclass_from_name(name);
      if (!cc)
        std::cout << "FlowCon:conclass not found\n";
      break;
    case flow_eSave_Con_c_name:
      fp.get();
      fp.getline(c_name, sizeof(c_name));
      break;
    case flow_eSave_Con_x_right:
      fp >> x_right;
      break;
    case flow_eSave_Con_x_left:
      fp >> x_left;
      break;
    case flow_eSave_Con_y_high:
      fp >> y_high;
      break;
    case flow_eSave_Con_y_low:
      fp >> y_low;
      break;
    case flow_eSave_Con_dest_node:
      fp.get();
      fp.getline(name, sizeof(name));
      dest_node = (FlowNode*)ctx->get_node_from_name(name);
      if (!dest_node)
        std::cout << "FlowCon:dest_node not found\n";
      break;
    case flow_eSave_Con_source_node:
      fp.get();
      fp.getline(name, sizeof(name));
      source_node = (FlowNode*)ctx->get_node_from_name(name);
      if (!source_node)
        std::cout << "FlowCon:source_node not found\n";
      break;
    case flow_eSave_Con_dest_conpoint:
      fp >> dest_conpoint;
      break;
    case flow_eSave_Con_source_conpoint:
      fp >> source_conpoint;
      break;
    case flow_eSave_Con_dest_direction:
      fp >> tmp;
      dest_direction = (flow_eDirection)tmp;
      break;
    case flow_eSave_Con_source_direction:
      fp >> tmp;
      source_direction = (flow_eDirection)tmp;
      break;
    case flow_eSave_Con_line_a:
      line_a.open(ctx, fp);
      break;
    case flow_eSave_Con_arc_a:
      arc_a.open(ctx, fp);
      break;
    case flow_eSave_Con_arrow_a:
      arrow_a.open(ctx, fp);
      break;
    case flow_eSave_Con_ref_a:
      ref_a.open(ctx, fp);
      break;
    case flow_eSave_Con_p_num:
      fp >> p_num;
      break;
    case flow_eSave_Con_l_num:
      fp >> l_num;
      break;
    case flow_eSave_Con_a_num:
      fp >> a_num;
      break;
    case flow_eSave_Con_arrow_num:
      fp >> arrow_num;
      break;
    case flow_eSave_Con_ref_num:
      fp >> ref_num;
      break;
    case flow_eSave_Con_point_x:
      for (int i = 0; i < p_num; i++)
        fp >> point_x[i];
      break;
    case flow_eSave_Con_point_y:
      for (int i = 0; i < p_num; i++)
        fp >> point_y[i];
      break;
    case flow_eSave_Con_source_ref_cnt:
      fp >> source_ref_cnt;
      break;
    case flow_eSave_Con_dest_ref_cnt:
      fp >> dest_ref_cnt;
      break;
    case flow_eSave_Con_trace_object:
      fp.get();
      fp.getline(trace_object, sizeof(trace_object));
      break;
    case flow_eSave_Con_trace_attribute:
      fp.get();
      fp.getline(trace_attribute, sizeof(trace_attribute));
      break;
    case flow_eSave_Con_trace_attr_type:
      fp >> tmp;
      trace_attr_type = (flow_eTraceType)tmp;
      break;
    case flow_eSave_Con_temporary_ref:
      fp >> temporary_ref;
      break;
    case flow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "FlowCon:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

void FlowCon::draw(int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;
  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * ctx->zoom_factor - ctx->offset_x >= ll_x
      && x_left * ctx->zoom_factor - ctx->offset_x <= ur_x
      && y_high * ctx->zoom_factor - ctx->offset_y >= ll_y
      && y_low * ctx->zoom_factor - ctx->offset_y <= ur_y) {
    if (temporary_ref || cc->con_type == flow_eConType_Reference)
      ref_a.draw(&cc->zero, highlight, dimmed, hot, NULL);
    else {
      for (int i = 0; i < l_num; i++)
        ((FlowLine*)line_a[i])->draw(&cc->zero, highlight, dimmed, hot, NULL);
      for (int i = 0; i < a_num; i++)
        ((FlowArc*)arc_a[i])->draw(&cc->zero, highlight, dimmed, hot, NULL);
      arrow_a.draw(&cc->zero, highlight, dimmed, hot, NULL);
    }
  }
}

void FlowCon::nav_draw(int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;
  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * ctx->nav_zoom_factor - ctx->nav_offset_x >= ll_x
      && x_left * ctx->nav_zoom_factor - ctx->nav_offset_x <= ur_x
      && y_high * ctx->nav_zoom_factor - ctx->nav_offset_y >= ll_y
      && y_low * ctx->nav_zoom_factor - ctx->nav_offset_y <= ur_y) {
    if (temporary_ref || cc->con_type == flow_eConType_Reference)
      ref_a.nav_draw(&cc->zero, highlight, NULL);
    else {
      for (int i = 0; i < l_num; i++)
        ((FlowLine*)line_a[i])->nav_draw(&cc->zero, highlight, NULL);
      for (int i = 0; i < a_num; i++)
        ((FlowArc*)arc_a[i])->nav_draw(&cc->zero, highlight, NULL);
      arrow_a.nav_draw(&cc->zero, highlight, NULL);
    }
  }
}

int FlowCon::con_route_noobstacle(double src_x, double src_y,
    flow_eDirection src_dir, double dest_x, double dest_y,
    flow_eDirection dest_dir)
{
  double x[8], y[8];

  x[0] = src_x;
  y[0] = src_y;
  int point = 1;

  route_eState state = eState_No;
  if (src_dir == flow_eDirection_Right && dest_dir == flow_eDirection_Left)
    state = eState_RightToLeft;
  else if (src_dir == flow_eDirection_Left && dest_dir == flow_eDirection_Right)
    state = eState_LeftToRight;
  else if (src_dir == flow_eDirection_Left && dest_dir == flow_eDirection_Left)
    state = eState_LeftToLeft;
  else if (src_dir == flow_eDirection_Right
      && dest_dir == flow_eDirection_Right)
    state = eState_RightToRight;

  for (;;) {
    switch (state) {
    case eState_RightToLeft:
      /* Right to Left */
      if (x[point - 1] < dest_x) {
        x[point] = (x[point - 1] + dest_x) / 2;
        y[point] = y[point - 1];
        x[point + 1] = x[point];
        y[point + 1] = dest_y;
        x[point + 2] = dest_x;
        y[point + 2] = dest_y;
        point += 3;
        state = eState_Success;
      } else {
        x[point] = x[point - 1] + 1;
        y[point] = y[point - 1];
        point++;
        if (y[point - 1] < dest_y)
          state = eState_UpToLeft; // Up to left
        else
          state = eState_DownToLeft; // Down to left
      }
      break;
    case eState_UpToLeft:
      /* Up to Left */
      if (y[point - 1] > dest_y) {
        x[point] = x[point - 1];
        y[point] = y[point - 1] + 1;
        point++;
        if (x[point - 1] > dest_x)
          state = eState_LeftToLeft;
        else
          state = eState_RightToLeft;
      } else {
        if (x[point - 1] < dest_x) {
          x[point] = x[point - 1];
          y[point] = dest_y;
          x[point + 1] = dest_x;
          y[point + 1] = dest_y;
          point += 2;
          state = eState_Success;
        } else {
          x[point] = x[point - 1];
          y[point] = y[point - 1] + 1;
          point++;
          state = eState_LeftToLeft; // Left to left
        }
      }
      break;
    case eState_UpToRight:
      /* Up to Right */
      if (y[point - 1] > dest_y) {
        x[point] = x[point - 1];
        y[point] = y[point - 1] + 1;
        if (x[point - 1] < dest_x)
          state = eState_RightToRight;
        else
          state = eState_LeftToRight;
        point++;
      } else {
        if (x[point - 1] > dest_x) {
          x[point] = x[point - 1];
          y[point] = dest_y;
          x[point + 1] = dest_x;
          y[point + 1] = dest_y;
          point += 2;
          state = eState_Success;
        } else {
          x[point] = x[point - 1];
          y[point] = y[point - 1] + 1;
          point++;
          state = eState_RightToRight; // Right to Right
        }
      }
      break;
    case eState_LeftToLeft:
      /* Left to left */
      if (x[point - 1] > dest_x) {
        x[point] = dest_x - 1;
        y[point] = y[point - 1];
        point++;
      } else {
        x[point] = x[point - 1] - 1;
        y[point] = y[point - 1];
        point++;
      }
      if (y[point - 1] < dest_y)
        state = eState_UpToLeft; // Up to left
      else
        state = eState_DownToLeft; // Down to left
      break;
    case eState_RightToRight:
      /* Right to right */
      if (x[point - 1] < dest_x) {
        x[point] = dest_x + 1;
        y[point] = y[point - 1];
        point++;
      } else {
        x[point] = x[point - 1] + 1;
        y[point] = y[point - 1];
        point++;
      }
      if (y[point - 1] < dest_y)
        state = eState_UpToRight; // Up to right
      else
        state = eState_DownToRight; // Down to right
      break;
    case eState_DownToLeft:
      /* Down to left */
      if (y[point - 1] < dest_y) {
        x[point] = x[point - 1];
        y[point] = y[point - 1] - 1;
        point++;
        if (x[point - 1] > dest_x)
          state = eState_LeftToLeft;
        else
          state = eState_RightToLeft;
      } else {
        if (x[point - 1] < dest_x) {
          x[point] = x[point - 1];
          y[point] = dest_y;
          x[point + 1] = dest_x;
          y[point + 1] = dest_y;
          point += 2;
          state = eState_Success;
        } else {
          x[point] = x[point - 1];
          y[point] = y[point - 1] - 1;
          point++;
          state = eState_LeftToLeft; // Left to left
        }
      }
      break;
    case eState_DownToRight:
      /* Down to right */
      if (y[point - 1] < dest_y) {
        x[point] = x[point - 1];
        y[point] = y[point - 1] - 1;
        point++;
        if (y[point - 1] < dest_y)
          state = eState_RightToRight;
        else
          state = eState_LeftToRight;
      } else {
        if (x[point - 1] > dest_x) {
          x[point] = x[point - 1];
          y[point] = dest_y;
          x[point + 1] = dest_x;
          y[point + 1] = dest_y;
          point += 2;
          state = eState_Success;
        } else {
          x[point] = x[point - 1];
          y[point] = y[point - 1] - 1;
          point++;
          state = eState_RightToRight; // Right to right
        }
      }
      break;
    case eState_LeftToRight:
      /* Left to Right */
      if (x[point - 1] > dest_x) {
        x[point] = (x[point - 1] + dest_x) / 2;
        y[point] = y[point - 1];
        x[point + 1] = x[point];
        y[point + 1] = dest_y;
        x[point + 2] = dest_x;
        y[point + 2] = dest_y;
        point += 3;
        state = eState_Success;
      } else {
        x[point] = x[point - 1] - 1;
        y[point] = y[point - 1];
        point++;
        if (y[point - 1] < dest_y)
          state = eState_UpToRight; // Up to right
        else
          state = eState_DownToRight; // Down to right
      }
      break;
    case eState_Success:
      /* Routing found */
      if (cc->corner == flow_eCorner_Rounded)
        draw_routed_roundcorner(point, x, y);
      else
        draw_routed(point, x, y);

      state = eState_Exit;
      break;
    default:
      std::cout << "Unknown state\n";
      state = eState_Exit;
    }
    if (state == eState_Exit)
      break;
    if (point > 9) {
      /* Max number of points exceeded */
      point = 8;
      state = eState_Success;
    }
  }
  //  printf("route : %d\n", point);
  return 1;
}

int FlowCon::con_route_grafcet(flow_eConType con_type, double src_x,
    double src_y, double dest_x, double dest_y)
{
  double x[8], y[8];

  switch (con_type) {
  case flow_eConType_StepDiv: {
    int point = 0;
    x[point] = src_x;
    y[point++] = src_y;
    x[point] = src_x;
    y[point++] = src_y + ctx->grafcet_con_delta;
    if (src_y + ctx->grafcet_con_delta < dest_y) {
      x[point] = dest_x;
      y[point++] = src_y + ctx->grafcet_con_delta;
    } else if (src_x > dest_x) {
      x[point] = dest_x + 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + ctx->grafcet_con_delta;
      x[point] = dest_x + 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - ctx->grafcet_con_delta;
    } else {
      x[point] = dest_x - 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + ctx->grafcet_con_delta;
      x[point] = dest_x - 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - ctx->grafcet_con_delta;
    }
    x[point] = dest_x;
    y[point++] = dest_y;
    p_num = point;
    draw_routed(point, x, y);
    break;
  }
  case flow_eConType_StepConv: {
    int point = 0;
    x[point] = dest_x;
    y[point++] = dest_y;
    x[point] = dest_x;
    y[point++] = dest_y - ctx->grafcet_con_delta;
    if (dest_y - ctx->grafcet_con_delta > src_y) {
      x[point] = src_x;
      y[point++] = dest_y - ctx->grafcet_con_delta;
    } else if (dest_x > src_x) {
      x[point] = src_x + 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - ctx->grafcet_con_delta;
      x[point] = src_x + 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + ctx->grafcet_con_delta;
    } else {
      x[point] = src_x - 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - ctx->grafcet_con_delta;
      x[point] = src_x - 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + ctx->grafcet_con_delta;
    }
    x[point] = src_x;
    y[point++] = src_y;
    p_num = point;
    draw_routed(point, x, y);
    break;
  }
  case flow_eConType_TransDiv: {
    int point = 0;
    x[point] = src_x;
    y[point++] = src_y;
    x[point] = src_x;
    y[point++] = src_y + 0.8 * ctx->grafcet_con_delta;
    if (src_y + ctx->grafcet_con_delta < dest_y) {
      x[point] = dest_x;
      y[point++] = src_y + 0.8 * ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + 1.2 * ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = src_y + 1.2 * ctx->grafcet_con_delta;
    } else if (src_x > dest_x) {
      x[point] = dest_x + 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + 0.8 * ctx->grafcet_con_delta;
      x[point] = dest_x + 2 * ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + 1.2 * ctx->grafcet_con_delta;
      x[point] = dest_x + 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + 1.2 * ctx->grafcet_con_delta;
      x[point] = dest_x + 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - ctx->grafcet_con_delta;
    } else {
      x[point] = dest_x - 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + 0.8 * ctx->grafcet_con_delta;
      x[point] = dest_x - 2 * ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + 1.2 * ctx->grafcet_con_delta;
      x[point] = dest_x - 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + 1.2 * ctx->grafcet_con_delta;
      x[point] = dest_x - 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - ctx->grafcet_con_delta;
    }
    x[point] = dest_x;
    y[point++] = dest_y;
    p_num = point;
    draw_routed_trans(point, x, y);
    break;
  }
  case flow_eConType_TransConv: {
    int point = 0;
    x[point] = dest_x;
    y[point++] = dest_y;
    x[point] = dest_x;
    y[point++] = dest_y - 0.8 * ctx->grafcet_con_delta;
    if (dest_y - ctx->grafcet_con_delta > src_y) {
      x[point] = src_x;
      y[point++] = dest_y - 0.8 * ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - 1.2 * ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = dest_y - 1.2 * ctx->grafcet_con_delta;
    } else if (dest_x > src_x) {
      x[point] = src_x + 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - 0.8 * ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - 1.2 * ctx->grafcet_con_delta;
      x[point] = src_x + 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - 1.2 * ctx->grafcet_con_delta;
      x[point] = src_x + 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + ctx->grafcet_con_delta;
    } else {
      x[point] = src_x - 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - 0.8 * ctx->grafcet_con_delta;
      x[point] = src_x - 2 * ctx->grafcet_con_delta;
      x[point] = dest_x;
      y[point++] = dest_y - 1.2 * ctx->grafcet_con_delta;
      x[point] = src_x - 2 * ctx->grafcet_con_delta;
      y[point++] = dest_y - 1.2 * ctx->grafcet_con_delta;
      x[point] = src_x - 2 * ctx->grafcet_con_delta;
      y[point++] = src_y + ctx->grafcet_con_delta;
      x[point] = src_x;
      y[point++] = src_y + ctx->grafcet_con_delta;
    }
    x[point] = src_x;
    y[point++] = src_y;
    p_num = point;
    draw_routed_trans(point, x, y);
    break;
  }
  default:;
  }
  for (int i = 0; i < p_num; i++) {
    point_x[i] = x[i];
    point_y[i] = y[i];
  }
  return 1;
}

int FlowCon::con_route(double src_x, double src_y, flow_eDirection src_dir,
    double dest_x, double dest_y, flow_eDirection dest_dir)
{
  double ll_x = MIN(source_node->x_left, dest_node->x_left) - 10 * ctx->draw_delta;
  double ur_x = MAX(source_node->x_right, dest_node->x_right) + 10 * ctx->draw_delta;
  double ll_y = MIN(source_node->y_low, dest_node->y_low) - 10 * ctx->draw_delta;
  double ur_y = MAX(source_node->y_high, dest_node->y_high) + 10 * ctx->draw_delta;

  /* Find the document node */
  FlowNode* doc = (FlowNode*)ctx->get_document(src_x, src_y);
  if (doc) {
    double doc_ll_x, doc_ur_x, doc_ll_y, doc_ur_y;
    doc->measure(&doc_ll_x, &doc_ll_y, &doc_ur_x, &doc_ur_y);
    ll_x = MAX(ll_x, doc_ll_x);
    ur_x = MIN(ur_x, doc_ur_x);
    ll_y = MAX(ll_y, doc_ll_y);
    ur_y = MIN(ur_y, doc_ur_y);

    if (dest_x < doc_ll_x || dest_x > doc_ur_x || dest_y < doc_ll_y
        || dest_y > doc_ur_y || src_x < doc_ll_x || src_x > doc_ur_x
        || src_y < doc_ll_y || src_y > doc_ur_y)
      return 0;
  }

  return con_route_area(ll_x, ll_y, ur_x, ur_y);
}

int FlowCon::con_route_area(
    double wind_ll_x, double wind_ll_y, double wind_ur_x, double wind_ur_y)
{
  /* Get the objects in this area */
  FlowNode* nodelist = 0;
  FlowCon* conlist = 0;
  for (int i = 0; i < ctx->a.size(); i++) {
    if (ctx->a[i]->in_area(wind_ll_x, wind_ll_y, wind_ur_x, wind_ur_y)) {
      if (ctx->a[i]->type() == flow_eObjectType_Node)
        ctx->a[i]->link_insert((FlowArrayElem**)&nodelist);
      if (ctx->a[i]->type() == flow_eObjectType_Con
          && ctx->a[i] != (FlowArrayElem*)this)
        ctx->a[i]->link_insert((FlowArrayElem**)&conlist);
    }
  }
  if (!nodelist)
    return 0;

  double src_x, src_y, dest_x, dest_y;
  flow_eDirection src_dir, dest_dir;
  int sts = dest_node->get_conpoint(dest_conpoint, &dest_x, &dest_y, &dest_dir);
  if (EVEN(sts))
    return sts;
  sts = source_node->get_conpoint(source_conpoint, &src_x, &src_y, &src_dir);
  if (EVEN(sts))
    return sts;

  double x[8], y[8];
  /* Find straight line between source and destination */
  if (fabs(dest_y - src_y) < CON_EPSILON
      && ((dest_dir == flow_eDirection_Right && src_dir == flow_eDirection_Left
              && dest_x <= src_x)
             || (dest_dir == flow_eDirection_Left
                    && src_dir == flow_eDirection_Right && dest_x >= src_x))) {
    int found = 0;
    for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
      if (node_p->in_horiz_line(dest_y,
              MIN(dest_x, src_x) + ctx->draw_delta + CON_EPSILON,
              MAX(dest_x, src_x) - ctx->draw_delta - CON_EPSILON)) {
        found = 1;
        break;
      }
    }
    if (!found) {
      x[0] = dest_x;
      y[0] = dest_y;
      x[1] = src_x;
      y[1] = src_y;
      point_x[0] = x[0] = dest_x;
      point_y[0] = y[0] = dest_y;
      point_x[1] = x[1] = src_x;
      point_y[1] = y[1] = src_y;
      int point = p_num = 2;
      if (cc->corner == flow_eCorner_Rounded)
        draw_routed_roundcorner(point, x, y);
      else
        draw_routed(point, x, y);
      return 1;
    }
  } else if (fabs(dest_x - src_x) < CON_EPSILON
      && ((dest_dir == flow_eDirection_Up && src_dir == flow_eDirection_Down
              && dest_y <= src_y)
             || (dest_dir == flow_eDirection_Down
                    && src_dir == flow_eDirection_Up && dest_y >= src_y))) {
    int found = 0;
    for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
      if (node_p->in_vert_line(dest_x,
              MIN(dest_y, src_y) + ctx->draw_delta + CON_EPSILON,
              MAX(dest_y, src_y) - ctx->draw_delta - CON_EPSILON)) {
        found = 1;
        break;
      }
    }
    if (!found) {
      x[0] = dest_x;
      y[0] = dest_y;
      x[1] = src_x;
      y[1] = src_y;
      point_x[0] = x[0] = dest_x;
      point_y[0] = y[0] = dest_y;
      point_x[1] = x[1] = src_x;
      point_y[1] = y[1] = src_y;
      int point = p_num = 2;
      if (cc->corner == flow_eCorner_Rounded)
        draw_routed_roundcorner(point, x, y);
      else
        draw_routed(point, x, y);
      return 1;
    }
  }

  /* Find vertical routing lines */
  vert_line_cnt = 0;
  find_vert_line_right(wind_ll_x, wind_ll_y, wind_ur_y, nodelist,
      nodelist, conlist, conlist, wind_ll_y, wind_ur_y);
  find_vert_line_left(wind_ur_x, wind_ll_y, wind_ur_y, nodelist, nodelist,
      conlist, conlist, wind_ll_y, wind_ur_y);

  for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
    if (node_p->obst_x_right < wind_ur_x)
      find_vert_line_right(node_p->obst_x_right, node_p->obst_y_low,
          node_p->obst_y_high, nodelist, node_p->link, conlist, conlist,
          wind_ll_y, wind_ur_y);
    if (node_p->obst_x_left > wind_ll_x)
      find_vert_line_left(node_p->obst_x_left, node_p->obst_y_low,
          node_p->obst_y_high, nodelist, node_p->link, conlist, conlist,
          wind_ll_y, wind_ur_y);
    if (vert_line_cnt > HV_LINE_ARRAY_SIZE - 3)
      break;
  }

  /* Find horizontal routing lines */
  horiz_line_cnt = 0;
  find_horiz_line_up(wind_ll_y, wind_ll_x, wind_ur_x, nodelist, nodelist,
      conlist, conlist, wind_ll_x, wind_ur_x);
  find_horiz_line_down(wind_ur_y, wind_ll_x, wind_ur_x, nodelist,
      nodelist, conlist, conlist, wind_ll_x, wind_ur_x);

  for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
    if (node_p->obst_y_high < wind_ur_y)
      find_horiz_line_up(node_p->obst_y_high, node_p->obst_x_left,
          node_p->obst_x_right, nodelist, node_p->link, conlist, conlist,
          wind_ll_x, wind_ur_x);
    if (node_p->obst_y_low > wind_ll_y)
      find_horiz_line_down(node_p->obst_y_low, node_p->obst_x_left,
          node_p->obst_x_right, nodelist, node_p->link, conlist, conlist,
          wind_ll_x, wind_ur_x);
    if (horiz_line_cnt > HV_LINE_ARRAY_SIZE - 3)
      break;
  }

  if (dest_dir == flow_eDirection_Center) {
    switch (src_dir) {
    case flow_eDirection_Center:
      if (src_y > dest_y)
        dest_dir = flow_eDirection_Up;
      else
        dest_dir = flow_eDirection_Down;
      if (dest_x > src_x)
        src_dir = flow_eDirection_Right;
      else
        src_dir = flow_eDirection_Left;
      break;
    case flow_eDirection_Right:
    case flow_eDirection_Left:
      if (src_y > dest_y)
        dest_dir = flow_eDirection_Up;
      else
        dest_dir = flow_eDirection_Down;
      break;
    case flow_eDirection_Up:
    case flow_eDirection_Down:
      if (src_x > dest_y)
        dest_dir = flow_eDirection_Right;
      else
        dest_dir = flow_eDirection_Left;
      break;
    }
  } else if (src_dir == flow_eDirection_Center) {
    switch (dest_dir) {
    case flow_eDirection_Center:
      if (dest_y > src_y)
        src_dir = flow_eDirection_Up;
      else
        src_dir = flow_eDirection_Down;
      if (src_x > dest_x)
        dest_dir = flow_eDirection_Right;
      else
        dest_dir = flow_eDirection_Left;
      break;
    case flow_eDirection_Right:
    case flow_eDirection_Left:
      if (dest_y > src_y)
        src_dir = flow_eDirection_Up;
      else
        src_dir = flow_eDirection_Down;
      break;
    case flow_eDirection_Up:
    case flow_eDirection_Down:
      if (dest_x > src_y)
        src_dir = flow_eDirection_Right;
      else
        src_dir = flow_eDirection_Left;
      break;
    }
  }

  /* Add the destination point line */
  switch (dest_dir) {
  case flow_eDirection_Right:
    horiz_line[horiz_line_cnt].y = dest_y;
    horiz_line[horiz_line_cnt].l_x = dest_x;
    horiz_line[horiz_line_cnt].u_x = wind_ur_x - ctx->draw_delta;
    horiz_line[horiz_line_cnt].dest = 1;
    find_horiz_line_right_border(dest_y, dest_x, dest_x,
        &horiz_line[horiz_line_cnt].u_x, nodelist, conlist);
    horiz_line_cnt++;
    break;
  case flow_eDirection_Left:
    horiz_line[horiz_line_cnt].y = dest_y;
    horiz_line[horiz_line_cnt].u_x = dest_x;
    horiz_line[horiz_line_cnt].l_x = wind_ll_x + ctx->draw_delta;
    horiz_line[horiz_line_cnt].dest = 1;
    find_horiz_line_left_border(dest_y, dest_x, dest_x,
        &horiz_line[horiz_line_cnt].l_x, nodelist, conlist);
    horiz_line_cnt++;
    break;
  case flow_eDirection_Up:
    vert_line[vert_line_cnt].x = dest_x;
    vert_line[vert_line_cnt].l_y = dest_y;
    vert_line[vert_line_cnt].u_y = wind_ur_y - ctx->draw_delta;
    vert_line[vert_line_cnt].dest = 1;
    find_vert_line_high_border(dest_x, dest_y, dest_y,
        &vert_line[vert_line_cnt].u_y, nodelist, conlist);
    vert_line_cnt++;
    break;
  case flow_eDirection_Down:
    vert_line[vert_line_cnt].x = dest_x;
    vert_line[vert_line_cnt].l_y = wind_ll_y + ctx->draw_delta;
    vert_line[vert_line_cnt].u_y = dest_y;
    vert_line[vert_line_cnt].dest = 1;
    find_vert_line_low_border(dest_x, dest_y, dest_y,
        &vert_line[vert_line_cnt].l_y, nodelist, conlist);
    vert_line_cnt++;
    break;
  case flow_eDirection_Center:
    break;
  }

  /* Sort the lines */
  sort_lines(dest_x, dest_y, dest_dir, src_x, src_y, src_dir);
  current_line_cnt = 1000;
  loop_cnt = 0;

  /* Get the source point line */
  line_table_cnt = 0;
  switch (src_dir) {
  case flow_eDirection_Right:
    horiz_line[horiz_line_cnt].y = src_y;
    horiz_line[horiz_line_cnt].l_x = src_x;
    horiz_line[horiz_line_cnt].u_x = wind_ur_x - ctx->draw_delta;
    horiz_line[horiz_line_cnt].dest = 0;
    find_horiz_line_right_border(src_y, src_x, src_x,
        &horiz_line[horiz_line_cnt].u_x, nodelist, conlist);
    horiz_line_cnt++;
    line_table[0].horiz[0] = &horiz_line[horiz_line_cnt - 1];
    line_table[0].horiz_x[0] = src_x;
    line_table[0].horiz_y[0] = src_y;
    line_table[0].horiz_cnt = 1;
    line_table[0].vert_cnt = 0;
    line_table[0].complete = 0;
    line_table[0].start_type = eLineType_Horiz;
    find_horiz_line_next_line(&horiz_line[horiz_line_cnt - 1]);
    break;
  case flow_eDirection_Left:
    horiz_line[horiz_line_cnt].y = src_y;
    horiz_line[horiz_line_cnt].u_x = src_x;
    horiz_line[horiz_line_cnt].l_x = wind_ll_x + ctx->draw_delta;
    horiz_line[horiz_line_cnt].dest = 0;
    find_horiz_line_left_border(src_y, src_x, src_x,
        &horiz_line[horiz_line_cnt].l_x, nodelist, conlist);
    horiz_line_cnt++;
    line_table[0].horiz[0] = &horiz_line[horiz_line_cnt - 1];
    line_table[0].horiz_x[0] = src_x;
    line_table[0].horiz_y[0] = src_y;
    line_table[0].horiz_cnt = 1;
    line_table[0].vert_cnt = 0;
    line_table[0].complete = 0;
    line_table[0].start_type = eLineType_Horiz;
    find_horiz_line_next_line(&horiz_line[horiz_line_cnt - 1]);
    break;
  case flow_eDirection_Up:
    vert_line[vert_line_cnt].x = src_x;
    vert_line[vert_line_cnt].l_y = src_y;
    vert_line[vert_line_cnt].u_y = wind_ur_y - ctx->draw_delta;
    vert_line[vert_line_cnt].dest = 0;
    find_vert_line_high_border(
        src_x, src_y, src_y, &vert_line[vert_line_cnt].u_y, nodelist, conlist);
    vert_line_cnt++;
    line_table[0].vert[0] = &vert_line[vert_line_cnt - 1];
    line_table[0].vert_x[0] = src_x;
    line_table[0].vert_y[0] = src_y;
    line_table[0].vert_cnt = 1;
    line_table[0].horiz_cnt = 0;
    line_table[0].complete = 0;
    line_table[0].start_type = eLineType_Vert;
    find_vert_line_next_line(&vert_line[vert_line_cnt - 1]);
    break;
  case flow_eDirection_Down:
    vert_line[vert_line_cnt].x = src_x;
    vert_line[vert_line_cnt].l_y = wind_ll_y + ctx->draw_delta;
    vert_line[vert_line_cnt].u_y = src_y;
    vert_line[vert_line_cnt].dest = 0;
    find_vert_line_low_border(
        src_x, src_y, src_y, &vert_line[vert_line_cnt].l_y, nodelist, conlist);
    vert_line_cnt++;
    line_table[0].vert[0] = &vert_line[vert_line_cnt - 1];
    line_table[0].vert_x[0] = src_x;
    line_table[0].vert_y[0] = src_y;
    line_table[0].vert_cnt = 1;
    line_table[0].horiz_cnt = 0;
    line_table[0].complete = 0;
    line_table[0].start_type = eLineType_Vert;
    find_vert_line_next_line(&vert_line[vert_line_cnt - 1]);
    break;
  case flow_eDirection_Center:
    break;
  }

  /* Select the shortest */
  int min_idx = 0;
  int min_cnt = 10000;
  for (int i = 0; i < line_table_cnt; i++) {
    if (line_table[i].complete) {
      if (line_table[i].start_type == eLineType_Horiz) {
        if (min_cnt > line_table[i].horiz_cnt) {
          min_cnt = line_table[i].horiz_cnt;
          min_idx = i;
        }
      } else {
        if (min_cnt > line_table[i].horiz_cnt) {
          min_cnt = line_table[i].vert_cnt;
          min_idx = i;
        }
      }
    }
  }
  //  printf( "Shortest: %d  cnt %d (of %d)\n", min_idx, min_cnt,
  //  line_table_cnt);
  if (!line_table_cnt)
    return 0;

  /* Draw the con */
  int point = 0;
  if (line_table[min_idx].start_type == eLineType_Horiz) {
    for (int j = 0; j < line_table[min_idx].horiz_cnt; j++) {
      point_x[point] = x[point] = line_table[min_idx].horiz_x[j];
      point_y[point] = y[point] = line_table[min_idx].horiz_y[j];
      point++;
      if (j < line_table[min_idx].vert_cnt) {
        point_x[point] = x[point] = line_table[min_idx].vert_x[j];
        point_y[point] = y[point] = line_table[min_idx].vert_y[j];
        point++;
      }
    }
  } else {
    for (int j = 0; j < line_table[min_idx].vert_cnt; j++) {
      point_x[point] = x[point] = line_table[min_idx].vert_x[j];
      point_y[point] = y[point] = line_table[min_idx].vert_y[j];
      point++;
      if (j < line_table[min_idx].horiz_cnt) {
        point_x[point] = x[point] = line_table[min_idx].horiz_x[j];
        point_y[point] = y[point] = line_table[min_idx].horiz_y[j];
        point++;
      }
    }
  }
  if (point > MAX_POINT - 1)
    return 0;

  point_x[point] = x[point] = dest_x;
  point_y[point] = y[point] = dest_y;
  point++;
  p_num = point;

  if (cc->corner == flow_eCorner_Rounded)
    draw_routed_roundcorner(point, x, y);
  else
    draw_routed(point, x, y);

  return 1;
}

void print_line()
{
  printf("Line nr %d, ", line_table_cnt);
  if (line_table[line_table_cnt].start_type == eLineType_Horiz) {
    for (int j = 0; j < line_table[line_table_cnt].horiz_cnt; j++) {
      printf("%ld ", long(line_table[line_table_cnt].horiz[j]));
      if (j < line_table[line_table_cnt].vert_cnt)
        printf("%ld ", long(line_table[line_table_cnt].vert[j]));
    }
  } else {
    for (int j = 0; j < line_table[line_table_cnt].vert_cnt; j++) {
      printf("%ld ", long(line_table[line_table_cnt].vert[j]));
      if (j < line_table[line_table_cnt].horiz_cnt)
        printf("%ld ", long(line_table[line_table_cnt].horiz[j]));
    }
  }
  printf("\n");
}

int con_cmp_v1(const void* l1, const void* l2)
{
  /* l1 is left and l2 is right of dest */
  if (((con_tVertLines*)l1)->x < sort_dest_x
      && ((con_tVertLines*)l2)->x > sort_dest_x)
    return 1;

  /* l2 is left and l1 is right of dest */
  if (((con_tVertLines*)l2)->x < sort_dest_x
      && ((con_tVertLines*)l1)->x > sort_dest_x)
    return -1;

  return (fabs(((con_tVertLines*)l1)->x - sort_dest_x)
      > fabs(((con_tVertLines*)l2)->x - sort_dest_x));
}

int con_cmp_v2(const void* l1, const void* l2)
{
  /* l1 is right and l2 is left of dest */
  if (((con_tVertLines*)l1)->x > sort_dest_x
      && ((con_tVertLines*)l2)->x < sort_dest_x)
    return 1;

  /* l2 is right and l1 is left of dest */
  if (((con_tVertLines*)l2)->x > sort_dest_x
      && ((con_tVertLines*)l1)->x < sort_dest_x)
    return -1;

  return (fabs(((con_tVertLines*)l1)->x - sort_dest_x)
      > fabs(((con_tVertLines*)l2)->x - sort_dest_x));
}

int con_cmp_h1(const void* l1, const void* l2)
{
  return (fabs(((con_tHorizLines*)l1)->y - sort_dest_y)
      > fabs(((con_tHorizLines*)l2)->y - sort_dest_y));
}

int con_cmp_h2(const void* l1, const void* l2)
{
  /* l1 intersects with the dest-node and not l2 */
  if ((sort_dest->obst_y_low < ((con_tHorizLines*)l1)->y
          && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_high
          && ((con_tHorizLines*)l1)->l_x > sort_dest_x)
      && !(sort_dest->obst_y_low < ((con_tHorizLines*)l2)->y
             && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_high
             && ((con_tHorizLines*)l2)->l_x > sort_dest_x))
    return 1;

  /* l2 intersects with the dest-node and not l1 */
  if ((sort_dest->obst_y_low < ((con_tHorizLines*)l2)->y
          && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_high
          && ((con_tHorizLines*)l2)->l_x > sort_dest_x)
      && !(sort_dest->obst_y_low < ((con_tHorizLines*)l1)->y
             && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_high
             && ((con_tHorizLines*)l1)->l_x > sort_dest_x))
    return -1;

  /* l1 is between dest and source and not l2 */
  if ((sort_dest->obst_y_high < sort_source->obst_y_low)
      && (sort_dest->obst_y_high < ((con_tHorizLines*)l1)->y
             && ((con_tHorizLines*)l1)->y < sort_source->obst_y_low)
      && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_low)
    return -1;

  /* l2 is between dest and source and not l1 */
  if ((sort_dest->obst_y_high < sort_source->obst_y_low)
      && (sort_dest->obst_y_high < ((con_tHorizLines*)l2)->y
             && ((con_tHorizLines*)l2)->y < sort_source->obst_y_low)
      && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_low)
    return 1;

  /* l1 is between dest and source and not l2 */
  if ((sort_dest->obst_y_low > sort_source->obst_y_high)
      && (sort_source->obst_y_high < ((con_tHorizLines*)l1)->y
             && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_low)
      && (((con_tHorizLines*)l2)->y < sort_source->obst_y_low
             || ((con_tHorizLines*)l2)->y > sort_dest->obst_y_high))
    return -1;

  /* l2 is between dest and source and not l1 */
  if ((sort_dest->obst_y_low > sort_source->obst_y_high)
      && (sort_source->obst_y_high < ((con_tHorizLines*)l2)->y
             && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_low)
      && (((con_tHorizLines*)l1)->y < sort_source->obst_y_low
             || ((con_tHorizLines*)l1)->y > sort_dest->obst_y_high))
    return 1;

  return (fabs(((con_tHorizLines*)l1)->y - sort_dest_y)
      > fabs(((con_tHorizLines*)l2)->y - sort_dest_y));
}

int con_cmp_h3(const void* l1, const void* l2)
{
  /* l1 intersects with the dest-node and not l2 */
  if ((sort_dest->obst_y_low < ((con_tHorizLines*)l1)->y
          && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_high
          && ((con_tHorizLines*)l1)->l_x < sort_dest_x)
      && !(sort_dest->obst_y_low < ((con_tHorizLines*)l2)->y
             && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_high
             && ((con_tHorizLines*)l2)->l_x < sort_dest_x))
    return 1;

  /* l2 intersects with the dest-node and not l1 */
  if ((sort_dest->obst_y_low < ((con_tHorizLines*)l2)->y
          && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_high
          && ((con_tHorizLines*)l2)->l_x < sort_dest_x)
      && !(sort_dest->obst_y_low < ((con_tHorizLines*)l1)->y
             && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_high
             && ((con_tHorizLines*)l1)->l_x < sort_dest_x))
    return -1;

  /* l1 is between dest and source and l2 is lower then dest */
  if ((sort_dest->obst_y_high < sort_source->obst_y_low)
      && (sort_dest->obst_y_high < ((con_tHorizLines*)l1)->y
             && ((con_tHorizLines*)l1)->y < sort_source->obst_y_low)
      && (((con_tHorizLines*)l2)->y < sort_source->obst_y_low
             || ((con_tHorizLines*)l2)->y > sort_dest->obst_y_high))
    return -1;

  /* l2 is between dest and source and l1 is lower then dest or higher then
   * src*/
  if ((sort_dest->obst_y_high < sort_source->obst_y_low)
      && (sort_dest->obst_y_high < ((con_tHorizLines*)l2)->y
             && ((con_tHorizLines*)l2)->y < sort_source->obst_y_low)
      && (((con_tHorizLines*)l1)->y < sort_source->obst_y_low
             || ((con_tHorizLines*)l1)->y > sort_dest->obst_y_high))
    return 1;

  /* l1 is between dest and source and l2 is higher than dest */
  if ((sort_dest->obst_y_low > sort_source->obst_y_high)
      && (sort_source->obst_y_high < ((con_tHorizLines*)l1)->y
             && ((con_tHorizLines*)l1)->y < sort_dest->obst_y_low)
      && ((con_tHorizLines*)l2)->y > sort_dest->obst_y_high)
    return -1;

  /* l2 is between dest and source and l1 is higher than dest */
  if ((sort_dest->obst_y_low > sort_source->obst_y_high)
      && (sort_source->obst_y_high < ((con_tHorizLines*)l2)->y
             && ((con_tHorizLines*)l2)->y < sort_dest->obst_y_low)
      && ((con_tHorizLines*)l1)->y > sort_dest->obst_y_high)
    return 1;

  return (fabs(((con_tHorizLines*)l1)->y - sort_dest_y)
      > fabs(((con_tHorizLines*)l2)->y - sort_dest_y));
}

int FlowCon::sort_lines(double dest_x, double dest_y, flow_eDirection dest_dir,
    double src_x, double src_y, flow_eDirection src_dir)
{
  sort_dest_x = dest_x;
  sort_dest_y = dest_y;
  sort_source = source_node;
  sort_dest = dest_node;
  if (dest_dir == flow_eDirection_Right && src_dir == flow_eDirection_Left
      && src_x > dest_x) {
    qsort(vert_line, vert_line_cnt, sizeof(vert_line[0]), con_cmp_v1);
    qsort(horiz_line, horiz_line_cnt, sizeof(horiz_line[0]), con_cmp_h1);
    ideal_line_cnt = 3;
  } else if (dest_dir == flow_eDirection_Right
      && src_dir == flow_eDirection_Left && src_x <= dest_x) {
    qsort(vert_line, vert_line_cnt, sizeof(vert_line[0]), con_cmp_v1);
    qsort(horiz_line, horiz_line_cnt, sizeof(horiz_line[0]), con_cmp_h3);
    ideal_line_cnt = 5;
  } else if (dest_dir == flow_eDirection_Left
      && src_dir == flow_eDirection_Right && src_x < dest_x) {
    qsort(vert_line, vert_line_cnt, sizeof(vert_line[0]), con_cmp_v2);
    qsort(horiz_line, horiz_line_cnt, sizeof(horiz_line[0]), con_cmp_h1);
    ideal_line_cnt = 3;
  } else if (dest_dir == flow_eDirection_Left
      && src_dir == flow_eDirection_Right && src_x > dest_x) {
    qsort(vert_line, vert_line_cnt, sizeof(vert_line[0]), con_cmp_v2);
    qsort(horiz_line, horiz_line_cnt, sizeof(horiz_line[0]), con_cmp_h2);
    ideal_line_cnt = 5;
  } else if (dest_dir == flow_eDirection_Right
      && src_dir == flow_eDirection_Right) {
    qsort(vert_line, vert_line_cnt, sizeof(vert_line[0]), con_cmp_v1);
    qsort(horiz_line, horiz_line_cnt, sizeof(horiz_line[0]), con_cmp_h1);
    ideal_line_cnt = 3;
  } else if (dest_dir == flow_eDirection_Left
      && src_dir == flow_eDirection_Left) {
    qsort(vert_line, vert_line_cnt, sizeof(vert_line[0]), con_cmp_v2);
    qsort(horiz_line, horiz_line_cnt, sizeof(horiz_line[0]), con_cmp_h1);
    ideal_line_cnt = 3;
  }

  return 1;
}

int FlowCon::find_horiz_line_next_line(con_tHorizLines* h_line)
{
  loop_cnt++;
  if (loop_cnt > ROUTE_LOOP_MAX)
    return 0;
  if (line_table_cnt >= LINE_TABLE_SIZE)
    return 0;

  /* Find vertical lines that intercept */
  for (int i = 0; i < vert_line_cnt; i++) {
    if (h_line->l_x <= vert_line[i].x && vert_line[i].x <= h_line->u_x
        && vert_line[i].l_y <= h_line->y && h_line->y <= vert_line[i].u_y) {
      if (vert_line[i].dest) {
        /* The route is complete */
        if (line_table_cnt >= LINE_TABLE_SIZE)
          return 0;
        if (line_table[line_table_cnt].vert_cnt
                + line_table[line_table_cnt].horiz_cnt
            >= current_line_cnt - 1)
          return 1;

        memcpy(&line_table[line_table_cnt + 1], &line_table[line_table_cnt],
            sizeof(line_table[0]));
        line_table[line_table_cnt].vert[line_table[line_table_cnt].vert_cnt]
            = &vert_line[i];
        line_table[line_table_cnt].vert_x[line_table[line_table_cnt].vert_cnt]
            = vert_line[i].x;
        line_table[line_table_cnt].vert_y[line_table[line_table_cnt].vert_cnt]
            = h_line->y;
        line_table[line_table_cnt].vert_cnt++;
        current_line_cnt = line_table[line_table_cnt].vert_cnt
            + line_table[line_table_cnt].horiz_cnt;
        line_table[line_table_cnt].complete = 1;
        line_table_cnt++;
        if (current_line_cnt == ideal_line_cnt)
          return CON__ROUTE_FOUND;
      } else {
        if ((line_table[line_table_cnt].vert_cnt
                    + line_table[line_table_cnt].horiz_cnt
                < current_line_cnt - 1)
            && (line_table[line_table_cnt].vert_cnt
                       + line_table[line_table_cnt].horiz_cnt
                   < MAX_POINT - 1)) {
          /* Check that the line is not already inserted */
          int found = 0;
          for (int j = 0; j < line_table[line_table_cnt].vert_cnt; j++) {
            if (line_table[line_table_cnt].vert[j] == &vert_line[i]) {
              found = 1;
              break;
            }
          }
          if (!found) {
            /* Try this line  */

            /* Store the counters */
            int vert_cnt = line_table[line_table_cnt].vert_cnt;
            int horiz_cnt = line_table[line_table_cnt].horiz_cnt;

            line_table[line_table_cnt].vert[line_table[line_table_cnt].vert_cnt]
                = &vert_line[i];
            line_table[line_table_cnt]
                .vert_x[line_table[line_table_cnt].vert_cnt]
                = vert_line[i].x;
            line_table[line_table_cnt]
                .vert_y[line_table[line_table_cnt].vert_cnt]
                = h_line->y;
            line_table[line_table_cnt].vert_cnt++;
            //            printf( "Trying vert: %d, vert_cnt %d, horiz_cnt %d nr
            //            %d\n",
            //		&vert_line[i], line_table[line_table_cnt].vert_cnt,
            //		line_table[line_table_cnt].horiz_cnt, i);
            //	    print_line();
            int sts = find_vert_line_next_line(&vert_line[i]);
            if (sts == CON__ROUTE_FOUND || EVEN(sts))
              return sts;

            /* Restore the counters */
            line_table[line_table_cnt].vert_cnt = vert_cnt;
            line_table[line_table_cnt].horiz_cnt = horiz_cnt;
          }
        }
      }
    }
  }
  return 1;
}

int FlowCon::find_vert_line_next_line(con_tVertLines* v_line)
{
  loop_cnt++;
  if (loop_cnt > ROUTE_LOOP_MAX)
    return 0;
  if (line_table_cnt >= LINE_TABLE_SIZE)
    return 0;

  /* Find horizontal lines that intercept */
  for (int i = 0; i < horiz_line_cnt; i++) {
    if (v_line->l_y <= horiz_line[i].y && horiz_line[i].y <= v_line->u_y
        && horiz_line[i].l_x <= v_line->x && v_line->x <= horiz_line[i].u_x) {
      if (horiz_line[i].dest) {
        /* The route is complete */
        if (line_table_cnt >= LINE_TABLE_SIZE)
          return 0;
        if (line_table[line_table_cnt].vert_cnt
                + line_table[line_table_cnt].horiz_cnt
            >= current_line_cnt - 1)
          return 1;

        memcpy(&line_table[line_table_cnt + 1], &line_table[line_table_cnt],
            sizeof(line_table[0]));
        line_table[line_table_cnt].horiz[line_table[line_table_cnt].horiz_cnt]
            = &horiz_line[i];
        line_table[line_table_cnt].horiz_y[line_table[line_table_cnt].horiz_cnt]
            = horiz_line[i].y;
        line_table[line_table_cnt].horiz_x[line_table[line_table_cnt].horiz_cnt]
            = v_line->x;
        line_table[line_table_cnt].horiz_cnt++;
        current_line_cnt = line_table[line_table_cnt].vert_cnt
            + line_table[line_table_cnt].horiz_cnt;
        line_table[line_table_cnt].complete = 1;
        line_table_cnt++;
        if (current_line_cnt == ideal_line_cnt)
          return CON__ROUTE_FOUND;
      } else {
        /* Check that the line is not already inserted */
        if ((line_table[line_table_cnt].vert_cnt
                    + line_table[line_table_cnt].horiz_cnt
                < current_line_cnt - 1)
            && (line_table[line_table_cnt].vert_cnt
                       + line_table[line_table_cnt].horiz_cnt
                   < MAX_POINT - 1)) {
          int found = 0;
          for (int j = 0; j < line_table[line_table_cnt].horiz_cnt; j++) {
            if (line_table[line_table_cnt].horiz[j] == &horiz_line[i]) {
              found = 1;
              break;
            }
          }
          if (!found) {
            /* Try this line  */

            /* Store the counters */
            int vert_cnt = line_table[line_table_cnt].vert_cnt;
            int horiz_cnt = line_table[line_table_cnt].horiz_cnt;

            line_table[line_table_cnt]
                .horiz[line_table[line_table_cnt].horiz_cnt]
                = &horiz_line[i];
            line_table[line_table_cnt]
                .horiz_y[line_table[line_table_cnt].horiz_cnt]
                = horiz_line[i].y;
            line_table[line_table_cnt]
                .horiz_x[line_table[line_table_cnt].horiz_cnt]
                = v_line->x;
            line_table[line_table_cnt].horiz_cnt++;
            //            printf( "Trying horiz: %d, vert_cnt %d, horiz_cnt %d
            //            nr %d\n",
            //		&horiz_line[i], line_table[line_table_cnt].vert_cnt,
            //		line_table[line_table_cnt].horiz_cnt, i);
            //	    print_line();
            int sts = find_horiz_line_next_line(&horiz_line[i]);
            if (sts == CON__ROUTE_FOUND || EVEN(sts))
              return sts;

            /* Restore the counters */
            line_table[line_table_cnt].vert_cnt = vert_cnt;
            line_table[line_table_cnt].horiz_cnt = horiz_cnt;
          }
        }
      }
    }
  }
  return 1;
}

int FlowCon::find_horiz_line_up(double check_y, double check_l_x,
    double check_u_x, FlowNode* nodelist, FlowNode* next_node, FlowCon* conlist,
    FlowCon* next_con, double wind_ll_x, double wind_ur_x)
{
  for (FlowNode* node_p = next_node; node_p; node_p = node_p->link) {
    if (node_p->obst_y_low > check_y) {
      double check_wind_l_x, check_wind_u_x;
      if (node_p->obst_x_left > check_u_x) {
        check_wind_u_x = node_p->obst_x_left;
        check_wind_l_x = check_u_x;
      } else if (node_p->obst_x_right < check_l_x) {
        check_wind_u_x = check_l_x;
        check_wind_l_x = node_p->obst_x_right;
      } else {
        check_wind_l_x = MAX(check_l_x, node_p->obst_x_left);
        check_wind_u_x = MIN(check_u_x, node_p->obst_x_right);
      }
      int found = 0;
      for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
        if (node_p2 != node_p
            && node_p2->in_area_exact(check_wind_l_x, check_y, check_wind_u_x,
                   node_p->obst_y_low)) {
          found = 1;
          break;
        }
      }
      if (!found) {
        /* Create a line */
        double horiz_line_y = (check_y + node_p->obst_y_low) / 2;
        found = 0;
        for (int j = 0; j < horiz_line_cnt; j++) {
          if (fabs(horiz_line[j].y - horiz_line_y) < ctx->draw_delta) {
            found = 1;
            break;
          }
        }
        if (found)
          continue;
        horiz_line[horiz_line_cnt].y = (check_y + node_p->obst_y_low) / 2;
        horiz_line[horiz_line_cnt].l_x = wind_ll_x + ctx->draw_delta;
        horiz_line[horiz_line_cnt].u_x = wind_ur_x - ctx->draw_delta;
        horiz_line[horiz_line_cnt].dest = 0;
        find_horiz_line_left_border(horiz_line[horiz_line_cnt].y,
            check_wind_l_x, horiz_line[horiz_line_cnt].u_x,
            &horiz_line[horiz_line_cnt].l_x, nodelist, conlist);
        find_horiz_line_right_border(horiz_line[horiz_line_cnt].y,
            check_wind_u_x, horiz_line[horiz_line_cnt].l_x,
            &horiz_line[horiz_line_cnt].u_x, nodelist, conlist);
        horiz_line_cnt++;
      }
    }
  }
  for (FlowCon* con_p = next_con; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;

    /* Check vertical lines in the con */
    if (cc->con_type == flow_eConType_Routed) {
      int i = !(con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        if (con_p->point_y[i] < check_y) {
          double l_x = MIN(con_p->point_x[i], con_p->point_x[i + 1]);
          double u_x = MAX(con_p->point_x[i], con_p->point_x[i + 1]);
          double check_wind_l_x, check_wind_u_x;
          if (l_x > check_u_x) {
            check_wind_u_x = l_x;
            check_wind_l_x = check_u_x;
          } else if (u_x < check_l_x) {
            check_wind_u_x = check_l_x;
            check_wind_l_x = u_x;
          } else {
            check_wind_l_x = MAX(check_l_x, l_x);
            check_wind_u_x = MIN(check_u_x, u_x);
          }
          int found = 0;
          for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
            if (node_p2->in_area_exact(check_wind_l_x, con_p->point_y[i],
                    check_wind_u_x, check_y)) {
              found = 1;
              break;
            }
          }
          if (!found) {
            /* Create a line */
            double horiz_line_y = (check_y + con_p->point_y[i]) / 2;
            found = 0;
            for (int j = 0; j < horiz_line_cnt; j++) {
              if (fabs(horiz_line[j].y - horiz_line_y) < ctx->draw_delta) {
                found = 1;
                break;
              }
            }
            if (found)
              continue;
            horiz_line[horiz_line_cnt].y = (check_y + con_p->point_y[i]) / 2;
            horiz_line[horiz_line_cnt].l_x = wind_ll_x + ctx->draw_delta;
            horiz_line[horiz_line_cnt].u_x = wind_ur_x - ctx->draw_delta;
            horiz_line[horiz_line_cnt].dest = 0;
            find_horiz_line_left_border(horiz_line[horiz_line_cnt].y,
                check_wind_l_x, horiz_line[horiz_line_cnt].u_x,
                &horiz_line[horiz_line_cnt].l_x, nodelist, conlist);
            find_horiz_line_right_border(horiz_line[horiz_line_cnt].y,
                check_wind_u_x, horiz_line[horiz_line_cnt].l_x,
                &horiz_line[horiz_line_cnt].u_x, nodelist, conlist);
            if (horiz_line[horiz_line_cnt].u_x < horiz_line[horiz_line_cnt].l_x)
              continue;
            horiz_line_cnt++;
          }
        }
      }
    }
  }
  return 1;
}

int FlowCon::find_horiz_line_down(double check_y, double check_l_x,
    double check_u_x, FlowNode* nodelist, FlowNode* next_node, FlowCon* conlist,
    FlowCon* next_con, double wind_ll_x, double wind_ur_x)
{
  for (FlowNode* node_p = next_node; node_p; node_p = node_p->link) {
    if (node_p->obst_y_high < check_y) {
      double check_wind_l_x, check_wind_u_x;
      if (node_p->obst_x_left > check_u_x) {
        check_wind_u_x = node_p->obst_x_left;
        check_wind_l_x = check_u_x;
      } else if (node_p->obst_x_right < check_l_x) {
        check_wind_u_x = check_l_x;
        check_wind_l_x = node_p->obst_x_right;
      } else {
        check_wind_l_x = MAX(check_l_x, node_p->obst_x_left);
        check_wind_u_x = MIN(check_u_x, node_p->obst_x_right);
      }
      int found = 0;
      for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
        if (node_p2 != node_p
            && node_p2->in_area_exact(check_wind_l_x, node_p->obst_y_high,
                   check_wind_u_x, check_y)) {
          found = 1;
          break;
        }
      }
      if (!found) {
        /* Create a line */
        double horiz_line_y = (check_y + node_p->obst_y_high) / 2;
        found = 0;
        for (int j = 0; j < horiz_line_cnt; j++) {
          if (fabs(horiz_line[j].y - horiz_line_y) < ctx->draw_delta) {
            found = 1;
            break;
          }
        }
        if (found)
          continue;
        horiz_line[horiz_line_cnt].y = (check_y + node_p->obst_y_high) / 2;
        horiz_line[horiz_line_cnt].l_x = wind_ll_x + ctx->draw_delta;
        horiz_line[horiz_line_cnt].u_x = wind_ur_x - ctx->draw_delta;
        horiz_line[horiz_line_cnt].dest = 0;
        find_horiz_line_left_border(horiz_line[horiz_line_cnt].y,
            check_wind_l_x, horiz_line[horiz_line_cnt].u_x,
            &horiz_line[horiz_line_cnt].l_x, nodelist, conlist);
        find_horiz_line_right_border(horiz_line[horiz_line_cnt].y,
            check_wind_u_x, horiz_line[horiz_line_cnt].l_x,
            &horiz_line[horiz_line_cnt].u_x, nodelist, conlist);
        horiz_line_cnt++;
      }
    }
  }
  for (FlowCon* con_p = next_con; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;

    /* Check vertical lines in the con */
    if (cc->con_type == flow_eConType_Routed) {
      int i = !(con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        if (con_p->point_y[i] < check_y) {
          double l_x = MIN(con_p->point_x[i], con_p->point_x[i + 1]);
          double u_x = MAX(con_p->point_x[i], con_p->point_x[i + 1]);
          double check_wind_l_x, check_wind_u_x;
          if (l_x > check_u_x) {
            check_wind_u_x = l_x;
            check_wind_l_x = check_u_x;
          } else if (u_x < check_l_x) {
            check_wind_u_x = check_l_x;
            check_wind_l_x = u_x;
          } else {
            check_wind_l_x = MAX(check_l_x, l_x);
            check_wind_u_x = MIN(check_u_x, u_x);
          }
          int found = 0;
          for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
            if (node_p2->in_area_exact(check_wind_l_x, con_p->point_y[i],
                    check_wind_u_x, check_y)) {
              found = 1;
              break;
            }
          }
          if (!found) {
            /* Create a line */
            double horiz_line_y = (check_y + con_p->point_y[i]) / 2;
            found = 0;
            for (int j = 0; j < horiz_line_cnt; j++) {
              if (fabs(horiz_line[j].y - horiz_line_y) < ctx->draw_delta) {
                found = 1;
                break;
              }
            }
            if (found)
              continue;
            horiz_line[horiz_line_cnt].y = (check_y + con_p->point_y[i]) / 2;
            horiz_line[horiz_line_cnt].l_x = wind_ll_x + ctx->draw_delta;
            horiz_line[horiz_line_cnt].u_x = wind_ur_x - ctx->draw_delta;
            horiz_line[horiz_line_cnt].dest = 0;
            find_horiz_line_left_border(horiz_line[horiz_line_cnt].y,
                check_wind_l_x, horiz_line[horiz_line_cnt].u_x,
                &horiz_line[horiz_line_cnt].l_x, nodelist, conlist);
            find_horiz_line_right_border(horiz_line[horiz_line_cnt].y,
                check_wind_u_x, horiz_line[horiz_line_cnt].l_x,
                &horiz_line[horiz_line_cnt].u_x, nodelist, conlist);
            if (horiz_line[horiz_line_cnt].u_x < horiz_line[horiz_line_cnt].l_x)
              continue;
            horiz_line_cnt++;
          }
        }
      }
    }
  }
  return 1;
}

int FlowCon::find_vert_line_right(double check_x, double check_l_y,
    double check_u_y, FlowNode* nodelist, FlowNode* next_node, FlowCon* conlist,
    FlowCon* next_con, double wind_ll_y, double wind_ur_y)
{
  for (FlowNode* node_p = next_node; node_p; node_p = node_p->link) {
    if (node_p->obst_x_left > check_x) {
      double check_wind_l_y, check_wind_u_y;
      if (node_p->obst_y_low > check_u_y) {
        check_wind_u_y = node_p->obst_y_low;
        check_wind_l_y = check_u_y;
      } else if (node_p->obst_y_high < check_l_y) {
        check_wind_u_y = check_l_y;
        check_wind_l_y = node_p->obst_y_high;
      } else {
        check_wind_l_y = MAX(check_l_y, node_p->obst_y_low);
        check_wind_u_y = MIN(check_u_y, node_p->obst_y_high);
      }
      int found = 0;
      for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
        if (node_p2 != node_p
            && node_p2->in_area_exact(check_x, check_wind_l_y,
                   node_p->obst_x_left, check_wind_u_y)) {
          found = 1;
          break;
        }
      }
      if (!found) {
        /* Create a line */
        double vert_line_x = (check_x + node_p->obst_x_left) / 2;
        found = 0;
        for (int j = 0; j < vert_line_cnt; j++) {
          if (fabs(vert_line[j].x - vert_line_x) < ctx->draw_delta) {
            found = 1;
            break;
          }
        }
        if (found)
          continue;
        vert_line[vert_line_cnt].x = (check_x + node_p->obst_x_left) / 2;
        vert_line[vert_line_cnt].l_y = wind_ll_y + ctx->draw_delta;
        vert_line[vert_line_cnt].u_y = wind_ur_y - ctx->draw_delta;
        vert_line[vert_line_cnt].dest = 0;
        find_vert_line_low_border(vert_line[vert_line_cnt].x, check_wind_l_y,
            vert_line[vert_line_cnt].u_y, &vert_line[vert_line_cnt].l_y,
            nodelist, conlist);
        find_vert_line_high_border(vert_line[vert_line_cnt].x, check_wind_u_y,
            vert_line[vert_line_cnt].l_y, &vert_line[vert_line_cnt].u_y,
            nodelist, conlist);
        vert_line_cnt++;
      }
    }
  }

  for (FlowCon* con_p = next_con; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;

    /* Check vertical lines in the con */
    if (con_p->cc->con_type == flow_eConType_Routed && !con_p->temporary_ref) {
      int i = (con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        if (con_p->point_x[i] > check_x) {
          double l_y = MIN(con_p->point_y[i], con_p->point_y[i + 1]);
          double u_y = MAX(con_p->point_y[i], con_p->point_y[i + 1]);
          double check_wind_l_y, check_wind_u_y;
          if (l_y > check_u_y) {
            check_wind_u_y = l_y;
            check_wind_l_y = check_u_y;
          } else if (u_y < check_l_y) {
            check_wind_u_y = check_l_y;
            check_wind_l_y = u_y;
          } else {
            check_wind_l_y = MAX(check_l_y, l_y);
            check_wind_u_y = MIN(check_u_y, u_y);
          }
          int found = 0;
          for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
            if (node_p2->in_area_exact(check_x, check_wind_l_y,
                    con_p->point_x[i], check_wind_u_y)) {
              found = 1;
              break;
            }
          }

          if (!found) {
            /* Create a line */
            double vert_line_x = (check_x + con_p->point_x[i]) / 2;
            found = 0;
            for (int j = 0; j < vert_line_cnt; j++) {
              if (fabs(vert_line[j].x - vert_line_x) < ctx->draw_delta) {
                found = 1;
                break;
              }
            }
            if (found)
              continue;
            vert_line[vert_line_cnt].x = (check_x + con_p->point_x[i]) / 2;
            vert_line[vert_line_cnt].l_y = wind_ll_y + ctx->draw_delta;
            vert_line[vert_line_cnt].u_y = wind_ur_y - ctx->draw_delta;
            vert_line[vert_line_cnt].dest = 0;
            find_vert_line_low_border(vert_line[vert_line_cnt].x,
                check_wind_l_y, vert_line[vert_line_cnt].u_y,
                &vert_line[vert_line_cnt].l_y, nodelist, conlist);
            find_vert_line_high_border(vert_line[vert_line_cnt].x,
                check_wind_u_y, vert_line[vert_line_cnt].l_y,
                &vert_line[vert_line_cnt].u_y, nodelist, conlist);
            if (vert_line[vert_line_cnt].u_y < vert_line[vert_line_cnt].l_y)
              continue;
            vert_line_cnt++;
          }
        }
      }
    }
  }
  return 1;
}

int FlowCon::find_vert_line_left(double check_x, double check_l_y,
    double check_u_y, FlowNode* nodelist, FlowNode* next_node, FlowCon* conlist,
    FlowCon* next_con, double wind_ll_y, double wind_ur_y)
{
  for (FlowNode* node_p = next_node; node_p; node_p = node_p->link) {
    if (node_p->obst_x_right < check_x) {
      double check_wind_l_y, check_wind_u_y;
      if (node_p->obst_y_low > check_u_y) {
        check_wind_u_y = node_p->obst_y_low;
        check_wind_l_y = check_u_y;
      } else if (node_p->obst_y_high < check_l_y) {
        check_wind_u_y = check_l_y;
        check_wind_l_y = node_p->obst_y_high;
      } else {
        check_wind_l_y = MAX(check_l_y, node_p->obst_y_low);
        check_wind_u_y = MIN(check_u_y, node_p->obst_y_high);
      }
      int found = 0;
      for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
        if (node_p2 != node_p
            && node_p2->in_area_exact(node_p->obst_x_right, check_wind_l_y,
                   check_x, check_wind_u_y)) {
          found = 1;
          break;
        }
      }
      if (!found) {
        /* Create a line */
        double vert_line_x = (check_x + node_p->obst_x_right) / 2;
        found = 0;
        for (int j = 0; j < vert_line_cnt; j++) {
          if (fabs(vert_line[j].x - vert_line_x) < ctx->draw_delta) {
            found = 1;
            break;
          }
        }
        if (found)
          continue;
        vert_line[vert_line_cnt].x = (check_x + node_p->obst_x_right) / 2;
        vert_line[vert_line_cnt].l_y = wind_ll_y + ctx->draw_delta;
        vert_line[vert_line_cnt].u_y = wind_ur_y - ctx->draw_delta;
        vert_line[vert_line_cnt].dest = 0;
        find_vert_line_low_border(vert_line[vert_line_cnt].x, check_wind_l_y,
            vert_line[vert_line_cnt].u_y, &vert_line[vert_line_cnt].l_y,
            nodelist, conlist);
        find_vert_line_high_border(vert_line[vert_line_cnt].x, check_wind_u_y,
            vert_line[vert_line_cnt].l_y, &vert_line[vert_line_cnt].u_y,
            nodelist, conlist);
        vert_line_cnt++;
      }
    }
  }
  for (FlowCon* con_p = next_con; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;

    /* Check vertical lines in the con */
    if (con_p->cc->con_type == flow_eConType_Routed && !con_p->temporary_ref) {
      int i = (con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        if (con_p->point_x[i] < check_x) {
          double l_y = MIN(con_p->point_y[i], con_p->point_y[i + 1]);
          double u_y = MAX(con_p->point_y[i], con_p->point_y[i + 1]);
          double check_wind_l_y, check_wind_u_y;
          if (l_y > check_u_y) {
            check_wind_u_y = l_y;
            check_wind_l_y = check_u_y;
          } else if (u_y < check_l_y) {
            check_wind_u_y = check_l_y;
            check_wind_l_y = u_y;
          } else {
            check_wind_l_y = MAX(check_l_y, l_y);
            check_wind_u_y = MIN(check_u_y, u_y);
          }
          int found = 0;
          for (FlowNode* node_p2 = nodelist; node_p2; node_p2 = node_p2->link) {
            if (node_p2->in_area_exact(con_p->point_x[i], check_wind_l_y,
                    check_x, check_wind_u_y)) {
              found = 1;
              break;
            }
          }
          if (!found) {
            /* Create a line */
            double vert_line_x = (check_x + con_p->point_x[i]) / 2;
            found = 0;
            for (int j = 0; j < vert_line_cnt; j++) {
              if (fabs(vert_line[j].x - vert_line_x) < ctx->draw_delta) {
                found = 1;
                break;
              }
            }
            if (found)
              continue;
            vert_line[vert_line_cnt].x = (check_x + con_p->point_x[i]) / 2;
            vert_line[vert_line_cnt].l_y = wind_ll_y + ctx->draw_delta;
            vert_line[vert_line_cnt].u_y = wind_ur_y - ctx->draw_delta;
            vert_line[vert_line_cnt].dest = 0;
            find_vert_line_low_border(vert_line[vert_line_cnt].x,
                check_wind_l_y, vert_line[vert_line_cnt].u_y,
                &vert_line[vert_line_cnt].l_y, nodelist, conlist);
            find_vert_line_high_border(vert_line[vert_line_cnt].x,
                check_wind_u_y, vert_line[vert_line_cnt].l_y,
                &vert_line[vert_line_cnt].u_y, nodelist, conlist);
            if (vert_line[vert_line_cnt].u_y < vert_line[vert_line_cnt].l_y)
              continue;
            vert_line_cnt++;
          }
        }
      }
    }
  }
  return 1;
}

void FlowCon::find_horiz_line_right_border(double y, double start_x,
    double start_x_con, double* border_x, FlowNode* nodelist, FlowCon* conlist)
{
  for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
    if (node_p->in_horiz_line(y, start_x, *border_x))
      if (node_p->obst_x_left < *border_x
          && node_p->obst_x_left >= start_x - CON_EPSILON)
        *border_x = node_p->obst_x_left;
  }
  for (FlowCon* con_p = conlist; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;
    if ((con_p->source_node == source_node
            && con_p->source_conpoint == source_conpoint)
        || (con_p->source_node == dest_node
               && con_p->source_conpoint == dest_conpoint)
        || (con_p->dest_node == source_node
               && con_p->dest_conpoint == source_conpoint)
        || (con_p->dest_node == dest_node
               && con_p->dest_conpoint == dest_conpoint))
      continue;

    /* Check horizontal lines in the con */
    if (con_p->cc->con_type == flow_eConType_Routed && !con_p->temporary_ref) {
      int i = !(con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        double l_x = MIN(con_p->point_x[i], con_p->point_x[i + 1]);
        if (con_p->point_y[i] - ctx->draw_delta < y
            && y < con_p->point_y[i] + ctx->draw_delta) {
          if (l_x < *border_x && l_x >= start_x_con - CON_EPSILON)
            *border_x = l_x;
        }
      }
    }
  }
}

void FlowCon::find_horiz_line_left_border(double y, double start_x,
    double start_x_con, double* border_x, FlowNode* nodelist, FlowCon* conlist)
{
  for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
    if (node_p->in_horiz_line(y, *border_x, start_x))
      if (node_p->obst_x_right > *border_x
          && node_p->obst_x_right <= start_x + CON_EPSILON)
        *border_x = node_p->obst_x_right;
  }
  for (FlowCon* con_p = conlist; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;
    if ((con_p->source_node == source_node
            && con_p->source_conpoint == source_conpoint)
        || (con_p->source_node == dest_node
               && con_p->source_conpoint == dest_conpoint)
        || (con_p->dest_node == source_node
               && con_p->dest_conpoint == source_conpoint)
        || (con_p->dest_node == dest_node
               && con_p->dest_conpoint == dest_conpoint))
      continue;

    /* Check horizontal lines in the con */
    if (con_p->cc->con_type == flow_eConType_Routed && !con_p->temporary_ref) {
      int i = !(con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        double u_x = MAX(con_p->point_x[i], con_p->point_x[i + 1]);
        if (con_p->point_y[i] - ctx->draw_delta < y
            && y < con_p->point_y[i] + ctx->draw_delta) {
          if (u_x > *border_x && u_x <= start_x_con + CON_EPSILON)
            *border_x = u_x;
        }
      }
    }
  }
}

void FlowCon::find_vert_line_high_border(double x, double start_y,
    double start_y_con, double* border_y, FlowNode* nodelist, FlowCon* conlist)
{
  for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
    if (node_p->in_vert_line(x, start_y, *border_y))
      if (node_p->obst_y_low < *border_y
          && node_p->obst_y_low >= start_y - CON_EPSILON)
        *border_y = node_p->obst_y_low;
  }
  for (FlowCon* con_p = conlist; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;
    if ((con_p->source_node == source_node
            && con_p->source_conpoint == source_conpoint)
        || (con_p->source_node == dest_node
               && con_p->source_conpoint == dest_conpoint)
        || (con_p->dest_node == source_node
               && con_p->dest_conpoint == source_conpoint)
        || (con_p->dest_node == dest_node
               && con_p->dest_conpoint == dest_conpoint))
      continue;

    /* Check vertical lines in the con */
    if (con_p->cc->con_type == flow_eConType_Routed && !con_p->temporary_ref) {
      int i = (con_p->source_direction == flow_eDirection_Right
          || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        double l_y = MIN(con_p->point_y[i], con_p->point_y[i + 1]);
        if (con_p->point_x[i] - ctx->draw_delta < x
            && x < con_p->point_x[i] + ctx->draw_delta) {
          if (l_y < *border_y && l_y >= start_y_con - CON_EPSILON)
            *border_y = l_y;
        }
      }
    }
  }
}

void FlowCon::find_vert_line_low_border(double x, double start_y,
    double start_y_con, double* border_y, FlowNode* nodelist, FlowCon* conlist)
{
  for (FlowNode* node_p = nodelist; node_p; node_p = node_p->link) {
    if (node_p->in_vert_line(x, *border_y, start_y))
      if (node_p->obst_y_high > *border_y
          && node_p->obst_y_high <= start_y + CON_EPSILON)
        *border_y = node_p->obst_y_high;
  }
  for (FlowCon* con_p = conlist; con_p; con_p = con_p->link) {
    if (con_p == this)
      continue;
    if ((con_p->source_node == source_node
            && con_p->source_conpoint == source_conpoint)
        || (con_p->source_node == dest_node
               && con_p->source_conpoint == dest_conpoint)
        || (con_p->dest_node == source_node
               && con_p->dest_conpoint == source_conpoint)
        || (con_p->dest_node == dest_node
               && con_p->dest_conpoint == dest_conpoint))
      continue;

    /* Check vertical lines in the con */
    if (con_p->cc->con_type == flow_eConType_Routed && !con_p->temporary_ref) {
      int i = (con_p->source_direction == flow_eDirection_Right
           || con_p->source_direction == flow_eDirection_Left);

      for (; i < con_p->p_num - 1; i += 2) {
        double u_y = MAX(con_p->point_y[i], con_p->point_y[i + 1]);
        if (con_p->point_x[i] - ctx->draw_delta < x
            && x < con_p->point_x[i] + ctx->draw_delta) {
          if (u_y > *border_y && u_y <= start_y_con + CON_EPSILON)
            *border_y = u_y;
        }
      }
    }
  }
}

int FlowCon::event_handler(flow_eEvent event, int x, int y)
{
  int sts = 0;
  if (temporary_ref || cc->con_type == flow_eConType_Reference)
    sts = ref_a.event_handler(&cc->zero, event, x, y, ref_a.size());
  else
    sts = line_a.event_handler(&cc->zero, event, x, y, l_num);
  if (event == flow_eEvent_CursorMotion) {
    if (sts && !hot
        && !(ctx->node_movement_active || ctx->node_movement_paste_active)) {
      ctx->fdraw->set_cursor(ctx->mw, draw_eCursor_CrossHair);
      set_hot(1);
    }
    if (!sts && hot) {
      ctx->fdraw->set_cursor(ctx->mw, draw_eCursor_Normal);
      set_hot(0);
    }
  }
  if (sts)
    ctx->register_callback_object(flow_eObjectType_Con, this);
  return sts;
}

std::ostream& operator<<(std::ostream& o, const FlowCon c)
{
  o << "Con: " << c.c_name << " Class: " << c.cc->cc_name;
  return o;
}

void FlowCon::draw_routed(int points, double* x, double* y)
{
  for (int i = 0; i < points - 1; i++) {
    FlowLine* l = (FlowLine*)line_a[i];
    l->move(&cc->zero, x[i], y[i], x[i + 1], y[i + 1], highlight, dimmed, hot);
  }

  p_num = points;
  if (l_num != points - 1) {
    l_num = points - 1;
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::draw_routed_trans(int points, double* x, double* y)
{
  int j = 0;
  for (int i = 0; i < points - 1; i++) {
    if (i == 2)
      continue;
    FlowLine* l = (FlowLine*)line_a[j];
    l->move(&cc->zero, x[i], y[i], x[i + 1], y[i + 1], highlight, dimmed, hot);
    j++;
  }

  p_num = points;
  if (l_num != j) {
    l_num = j;
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::draw_routed_roundcorner(int points, double* x, double* y)
{
  con_eCorner corner_type[8];
  double r_x[8], r_y[8];
  for (int i = 1; i < points - 1; i++) {
    double r = cc->round_corner_amount;

    if (i == 1 && fabs(y[0] - y[1]) < DBL_EPSILON
        && fabs(x[0] - x[1]) < DBL_EPSILON) {
      /* First line is a Null line */
      corner_type[0] = eCorner_Sharp;
      if (i != points - 2) {
        corner_type[i] = eCorner_Sharp;
        i++;
        continue;
      }
    }

    /* Find corner type */
    if (fabs(y[i - 1] - y[i]) < DBL_EPSILON) {
      if (fabs(y[i] - y[i + 1]) < DBL_EPSILON) {
        /* Next line is a Null line */
        corner_type[i - 1] = eCorner_Sharp;
        if (i != points - 2) {
          corner_type[i] = eCorner_Sharp;
          i++;
          continue;
        }
      }

      if (x[i - 1] < x[i] && y[i] < y[i + 1])
        corner_type[i - 1] = eCorner_RightToUp;
      else if (x[i - 1] < x[i] && y[i] > y[i + 1])
        corner_type[i - 1] = eCorner_RightToDown;
      else if (x[i - 1] > x[i] && y[i] < y[i + 1])
        corner_type[i - 1] = eCorner_LeftToUp;
      else if (x[i - 1] > x[i] && y[i] > y[i + 1])
        corner_type[i - 1] = eCorner_LeftToDown;

      /* Check if short line */
      if (fabs(x[i] - x[i - 1]) < 2 * r) {
        r_x[i - 1] = fabs(x[i] - x[i - 1]) / 2;
        if (i > 1)
          r_x[i - 2] = r_x[i - 1];
      } else
        r_x[i - 1] = r;
      r_y[i - 1] = r;
    } else if (fabs(x[i - 1] - x[i]) < DBL_EPSILON) {
      if (fabs(x[i] - x[i + 1]) < DBL_EPSILON) {
        /* Next line is a Null line */
        corner_type[i - 1] = eCorner_Sharp;
        if (i != points - 2) {
          corner_type[i] = eCorner_Sharp;
          i++;
          continue;
        }
      }

      if (y[i - 1] < y[i] && x[i] < x[i + 1])
        corner_type[i - 1] = eCorner_UpToRight;
      else if (y[i - 1] < y[i] && x[i] > x[i + 1])
        corner_type[i - 1] = eCorner_UpToLeft;
      else if (y[i - 1] > y[i] && x[i] < x[i + 1])
        corner_type[i - 1] = eCorner_DownToRight;
      else if (y[i - 1] > y[i] && x[i] > x[i + 1])
        corner_type[i - 1] = eCorner_DownToLeft;

      /* Check if short line */
      if (fabs(y[i] - y[i - 1]) < 2 * r) {
        r_y[i - 1] = fabs(y[i] - y[i - 1]) / 2;
        if (i > 1)
          r_y[i - 2] = r_y[i - 1];
      } else
        r_y[i - 1] = r;
      r_x[i - 1] = r;
    } else
      corner_type[i - 1] = eCorner_Sharp;
  }
  double line_x1[8], line_y1[8], line_x2[8], line_y2[8];
  double arc_ll_x[8], arc_ll_y[8], arc_ur_x[8], arc_ur_y[8];
  int arc_angle1[8], arc_angle2[8];
  line_x1[0] = x[0];
  line_y1[0] = y[0];
  for (int i = 1; i < points - 1; i++) {
    switch (corner_type[i - 1]) {
    case eCorner_RightToUp:
    case eCorner_RightToDown: {
      line_x2[i - 1] = x[i] - r_x[i - 1];
      line_y2[i - 1] = y[i];
      switch (corner_type[i - 1]) {
      case eCorner_RightToUp:
        line_x1[i] = x[i];
        line_y1[i] = y[i] + r_y[i - 1];
        arc_ll_x[i - 1] = x[i] - 2 * r_x[i - 1];
        arc_ll_y[i - 1] = y[i];
        arc_ur_x[i - 1] = x[i];
        arc_ur_y[i - 1] = y[i] + 2 * r_y[i - 1];
        arc_angle1[i - 1] = 0;
        arc_angle2[i - 1] = 90;
        break;
      case eCorner_RightToDown:
        line_x1[i] = x[i];
        line_y1[i] = y[i] - r_y[i - 1];
        arc_ll_x[i - 1] = x[i] - 2 * r_x[i - 1];
        arc_ll_y[i - 1] = y[i] - 2 * r_y[i - 1];
        arc_ur_x[i - 1] = x[i];
        arc_ur_y[i - 1] = y[i];
        arc_angle1[i - 1] = 270;
        arc_angle2[i - 1] = 90;
        break;
      default:;
      }
      break;
    }
    case eCorner_LeftToUp:
    case eCorner_LeftToDown: {
      line_x2[i - 1] = x[i] + r_x[i - 1];
      line_y2[i - 1] = y[i];
      switch (corner_type[i - 1]) {
      case eCorner_LeftToUp:
        line_x1[i] = x[i];
        line_y1[i] = y[i] + r_y[i - 1];
        arc_ll_x[i - 1] = x[i];
        arc_ll_y[i - 1] = y[i];
        arc_ur_x[i - 1] = x[i] + 2 * r_x[i - 1];
        arc_ur_y[i - 1] = y[i] + 2 * r_y[i - 1];
        arc_angle1[i - 1] = 90;
        arc_angle2[i - 1] = 90;
        break;
      case eCorner_LeftToDown:
        line_x1[i] = x[i];
        line_y1[i] = y[i] - r_y[i - 1];
        arc_ll_x[i - 1] = x[i];
        arc_ll_y[i - 1] = y[i] - 2 * r_y[i - 1];
        arc_ur_x[i - 1] = x[i] + 2 * r_x[i - 1];
        arc_ur_y[i - 1] = y[i];
        arc_angle1[i - 1] = 180;
        arc_angle2[i - 1] = 90;
        break;
      default:;
      }
      break;
    }
    case eCorner_UpToRight:
    case eCorner_UpToLeft: {
      line_x2[i - 1] = x[i];
      line_y2[i - 1] = y[i] - r_y[i - 1];
      switch (corner_type[i - 1]) {
      case eCorner_UpToRight:
        line_x1[i] = x[i] + r_x[i - 1];
        line_y1[i] = y[i];
        arc_ll_x[i - 1] = x[i];
        arc_ll_y[i - 1] = y[i] - 2 * r_y[i - 1];
        arc_ur_x[i - 1] = x[i] + 2 * r_x[i - 1];
        arc_ur_y[i - 1] = y[i];
        arc_angle1[i - 1] = 180;
        arc_angle2[i - 1] = 90;
        break;
      case eCorner_UpToLeft:
        line_x1[i] = x[i] - r_x[i - 1];
        line_y1[i] = y[i];
        arc_ll_x[i - 1] = x[i] - 2 * r_x[i - 1];
        arc_ll_y[i - 1] = y[i] - 2 * r_y[i - 1];
        arc_ur_x[i - 1] = x[i];
        arc_ur_y[i - 1] = y[i];
        arc_angle1[i - 1] = 270;
        arc_angle2[i - 1] = 90;
        break;
      default:;
      }
      break;
    }
    case eCorner_DownToRight:
    case eCorner_DownToLeft: {
      line_x2[i - 1] = x[i];
      line_y2[i - 1] = y[i] + r_y[i - 1];
      switch (corner_type[i - 1]) {
      case eCorner_DownToRight:
        line_x1[i] = x[i] + r_x[i - 1];
        line_y1[i] = y[i];
        arc_ll_x[i - 1] = x[i];
        arc_ll_y[i - 1] = y[i];
        arc_ur_x[i - 1] = x[i] + 2 * r_x[i - 1];
        arc_ur_y[i - 1] = y[i] + 2 * r_y[i - 1];
        arc_angle1[i - 1] = 90;
        arc_angle2[i - 1] = 90;
        break;
      case eCorner_DownToLeft:
        line_x1[i] = x[i] - r_x[i - 1];
        line_y1[i] = y[i];
        arc_ll_x[i - 1] = x[i] - 2 * r_x[i - 1];
        arc_ll_y[i - 1] = y[i];
        arc_ur_x[i - 1] = x[i];
        arc_ur_y[i - 1] = y[i] + 2 * r_y[i - 1];
        arc_angle1[i - 1] = 0;
        arc_angle2[i - 1] = 90;
        break;
      default:;
      }
      break;
    }
    case eCorner_Sharp:
      line_x2[i - 1] = x[i];
      line_y2[i - 1] = y[i];
      line_x1[i] = x[i];
      line_y1[i] = y[i];
      arc_ll_x[i - 1] = 0;
      arc_ll_y[i - 1] = 0;
      arc_ur_x[i - 1] = 0;
      arc_ur_y[i - 1] = 0;
      break;
    }
  }
  line_x2[points - 2] = x[points - 1];
  line_y2[points - 2] = y[points - 1];

  for (int i = 0; i < points - 1; i++) {
    FlowLine* l = (FlowLine*)line_a[i];
    l->move(&cc->zero, line_x1[i], line_y1[i], line_x2[i], line_y2[i],
        highlight, dimmed, hot);
  }
  for (int i = 0; i < points - 2; i++) {
    FlowArc* a = (FlowArc*)arc_a[i];
    a->move(&cc->zero, arc_ll_x[i], arc_ll_y[i], arc_ur_x[i], arc_ur_y[i],
        arc_angle1[i], arc_angle2[i], highlight, dimmed, hot);
  }
  p_num = points;
  if (l_num != points - 1 || a_num != points - 2) {
    l_num = points - 1;
    a_num = points - 2;
    ctx->set_dirty(x_left, y_low, x_right, y_high);
  }
}

void FlowCon::set_movement_type(FlowArrayElem** a, int a_size)
{
  int source_found = 0, dest_found = 0;
  for (int i = 0; i < a_size; i++) {
    if (a[i] == (FlowArrayElem*)source_node)
      source_found = 1;
    if (a[i] == (FlowArrayElem*)dest_node)
      dest_found = 1;
    if (source_found && dest_found)
      break;
  }
  if (source_found && dest_found)
    movement_type = flow_eMoveType_Frozen;
  else
    movement_type = flow_eMoveType_Route;
}

void FlowCon::move_ref(double x1, double y1, double x2, double y2)
{
  double rect_x = x1 - ctx->refcon_width / 2;
  double rect_y = y1 - ctx->refcon_height / 2;
  switch (source_direction) {
  case flow_eDirection_Center:
    rect_y = y1 - (source_ref_cnt - 0.5) * ctx->refcon_height;
    break;
  case flow_eDirection_Right:
    rect_x = x1 + source_ref_cnt * ctx->refcon_width;
    break;
  case flow_eDirection_Left:
    rect_x = x1 - (source_ref_cnt + 1) * ctx->refcon_width;
    break;
  case flow_eDirection_Up:
    rect_y = y1 + source_ref_cnt * ctx->refcon_height;
    break;
  case flow_eDirection_Down:
    rect_y = y1 - (source_ref_cnt + 1) * ctx->refcon_height;
    break;
  }
  double text_x = rect_x + 0.2 * ctx->refcon_width;
  double text_y = rect_y + 0.8 * ctx->refcon_height;

  char reftext[20];
  int new_ref = (ref_a.size() == 0);
  if (new_ref) {
    sprintf(reftext, "R%d", ctx->refcon_cnt++);
    FlowRect* r1 = new FlowRect(ctx, rect_x, rect_y, ctx->refcon_width,
        ctx->refcon_height, flow_eDrawType_Line, ctx->refcon_linewidth);
    FlowText* t1 = new FlowText(ctx, reftext, text_x, text_y,
        flow_eDrawType_TextHelveticaBold, ctx->refcon_textsize);
    ref_a.insert(r1);
    ref_a.insert(t1);
  } else {
    FlowRect* r1 = (FlowRect*)ref_a[0];
    FlowText* t1 = (FlowText*)ref_a[1];
    r1->move(&cc->zero, rect_x, rect_y, highlight, dimmed, hot);
    t1->move(&cc->zero, text_x, text_y, highlight, dimmed, hot);
  }
  switch (dest_direction) {
  case flow_eDirection_Center:
    rect_x = x2 - ctx->refcon_width / 2;
    rect_y = y2 - (dest_ref_cnt - 0.5) * ctx->refcon_height;
    break;
  case flow_eDirection_Right:
    rect_x = x2 + dest_ref_cnt * ctx->refcon_width;
    rect_y = y2 - ctx->refcon_height / 2;
    break;
  case flow_eDirection_Left:
    rect_x = x2 - (dest_ref_cnt + 1) * ctx->refcon_width;
    rect_y = y2 - ctx->refcon_height / 2;
    break;
  case flow_eDirection_Up:
    rect_x = x2 - ctx->refcon_width / 2;
    rect_y = y2 + dest_ref_cnt * ctx->refcon_height;
    break;
  case flow_eDirection_Down:
    rect_x = x2 - ctx->refcon_width / 2;
    rect_y = y2 - (dest_ref_cnt + 1) * ctx->refcon_height;
    break;
  }
  text_x = rect_x + 0.2 * ctx->refcon_width;
  text_y = rect_y + 0.8 * ctx->refcon_height;
  if (new_ref) {
    FlowRect* r2 = new FlowRect(ctx, rect_x, rect_y, ctx->refcon_width,
        ctx->refcon_height, flow_eDrawType_Line, ctx->refcon_linewidth);
    FlowText* t2 = new FlowText(ctx, reftext, text_x, text_y,
        flow_eDrawType_TextHelveticaBold, ctx->refcon_textsize);
    ref_a.insert(r2);
    ref_a.insert(t2);
  } else {
    FlowRect* r2 = (FlowRect*)ref_a[2];
    FlowText* t2 = (FlowText*)ref_a[3];
    r2->move(&cc->zero, rect_x, rect_y, highlight, dimmed, hot);
    t2->move(&cc->zero, text_x, text_y, highlight, dimmed, hot);
  }
}

void FlowCon::conpoint_refcon_redraw(void* node, int conpoint)
{
  double x1, y1, x2, y2;
  flow_eDirection dir;

  if (!(temporary_ref || cc->con_type == flow_eConType_Reference))
    return;

  if (source_node == (FlowNode*)node && conpoint == source_conpoint) {
    source_node->get_conpoint(source_conpoint, &x1, &y1, &dir);
    dest_node->get_conpoint(dest_conpoint, &x2, &y2, &dir);
    source_ref_cnt = source_node->refcon_cnt[conpoint]++;
    move_ref(x1, y1, x2, y2);
  } else if (dest_node == (FlowNode*)node && conpoint == dest_conpoint) {
    source_node->get_conpoint(source_conpoint, &x1, &y1, &dir);
    dest_node->get_conpoint(dest_conpoint, &x2, &y2, &dir);
    dest_ref_cnt = dest_node->refcon_cnt[conpoint]++;
    move_ref(x1, y1, x2, y2);
  }
}

void FlowCon::remove_notify()
{
  if (temporary_ref || cc->con_type == flow_eConType_Reference) {
    source_node->conpoint_refcon_reconfig(source_conpoint);
    dest_node->conpoint_refcon_reconfig(dest_conpoint);
  }
}

void FlowCon::set_trace_attr(const char* object, const char* attribute,
    flow_eTraceType type, int inverted)
{
  strncpy(trace_object, object, sizeof(trace_object));
  strncpy(trace_attribute, attribute, sizeof(trace_attribute));
  trace_attr_type = type;
}

FlowTraceAttr FlowCon::get_trace_attr()
{
  FlowTraceAttr attr;
  strncpy(attr.object, trace_object, sizeof(attr.object));
  strncpy(attr.attribute, trace_attribute, sizeof(attr.attribute));
  attr.type = trace_attr_type;
  attr.inverted = 0;
  return attr;
}

void FlowCon::trace_scan()
{
  if (!trace_p)
    return;

  if (trace_attr_type == flow_eTraceType_Boolean) {
    int on = *(unsigned int*)trace_p;
    if (highlight != on)
      set_highlight(on);
  }
}

int FlowCon::trace_init()
{
  if (streq(trace_object, ""))
    return 1;

  return ctx->trace_connect_func(
      (void*)this, trace_object, trace_attribute, trace_attr_type, &trace_p);
}

void FlowCon::trace_close()
{
  if (streq(trace_object, ""))
    return;

  ctx->trace_disconnect_func((void*)this);
}

void FlowCon::get_object_name(char* name)
{
  strcpy(name, c_name);
}
