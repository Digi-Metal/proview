/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdio.h>

#include "co_dcli.h"
#include "co_string.h"

#include "cow_qt_helpers.h"

#include "glow_curveapi.h"
#include "glow_curvewidget_qt.h"
#include "glow_growwidget_qt.h"

#include "ge_curve_qt.h"

#include <QDialogButtonBox>
#include <QFileDialog>
#include <QHBoxLayout>
#include <QLabel>
#include <QMenuBar>
#include <QPushButton>
#include <QVBoxLayout>

typedef struct {
  char text[40];
  time_ePeriod period;
} ge_sTimeComboText;

ge_sTimeComboText curve_timecombo_text[] = { { "One Second",
                                                 time_ePeriod_OneSecond },
  { "10 Seconds", time_ePeriod_10Seconds },
  { "One Minute", time_ePeriod_OneMinute },
  { "10 Minutes", time_ePeriod_10Minutes },
  { "One Hour", time_ePeriod_OneHour }, { "One Day", time_ePeriod_OneDay },
  { "One Week", time_ePeriod_OneWeek }, { "One Month", time_ePeriod_OneMonth },
  { "One Year", time_ePeriod_OneYear },
  { "Last Minute", time_ePeriod_LastMinute },
  { "Last 10 Minutes", time_ePeriod_Last10Minutes },
  { "Last Hour", time_ePeriod_LastHour }, { "Today", time_ePeriod_Today },
  { "Yesterday", time_ePeriod_Yesterday },
  { "This Week", time_ePeriod_ThisWeek },
  { "Last Week", time_ePeriod_LastWeek },
  { "This Month", time_ePeriod_ThisMonth },
  { "Last Month", time_ePeriod_LastMonth },
  { "This Year", time_ePeriod_ThisYear }, { "All Time", time_ePeriod_AllTime },
  { "Edit", time_ePeriod_UserDefined }, { "Markers", ge_ePeriod_Markers },
  { "", time_ePeriod_ } };

void GeCurveQt::set_period(time_ePeriod period, int nocallback)
{
  for (int i = 0; curve_timecombo_text[i].text[0]; i++) {
    if (curve_timecombo_text[i].period == period) {
      if (nocallback) {
        disable_timecombo_callback = 1;
      }
      timebox_timecombo->setCurrentIndex(i);
      if (nocallback) {
        disable_timecombo_callback = 0;
      }
      break;
    }
  }
}

int GeCurveQt::get_period(time_ePeriod* period)
{
  *period = time_ePeriod_;

  QString gtext = timebox_timecombo->currentText();
  if (gtext.isNull()) {
    return 0;
  }

  for (int i = 0; curve_timecombo_text[i].text[0]; i++) {
    if (gtext.compare(translate_utf8(curve_timecombo_text[i].text)) == 0) {
      *period = curve_timecombo_text[i].period;
      return 1;
    }
  }
  return 0;
}

void GeCurveQtWidget::activate_configure()
{
  curve->activate_configure();
}

void GeCurveQtWidget::activate_madd()
{
  if (curve->madd_cb) {
    (curve->madd_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_print()
{
  curve->activate_print();
}

void GeCurveQtWidget::activate_zoomin()
{
  curve_Zoom(curve->growcurve_ctx, 2.0);
}

void GeCurveQtWidget::activate_zoomout()
{
  curve_Zoom(curve->growcurve_ctx, 0.5);
}

void GeCurveQtWidget::activate_zoomreset()
{
  curve_Unzoom(curve->growcurve_ctx);
}

void GeCurveQtWidget::activate_page_right()
{
  curve_Scroll(curve->growcurve_ctx, -0.9);
}

void GeCurveQtWidget::activate_page_left()
{
  curve_Scroll(curve->growcurve_ctx, 0.9);
}

void GeCurveQtWidget::activate_scroll_right()
{
  curve_Scroll(curve->growcurve_ctx, -0.1);
}

void GeCurveQtWidget::activate_scroll_left()
{
  curve_Scroll(curve->growcurve_ctx, 0.1);
  curve->set_inputfocus();
}

void GeCurveQtWidget::activate_increase_period()
{
  if (curve->increase_period_cb) {
    (curve->increase_period_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_reload()
{
  if (curve->reload_cb) {
    (curve->reload_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_add()
{
  if (curve->add_cb) {
    (curve->add_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_remove()
{
  if (curve->remove_cb) {
    (curve->remove_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_prev_period()
{
  if (curve->prev_period_cb) {
    (curve->prev_period_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_next_period()
{
  if (curve->next_period_cb) {
    (curve->next_period_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_decrease_period()
{
  if (curve->decrease_period_cb) {
    (curve->decrease_period_cb)(curve->parent_ctx);
  }
}

void GeCurveQtWidget::activate_timecombo(int index)
{
  time_ePeriod period;

  if (curve->disable_timecombo_callback) {
    return;
  }

  if (curve->timebox_timecombo->currentText().isNull()) {
    return;
  }

  int sts = curve->get_period(&period);
  if (EVEN(sts)) {
    return;
  }

  if (period == time_ePeriod_UserDefined) {
    curve->activate_edit();
  } else if (period == ge_ePeriod_Markers) {
    curve->activate_period_markers();
  } else {
    curve->activate_period(period);
  }
  curve->current_period = period;
}

void GeCurveQtWidget::activate_background()
{
  curve->activate_background();
}

void GeCurveQtWidget::activate_showname()
{
}

void GeCurveQtWidget::activate_filledcurves(bool set)
{
  if (sender() == ((GeCurveQt*)curve)->tools_curve_fill) {
    curve->fill_curves = !curve->fill_curves;
    set = curve->fill_curves;
  } else {
    set = ((QAction*)sender())->isChecked();
  }
  curve->activate_filledcurves(set);
}

void GeCurveQtWidget::activate_curvetype()
{
  QAction* a = ((QAction*)sender());
  curve->activate_curvetype(static_cast<glow_eCurveType>(a->data().toInt()));
}

void GeCurveQtWidget::activate_digsplit()
{
  curve->activate_digsplit();
}

void GeCurveQtWidget::activate_xlimits()
{
  curve->open_minmax(0);
}

void GeCurveQtWidget::activate_new()
{
  curve->activate_new();
}

void GeCurveQtWidget::activate_save()
{
  curve->activate_save();
}

void GeCurveQtWidget::activate_open()
{
  curve->activate_open();
}

void GeCurveQtWidget::activate_snapshot()
{
  curve->activate_snapshot();
}

void GeCurveQtWidget::activate_export()
{
  curve->activate_export();
}

void GeCurveQtWidget::activate_help()
{
  curve->activate_help();
}

void GeCurveQtWidget::activate_export_browse()
{
  pwr_tFileName folder;
  dcli_translate_filename(folder, "~");

  // QFileDialog::getOpenFileName() is broken
  QFileDialog dialog(this, translate_utf8("File Selection"), fl(folder), "History files (*.txt,*.csv,*.skv);;All Files (*)");

  int sts = dialog.exec();
  if (sts == QDialog::Accepted && dialog.selectedFiles().length() > 0) {
    curve->export_filename_widget->setText(dialog.selectedFiles().first());
  }
}

void GeCurveQt::enable(unsigned int mask)
{
  if (mask & curve_mEnable_New) {
    menu_new->setVisible(true);
  }
  if (mask & curve_mEnable_Save) {
    menu_save->setVisible(true);
  }
  if (mask & curve_mEnable_Open) {
    menu_open->setVisible(true);
  }
  if (mask & curve_mEnable_Snapshot) {
    menu_snapshot->setVisible(true);
    tools_snapshot->setVisible(true);
  }
  if (mask & curve_mEnable_Export) {
    menu_export->setVisible(true);
  }
  if (mask & curve_mEnable_Timebox) {
    timetools->setVisible(true);
  }
  if (mask & curve_mEnable_Add) {
    tools_add->setVisible(true);
  }
  if (mask & curve_mEnable_CurveType) {
    tools_curvetype_line->setVisible(true);
    tools_curvetype_points->setVisible(true);
    tools_curvetype_linepoints->setVisible(true);
  }
  if (mask & curve_mEnable_CurveTypeSquare) {
    tools_curvetype_square->setVisible(true);
  }
  if (mask & curve_mEnable_FillCurve) {
    tools_curve_fill->setVisible(true);
  }
  if (mask & curve_mEnable_DigitalSplit) {
    tools_curve_digsplit->setVisible(true);
  }
  layout_mask = mask;
}

void GeCurveQt::setup(unsigned int mask)
{
  menu_new->setVisible(mask & curve_mEnable_New);
  menu_save->setVisible(mask & curve_mEnable_Save);
  menu_open->setVisible(mask & curve_mEnable_Open);
  menu_snapshot->setVisible(mask & curve_mEnable_Snapshot);
  tools_snapshot->setVisible(mask & curve_mEnable_Snapshot);
  menu_export->setVisible(mask & curve_mEnable_Export);
  timetools->setVisible(mask & curve_mEnable_Timebox);
  tools_add->setVisible(mask & curve_mEnable_Add);
  tools_curvetype_line->setVisible(
      mask & curve_mEnable_CurveType);
  tools_curvetype_points->setVisible(
      mask & curve_mEnable_CurveType);
  tools_curvetype_linepoints->setVisible(
      mask & curve_mEnable_CurveType);
  tools_curvetype_square->setVisible(
      mask & curve_mEnable_CurveType);
  tools_curve_fill->setVisible(mask & curve_mEnable_FillCurve);
  tools_curve_digsplit->setVisible(
      mask & curve_mEnable_DigitalSplit);
  layout_mask = mask;
}

void GeCurveQt::pop()
{
  ::pop(toplevel);
}

void GeCurveQt::write_title(char* str)
{
  toplevel->setWindowTitle(fl(str));
}

void GeCurveQt::resize()
{
  double zoom_y;
  curve_GetPreferedZoomY(growcurve_ctx, growaxis_main_widget->height(), &zoom_y);
  grow_ZoomY(growaxis_ctx, zoom_y);
  grow_ZoomX(growaxis_ctx, zoom_y);
  growaxis_main_widget->setMinimumWidth(zoom_y * axis_window_width + 4);
}

void GeCurveQt::axis_set_width(int width)
{
  growaxis_main_widget->setMinimumWidth(width + 4);
}

void GeCurveQt::open_minmax(int idx)
{
  char min_value_str[80];
  char max_value_str[80];
  if (idx < cd->cols) {
    sprintf(min_value_str, "%f", cd->y_min_value_axis[idx]);
    sprintf(max_value_str, "%f", cd->y_max_value_axis[idx]);
  } else {
    sprintf(min_value_str, "%f", cd->x_min_value_axis[idx - cd->cols]);
    sprintf(max_value_str, "%f", cd->x_max_value_axis[idx - cd->cols]);
  }

  // Create an input dialog
  QDialog minmax_widget(toplevel);
  minmax_widget.setWindowTitle(fl("Axis Limits"));
  //Do not set the "DeleteOnClose" attribute,
  //we need to access the dialog fields after exec()

  QLineEdit* minmax_textmin_widget = new QLineEdit(fl(min_value_str));
  QLabel* min_label = new QLabel(translate_utf8("MinValue"));
  min_label->setFixedWidth(100);
  QLineEdit* minmax_textmax_widget = new QLineEdit(fl(max_value_str));
  QObject::connect(minmax_textmax_widget, SIGNAL(returnPressed()), &minmax_widget,
      SLOT(accept()));
  QLabel* max_label = new QLabel(translate_utf8("MaxValue"));
  max_label->setFixedWidth(100);

  QDialogButtonBox* buttons = new QDialogButtonBox();
  buttons->addButton(QDialogButtonBox::Ok);
  buttons->addButton(QDialogButtonBox::Cancel);

  QObject::connect(buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()),
      &minmax_widget, SLOT(accept()));
  QObject::connect(buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()),
      &minmax_widget, SLOT(reject()));

  QHBoxLayout* minmax_hbox1 = new QHBoxLayout();
  minmax_hbox1->addWidget(min_label);
  add_expanding(minmax_hbox1, minmax_textmin_widget);

  QHBoxLayout* minmax_hbox2 = new QHBoxLayout();
  minmax_hbox2->addWidget(max_label);
  add_expanding(minmax_hbox2, minmax_textmax_widget);

  QVBoxLayout* minmax_vbox = new QVBoxLayout(&minmax_widget);
  minmax_vbox->addLayout(minmax_hbox1);
  add_expanding(minmax_vbox, minmax_hbox2);
  minmax_vbox->addWidget(separator(QFrame::HLine));
  minmax_vbox->addWidget(buttons);

  minmax_widget.setLayout(minmax_vbox);

  minmax_idx = idx;

  int res = minmax_widget.exec();
  if (res == QDialog::Accepted) {
    bool ok = true;
    double min_value = minmax_textmin_widget->text().toDouble(&ok);
    if (!ok) {
      return;
    }

    double max_value = minmax_textmax_widget->text().toDouble(&ok);
    if (!ok) {
      return;
    }

    activate_minmax_ok(min_value, max_value);
  }
}

void GeCurveQt::open_export(
    pwr_tTime* from, pwr_tTime* to, int rows, char* filename)
{
  if (!cd) {
    return;
  }

  // Create an input dialog
  QDialog export_widget(toplevel);
  export_widget.setWindowTitle(fl("Export"));
  //Do not set the "DeleteOnClose" attribute,
  //we need to access the dialog fields after exec()

  QLabel* attr_label = new QLabel(translate_utf8("Attribute"));
  attr_label->setFixedWidth(90);
  QComboBox* export_attrcombo_widget = new QComboBox();
  export_attrcombo_widget->addItem(translate_utf8("All Attributes"));
  for (int i = 0; i < cd->cols; i++) {
    export_attrcombo_widget->addItem(convert_utf8(cd->y_name[i]));
  }
  export_attrcombo_widget->setCurrentIndex(0);

  export_filename_widget = new QLineEdit(fl(filename));
  QLabel* filename_label = new QLabel(translate_utf8("Filename"));
  filename_label->setFixedWidth(90);
  QPushButton* export_browse = new QPushButton(translate_utf8("Browse"));
  QObject::connect(export_browse, SIGNAL(clicked()), toplevel, SLOT(activate_export_browse()));

  QDialogButtonBox* buttons = new QDialogButtonBox();
  buttons->addButton(QDialogButtonBox::Ok);
  buttons->addButton(QDialogButtonBox::Cancel);

  QObject::connect(buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()),
      &export_widget, SLOT(accept()));
  QObject::connect(buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()),
      &export_widget, SLOT(reject()));

  QVBoxLayout* export_vbox = new QVBoxLayout(&export_widget);

  QHBoxLayout* export_hbox1 = new QHBoxLayout();
  export_hbox1->addWidget(attr_label);
  add_expanding(export_hbox1, export_attrcombo_widget);
  export_vbox->addLayout(export_hbox1);

  QLineEdit* export_fromtime_widget;
  QLineEdit* export_totime_widget;
  if (layout_mask & curve_mEnable_ExportTime) {
    char fromtime_str[40];
    char totime_str[40];
    time_AtoAscii(
        from, time_eFormat_DateAndTime, fromtime_str, sizeof(fromtime_str));
    time_AtoAscii(to, time_eFormat_DateAndTime, totime_str, sizeof(totime_str));

    export_fromtime_widget = new QLineEdit(fl(fromtime_str));
    export_fromtime_widget->setFixedWidth(200);
    QLabel* fromtime_label = new QLabel(translate_utf8("From"));
    fromtime_label->setFixedWidth(90);

    export_totime_widget = new QLineEdit(fl(totime_str));
    export_totime_widget->setFixedWidth(200);
    QLabel* totime_label = new QLabel(translate_utf8("To"));
    totime_label->setFixedWidth(90);

    QHBoxLayout* export_hbox2 = new QHBoxLayout();
    export_hbox2->addWidget(fromtime_label);
    export_hbox2->addWidget(export_fromtime_widget);
    export_hbox2->addWidget(totime_label);
    export_hbox2->addWidget(export_totime_widget);

    export_vbox->addLayout(export_hbox2);
  }

  QLineEdit* export_rows_widget;
  if (layout_mask & curve_mEnable_ExportTime) {
    char rows_str[40];
    sprintf(rows_str, "%d", rows);

    export_rows_widget = new QLineEdit(fl(rows_str));
    export_rows_widget->setFixedWidth(80);
    QLabel* rows_label = new QLabel(translate_utf8("Max number of rows"));
    rows_label->setFixedWidth(150);

    QHBoxLayout* export_hbox4 = new QHBoxLayout();
    export_hbox4->addWidget(rows_label);
    export_hbox4->addWidget(export_rows_widget);
    add_expanding(export_vbox, export_hbox4);
  }

  QHBoxLayout* export_hbox5 = new QHBoxLayout();
  export_hbox5->addWidget(filename_label);
  add_expanding(export_hbox5, export_filename_widget);
  export_hbox5->addWidget(export_browse);
  add_expanding(export_vbox, export_hbox5);

  export_vbox->addWidget(separator(QFrame::HLine));
  export_vbox->addWidget(buttons);

  export_widget.setLayout(export_vbox);

  int res = export_widget.exec();
  if (res == QDialog::Accepted) {
    pwr_tTime from, to;
    int rows = 5000;
    pwr_tFileName filename;
    pwr_tStatus sts;
    int idx = 0;

    from = pwr_cNTime;
    time_GetTime(&to);

    QString value = export_attrcombo_widget->currentText();
    if (value.isNull()) {
      return;
    }

    if (value.compare(translate_utf8("All Attributes")) == 0) {
      idx = -1;
    } else {
      for (int i = 0; i < cd->cols; i++) {
        if (value.compare(convert_utf8(cd->y_name[i])) == 0) {
          idx = i;
          break;
        }
      }
    }

    if (layout_mask & curve_mEnable_ExportTime) {
      sts = time_AsciiToA(
          qPrintable(export_fromtime_widget->text()), &from);

      if (EVEN(sts)) {
        wow->DisplayError("Syntax Error", "From time syntax error");
        return;
      }

      sts = time_AsciiToA(qPrintable(export_totime_widget->text()), &to);
      if (EVEN(sts)) {
        wow->DisplayError("Syntax Error", "To time syntax error");
        return;
      }

      bool ok = true;
      value = export_rows_widget->text();
      rows = value.toInt(&ok);
      if (!ok) {
        return;
      }
    }

    strcpy(filename, qPrintable(export_filename_widget->text()));

    if (export_cb) {
      sts = (export_cb)(parent_ctx, &from, &to, rows, idx, filename);
      if (EVEN(sts)) {
        wow->DisplayError("Export error", "Export error");
        return;
      }
    }
  }
}

void GeCurveQt::set_times(pwr_tTime* from, pwr_tTime* to)
{
  char timestr[32];

  time_AtoFormAscii(to, SWE, SECOND, timestr, sizeof(timestr));
  timebox_stop_time->setText(fl(timestr));

  time_AtoFormAscii(from, SWE, SECOND, timestr, sizeof(timestr));
  timebox_start_time->setText(fl(timestr));
}

void GeCurveQt::set_times_sensitivity(int sensitive)
{
  timebox_start_time->setEnabled(sensitive);
  timebox_stop_time->setEnabled(sensitive);
}

pwr_tStatus GeCurveQt::get_times(pwr_tTime* from, pwr_tTime* to)
{
  pwr_tStatus sts = time_FormAsciiToA(qPrintable(timebox_start_time->text()), SWE, SECOND, from);
  if (EVEN(sts)) {
    return sts;
  }

  sts = time_FormAsciiToA(qPrintable(timebox_stop_time->text()), SWE, SECOND, to);
  if (EVEN(sts)) {
    return sts;
  }

  return 1;
}

void GeCurveQt::set_inputfocus()
{
  growcurve_main_widget->setFocus();
}

void GeCurveQt::set_clock_cursor()
{
  toplevel->setCursor(Qt::WaitCursor);
}

void GeCurveQt::reset_cursor()
{
  toplevel->unsetCursor();
}

void* GeCurveQt::get_widget()
{
  if (options & curve_mOptions_Embedded) {
    return vbox;
  } else {
    return this;
  }
}

GeCurveQt::~GeCurveQt()
{
  delete wow;
}

void GeCurveQtWidget::closeEvent(QCloseEvent* event)
{
  if (!(curve->options & curve_mOptions_Embedded)) {
    curve->activate_exit();
  }
  QWidget::closeEvent(event);
}

void GeCurveQtWidget::focusInEvent(QFocusEvent* event)
{
  if (!curve->focustimer.disabled()) {
    curve->set_inputfocus();
    curve->focustimer.disable(400);
  }

  QWidget::focusInEvent(event);
}

GeCurveQt::GeCurveQt(void* gc_parent_ctx, QWidget* parent_widget,
    char* curve_name, char* filename, GeCurveData* curve_data, int pos_right,
    int gc_width, int gc_height, unsigned int gc_options, int gc_color_theme,
    void* basewidget)
    : GeCurve(gc_parent_ctx, curve_name, filename, curve_data, pos_right,
          gc_width, gc_height, gc_options, gc_color_theme),
      disable_timecombo_callback(0)
{
  int window_width = 900;
  int window_height = 700;
  const int names_height = 150;
  const int nav_height = 120;
  float height_scale = 1;

  if (gc_width != 0) {
    window_width = gc_width;
  }
  if (gc_height != 0) {
    height_scale = (float)gc_height / window_height;
    window_height = gc_height;
  }

  str_StrncpyCutOff(title, curve_name, sizeof(title), 1);

  // Qt
  toplevel = new GeCurveQtWidget(this, parent_widget);
  if (!(options & curve_mOptions_Embedded)) {
    toplevel->setMinimumSize(window_width, window_height);
    toplevel->setWindowTitle(convert_utf8(title));
    toplevel->setAttribute(Qt::WA_DeleteOnClose);

    CoWowQt::SetWindowIcon(toplevel);
  }

  QMenuBar* menu_bar = new QMenuBar();

  // File Entry
  QMenu* file = menu_bar->addMenu(translate_utf8("&File"));
  menu_add = addMenuItem(toplevel, file, "&Add", SLOT(activate_madd()));
  addMenuItem(toplevel, file, "&Refresh", SLOT(activate_configure()), "CTRL+R");
  addMenuItem(
      toplevel, file, "&Print", SLOT(activate_print()), "", "document-print");
  menu_new = addMenuItem(toplevel, file, "&New", SLOT(activate_new()));
  menu_open = addMenuItem(toplevel, file, "&Open", SLOT(activate_open()));
  menu_save = addMenuItem(toplevel, file, "S&ave", SLOT(activate_save()), "CTRL+S");
  menu_snapshot = addMenuItem(toplevel, file, "&Snapshot", SLOT(activate_snapshot()), "CTRL+N");
  menu_export = addMenuItem(toplevel, file, "&Export", SLOT(activate_export()));
  addMenuItem(
      toplevel, file, "&Close", SLOT(close()), "CTRL+W", "window-close");

  // View menu
  QMenu* view = menu_bar->addMenu(translate_utf8("&View"));
  addMenuItem(
      toplevel, view, "Zoom &In", SLOT(activate_zoomin()), "CTRL+I", "zoom-in");
  addMenuItem(toplevel, view, "Zoom &Out", SLOT(activate_zoomout()), "CTRL+O",
      "zoom-out");
  addMenuItem(toplevel, view, "Zoom &Reset", SLOT(activate_zoomreset()), "",
      "zoom-original");
  addMenuItem(toplevel, view, "&Background Color", SLOT(activate_background()));
  addMenuItem(
      toplevel, view, "&Show Names", SLOT(activate_showname()), "CTRL+W");
  addCheckableMenuItem(
      toplevel, view, "&Filled Curves", SLOT(activate_filledcurves()));
  addMenuItem(toplevel, view, "_X-Axis Limits", SLOT(activate_xlimits()));

  // Menu Help
  QMenu* help = menu_bar->addMenu(translate_utf8("&Help"));
  addMenuItem(
      toplevel, help, "&Help", SLOT(activate_help()), "CTRL+H", "system-help");

  // Toolbar
  QToolBar* tools = new QToolBar();
  addToolItem(toplevel, tools, "Zoom in", SLOT(activate_zoomin()),
      "$pwr_exe/xtt_zoom_in.png");
  addToolItem(toplevel, tools, "Zoom out", SLOT(activate_zoomout()),
      "$pwr_exe/xtt_zoom_out.png");
  addToolItem(toplevel, tools, "Zoom reset", SLOT(activate_zoomreset()),
      "$pwr_exe/xtt_zoom_reset.png");
  addToolItem(toplevel, tools, "Page left", SLOT(activate_page_left()),
      "$pwr_exe/ge_page_left.png");
  addToolItem(toplevel, tools, "Scroll left", SLOT(activate_scroll_left()),
      "$pwr_exe/ge_scroll_left.png");
  addToolItem(toplevel, tools, "Scroll right", SLOT(activate_scroll_right()),
      "$pwr_exe/ge_scroll_right.png");
  addToolItem(toplevel, tools, "Page right", SLOT(activate_page_right()),
      "$pwr_exe/ge_page_right.png");
  tools_add = addToolItem(
      toplevel, tools, "Add", SLOT(activate_add()), "$pwr_exe/xtt_add.png");
  tools_curvetype_line = addToolItem(toplevel, tools, "Curve line",
      SLOT(activate_curvetype()), "$pwr_exe/xtt_curve_line.png");
  tools_curvetype_line->setData(glow_eCurveType_Line);
  tools_curvetype_points = addToolItem(toplevel, tools, "Curve points",
      SLOT(activate_curvetype()), "$pwr_exe/xtt_curve_points.png");
  tools_curvetype_points->setData(glow_eCurveType_Points);
  tools_curvetype_linepoints
      = addToolItem(toplevel, tools, "Curve line and points",
          SLOT(activate_curvetype()), "$pwr_exe/xtt_curve_linepoints.png");
  tools_curvetype_linepoints->setData(glow_eCurveType_LinePoints);
  tools_curvetype_square = addToolItem(toplevel, tools, "Curve square",
      SLOT(activate_curvetype()), "$pwr_exe/xtt_curve_square.png");
  tools_curvetype_square->setData(glow_eCurveType_Square);
  tools_curve_fill = addToolItem(toplevel, tools, "Filled curves",
      SLOT(activate_filledcurves()), "$pwr_exe/xtt_curve_fill.png");
  tools_curve_digsplit = addToolItem(toplevel, tools, "Split digital curves",
      SLOT(activate_digsplit()), "$pwr_exe/xtt_curve_digsplit.png");
  tools_snapshot = addToolItem(toplevel, tools, "Snapshot",
      SLOT(activate_snapshot()), "$pwr_exe/xtt_snapshot.png");

  // Time box
  timetools = new QToolBar();

  QLabel* sea_time_start_label = new QLabel(translate_utf8("Time"));
  sea_time_start_label->setFixedWidth(70);
  timetools->addWidget(sea_time_start_label);

  // Time option menu
  timebox_timecombo = new QComboBox();

  for (int i = 0; curve_timecombo_text[i].text[0]; i++) {
    timebox_timecombo->addItem(translate_utf8(curve_timecombo_text[i].text));
  }

  QObject::connect(timebox_timecombo, SIGNAL(activated(int)), toplevel,
      SLOT(activate_timecombo(int)));

  timetools->addWidget(timebox_timecombo);
  timebox_start_time = new QLineEdit();
  timebox_start_time->setFixedWidth(160);
  timetools->addWidget(timebox_start_time);

  QLabel* sea_time_stop_label = new QLabel(translate_utf8("-"));
  sea_time_stop_label->setFixedWidth(20);
  timetools->addWidget(sea_time_stop_label);

  timebox_stop_time = new QLineEdit();
  timebox_stop_time->setFixedWidth(160);
  timetools->addWidget(timebox_stop_time);

  addToolItem(toplevel, timetools, "Previous period",
      SLOT(activate_prev_period()), "$pwr_exe/ge_scroll_left.png");
  addToolItem(toplevel, timetools, "Next period", SLOT(activate_next_period()),
      "$pwr_exe/ge_scroll_right.png");
  addToolItem(toplevel, timetools, "Increase period",
      SLOT(activate_increase_period()), "$pwr_exe/xtt_up.png");
  addToolItem(toplevel, timetools, "Decrease period",
      SLOT(activate_decrease_period()), "$pwr_exe/xtt_down.png");

  timetools->addSeparator();

  addToolItem(toplevel, timetools, "Update curve", SLOT(activate_reload()),
      "$pwr_exe/ge_reload.png");
  addToolItem(toplevel, timetools, "Add curve item", SLOT(activate_add()),
      "$pwr_exe/xtt_add.png");
  addToolItem(toplevel, timetools, "Remove selected curve",
      SLOT(activate_remove()), "$pwr_exe/xtt_remove.png");

  QWidget* w;
  grownames_main_widget = scrolledgrowwidgetqt_new(init_grownames_cb, this, &w);
  // grownames_main_widget must be realized _before_ growcurve_main_widget,
  // Otherwise growcurve_main_widget crashes :(
  grownames_main_widget->show();
  growcurve_main_widget = curvewidgetqt_new(init_growcurve_cb, this);
  growaxis_main_widget = growwidgetqt_new(init_growaxis_cb, this);
  nav_widget = curvenavwidgetqt_new(growcurve_main_widget);

  QHBoxLayout* hbox = new QHBoxLayout();
  hbox->addWidget(growaxis_main_widget);
  add_expanding(hbox, growcurve_main_widget);

  QSplitter* vpaned = new QSplitter(Qt::Vertical);

  vpaned->addWidget(grownames_main_widget);
  add_expanding(vpaned, hbox);
  vpaned->addWidget(nav_widget);

  QVBoxLayout* vbox_layout = new QVBoxLayout(toplevel);
  vbox_layout->setMenuBar(menu_bar);
  vbox_layout->addWidget(tools);
  vbox_layout->addWidget(timetools);
  add_expanding(vbox_layout, vpaned);

  if (!(options & curve_mOptions_Embedded)) {
    toplevel->setLayout(vbox_layout);

    toplevel->show();
  } else {
    vbox = layout_to_widget(vbox_layout);
    vbox->setMinimumSize(window_width, window_height);
  }

  QList<int> sizes;
  sizes << names_height * height_scale;
  sizes << (window_height - names_height - nav_height) * height_scale;
  sizes << nav_height * height_scale;
  vpaned->setSizes(sizes);

  timetools->setVisible(false);
  menu_new->setVisible(false);
  menu_save->setVisible(false);
  menu_open->setVisible(false);
  menu_snapshot->setVisible(false);
  menu_export->setVisible(false);
  tools_snapshot->setVisible(false);
  tools_curvetype_line->setVisible(false);
  tools_curvetype_points->setVisible(false);
  tools_curvetype_linepoints->setVisible(false);
  tools_curvetype_square->setVisible(false);
  tools_curve_fill->setVisible(false);
  tools_curve_digsplit->setVisible(false);

  wow = new CoWowQt(toplevel);

  timebox_timecombo->setCurrentIndex(2);

  if (!(options & curve_mOptions_Embedded)) {
    if (options & curve_mOptions_FullScreen) {
      toplevel->showFullScreen();
    } else if (options & curve_mOptions_Maximize) {
      toplevel->showMaximized();
    } else if (options & curve_mOptions_FullMaximize) {
      toplevel->showMaximized();
    } else if (options & curve_mOptions_Iconify) {
      toplevel->showMinimized();
    } else if (options & curve_mOptions_Invisible) {
      toplevel->setVisible(false);
    }

    if (basewidget) {
      toplevel->setModal(true);
    }
  }
}
