/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* ge_graph_command.cpp
   This module contains routines for handling of command line in ge. */

#include <stdlib.h>

#include "co_ccm.h"
#include "co_ccm_msg.h"
#include "co_dcli.h"
#include "co_dcli_msg.h"
#include "co_string.h"

#include "ge.h"
#include "ge_dyn.h"
#include "ge_msg.h"

#if LDH
#include "wb_wccm.h"
#endif

static Graph* current_graph;

static void graph_group_replace_attr(grow_tObject group, char* from_str,
    char* to_str, int* replace_cnt, int strict);

static int graph_show_func(void* client_data, void* client_flag);
static int graph_save_func(void* client_data, void* client_flag);
static int graph_open_func(void* client_data, void* client_flag);
static int graph_new_func(void* client_data, void* client_flag);
static int graph_set_func(void* client_data, void* client_flag);
static int graph_add_func(void* client_data, void* client_flag);
static int graph_create_func(void* client_data, void* client_flag);
static int graph_replace_func(void* client_data, void* client_flag);
static int graph_rotate_func(void* client_data, void* client_flag);
static int graph_flip_func(void* client_data, void* client_flag);
static int graph_scale_func(void* client_data, void* client_flag);
static int graph_move_func(void* client_data, void* client_flag);
static int graph_exit_func(void* client_data, void* client_flag);
static int graph_quit_func(void* client_data, void* client_flag);
static int graph_group_func(void* client_data, void* client_flag);
static int graph_select_func(void* client_data, void* client_flag);
static int graph_export_func(void* client_data, void* client_flag);
static int graph_replace_func(void* client_data, void* client_flag);
static int graph_disable_func(void* client_data, void* client_flag);
static int graph_convert_func(void* client_data, void* client_flag);
static int graph_two_func(void* client_data, void* client_flag);
static int graph_build_func(void* client_data, void* client_flag);
static int graph_customcolor_func(void* client_data, void* client_flag);
static int graph_search_func(void* client_data, void* client_flag);
static int graph_filter_func(void* client_data, void* client_flag);
static int graph_check_func(void* client_data, void* client_flag);

dcli_tCmdTable graph_command_table[] = { { "SHOW", &graph_show_func,
                                             { "dcli_arg1", "dcli_arg2", "" } },
  { "SAVE", &graph_save_func, { "dcli_arg1", "/FILE", "" } },
  { "OPEN", &graph_open_func, { "dcli_arg1", "/FILE", "" } },
  { "NEW", &graph_new_func, { "" } },
  { "SET", &graph_set_func, { "dcli_arg1", "dcli_arg2", "dcli_arg3",
                                "dcli_arg4", "/ON", "/OFF", "/RESET", "" } },
  { "ADD", &graph_add_func, { "dcli_arg1", "dcli_arg2", "/X1", "/Y1", "" } },
  { "ROTATE", &graph_rotate_func, { "dcli_arg1", "/ANGLE", "" } },
  { "FLIP", &graph_flip_func, { "dcli_arg1", "" } },
  { "SCALE", &graph_scale_func,
      { "dcli_arg1", "/SCALEX", "/SCALEY", "/X", "/Y", "" } },
  { "MOVE", &graph_move_func,
      { "dcli_arg1", "/X", "/Y", "/ABSX", "/ABSY", "" } },
  { "CREATE", &graph_create_func,
      { "dcli_arg1", "/X1", "/Y1", "/X2", "/Y2", "/WIDTH", "/HEIGHT", "/ANGLE1",
          "/ANGLE2", "/TEXT", "/SUBGRAPH", "/IMAGE", "" } },
  { "REPLACE", &graph_replace_func,
      { "dcli_arg1", "/FROM", "/TO", "/STRICT", "" } },
  { "CONVERT", &graph_convert_func, { "dcli_arg1", "" } },
  { "EXIT", &graph_exit_func, { "" } }, { "QUIT", &graph_quit_func, { "" } },
  { "GROUP", &graph_group_func, { "" } },
  { "SELECT", &graph_select_func, { "dcli_arg1", "/NAME", "" } },
  { "EXPORT", &graph_export_func, { "dcli_arg1", "/SIGNATURE", "/FILE", "" } },
  { "DISABLE", &graph_disable_func, { "dcli_arg1", "" } },
  { "TWO", &graph_two_func, { "" } }, { "BUILD", &graph_build_func, { "" } },
  { "CUSTOMCOLOR", &graph_customcolor_func,
      { "dcli_arg", "/FILE", "/LIGHTNESS", "/ISDEFAULT", "" } },
  { "SEARCH", &graph_search_func, { "dcli_arg", "dcli_arg2", "/NAME", "" } },
  { "FILTER", &graph_filter_func,
      { "dcli_arg", "/RESET", "/TYPE", "/PATTERN", "" } },
  { "CHECK", &graph_check_func, { "dcli_arg", "/INSTANCE", "" } },
  { "", NULL, { "" } }
};

static void graph_store_graph(Graph* graph)
{
  current_graph = graph;
}

static void graph_get_stored_graph(Graph** graph)
{
  *graph = current_graph;
}

static int graph_show_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "VERSION", strlen(arg1_str)) == 0) {
    // Command is "SHOW VERSION"
    char message_str[80];
    int grow_version, graph_version;

    grow_GetVersion(graph->grow->ctx, &grow_version, &graph_version);

    sprintf(message_str, "Current graph: V%d.%03d, Grow: V%d.%03d",
        int(graph_version / 1000), graph_version % 1000,
        int(grow_version / 1000), grow_version % 1000);
    graph->message('I', message_str);
  } else {
    graph->message('E', "Unknown qualifier");
    return GE__QUAL;
  }
  return GE__SUCCESS;
}

static int graph_save_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char file_str[80];
  char name[40];

  if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
    if (strlen(file_str) > 39) {
      graph->message('E', "Filename to long");
      return GE__FILENAME;
    }
    strcpy(name, file_str);
  } else if (ODD(dcli_get_qualifier("dcli_arg1", file_str, sizeof(file_str)))) {
    if (strlen(file_str) > 39) {
      graph->message('E', "Filename to long");
      return GE__FILENAME;
    }
    strcpy(name, file_str);
  } else
    graph->get_name(name);

  // Assume that parent is Ge
  ((Ge*)graph->parent_ctx)->save(name);
  return GE__SUCCESS;
}

static int graph_quit_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  // Assume that parent is Ge
  delete (Ge*)graph->parent_ctx;
  return GE__SUCCESS;
}

static int graph_build_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char name[40];
  pwr_tCmd cmd;

  graph->get_name(name);
  if (streq(name, "") || graph->is_modified()) {
    graph->message('E', "Build error, graph is not saved");
    return GE__NOTSAVED;
  }

  sprintf(cmd, "cp -a $pwrp_pop/%s.pwg $pwrp_exe/", name);
  system(cmd);

  return GE__SUCCESS;
}

static int graph_customcolor_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;
  char arg1_str[80];
  int arg1_sts;
  int sts;
  char file_str[80];

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "WRITE", strlen(arg1_str)) == 0) {
    // Command is "CUSTOMCOLOR WRITE"

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = grow_WriteCustomColorFile(graph->grow->ctx, file_str);
    if (EVEN(sts)) {
      graph->message('E', "Write error");
      return GE__SYNTAX;
    }
    graph->message('I', "Custom color file created");
  } else if (str_NoCaseStrncmp(arg1_str, "READ", strlen(arg1_str)) == 0) {
    // Command is "CUSTOMCOLOR READ"

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = grow_ReadCustomColorFile(graph->grow->ctx, file_str);
    if (EVEN(sts)) {
      graph->message('E', "Read error");
      return GE__SYNTAX;
    }
    if (graph->update_colorpalette_cb)
      (graph->update_colorpalette_cb)(graph->parent_ctx);

    graph->message('I', "Custom color file read");
  } else if (str_NoCaseStrncmp(arg1_str, "PRINT", strlen(arg1_str)) == 0) {
    // Command is "CUSTOMCOLOR PRINT"

    grow_PrintRgbColors(graph->grow->ctx);
  } else if (str_NoCaseStrncmp(arg1_str, "SET", strlen(arg1_str)) == 0) {
    // Command is "CUSTOMCOLOR SET"
    char str[80];

    if (ODD(dcli_get_qualifier("/LIGHTNESS", str, sizeof(str)))) {
      int lightness;
      int num;

      num = sscanf(str, "%d", &lightness);
      if (num != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SetColorThemeLightness(graph->grow->ctx, lightness);
      graph->message('I', "ColorTheme lightness set");
    } else if (ODD(dcli_get_qualifier("/ISDEFAULT", str, sizeof(str)))) {
      int isdefault;
      int num;

      num = sscanf(str, "%d", &isdefault);
      if (num != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SetColorThemeIsDefault(graph->grow->ctx, isdefault);
      graph->message('I', "ColorTheme is default set");
    } else {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_search_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;
  char arg1_str[80];
  int arg1_sts;
  int sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    // Command is "SEARCH OBJECT"
    char name_str[80];

    sts = dcli_get_qualifier("/NAME", name_str, sizeof(name_str));
    if (EVEN(sts))
      sts = dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str));
    if (EVEN(sts)) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    sts = graph->search_object(name_str);
    if (EVEN(sts))
      graph->message('E', "No such object");
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_filter_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;
  char arg1_str[80];
  int arg1_sts;
  int sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "NAVIGATOR", strlen(arg1_str)) == 0) {
    // Command is "FILTER NAVIGATOR"
    char type_str[80];
    char pattern_str[80];
    int type;

    if (ODD(dcli_get_qualifier("/RESET", 0, 0))) {
      ((Ge*)graph->parent_ctx)->objectnav->filter(0, 0);
      return GE__SUCCESS;
    }

    sts = dcli_get_qualifier("/TYPE", type_str, sizeof(type_str));
    if (EVEN(sts)) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    if (str_NoCaseStrcmp(type_str, "name") == 0)
      type = 1;
    else if (str_NoCaseStrcmp(type_str, "class") == 0)
      type = 2;
    else {
      graph->message('E', "Syntax error in filter type");
      return GE__SYNTAX;
    }

    sts = dcli_get_qualifier("/PATTERN", pattern_str, sizeof(pattern_str));
    if (EVEN(sts)) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    ((Ge*)graph->parent_ctx)->objectnav->filter(type, pattern_str);
    ;
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_check_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "SYNTAX", strlen(arg1_str)) == 0) {
    // Command is "CHECK SYNTAX"
    pwr_tAName instance_str;
    char* instance_p;
    int sts;

    sts = dcli_get_qualifier("/INSTANCE", instance_str, sizeof(instance_str));
    if (ODD(sts))
      instance_p = instance_str;
    else
      instance_p = 0;

    graph->syntax_check(instance_p);
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_exit_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;
  char name[40];

  graph->get_name(name);
  if (streq(name, "")) {
    graph->message('E', "Graph has no name, 'save as' or 'quit'");
    return GE__NONAME;
  }

  // Assume that parent is Ge
  ((Ge*)graph->parent_ctx)->save(name);
  delete (Ge*)graph->parent_ctx;
  return GE__SUCCESS;
}

static int graph_open_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  pwr_tFileName file_str;
  pwr_tFileName name;

  if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
    strcpy(name, file_str);
  } else if (ODD(dcli_get_qualifier("dcli_arg1", file_str, sizeof(file_str)))) {
    strcpy(name, file_str);
  } else {
    graph->message('E', "Enter filename");
    return GE__SYNTAX;
  }

  // Assume that parent is Ge
  ((Ge*)graph->parent_ctx)->open(name);
  return GE__SUCCESS;
}

static int graph_new_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  // Assume that parent is Ge
  ((Ge*)graph->parent_ctx)->clear();
  return GE__SUCCESS;
}

static int graph_set_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "VERIFY", strlen(arg1_str)) == 0) {
    graph->verify = 1;
  } else if (str_NoCaseStrncmp(arg1_str, "NOVERIFY", strlen(arg1_str)) == 0) {
    graph->verify = 0;
  } else if (str_NoCaseStrncmp(arg1_str, "FILL", strlen(arg1_str)) == 0) {
    graph->set_fill(1);
  } else if (str_NoCaseStrncmp(arg1_str, "NOFILL", strlen(arg1_str)) == 0) {
    graph->set_fill(0);
  } else if (str_NoCaseStrncmp(arg1_str, "BORDER", strlen(arg1_str)) == 0) {
    graph->set_border(1);
  } else if (str_NoCaseStrncmp(arg1_str, "NOBORDER", strlen(arg1_str)) == 0) {
    graph->set_border(0);
  } else if (str_NoCaseStrncmp(arg1_str, "SHADOW", strlen(arg1_str)) == 0) {
    graph->set_shadow(1);
  } else if (str_NoCaseStrncmp(arg1_str, "NOSHADOW", strlen(arg1_str)) == 0) {
    graph->set_shadow(0);
  } else if (str_NoCaseStrncmp(arg1_str, "GRID", strlen(arg1_str)) == 0) {
    graph->set_grid(1);
  } else if (str_NoCaseStrncmp(arg1_str, "NOGRID", strlen(arg1_str)) == 0) {
    graph->set_grid(0);
  } else if (str_NoCaseStrncmp(arg1_str, "LINEWIDTH", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int line_width;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(arg2_str, "%d", &line_width);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    if (line_width < 1 || line_width > 8) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    graph->set_linewidth(line_width);
  } else if (str_NoCaseStrncmp(arg1_str, "GRIDSIZE", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    float grid_size;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(arg2_str, "%f", &grid_size);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    graph->set_gridsize(double(grid_size));
  } else if (str_NoCaseStrncmp(arg1_str, "TEXTSIZE", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int text_size, size;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(arg2_str, "%d", &text_size);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    switch (text_size) {
    case 8:
      size = 0;
      break;
    case 10:
      size = 1;
      break;
    case 12:
      size = 2;
      break;
    case 14:
      size = 3;
      break;
    case 18:
      size = 4;
      break;
    case 24:
      size = 5;
      break;
    default:
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    graph->set_textsize(size);
  } else if (str_NoCaseStrncmp(arg1_str, "TEXTFONT", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int sts;
    int value;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(arg2_str, "%d", &value);
    if (sts != 1) {
      sts = AttrNav::string_to_enum(glow_eType_Font, arg2_str, &value);
      if (EVEN(sts)) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
    }
    graph->textfont = (glow_eFont)value;
  } else if (str_NoCaseStrncmp(arg1_str, "BOLD", strlen(arg1_str)) == 0) {
    graph->set_textbold(1);
  } else if (str_NoCaseStrncmp(arg1_str, "NOBOLD", strlen(arg1_str)) == 0) {
    graph->set_textbold(0);
  } else if (str_NoCaseStrncmp(arg1_str, "BACKGROUNDCOLOR", strlen(arg1_str))
      == 0) {
    char arg2_str[80];
    int value;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->set_background_color();
    } else {
      sts = sscanf(arg2_str, "%d", &value);
      if (sts != 1) {
        sts = AttrNav::string_to_enum(glow_eType_Color, arg2_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
      }
      if (value < 0 || value >= glow_eDrawType_CustomColor__) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SetBackgroundColor(graph->grow->ctx, (glow_eDrawType)value);
    }
  } else if (str_NoCaseStrncmp(arg1_str, "FILLCOLOR", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    glow_eDrawType fill_color, border_color, text_color;
    int value;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    sts = sscanf(arg2_str, "%d", &value);
    if (sts != 1) {
      sts = AttrNav::string_to_enum(glow_eType_Color, arg2_str, &value);
      if (EVEN(sts)) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
    }
    if (value < 0 || value >= glow_eDrawType_CustomColor__) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    (graph->get_current_colors_cb)(
        graph->parent_ctx, &fill_color, &border_color, &text_color);
    fill_color = (glow_eDrawType)value;
    (graph->set_current_colors_cb)(
        graph->parent_ctx, fill_color, border_color, text_color);
  } else if (str_NoCaseStrncmp(arg1_str, "BORDERCOLOR", strlen(arg1_str))
      == 0) {
    char arg2_str[80];
    glow_eDrawType fill_color, border_color, text_color;
    int value;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    sts = sscanf(arg2_str, "%d", &value);
    if (sts != 1) {
      sts = AttrNav::string_to_enum(glow_eType_Color, arg2_str, &value);
      if (EVEN(sts)) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
    }
    if (value < 0 || value >= glow_eDrawType_CustomColor__) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    (graph->get_current_colors_cb)(
        graph->parent_ctx, &fill_color, &border_color, &text_color);
    border_color = (glow_eDrawType)value;
    (graph->set_current_colors_cb)(
        graph->parent_ctx, fill_color, border_color, text_color);
  } else if (str_NoCaseStrncmp(arg1_str, "TEXTCOLOR", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    glow_eDrawType fill_color, border_color, text_color;
    int value;
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    sts = sscanf(arg2_str, "%d", &value);
    if (sts != 1) {
      sts = AttrNav::string_to_enum(glow_eType_Color, arg2_str, &value);
      if (EVEN(sts)) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
    }
    if (value < 0 || value >= glow_eDrawType_CustomColor__) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    (graph->get_current_colors_cb)(
        graph->parent_ctx, &fill_color, &border_color, &text_color);
    text_color = (glow_eDrawType)value;
    (graph->set_current_colors_cb)(
        graph->parent_ctx, fill_color, border_color, text_color);
  } else if (str_NoCaseStrncmp(arg1_str, "CURRENTOBJECT", strlen(arg1_str))
      == 0) {
    char arg2_str[80];
    int arg2_sts;

    arg2_sts = dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str));

    if (str_NoCaseStrncmp(arg2_str, "FILLCOLOR", strlen(arg2_str)) == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%u", &value);
      if (sts != 1) {
        sts = AttrNav::string_to_enum(glow_eType_Color, arg3_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
      }
      if (value < 0 || value >= glow_eDrawType_CustomColor__) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectOrigFillColor(graph->grow->ctx, (glow_eDrawType)value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "SHADOW", strlen(arg2_str)) == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%u", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      if (!(value == 0 || value == 1)) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectShadow(graph->grow->ctx, value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "COLORTONE", strlen(arg2_str))
        == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%u", &value);
      if (sts != 1) {
        sts = AttrNav::string_to_enum(glow_eType_Tone, arg3_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
      }
      if (value < 0 || value > 99) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectOrigColorTone(graph->grow->ctx, (glow_eDrawTone)value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "COLORLIGHTNESS", strlen(arg2_str))
        == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%d", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectOrigColLightness(graph->grow->ctx, value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "COLORINTENSITY", strlen(arg2_str))
        == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%d", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectOrigColIntensity(graph->grow->ctx, value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "COLORSHIFT", strlen(arg2_str))
        == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%d", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectOrigColorShift(graph->grow->ctx, value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "GRADIENT", strlen(arg2_str)) == 0) {
      char arg3_str[80];
      int sts;
      int value;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }

      sts = sscanf(arg3_str, "%u", &value);
      if (sts != 1) {
        sts = AttrNav::string_to_enum(glow_eType_Gradient, arg3_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
      }
      grow_SelectClear(graph->grow->ctx);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);

      grow_SetSelectGradient(graph->grow->ctx, (glow_eGradient)value);

      grow_SelectRemove(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg2_str, "ATTRIBUTES", strlen(arg2_str))
        == 0) {
      char arg3_str[80];
      char arg4_str[80];
      attr_sItem* itemlist;
      attr_sItem* item_p;
      int item_cnt;
      void* client_data;
      char attr_name[80];
      int i_value;
      float f_value;
      double d_value;
      int i;
      int sts;
      int found;

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg4", arg4_str, sizeof(arg4_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      graph->get_attr_items(
          graph->current_cmd_object, &itemlist, &item_cnt, &client_data);

      found = 0;
      item_p = itemlist;
      for (i = 0; i < item_cnt; i++) {
        // str_ToUpper( attr_name, item_p->name);
        strcpy(attr_name, item_p->name);
        if (str_NoCaseStrcmp(arg3_str, attr_name) == 0) {
          found = 1;
          break;
        }
        item_p++;
      }

      if (!found) {
        graph->message('E', "No such attribute");
        return GE__NOATTR;
      }
      switch (item_p->type) {
      case glow_eType_Int:
      case glow_eType_TraceColor:
      case glow_eType_Boolean:
        sts = sscanf(arg4_str, "%d", &i_value);
        if (sts != 1) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
        memcpy(item_p->value, (char*)&i_value, sizeof(i_value));
        break;
      case glow_eType_Double:
        sts = sscanf(arg4_str, "%f", &f_value);
        if (sts != 1) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
        d_value = double(f_value);
        memcpy(item_p->value, (char*)&d_value, sizeof(d_value));
        break;
      case glow_eType_String:
        strncpy((char*)item_p->value, arg4_str, item_p->size);
        break;
      case glow_eType_Direction:
      case glow_eType_Color:
      case glow_eType_Tone:
      case glow_eType_ToneOrColor:
      case glow_eType_Cycle:
      case glow_eType_MB3Action:
      case ge_eAttrType_AnimSequence:
      case ge_eAttrType_LimitType:
      case glow_eType_Relief:
      case glow_eType_InputFocusMark:
      case ge_eAttrType_ScaleType:
      case glow_eType_Adjustment:
      case glow_eType_Font:
      case ge_eAttrType_CurveDataType:
      case glow_eType_Gradient:
      case glow_eType_HotIndication:
      case glow_eType_AppMotion:
      case glow_eType_AnnotType:
      case ge_eAttrType_OptionMenuType: {
        int value;
        sts = sscanf(arg4_str, "%u", &value);
        if (sts != 1) {
          sts = AttrNav::string_to_enum(item_p->type, arg4_str, &value);
          if (EVEN(sts)) {
            graph->message('E', "Syntax error");
            return GE__SYNTAX;
          }
        }
        memcpy(item_p->value, (char*)&value, sizeof(value));
        break;
      }
      case glow_eType_TextSize: {
        int value;
        sts = AttrNav::string_to_enum(item_p->type, arg4_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
        memcpy(item_p->value, (char*)&value, sizeof(value));
        break;
      }
      case glow_eType_Access:
      case ge_eAttrType_DynType1:
      case ge_eAttrType_DynType2:
      case ge_eAttrType_ActionType1:
      case ge_eAttrType_InputFocus: {
        unsigned int value;
        sts = sscanf(arg4_str, "%u", &value);
        if (sts != 1) {
          sts = AttrNav::string_to_mask(item_p->type, arg4_str, &value);
          if (EVEN(sts)) {
            graph->message('E', "Syntax error");
            return GE__SYNTAX;
          }
        }
        memcpy(item_p->value, (char*)&value, sizeof(value));
        break;
      }
      case ge_eAttrType_InstanceMask: {
        unsigned int value;
        sts = AttrNav::string_to_mask(item_p->type, arg4_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          return GE__SYNTAX;
        }
        memcpy(item_p->value, (char*)&value, sizeof(value));
        break;
      }
      default:;
      }
      grow_UpdateObject(graph->grow->ctx, graph->current_cmd_object,
          (grow_sAttrInfo*)client_data);

    } else if (str_NoCaseStrncmp(arg2_str, "ATTR1", strlen(arg2_str)) == 0) {
      char arg3_str[80];

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      graph->connect(graph->current_cmd_object, arg3_str, 0);
    } else if (str_NoCaseStrncmp(arg2_str, "ATTR2", strlen(arg2_str)) == 0) {
      char arg3_str[80];

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      graph->connect(graph->current_cmd_object, arg3_str, 1);
    } else if (str_NoCaseStrncmp(arg2_str, "ANNOTATION", strlen(arg2_str))
        == 0) {
      char arg3_str[80];

      if (!graph->current_cmd_object) {
        graph->message('E', "No current object");
        return GE__NOCURRENT;
      }
      if (grow_GetObjectType(graph->current_cmd_object)
          != glow_eObjectType_GrowNode) {
        graph->message(
            'E', "Current object type doesn't support this operation");
        return GE__CURRENT_TYPE;
      }
      if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      grow_SetAnnotation(
          graph->current_cmd_object, 1, arg3_str, strlen(arg3_str));
    } else {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "GRAPHATTRIBUTES", strlen(arg1_str))
      == 0) {
    char arg2_str[80];
    char arg3_str[80];
    int i, j;
    grow_sAttrInfo* grow_info = 0;
    grow_sAttrInfo* grow_info_sub = NULL;
    grow_sAttrInfo* grow_info_p = NULL;
    int grow_info_cnt;
    char attr_name[80];
    int i_value;
    float f_value;
    double d_value;
    int sts;
    int found;
    char transtab[][32] = { "DynType1", "DynType1", "DynType2", "DynType2",
      "DynActionType1", "Action", "DynColor1", "Color1", "DynColor2", "Color2",
      "DynColor3", "Color3", "DynColor4", "Color4", "DynAttr1", "AnimSequence",
      "DynAttr2", "", "DynAttr3", "", "DynAttr4", "", "Dynamic", "", "" };

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    found = 0;
    for (j = 0; j < 2; j++) {
      if (j == 0) {
        grow_GetSubGraphAttrInfo(
            graph->grow->ctx, (char*)transtab, &grow_info_sub, &grow_info_cnt);
        grow_info_p = grow_info_sub;
      } else {
        grow_GetGraphAttrInfo(graph->grow->ctx, &grow_info, &grow_info_cnt);
        grow_info_p = grow_info;
      }
      for (i = 0; i < grow_info_cnt; i++) {
        // str_ToUpper( attr_name, grow_info_p->name);
        strcpy(attr_name, grow_info_p->name);
        if (str_NoCaseStrcmp(arg2_str, attr_name) == 0) {
          found = 1;
          break;
        }
        grow_info_p++;
      }
      if (found)
        break;
    }
    if (!found) {
      graph->message('E', "No such attribute");
      grow_FreeSubGraphAttrInfo(grow_info_sub);
      if (grow_info)
        grow_FreeGraphAttrInfo(grow_info);
      return GE__NOATTR;
    }
    switch (grow_info_p->type) {
    case glow_eType_Int:
    case glow_eType_Boolean:
      sts = sscanf(arg3_str, "%d", &i_value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        grow_FreeSubGraphAttrInfo(grow_info_sub);
        if (grow_info)
          grow_FreeGraphAttrInfo(grow_info);
        return GE__SYNTAX;
      }
      memcpy(grow_info_p->value_p, (char*)&i_value, sizeof(i_value));
      break;
    case glow_eType_Double:
      sts = sscanf(arg3_str, "%f", &f_value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        grow_FreeSubGraphAttrInfo(grow_info_sub);
        if (grow_info)
          grow_FreeGraphAttrInfo(grow_info);
        return GE__SYNTAX;
      }
      d_value = double(f_value);
      memcpy(grow_info_p->value_p, (char*)&d_value, sizeof(d_value));
      break;
    case glow_eType_String:
      strncpy((char*)grow_info_p->value_p, arg3_str, grow_info_p->size);
      break;
    case glow_eType_TraceColor:
      grow_info_p->type = glow_eType_Color;
    case glow_eType_Direction:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case glow_eType_Relief:
    case glow_eType_InputFocusMark:
    case ge_eAttrType_ScaleType:
    case glow_eType_Adjustment:
    case glow_eType_Font:
    case ge_eAttrType_CurveDataType:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case glow_eType_AnnotType:
    case ge_eAttrType_OptionMenuType: {
      int value;
      sts = sscanf(arg3_str, "%u", &value);
      if (sts != 1) {
        sts = AttrNav::string_to_enum(grow_info_p->type, arg3_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          grow_FreeSubGraphAttrInfo(grow_info_sub);
          if (grow_info)
            grow_FreeGraphAttrInfo(grow_info);
          return GE__SYNTAX;
        }
      }
      memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_TextSize: {
      int value;
      sts = AttrNav::string_to_enum(grow_info_p->type, arg3_str, &value);
      if (EVEN(sts)) {
        graph->message('E', "Syntax error");
        grow_FreeSubGraphAttrInfo(grow_info_sub);
        if (grow_info)
          grow_FreeGraphAttrInfo(grow_info);
        return GE__SYNTAX;
      }
      memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_InputFocus: {
      unsigned int value;
      sts = sscanf(arg3_str, "%u", &value);
      if (sts != 1) {
        sts = AttrNav::string_to_mask(grow_info_p->type, arg3_str, &value);
        if (EVEN(sts)) {
          graph->message('E', "Syntax error");
          grow_FreeSubGraphAttrInfo(grow_info_sub);
          if (grow_info)
            grow_FreeGraphAttrInfo(grow_info);
          return GE__SYNTAX;
        }
      }
      memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
      break;
    }
    default:;
    }

    grow_FreeSubGraphAttrInfo(grow_info_sub);
    if (grow_info)
      grow_FreeGraphAttrInfo(grow_info);
  } else if (str_NoCaseStrncmp(arg1_str, "EXTERN", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int sts;
    grow_tObject nodeclass;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    // str_ToLower( arg2_str, arg2_str);
    sts = grow_FindNodeClassByName(graph->grow->ctx, arg2_str, &nodeclass);
    if (EVEN(sts)) {
      graph->message('E', "Subgraph not found");
      return GE__NOSUBGRAPH;
    }

    grow_SetNodeClassExtern(nodeclass, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "INTERN", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int sts;
    grow_tObject nodeclass;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    // str_ToLower( arg2_str, arg2_str);
    sts = grow_FindNodeClassByName(graph->grow->ctx, arg2_str, &nodeclass);
    if (EVEN(sts)) {
      graph->message('E', "Subgraph not found");
      return GE__NOSUBGRAPH;
    }

    grow_SetNodeClassExtern(nodeclass, 0);
  } else if (str_NoCaseStrncmp(arg1_str, "JAVAPATH", strlen(arg1_str)) == 0) {
    char arg2_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    // str_ToLower( arg2_str, arg2_str);

    strcpy(graph->java_path, arg2_str);
  } else if (str_NoCaseStrncmp(arg1_str, "JAVAPACKAGE", strlen(arg1_str))
      == 0) {
    char arg2_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    // str_ToLower( arg2_str, arg2_str);

    strcpy(graph->java_package, arg2_str);
  } else if (str_NoCaseStrncmp(arg1_str, "ZOOM", strlen(arg1_str)) == 0) {
    if (ODD(dcli_get_qualifier("/RESET", 0, 0))) {
      grow_UnZoom(graph->grow->ctx);
    } else {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
  } else if (str_NoCaseStrcmp(arg1_str, "ADVANCEDUSER") == 0
      || str_NoCaseStrcmp(arg1_str, "NOADVANCEDUSER") == 0
      || str_NoCaseStrcmp(arg1_str, "ALLTOPLEVEL") == 0
      || str_NoCaseStrcmp(arg1_str, "NOALLTOPLEVEL") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWCLASS") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWCLASS") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWALIAS") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWALIAS") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWDESCRIPTION") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWDESCRIPTION") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWOBJREF") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWOBJREF") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWOBJXREF") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWOBJXREF") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWATTRREF") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWATTRREF") == 0
      || str_NoCaseStrcmp(arg1_str, "SHOWATTRXREF") == 0
      || str_NoCaseStrcmp(arg1_str, "NOSHOWATTRXREF") == 0
      || str_NoCaseStrcmp(arg1_str, "BUILDCROSSREF") == 0
      || str_NoCaseStrcmp(arg1_str, "NOBUILDCROSSREF") == 0
      || str_NoCaseStrcmp(arg1_str, "BUILDMANUAL") == 0
      || str_NoCaseStrcmp(arg1_str, "NOBUILDMANUAL") == 0
      || str_NoCaseStrcmp(arg1_str, "WINDOW") == 0
      || str_NoCaseStrcmp(arg1_str, "INPUTFOCUS") == 0) {
    // Compatible with xnav init file
  } else if (str_NoCaseStrncmp(arg1_str, "ENABLECOMMENT", strlen(arg1_str))
      == 0) {
    graph->disable_log = 0;
  } else if (str_NoCaseStrncmp(arg1_str, "NOENABLECOMMENT", strlen(arg1_str))
      == 0) {
    graph->disable_log = 1;
  } else if (str_NoCaseStrncmp(arg1_str, "EDITSETMODE", strlen(arg1_str))
      == 0) {
    char arg2_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    if (str_NoCaseStrcmp(arg2_str, "none") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_None);
      graph->message('E', "Mode set to None");
    } else if (str_NoCaseStrcmp(arg2_str, "x0") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_X0);
      graph->message('E', "Mode set to X0");
    } else if (str_NoCaseStrcmp(arg2_str, "y0") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_Y0);
      graph->message('E', "Mode set to Y0");
    } else if (str_NoCaseStrcmp(arg2_str, "x0y0") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_X0Y0);
      graph->message('E', "Mode set to X0Y0");
    } else if (str_NoCaseStrcmp(arg2_str, "x1") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_X1);
      graph->message('E', "Mode set to X1");
    } else if (str_NoCaseStrcmp(arg2_str, "y1") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_Y1);
      graph->message('E', "Mode set to Y1");
    } else if (str_NoCaseStrcmp(arg2_str, "x1y1") == 0) {
      grow_SetEditSetMode(graph->grow->ctx, glow_eEditSetMode_X1Y1);
      graph->message('E', "Mode set to X1Y1");
    } else {
      graph->message('E', "No such mode");
      return GE__SYNTAX;
    }
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_two_func(void* client_data, void* client_flag)
{
  return GE__SUCCESS;
}

static int graph_add_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "POLYLINE", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x, y;
    glow_sPoint points[2];
    int point_cnt;

    if (!graph->current_cmd_object) {
      graph->message('E', "No current object");
      return GE__NOCURRENT;
    }
    if (grow_GetObjectType(graph->current_cmd_object)
        != glow_eObjectType_GrowPolyLine) {
      graph->message('E', "Current object type doesn't support this operation");
      return GE__CURRENT_TYPE;
    }
    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y = value;

    points[0].x = x;
    points[0].y = y;
    point_cnt = 1;
    grow_AddPolyLinePoints(
        graph->current_cmd_object, (glow_sPoint*)&points, point_cnt);
    grow_SetModified(graph->grow->ctx, 1);
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_rotate_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;
  char str[80];
  int sts;
  float value;
  double angle;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "CURRENTOBJECT", strlen(arg1_str)) == 0) {
    if (!graph->current_cmd_object) {
      graph->message('E', "No current object");
      return GE__NOCURRENT;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "SELECTEDOBJECT", strlen(arg1_str))
      == 0) {
    grow_tObject* sel_list;
    int sel_count;

    grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
    if (sel_count != 1) {
      graph->message('E', "Select one object");
      return GE__SYNTAX;
    }
    graph->current_cmd_object = sel_list[0];
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }

  if (EVEN(dcli_get_qualifier("/ANGLE", str, sizeof(str)))) {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  sts = sscanf(str, "%f", &value);
  if (sts != 1) {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  angle = double(value);

  grow_StoreTransform(graph->current_cmd_object);
  grow_SetObjectRotation(
      graph->current_cmd_object, angle, 0, 0, glow_eRotationPoint_Center);
  grow_SetModified(graph->grow->ctx, 1);

  return GE__SUCCESS;
}

static int graph_flip_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "HORIZONTAL", strlen(arg1_str)) == 0) {
    grow_FlipSelectedObjects(graph->grow->ctx, glow_eFlipDirection_Horizontal);
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "VERTICAL", strlen(arg1_str)) == 0) {
    grow_FlipSelectedObjects(graph->grow->ctx, glow_eFlipDirection_Vertical);
    grow_SetModified(graph->grow->ctx, 1);
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_select_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;
  char name_str[80];

  if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
    grow_tObject object;
    int sts;

    sts = grow_FindObjectByName(graph->grow->ctx, name_str, &object);
    if (EVEN(sts)) {
      graph->message('E', "No such object");
      return sts;
    }
    grow_SetHighlight(object, 1);
    grow_SelectInsert(graph->grow->ctx, object);
  } else {
    arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

    if (str_NoCaseStrncmp(arg1_str, "CURRENTOBJECT", strlen(arg1_str)) == 0) {
      grow_SetHighlight(graph->current_cmd_object, 1);
      grow_SelectInsert(graph->grow->ctx, graph->current_cmd_object);
    } else if (str_NoCaseStrncmp(arg1_str, "ALL", strlen(arg1_str)) == 0) {
      graph->select_all_objects();
    } else if (str_NoCaseStrncmp(arg1_str, "CLEAR", strlen(arg1_str)) == 0) {
      grow_SelectClear(graph->grow->ctx);
    } else {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
  }
  return GE__SUCCESS;
}

static int graph_export_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "JAVA", strlen(arg1_str)) == 0) {
    char filename[120];
    char name[80];
    char graph_name[80];
    char* signature_p;
    char signature[80];
    char* s;
    int sts;

    if (dcli_get_qualifier("/SIGNATURE", signature, sizeof(signature)))
      signature_p = signature;
    else
      signature_p = 0;

    if (!graph->get_java_name(name)) {
      // Set default name
      graph->get_name(graph_name);
      if (!streq(graph_name, "")) {
        if (str_StartsWith(graph_name, "pwr_c_")) {
          strcpy(name, "Jopc");
          strcat(name, &graph_name[6]);
          name[4] = _toupper(name[4]);
        } else if (str_StartsWith(graph_name, "pwr_")) {
          strcpy(name, "Jop");
          strcat(name, &graph_name[4]);
          name[3] = _toupper(name[3]);
        } else {
          strcpy(name, graph_name);
          name[0] = _toupper(name[0]);
        }
      } else {
        graph->message('E', "Graph is unnamed");
        return GE__NONAME;
      }
    }

    if (isdigit(name[0])) {
      graph->message('E', "Java name syntax error");
      return GE__JAVANAMESYNTAX;
    }

    if (graph->is_subgraph()) {
      graph->message('E', "Unable to save subgraph as ge java");
    } else {
      char framename[80];
      char appletname[80];
      char systemname[80];
      char cmd[320];

      strcpy(framename, name);
      if ((s = strrchr(framename, '.')))
        *s = 0;

      strcpy(appletname, name);
      if ((s = strrchr(appletname, '.')))
        *s = 0;
      strcat(appletname, "_A");

      strcpy(filename, name);
      if (!strrchr(filename, '.'))
        strcat(filename, ".java");

      // Export frame
      if (graph->is_javaapplication()) {
        sts = graph->export_gejava(filename, framename, 0, 0);
        if (EVEN(sts)) {
          graph->message('E', "Java export error");
          return sts;
        }

        if (sts != GE__ISBASECLASS) {
          // Compile frame
          graph->get_systemname(systemname);

          sprintf(cmd, "$pwr_exe/ge_javac.sh java %s %s \"%s\"", filename,
              systemname, signature);
          sts = system(cmd);
          if (sts != 0) {
            graph->message('E', "Java compilation errors");
            return GE__JAVAC;
          }
        }
      }

      if (graph->is_javaapplet()) {
        // Export applet

        strcpy(filename, appletname);
        strcat(filename, ".java");

        sts = graph->export_gejava(filename, appletname, 1, 0);
        if (EVEN(sts)) {
          graph->message('E', "Java export error");
          return sts;
        }

        if (sts != GE__ISBASECLASS) {
          // Compile applet
          graph->get_systemname(systemname);

          sprintf(cmd, "$pwr_exe/ge_javac.sh java_web %s %s \"%s\"", filename,
              systemname, signature);
          sts = system(cmd);
          if (sts != 0) {
            graph->message('E', "Java compilation errors");
            return GE__JAVAC;
          }

          // Export html
          strcpy(filename, "$pwrp_web/");
          strcat(filename, framename);
          strcat(filename, ".html");
          // str_ToLower( filename, filename);

          sts = graph->export_gejava(filename, framename, 0, 1);
          if (EVEN(sts)) {
            graph->message('E', "Java export error");
            return sts;
          }
        }
      }
      if (graph->is_javaapplication() && graph->is_javaapplet())
        graph->message('I', "Java frame and applet exported");
      else if (graph->is_javaapplication())
        graph->message('I', "Java frame exported");
      else if (graph->is_javaapplet())
        graph->message('I', "Java applet exported");
      else
        graph->message('I', "This graph is not java frame or applet");
    }
  } else if (str_NoCaseStrncmp(arg1_str, "IMAGE", strlen(arg1_str)) == 0) {
    char file_str[120];
    int sts;

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      graph->message('E', "Enter file");
      return GE__FILENAME;
    }

    sts = graph->export_image(file_str);
    if (EVEN(sts)) {
      graph->message('E', "Export error");
    } else
      graph->message('E', "Graph exported");
  } else {
    graph->message('E', "Syntax error");
  }
  return GE__SUCCESS;
}

static int graph_group_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;
  int sts;
  grow_tObject group;
  char last_group_name[80];

  sts = grow_GroupSelect(graph->grow->ctx, &group, last_group_name);
  if (EVEN(sts)) {
    graph->current_cmd_object = 0;
    graph->message('E', "Group error");
    return sts;
  }

  graph->current_cmd_object = group;

  return GE__SUCCESS;
}

static int graph_scale_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;
  char str[80];
  int sts;
  float value;
  double scalex, scaley;
  glow_eScaleType scale_type;
  double x0, y0;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "CURRENTOBJECT", strlen(arg1_str)) == 0) {
    if (!graph->current_cmd_object) {
      graph->message('E', "No current object");
      return GE__NOCURRENT;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "SELECTEDOBJECT", strlen(arg1_str))
      == 0) {
    grow_tObject* sel_list;
    int sel_count;

    grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
    if (sel_count != 1) {
      graph->message('E', "Select one object");
      return GE__SYNTAX;
    }
    graph->current_cmd_object = sel_list[0];
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }

  if (EVEN(dcli_get_qualifier("/SCALEX", str, sizeof(str)))) {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  sts = sscanf(str, "%f", &value);
  if (sts != 1) {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  scalex = double(value);

  if (EVEN(dcli_get_qualifier("/SCALEY", str, sizeof(str)))) {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  sts = sscanf(str, "%f", &value);
  if (sts != 1) {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  scaley = double(value);

  scale_type = glow_eScaleType_LowerLeft;
  x0 = 0;
  y0 = 0;

  if (ODD(dcli_get_qualifier("/X", str, sizeof(str)))) {
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x0 = double(value);
    scale_type = glow_eScaleType_FixPoint;
  }

  if (ODD(dcli_get_qualifier("/Y", str, sizeof(str)))) {
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y0 = double(value);
    scale_type = glow_eScaleType_FixPoint;
  }

  grow_StoreTransform(graph->current_cmd_object);
  grow_SetObjectScale(
      graph->current_cmd_object, scalex, scaley, x0, y0, scale_type);
  grow_SetModified(graph->grow->ctx, 1);

  return GE__SUCCESS;
}

static int graph_move_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;
  char str[80];
  int sts;
  float value;
  double x0, y0;
  double ll_x, ll_y, ur_x, ur_y;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "CURRENTOBJECT", strlen(arg1_str)) == 0) {
    if (!graph->current_cmd_object) {
      graph->message('E', "No current object");
      return GE__NOCURRENT;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "SELECTEDOBJECT", strlen(arg1_str))
      == 0) {
    grow_tObject* sel_list;
    int sel_count;

    grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
    if (sel_count != 1) {
      graph->message('E', "Select one object");
      return GE__SYNTAX;
    }
    graph->current_cmd_object = sel_list[0];
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }

  if (ODD(dcli_get_qualifier("/X", str, sizeof(str)))) {
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x0 = double(value);
  } else if (ODD(dcli_get_qualifier("/ABSX", str, sizeof(str)))) {
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    grow_MeasureNode(graph->current_cmd_object, &ll_x, &ll_y, &ur_x, &ur_y);
    x0 = double(value) - ll_x;
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }

  if (ODD(dcli_get_qualifier("/Y", str, sizeof(str)))) {
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y0 = double(value);
  } else if (ODD(dcli_get_qualifier("/ABSY", str, sizeof(str)))) {
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    grow_MeasureNode(graph->current_cmd_object, &ll_x, &ll_y, &ur_x, &ur_y);
    y0 = double(value) - ll_y;
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }

  // grow_StoreTransform( graph->current_cmd_object);
  // grow_SetObjectPosition( graph->current_cmd_object, x0, y0);
  grow_MoveObject(graph->current_cmd_object, x0, y0);
  grow_SetModified(graph->grow->ctx, 1);

  return GE__SUCCESS;
}

static int graph_create_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "RECTANGLE", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x, y, width, height;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y = value;

    if (EVEN(dcli_get_qualifier("/WIDTH", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    width = value;

    if (EVEN(dcli_get_qualifier("/HEIGHT", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    height = value;

    grow_CreateGrowRect(graph->grow->ctx, "", x, y, width, height,
        graph->get_border_drawtype(), graph->linewidth, 0, glow_mDisplayLevel_1,
        graph->fill, graph->border, graph->shadow, graph->get_fill_drawtype(),
        NULL, &graph->current_cmd_object);
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "ARC", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x1, y1, x2, y2;
    int angle1, angle2;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

    if (EVEN(dcli_get_qualifier("/X2", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x2 = value;

    if (EVEN(dcli_get_qualifier("/Y2", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y2 = value;

    if (ODD(dcli_get_qualifier("/ANGLE1", str, sizeof(str)))) {
      sts = sscanf(str, "%d", &angle1);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
    } else
      angle1 = 0;

    if (ODD(dcli_get_qualifier("/ANGLE2", str, sizeof(str)))) {
      sts = sscanf(str, "%d", &angle2);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
    } else
      angle2 = 360;

    grow_CreateGrowArc(graph->grow->ctx, "", x1, y1, x2, y2, angle1, angle2,
        graph->get_border_drawtype(), graph->linewidth, graph->fill,
        graph->border, graph->shadow, graph->get_fill_drawtype(), NULL,
        &graph->current_cmd_object);
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "LINE", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x1, y1, x2, y2;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

    if (EVEN(dcli_get_qualifier("/X2", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x2 = value;

    if (EVEN(dcli_get_qualifier("/Y2", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y2 = value;

    grow_CreateGrowLine(graph->grow->ctx, "", x1, y1, x2, y2,
        graph->get_border_drawtype(), graph->linewidth, 0, NULL,
        &graph->current_cmd_object);
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "POLYLINE", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x1, y1, x2, y2;
    glow_sPoint points[2];
    int point_cnt;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

    if (EVEN(dcli_get_qualifier("/X2", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x2 = value;

    if (EVEN(dcli_get_qualifier("/Y2", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y2 = value;

    points[0].x = x1;
    points[0].y = y1;
    points[1].x = x2;
    points[1].y = y2;
    point_cnt = 2;
    grow_CreateGrowPolyLine(graph->grow->ctx, "", (glow_sPoint*)&points,
        point_cnt, graph->get_border_drawtype(), graph->linewidth, 0,
        graph->fill, graph->border, graph->shadow, graph->get_fill_drawtype(),
        0, NULL, &graph->current_cmd_object);

    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "TEXT", strlen(arg1_str)) == 0) {
    char str[80];
    char text_str[80];
    int sts;
    float value;
    double x1, y1;
    glow_eDrawType fill_color, border_color, text_color;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

    if (EVEN(dcli_get_qualifier("/TEXT", text_str, sizeof(text_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    glow_eDrawType drawtype;
    int textsize = 0;

    if (graph->textbold)
      drawtype = glow_eDrawType_TextHelveticaBold;
    else
      drawtype = glow_eDrawType_TextHelvetica;

    switch (graph->textsize) {
    case 0:
      textsize = 0;
      break;
    case 1:
      textsize = 1;
      break;
    case 2:
      textsize = 2;
      break;
    case 3:
      textsize = 4;
      break;
    case 4:
      textsize = 6;
      break;
    case 5:
      textsize = 8;
      break;
    }

    (graph->get_current_colors_cb)(
        graph->parent_ctx, &fill_color, &border_color, &text_color);

    grow_CreateGrowText(graph->grow->ctx, "", text_str, x1, y1, drawtype,
        text_color, textsize, graph->textfont, glow_mDisplayLevel_1, NULL,
        &graph->current_cmd_object);
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x1, y1, x2 = 0.0, y2 = 0.0;
    char subgraph_str[80];
    char name[80];
    grow_tNodeClass nc;
    grow_tNode n1;
    int scale_x, scale_y;
    double sx, sy;
    double ll_x, ll_y, ur_x, ur_y;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

    if (ODD(dcli_get_qualifier("/X2", str, sizeof(str)))) {
      sts = sscanf(str, "%f", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      x2 = value;
      if (feq(x1, x2)) {
        graph->message('E', "Invalid coordinate");
        return GE__COORDINATE;
      }
      scale_x = 1;
    } else
      scale_x = 0;

    if (ODD(dcli_get_qualifier("/Y2", str, sizeof(str)))) {
      sts = sscanf(str, "%f", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      y2 = value;
      if (feq(y1, y2)) {
        graph->message('E', "Invalid coordinate");
        return GE__COORDINATE;
      }
      scale_y = 1;
    } else
      scale_y = 0;

    if (EVEN(dcli_get_qualifier(
            "/SUBGRAPH", subgraph_str, sizeof(subgraph_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    // str_ToLower( subgraph_str, subgraph_str);

    sts = grow_FindNodeClassByName(graph->grow->ctx, subgraph_str, &nc);
    if (EVEN(sts)) {
      // Load the subgraph
      grow_OpenSubGraphFromName(graph->grow->ctx, subgraph_str);
    }
    sts = grow_FindNodeClassByName(graph->grow->ctx, subgraph_str, &nc);
    if (EVEN(sts)) {
      graph->message('E', "Unable to open subgraph");
      return GE__SUBGRAPHLOAD;
    }

    sprintf(name, "O%d", grow_GetNextObjectNameNumber(graph->grow->ctx));

    if (!grow_IsSliderClass(nc))
      grow_CreateGrowNode(graph->grow->ctx, name, nc, x1, y1, NULL, &n1);
    else
      grow_CreateGrowSlider(graph->grow->ctx, name, nc, x1, y1, NULL, &n1);

    GeDyn* dyn = new GeDyn(graph);
    grow_SetUserData(n1, (void*)dyn);

    grow_MoveNode(n1, x1, y1);
    if (scale_x || scale_y) {
      grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
      if (scale_x)
        sx = (x2 - x1) / (ur_x - ll_x);
      else
        sx = 1;
      if (scale_y)
        sy = (y2 - y1) / (ur_y - ll_y);
      else
        sy = 1;
      grow_StoreTransform(n1);
      grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
    }
    graph->current_cmd_object = n1;
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "BAR", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x1, y1, x2 = 0.0, y2 = 0.0;

    grow_tNode n1;
    int scale_x, scale_y;
    double sx, sy;
    double ll_x, ll_y, ur_x, ur_y;

    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

    if (ODD(dcli_get_qualifier("/X2", str, sizeof(str)))) {
      sts = sscanf(str, "%f", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      x2 = value;
      if (feq(x1, x2)) {
        graph->message('E', "Invalid coordinate");
        return GE__COORDINATE;
      }
      scale_x = 1;
    } else
      scale_x = 0;

    if (ODD(dcli_get_qualifier("/Y2", str, sizeof(str)))) {
      sts = sscanf(str, "%f", &value);
      if (sts != 1) {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      y2 = value;
      if (feq(y1, y2)) {
        graph->message('E', "Invalid coordinate");
        return GE__COORDINATE;
      }
      scale_y = 1;
    } else
      scale_y = 0;

    graph->create_bar(&n1, x1, y1, 0);

    if (scale_x || scale_y) {
      grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
      if (scale_x)
        sx = (x2 - x1) / (ur_x - ll_x);
      else
        sx = 1;
      if (scale_y)
        sy = (y2 - y1) / (ur_y - ll_y);
      else
        sy = 1;
      grow_StoreTransform(n1);
      grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
    }
    graph->current_cmd_object = n1;
    grow_SetModified(graph->grow->ctx, 1);
  } else if (str_NoCaseStrncmp(arg1_str, "IMAGE", strlen(arg1_str)) == 0) {
    char str[80];
    int sts;
    float value;
    double x1, y1;
    grow_tObject i1;
    char name[80];
    char image_str[80];

    if (EVEN(dcli_get_qualifier("/IMAGE", image_str, sizeof(image_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    if (EVEN(dcli_get_qualifier("/X1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    x1 = value;

    if (EVEN(dcli_get_qualifier("/Y1", str, sizeof(str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    sts = sscanf(str, "%f", &value);
    if (sts != 1) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }
    y1 = value;

#if 0
    if ( ODD( dcli_get_qualifier( "/X2", str, sizeof(str))))
    {
      sts = sscanf( str, "%f", &value);
      if ( sts != 1)
      {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      x2 = value;
      if ( x1 == x2)
      {
        graph->message('E', "Invalid coordinate");
        return GE__COORDINATE;
      }
      scale_x = 1;
    }
    else
      scale_x = 0;

    if ( ODD( dcli_get_qualifier( "/Y2", str, sizeof(str))))
    {
      sts = sscanf( str, "%f", &value);
      if ( sts != 1)
      {
        graph->message('E', "Syntax error");
        return GE__SYNTAX;
      }
      y2 = value;
      if ( y1 == y2)
      {
        graph->message('E', "Invalid coordinate");
        return GE__COORDINATE;
      }
      scale_y = 1;
    }
    else
      scale_y = 0;
#endif

    sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

    grow_CreateGrowImage(graph->grow->ctx, name, image_str, x1, y1, NULL, &i1);

    graph->journal_store(journal_eAction_CreateObject, i1);
    graph->current_cmd_object = i1;
    grow_SetModified(graph->grow->ctx, 1);
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_convert_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));
  if (str_NoCaseStrncmp(arg1_str, "V45", strlen(arg1_str)) == 0) {
    char name[40];
    char msg[80];
    int sts;

    sts = graph->convert();
    if (EVEN(sts)) {
      grow_GetName(graph->grow->ctx, name);
      sprintf(msg, "Conversion failed, graph %s", name);
      graph->message('E', msg);
      return sts;
    }
    grow_GetName(graph->grow->ctx, name);
    sprintf(msg, "Graph %s converted", name);
    graph->message('I', msg);

    grow_UpdateVersion(graph->grow->ctx);
    grow_SetModified(graph->grow->ctx, 1);
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_disable_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "LOG", strlen(arg1_str)) == 0) {
    graph->disable_log = 1;
    graph->message('I', "Log disabled");
  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static int graph_replace_func(void* client_data, void* client_flag)
{
  Graph* graph = (Graph*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "ATTRIBUTE", strlen(arg1_str)) == 0) {
    grow_tObject* sel_list;
    int sel_count;
    char from_str[120];
    char to_str[120];
    int replace_cnt = 0;
    int strict;

    if (EVEN(dcli_get_qualifier("/FROM", from_str, sizeof(from_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    if (EVEN(dcli_get_qualifier("/TO", to_str, sizeof(to_str)))) {
      graph->message('E', "Syntax error");
      return GE__SYNTAX;
    }

    strict = ODD(dcli_get_qualifier("/STRICT", 0, 0));
    if (!strict)
      str_ToLower(from_str, from_str);

    grow_GetSelectList(graph->grow->ctx, &sel_list, &sel_count);
    for (int i = 0; i < sel_count; i++) {
      switch (grow_GetObjectType(sel_list[i])) {
      case glow_eObjectType_GrowGroup:
        graph_group_replace_attr(
            sel_list[i], from_str, to_str, &replace_cnt, strict);
      // Do this for groups also (no break)
      case glow_eObjectType_GrowNode:
      case glow_eObjectType_GrowSlider:
      case glow_eObjectType_GrowTrend:
      case glow_eObjectType_GrowTable:
      case glow_eObjectType_GrowWindow:
      case glow_eObjectType_GrowFolder:
      case glow_eObjectType_GrowBar: {
        GeDyn* dyn;

        grow_GetUserData(sel_list[i], (void**)&dyn);
        dyn->replace_attribute(from_str, to_str, &replace_cnt, strict);
        break;
      }
      default:;
      }
    }
    if (replace_cnt) {
      char msg[80];
      sprintf(msg, "%d attributes replaced", replace_cnt);
      graph->message('I', msg);
    } else
      graph->message('I', "Nothing replaced");

  } else {
    graph->message('E', "Syntax error");
    return GE__SYNTAX;
  }
  return GE__SUCCESS;
}

static void graph_group_replace_attr(grow_tObject group, char* from_str,
    char* to_str, int* replace_cnt, int strict)
{
  grow_tObject* objectlist;
  int object_cnt;

  grow_GetGroupObjectList(group, &objectlist, &object_cnt);
  for (int i = 0; i < object_cnt; i++) {
    switch (grow_GetObjectType(objectlist[i])) {
    case glow_eObjectType_GrowGroup:
      graph_group_replace_attr(
          objectlist[i], from_str, to_str, replace_cnt, strict);
    // Do this for groups also (no break)
    case glow_eObjectType_GrowNode:
    case glow_eObjectType_GrowSlider:
    case glow_eObjectType_GrowTrend:
    case glow_eObjectType_GrowTable:
    case glow_eObjectType_GrowWindow:
    case glow_eObjectType_GrowFolder:
    case glow_eObjectType_GrowBar: {
      GeDyn* dyn;

      grow_GetUserData(objectlist[i], (void**)&dyn);
      dyn->replace_attribute(from_str, to_str, replace_cnt, strict);
      break;
    }
    default:;
    }
  }
}

int Graph::command(char* input_str)
{
  char command[160];
  int sts, sym_sts;
  char symbol_value[80];

  if (input_str[0] == '@') {
    /* Read command file */
    // char *s;
    // if ( (s = strchr( input_str, ' ')))
    //   dcli_toupper( s, s);
    sts = dcli_replace_symbol(input_str, command, sizeof(command));
    if (EVEN(sts))
      return sts;

    sts = readcmdfile(&command[1]);
    if (sts == DCLI__NOFILE) {
      char tmp[200];
      snprintf(tmp, 200, "Unable to open file \"%s\"", &command[1]);
      message('E', tmp);
      return DCLI__SUCCESS;
    } else if (EVEN(sts))
      return sts;
    return DCLI__SUCCESS;
  }

  // dcli_toupper( input_str, input_str);
  sts = dcli_replace_symbol(input_str, command, sizeof(command));
  if (EVEN(sts))
    return sts;

  sts = dcli_cli(
      (dcli_tCmdTable*)&graph_command_table, command, (void*)this, 0);
  if (sts == DCLI__COM_NODEF) {
    /* Try to find a matching symbol */
    sym_sts = dcli_get_symbol_cmd(command, symbol_value);
    if (ODD(sym_sts)) {
      if (symbol_value[0] == '@') {
        /* Read command file */
        sts = readcmdfile(&symbol_value[1]);
        if (sts == DCLI__NOFILE) {
          char tmp[200];
          snprintf(tmp, 200, "Unable to open file \"%s\"", &symbol_value[1]);
          message('E', tmp);
          return DCLI__SUCCESS;
        } else if (EVEN(sts))
          return sts;
        return DCLI__SUCCESS;
      }
      sts = dcli_cli(
          (dcli_tCmdTable*)&graph_command_table, symbol_value, (void*)this, 0);
    } else if (sym_sts == DCLI__SYMBOL_AMBIG)
      sts = sym_sts;
  }
  if (sts == DCLI__COM_AMBIG)
    message('E', "Ambiguous command");
  else if (sts == DCLI__COM_NODEF)
    message('E', "Undefined command");
  else if (sts == DCLI__QUAL_AMBIG)
    message('E', "Ambiguous qualifier");
  else if (sts == DCLI__QUAL_NODEF)
    message('E', "Undefined qualifier");
  else if (sts == DCLI__SYMBOL_AMBIG)
    message('E', "Ambiguous symbol abbrevation");

  return sts;
}

static int graph_gettextextent_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2; // Textsize
  ccm_sArg* arg_p3; // Bold
  ccm_sArg* arg_p4; // Width
  ccm_sArg* arg_p5 = NULL; // Height
  ccm_sArg* arg_p6 = NULL; // Descent
  Graph* graph;
  glow_eDrawType draw_type;
  double z_width, z_height, z_descent;
  int text_idx;

  if (arg_count < 4 || arg_count > 6)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  if (arg_count > 4)
    arg_p5 = arg_p4->next;
  if (arg_count > 5)
    arg_p6 = arg_p5->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_count > 4 && arg_p5->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_count > 5 && arg_p6->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  if (arg_p3->value_int)
    draw_type = glow_eDrawType_TextHelveticaBold;
  else
    draw_type = glow_eDrawType_TextHelvetica;

  switch (arg_p2->value_int) {
  case 8:
    text_idx = 0;
    break;
  case 10:
    text_idx = 1;
    break;
  case 12:
    text_idx = 2;
    break;
  case 14:
    text_idx = 3;
    break;
  case 18:
    text_idx = 4;
    break;
  case 24:
    text_idx = 5;
    break;
  default:
    text_idx = 0;
  }
  grow_GetTextExtent(graph->grow->ctx, arg_list->value_string,
      strlen(arg_list->value_string), draw_type, text_idx, glow_eFont_Helvetica,
      &z_width, &z_height, &z_descent);

  arg_p4->value_float = float(z_width);
  arg_p4->value_returned = 1;

  if (arg_count > 4) {
    arg_p5->value_float = float(z_height);
    arg_p5->value_returned = 1;
  }

  if (arg_count > 5) {
    arg_p5->value_float = float(z_descent);
    arg_p5->value_returned = 1;
  }
  return 1;
}

static int graph_selectadd_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SelectInsert(graph->grow->ctx, (grow_tObject)arg_list->value_int);
  return 1;
}

static int graph_getcurrentobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_setextern_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts;
  grow_tObject nodeclass;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(
      graph->grow->ctx, arg_list->value_string, &nodeclass);
  if (ODD(sts)) {
    grow_SetNodeClassExtern(nodeclass, 1);
    *return_int = 1;
    *return_decl = CCM_DECL_INT;
  } else {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
  }
  return 1;
}

static int graph_setexternall_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetNodeClassExternAll(graph->grow->ctx, 1);
  return 1;
}

static int graph_setintern_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts;
  grow_tObject nodeclass;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(
      graph->grow->ctx, arg_list->value_string, &nodeclass);
  if (ODD(sts)) {
    grow_SetNodeClassExtern(nodeclass, 0);
    *return_int = 1;
    *return_decl = CCM_DECL_INT;
  } else {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
  }
  return 1;
}

static int graph_setinternall_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetNodeClassExternAll(graph->grow->ctx, 0);
  return 1;
}

static int graph_true_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_false_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  *return_int = 0;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setdraw_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  if (arg_list->value_int == 0)
    grow_SetNodraw(graph->grow->ctx);
  else {
    grow_ResetNodraw(graph->grow->ctx);
    grow_Redraw(graph->grow->ctx);
  }

  return 1;
}

static int graph_getfirstobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject first;
  int sts;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GetFirstObject(graph->grow->ctx, &first);
  if (ODD(sts))
    *return_int = (long int)first;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_getnextobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject next;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GetNextObject(
      graph->grow->ctx, (grow_tObject)arg_list->value_int, &next);
  if (ODD(sts))
    *return_int = (long int)next;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_groupgetfirstobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject first;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GroupGetFirstObject((grow_tObject)arg_list->value_int, &first);
  if (ODD(sts))
    *return_int = (long int)first;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_groupgetnextobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject next;
  int sts;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GroupGetNextObject((grow_tObject)arg_list->value_int,
      (grow_tObject)arg_p2->value_int, &next);
  if (ODD(sts))
    *return_int = (long int)next;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_getobjecttype_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  type = grow_GetObjectType((grow_tObject)arg_list->value_int);
  *return_int = type;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_getobjectclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tNodeClass classid;
  char name[80];

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_decl = CCM_DECL_STRING;

  grow_GetObjectClass((grow_tObject)arg_list->value_int, &classid);
  if (classid != 0) {
    grow_GetNodeClassName(classid, name, sizeof(name));
    strcpy(return_string, name);
  } else
    strcpy(return_string, "");
  return 1;
}

static int graph_getobjectfill_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectFill((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectfill_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectFill((grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_getobjectborder_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectBorder((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectborder_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectBorder((grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_getobjectgradient_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectGradient((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectgradient_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectGradient(
      (grow_tObject)arg_list->value_int, (glow_eGradient)arg_p2->value_int);
  return 1;
}

static int graph_getobjectfillcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int
      = (long int)grow_GetObjectFillColor((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectfillcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalFillColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_getobjectbordercolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int
      = (long int)grow_GetObjectBorderColor((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectbordercolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalBorderColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_getobjecttextcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int
      = (long int)grow_GetObjectTextColor((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjecttextcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalTextColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_setobjectbackgroundcolor_func(void* filectx,
    ccm_sArg* arg_list, int arg_count, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalBackgroundColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_getobjectshadow_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectShadow((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectshadow_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectShadow((grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_setcurrentobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  graph->current_cmd_object = (grow_tObject)arg_list->value_int;
  return 1;
}

static int graph_getobjectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  char name[80];
  int type;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  type = grow_GetObjectType((grow_tObject)arg_list->value_int);
  if (type == glow_eObjectType_GrowNode || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar) {
    grow_GetObjectName((grow_tObject)arg_list->value_int, name, sizeof(name),
        glow_eName_Object);
    strcpy(return_string, name);
  } else
    strcpy(return_string, "");

  *return_decl = CCM_DECL_STRING;
  return 1;
}

static int graph_getobjectdyntype_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  ccm_sArg* arg_p2; // Dyntype1 return
  ccm_sArg* arg_p3 = NULL; // Dyntype2 return
  ccm_sArg* arg_p4 = NULL; // Actiontype1 return
  ccm_sArg* arg_p5 = NULL; // Actiontype2 return
  GeDyn* dyn;
  grow_tObject o;

  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_count > 2)
    arg_p3 = arg_p2->next;
  if (arg_count > 3)
    arg_p4 = arg_p3->next;
  if (arg_count > 4)
    arg_p5 = arg_p4->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_count > 2 && arg_p3->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_count > 3 && arg_p4->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_count > 4 && arg_p5->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowNode || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar) {
    grow_GetUserData(o, (void**)&dyn);
    arg_p2->value_int = dyn->get_dyntype1(o);
    arg_p2->value_returned = 1;
    if (arg_count > 2) {
      arg_p3->value_int = dyn->get_dyntype2(o);
      arg_p3->value_returned = 1;
    }
    if (arg_count > 3) {
      arg_p4->value_int = dyn->get_actiontype1(o);
      arg_p4->value_returned = 1;
    }
    if (arg_count > 4) {
      arg_p5->value_int = dyn->get_actiontype2(o);
      arg_p5->value_returned = 1;
    }
  } else {
    arg_p2->value_int = 0;
    arg_p2->value_returned = 1;
    if (arg_count > 2) {
      arg_p3->value_int = 0;
      arg_p3->value_returned = 1;
    }
    if (arg_count > 3) {
      arg_p4->value_int = 0;
      arg_p4->value_returned = 1;
    }
    if (arg_count > 4) {
      arg_p5->value_int = 0;
      arg_p5->value_returned = 1;
    }
  }
  return 1;
}

static int graph_getobjecttext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  grow_tObject o;
  char text[K_STRING_SIZE];

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowText) {
    grow_GetObjectText(o, text, sizeof(text));
    strncpy(return_string, text, sizeof(K_STRING_SIZE));
  } else
    strcpy(return_string, "");

  *return_decl = CCM_DECL_STRING;
  return 1;
}

static int graph_setobjecttext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  grow_tObject o;
  ccm_sArg* arg_p2; // Text

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowText) {
    grow_SetObjectText(o, arg_p2->value_string);
  }
  return 1;
}

static int graph_findobjectbyname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject object;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindObjectByName(
      graph->grow->ctx, arg_list->value_string, &object);
  if (ODD(sts))
    *return_int = (long int)object;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_reload_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;
  char name[80];

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_GetName(graph->grow->ctx, name);
  if (!streq(name, "")) {
    grow_New(graph->grow->ctx);
    graph->open(name);
  }
  return 1;
}

static int graph_setobjectattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  ccm_sArg* arg_p2; // Attribute
  ccm_sArg* arg_p3; // Attribute value
  grow_tObject o;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowNode || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar
      || type == glow_eObjectType_GrowTable
      || type == glow_eObjectType_GrowWindow
      || type == glow_eObjectType_GrowFolder || type == glow_eObjectType_GrowBar
      || type == glow_eObjectType_GrowTrend || type == glow_eObjectType_GrowRect
      || type == glow_eObjectType_GrowAxis) {
    attr_sItem* itemlist;
    attr_sItem* item_p;
    int item_cnt;
    void* client_data;
    char attr_name[80];
    int i_value;
    double d_value;
    int i;
    int sts;
    int found;
    GeDyn* dyn;

    graph->get_attr_items(o, &itemlist, &item_cnt, &client_data);

    found = 0;
    item_p = itemlist;
    for (i = 0; i < item_cnt; i++) {
      strcpy(attr_name, item_p->name);
      if (str_NoCaseStrcmp(arg_p2->value_string, attr_name) == 0) {
        found = 1;
        break;
      }
      item_p++;
    }

    if (!found) {
      *return_decl = CCM_DECL_INT;
      *return_int = GE__NOATTR;
      return 1;
    }

    switch (item_p->type) {
    case glow_eType_Int:
    case glow_eType_TraceColor:
    case glow_eType_Boolean:
      if (arg_p3->value_decl != CCM_DECL_INT)
        return CCM__ARGMISM;

      i_value = arg_p3->value_int;
      memcpy(item_p->value, (char*)&i_value, sizeof(i_value));
      break;
    case glow_eType_Double:
      if (arg_p3->value_decl != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      d_value = double(arg_p3->value_float);
      memcpy(item_p->value, (char*)&d_value, sizeof(d_value));
      break;
    case glow_eType_String:
      if (arg_p3->value_decl != CCM_DECL_STRING)
        return CCM__ARGMISM;
      strncpy((char*)item_p->value, arg_p3->value_string, item_p->size);
      break;
    case glow_eType_Direction:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case glow_eType_Relief:
    case glow_eType_InputFocusMark:
    case ge_eAttrType_ScaleType:
    case glow_eType_Adjustment:
    case glow_eType_Font:
    case ge_eAttrType_CurveDataType:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case glow_eType_AnnotType:
    case ge_eAttrType_OptionMenuType: {
      int value;

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      if (arg_p3->value_decl == CCM_DECL_INT) {
        value = arg_p3->value_int;
      } else {
        sts = AttrNav::string_to_enum(
            item_p->type, arg_p3->value_string, &value);
        if (EVEN(sts)) {
          *return_int = GE__SYNTAX;
          *return_decl = CCM_DECL_INT;
          return 1;
        }
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_TextSize: {
      int value;
      char str[40];

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      if (arg_p3->value_decl == CCM_DECL_INT)
        sprintf(str, "%d", (int)arg_p3->value_int);
      else
        strncpy(str, arg_p3->value_string, sizeof(str));

      sts = AttrNav::string_to_enum(item_p->type, str, &value);
      if (EVEN(sts)) {
        *return_int = GE__SYNTAX;
        *return_decl = CCM_DECL_INT;
        return 1;
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_ActionType2:
    case ge_eAttrType_InstanceMask:
    case ge_eAttrType_InputFocus: {
      unsigned int value;

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      if (arg_p3->value_decl == CCM_DECL_INT)
        value = arg_p3->value_int;
      else {
        sts = AttrNav::string_to_mask(
            item_p->type, arg_p3->value_string, &value);
        if (EVEN(sts)) {
          return GE__SYNTAX;
        }
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      if (item_p->type == ge_eAttrType_DynType1
          || item_p->type == ge_eAttrType_DynType2
          || item_p->type == ge_eAttrType_ActionType1
          || item_p->type == ge_eAttrType_ActionType2) {
        grow_GetUserData(o, (void**)&dyn);
        dyn->update_elements();
      }
      break;
    }
    default:;
    }
    grow_UpdateObject(graph->grow->ctx, o, (grow_sAttrInfo*)client_data);
  }
  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_getobjectattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  ccm_sArg* arg_p2; // Attribute
  ccm_sArg* arg_p3; // Attribute value
  grow_tObject o;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowNode || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar
      || type == glow_eObjectType_GrowTable
      || type == glow_eObjectType_GrowWindow
      || type == glow_eObjectType_GrowFolder || type == glow_eObjectType_GrowBar
      || type == glow_eObjectType_GrowTrend || type == glow_eObjectType_GrowRect
      || type == glow_eObjectType_GrowAxis) {
    attr_sItem* itemlist;
    attr_sItem* item_p;
    int item_cnt;
    void* client_data;
    char attr_name[80];
    int i_value;
    double d_value;
    int i;
    int sts;
    int found;

    graph->get_attr_items(o, &itemlist, &item_cnt, &client_data);

    found = 0;
    item_p = itemlist;
    for (i = 0; i < item_cnt; i++) {
      strcpy(attr_name, item_p->name);
      if (str_NoCaseStrcmp(arg_p2->value_string, attr_name) == 0) {
        found = 1;
        break;
      }
      item_p++;
    }

    if (!found) {
      *return_decl = CCM_DECL_INT;
      *return_int = GE__NOATTR;
      return 1;
    }

    switch (item_p->type) {
    case glow_eType_Int:
    case glow_eType_TraceColor:
    case glow_eType_Boolean:
      if (arg_p3->value_decl != CCM_DECL_INT)
        return CCM__ARGMISM;

      i_value = arg_p3->value_int;
      memcpy(
          (char*)&arg_p3->value_int, item_p->value, sizeof(arg_p3->value_int));
      arg_p3->value_returned = 1;
      break;
    case glow_eType_Double:
      if (arg_p3->value_decl != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      memcpy((char*)&d_value, item_p->value, sizeof(d_value));
      arg_p3->value_float = (float)d_value;
      arg_p3->value_returned = 1;
      break;
    case glow_eType_String:
      if (arg_p3->value_decl != CCM_DECL_STRING)
        return CCM__ARGMISM;
      strncpy(arg_p3->value_string, (char*)item_p->value,
          MIN(item_p->size, (int)sizeof(arg_p3->value_string)));
      arg_p3->value_returned = 1;
      break;
    case glow_eType_Direction:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case glow_eType_Relief:
    case glow_eType_InputFocusMark:
    case ge_eAttrType_ScaleType:
    case glow_eType_Adjustment:
    case glow_eType_Font:
    case ge_eAttrType_CurveDataType:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case glow_eType_AnnotType:
    case ge_eAttrType_OptionMenuType: {
      int value;

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));

      if (arg_p3->value_decl == CCM_DECL_INT) {
        arg_p3->value_int = value;
        arg_p3->value_returned = 1;
      } else {
        sts = AttrNav::enum_to_string(item_p->type, value, arg_p3->value_string,
            sizeof(arg_p3->value_string));
        if (EVEN(sts)) {
          *return_int = GE__SYNTAX;
          *return_decl = CCM_DECL_INT;
          return 1;
        }
      }
      break;
    }
    case glow_eType_TextSize: {
      int value;
      char str[40];

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));
      sts = AttrNav::enum_to_string(item_p->type, value, str, sizeof(str));
      if (EVEN(sts)) {
        *return_int = GE__SYNTAX;
        *return_decl = CCM_DECL_INT;
        return 1;
      }

      if (arg_p3->value_decl == CCM_DECL_INT)
        sscanf(str, "%d", (int*)&arg_p3->value_int);
      else
        strncpy(arg_p3->value_string, str, sizeof(arg_p3->value_string));
      arg_p3->value_returned = 1;
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_ActionType2:
    case ge_eAttrType_InstanceMask:
    case ge_eAttrType_InputFocus: {
      unsigned int value;

      if (arg_p3->value_decl != CCM_DECL_INT)
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));
      arg_p3->value_int = value;
      arg_p3->value_returned = 1;
      break;
    }
    default:;
    }
  }
  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_getrgbcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // Red
  ccm_sArg* arg_p3; // Green
  ccm_sArg* arg_p4; // Blue
  double r, g, b;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_GetRgbColor(
      graph->grow->ctx, (glow_eDrawType)arg_list->value_int, &r, &g, &b);

  arg_p2->value_float = (float)r;
  arg_p3->value_float = (float)g;
  arg_p4->value_float = (float)b;
  arg_p2->value_returned = 1;
  arg_p3->value_returned = 1;
  arg_p4->value_returned = 1;

  return 1;
}

static int graph_setrgbcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // Red
  ccm_sArg* arg_p3; // Green
  ccm_sArg* arg_p4; // Blue
  double r, g, b;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  r = (double)arg_p2->value_float;
  g = (double)arg_p3->value_float;
  b = (double)arg_p4->value_float;

  grow_SetRgbColor(
      graph->grow->ctx, (glow_eDrawType)arg_list->value_int, r, g, b);
  if (graph->update_colorpalette_cb)
    (graph->update_colorpalette_cb)(graph->parent_ctx);

  return 1;
}

static int graph_measureobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // ll_x
  ccm_sArg* arg_p3; // ll_y
  ccm_sArg* arg_p4; // ur_x
  ccm_sArg* arg_p5; // ur_y
  double ll_x, ll_y, ur_x, ur_y;

  if (arg_count != 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  arg_p5 = arg_p4->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p5->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_MeasureNode(
      (grow_tObject)arg_list->value_int, &ll_x, &ll_y, &ur_x, &ur_y);
  arg_p2->value_float = (float)ll_x;
  arg_p3->value_float = (float)ll_y;
  arg_p4->value_float = (float)ur_x;
  arg_p5->value_float = (float)ur_y;
  arg_p2->value_returned = 1;
  arg_p3->value_returned = 1;
  arg_p4->value_returned = 1;
  arg_p5->value_returned = 1;

  return 1;
}

static int graph_deleteobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  graph_get_stored_graph(&graph);

  grow_DeleteObject(graph->grow->ctx, (grow_tObject)arg_list->value_int);

  return 1;
}

static int graph_setobjectclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // Class
  int sts;
  grow_tNodeClass nc;
  pwr_tFileName cname;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(graph->grow->ctx, arg_p2->value_string, &nc);
  if (EVEN(sts)) {
    // Load the subgraph

    strcpy(cname, "$pwrp_exe/");
    strncat(cname, arg_p2->value_string, sizeof(cname) - strlen(cname) - 1);
    strncat(cname, ".pwsg", sizeof(cname) - strlen(cname) - 1);

    sts = grow_OpenSubGraph(graph->grow->ctx, cname);
    if (EVEN(sts)) {
      strcpy(cname, "$pwr_exe/");
      strncat(cname, arg_p2->value_string, sizeof(cname) - strlen(cname) - 1);
      strncat(cname, ".pwsg", sizeof(cname) - strlen(cname) - 1);

      sts = grow_OpenSubGraph(graph->grow->ctx, cname);
    }
  }
  sts = grow_FindNodeClassByName(graph->grow->ctx, arg_p2->value_string, &nc);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = grow_SetObjectClass((grow_tNode)arg_list->value_int, nc);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_scaleobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // scale x
  ccm_sArg* arg_p3; // scale y
  double scalex, scaley;
  glow_eScaleType scale_type;
  grow_tObject oid = (grow_tObject)arg_list->value_int;

  if (oid == 0)
    return 1;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  scalex = (double)arg_p2->value_float;
  scaley = (double)arg_p3->value_float;

  scale_type = glow_eScaleType_LowerLeft;

  grow_StoreTransform(oid);
  grow_SetObjectScale(oid, scalex, scaley, 0, 0, scale_type);

  return 1;
}
static int graph_moveobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // scale x
  ccm_sArg* arg_p3; // scale y
  double x0, y0;
  grow_tObject oid = (grow_tObject)arg_list->value_int;

  if (oid == 0)
    return 1;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  x0 = (double)arg_p2->value_float;
  y0 = (double)arg_p3->value_float;

  grow_MoveObject(oid, x0, y0);

  return 1;
}

static int graph_moveabsobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // scale x
  ccm_sArg* arg_p3; // scale y
  double x0, y0;
  double ll_x, ll_y, ur_x, ur_y;
  grow_tObject oid = (grow_tObject)arg_list->value_int;

  if (oid == 0)
    return 1;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_MeasureNode(oid, &ll_x, &ll_y, &ur_x, &ur_y);

  x0 = (double)arg_p2->value_float - ll_x;
  y0 = (double)arg_p3->value_float - ll_y;

  grow_MoveObject(oid, x0, y0);

  return 1;
}

static int graph_getgraphname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);
  graph->get_name(return_string);
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int graph_ccm_deffilename_func(
    char* outfile, char* infile, void* client_data)
{
  dcli_get_defaultfilename(infile, outfile, ".ge_com");
  dcli_translate_filename(outfile, outfile);
  return 1;
}

static int graph_ccm_errormessage_func(
    char* msg, int severity, void* client_data)
{
  Graph* graph = (Graph*)client_data;

  if (EVEN(severity))
    graph->message('I', msg);
  else
    graph->message('E', msg);
  return 1;
}

int graph_externcmd_func(char* cmd, void* client_data)
{
  Graph* graph = (Graph*)client_data;
  int sts;

  graph->scriptmode++;
  sts = graph->command(cmd);
  graph->scriptmode--;
  return sts;
}

#if LDH
static int graph_wccm_get_ldhsession_cb(void* ctx, ldh_tSesContext* ldhses)
{
  Graph* graph = (Graph*)ctx;
  int sts;

  if (graph->ldhses)
    *ldhses = graph->ldhses;
  else {
    if (graph->get_ldhses_cb) {
      sts = (graph->get_ldhses_cb)(graph->parent_ctx, &graph->ldhses, 1);
      if (EVEN(sts))
        return sts;

      *ldhses = graph->ldhses;
    } else
      return 0;
  }
  return 1;
}
#endif

#if LDH
static int graph_wccm_get_wbctx_cb(void* ctx, ldh_tWBContext* wbctx)
{
  Graph* graph = (Graph*)ctx;
  int sts;

  if (graph->ldhses)
    *wbctx = ldh_SessionToWB(graph->ldhses);
  else {
    if (graph->get_ldhses_cb) {
      sts = (graph->get_ldhses_cb)(graph->parent_ctx, &graph->ldhses, 1);
      if (EVEN(sts))
        return sts;

      *wbctx = ldh_SessionToWB(graph->ldhses);
    } else
      return 0;
  }
  return 1;
}
#endif

/************************************************************************
*
* Name:		readcmdfile()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

int Graph::readcmdfile(char* incommand)
{
  char input_str[160];
  int sts;
  int appl_sts;

  if (!ccm_func_registred) {
    sts = ccm_register_function(
        "Ge", "GetTextExtent", graph_gettextextent_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetCurrentObject", graph_getcurrentobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SelectAdd", graph_selectadd_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SetExtern", graph_setextern_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SetIntern", graph_setintern_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SetExternAll", graph_setexternall_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SetInternAll", graph_setinternall_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SetDraw", graph_setdraw_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "IsW1", graph_true_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "IsW2", graph_false_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetFirstObject", graph_getfirstobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetNextObject", graph_getnextobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GroupGetFirstObject", graph_groupgetfirstobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GroupGetNextObject", graph_groupgetnextobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectType", graph_getobjecttype_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectClass", graph_getobjectclass_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectFill", graph_getobjectfill_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectFill", graph_setobjectfill_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectBorder", graph_getobjectborder_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectBorder", graph_setobjectborder_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectGradient", graph_getobjectgradient_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectGradient", graph_setobjectgradient_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectFillColor", graph_getobjectfillcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectFillColor", graph_setobjectfillcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectBorderColor", graph_getobjectbordercolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectBorderColor", graph_setobjectbordercolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectTextColor", graph_getobjecttextcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectTextColor", graph_setobjecttextcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectBackgroundColor", graph_setobjectbackgroundcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectShadow", graph_getobjectshadow_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectShadow", graph_setobjectshadow_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetCurrentObject", graph_setcurrentobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectName", graph_getobjectname_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectDynType", graph_getobjectdyntype_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectText", graph_getobjecttext_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectText", graph_setobjecttext_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "FindObjectByName", graph_findobjectbyname_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "Reload", graph_reload_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectAttribute", graph_setobjectattribute_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "GetObjectAttribute", graph_getobjectattribute_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "GetRgbColor", graph_getrgbcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "SetRgbColor", graph_setrgbcolor_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "MeasureObject", graph_measureobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "DeleteObject", graph_deleteobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "SetObjectClass", graph_setobjectclass_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "ScaleObject", graph_scaleobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "MoveObject", graph_moveobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Ge", "MoveAbsObject", graph_moveabsobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Ge", "GetGraphName", graph_getgraphname_func);
    if (EVEN(sts))
      return sts;
    ccm_func_registred = 1;

#if LDH
    // Register wb standard functions
    wccm_register(graph_wccm_get_wbctx_cb, graph_wccm_get_ldhsession_cb, 0);
#endif

    sts = ccm_create_external_var(
        "eObjectType_Rect", CCM_DECL_INT, 0, glow_eObjectType_GrowRect, 0);
    sts = ccm_create_external_var(
        "eObjectType_Line", CCM_DECL_INT, 0, glow_eObjectType_GrowLine, 0);
    sts = ccm_create_external_var(
        "eObjectType_Arc", CCM_DECL_INT, 0, glow_eObjectType_GrowArc, 0);
    sts = ccm_create_external_var("eObjectType_ConPoint", CCM_DECL_INT, 0,
        glow_eObjectType_GrowConPoint, 0);
    sts = ccm_create_external_var(
        "eObjectType_Annot", CCM_DECL_INT, 0, glow_eObjectType_GrowSubAnnot, 0);
    sts = ccm_create_external_var("eObjectType_PolyLine", CCM_DECL_INT, 0,
        glow_eObjectType_GrowPolyLine, 0);
    sts = ccm_create_external_var(
        "eObjectType_SubGraph", CCM_DECL_INT, 0, glow_eObjectType_GrowNode, 0);
    sts = ccm_create_external_var(
        "eObjectType_Text", CCM_DECL_INT, 0, glow_eObjectType_GrowText, 0);
    sts = ccm_create_external_var(
        "eObjectType_Bar", CCM_DECL_INT, 0, glow_eObjectType_GrowBar, 0);
    sts = ccm_create_external_var(
        "eObjectType_Trend", CCM_DECL_INT, 0, glow_eObjectType_GrowTrend, 0);
    sts = ccm_create_external_var(
        "eObjectType_Slider", CCM_DECL_INT, 0, glow_eObjectType_GrowSlider, 0);
    sts = ccm_create_external_var(
        "eObjectType_Image", CCM_DECL_INT, 0, glow_eObjectType_GrowImage, 0);
    sts = ccm_create_external_var(
        "eObjectType_Group", CCM_DECL_INT, 0, glow_eObjectType_GrowGroup, 0);
    sts = ccm_create_external_var(
        "eObjectType_Axis", CCM_DECL_INT, 0, glow_eObjectType_GrowAxis, 0);
    sts = ccm_create_external_var("eObjectType_RectRounded", CCM_DECL_INT, 0,
        glow_eObjectType_GrowRectRounded, 0);
    sts = ccm_create_external_var("eObjectType_ConGlue", CCM_DECL_INT, 0,
        glow_eObjectType_GrowConGlue, 0);
    sts = ccm_create_external_var(
        "eObjectType_Menu", CCM_DECL_INT, 0, glow_eObjectType_GrowMenu, 0);
    sts = ccm_create_external_var(
        "eObjectType_Window", CCM_DECL_INT, 0, glow_eObjectType_GrowWindow, 0);
    sts = ccm_create_external_var(
        "eObjectType_Table", CCM_DECL_INT, 0, glow_eObjectType_GrowTable, 0);
    sts = ccm_create_external_var(
        "eObjectType_Folder", CCM_DECL_INT, 0, glow_eObjectType_GrowFolder, 0);
    sts = ccm_create_external_var("eObjectType_XYCurve", CCM_DECL_INT, 0,
        glow_eObjectType_GrowXYCurve, 0);
    sts = ccm_create_external_var("eObjectType_AxisArc", CCM_DECL_INT, 0,
        glow_eObjectType_GrowAxisArc, 0);
    sts = ccm_create_external_var(
        "eObjectType_Pie", CCM_DECL_INT, 0, glow_eObjectType_GrowPie, 0);
    sts = ccm_create_external_var("eObjectType_BarChart", CCM_DECL_INT, 0,
        glow_eObjectType_GrowBarChart, 0);
    sts = ccm_create_external_var("eObjectType_Toolbar", CCM_DECL_INT, 0,
        glow_eObjectType_GrowToolbar, 0);

    sts = ccm_create_external_var(
        "mDynType1_No", CCM_DECL_INT, 0, ge_mDynType1_No, 0);
    sts = ccm_create_external_var(
        "mDynType1_Inherit", CCM_DECL_INT, 0, ge_mDynType1_Inherit, 0);
    sts = ccm_create_external_var(
        "mDynType1_Tone", CCM_DECL_INT, 0, ge_mDynType1_Tone, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigLowColor", CCM_DECL_INT, 0, ge_mDynType1_DigLowColor, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigColor", CCM_DECL_INT, 0, ge_mDynType1_DigColor, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigError", CCM_DECL_INT, 0, ge_mDynType1_DigError, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigWarning", CCM_DECL_INT, 0, ge_mDynType1_DigWarning, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigFlash", CCM_DECL_INT, 0, ge_mDynType1_DigFlash, 0);
    sts = ccm_create_external_var(
        "mDynType1_Invisible", CCM_DECL_INT, 0, ge_mDynType1_Invisible, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigBorder", CCM_DECL_INT, 0, ge_mDynType1_DigBorder, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigText", CCM_DECL_INT, 0, ge_mDynType1_DigText, 0);
    sts = ccm_create_external_var(
        "mDynType1_Value", CCM_DECL_INT, 0, ge_mDynType1_Value, 0);
    sts = ccm_create_external_var(
        "mDynType1_AnalogColor", CCM_DECL_INT, 0, ge_mDynType1_AnalogColor, 0);
    sts = ccm_create_external_var(
        "mDynType1_Rotate", CCM_DECL_INT, 0, ge_mDynType1_Rotate, 0);
    sts = ccm_create_external_var(
        "mDynType1_Move", CCM_DECL_INT, 0, ge_mDynType1_Move, 0);
    sts = ccm_create_external_var(
        "mDynType1_AnalogShift", CCM_DECL_INT, 0, ge_mDynType1_AnalogShift, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigShift", CCM_DECL_INT, 0, ge_mDynType1_DigShift, 0);
    sts = ccm_create_external_var(
        "mDynType1_Animation", CCM_DECL_INT, 0, ge_mDynType1_Animation, 0);
    sts = ccm_create_external_var(
        "mDynType1_Bar", CCM_DECL_INT, 0, ge_mDynType1_Bar, 0);
    sts = ccm_create_external_var(
        "mDynType1_Trend", CCM_DECL_INT, 0, ge_mDynType1_Trend, 0);
    sts = ccm_create_external_var("mDynType1_SliderBackground", CCM_DECL_INT, 0,
        ge_mDynType1_SliderBackground, 0);
    sts = ccm_create_external_var(
        "mDynType1_Video", CCM_DECL_INT, 0, ge_mDynType1_Video, 0);
    sts = ccm_create_external_var(
        "mDynType1_FillLevel", CCM_DECL_INT, 0, ge_mDynType1_FillLevel, 0);
    sts = ccm_create_external_var(
        "mDynType1_FastCurve", CCM_DECL_INT, 0, ge_mDynType1_FastCurve, 0);
    sts = ccm_create_external_var(
        "mDynType1_AnalogText", CCM_DECL_INT, 0, ge_mDynType1_AnalogText, 0);
    sts = ccm_create_external_var(
        "mDynType1_Table", CCM_DECL_INT, 0, ge_mDynType1_Table, 0);
    sts = ccm_create_external_var(
        "mDynType1_StatusColor", CCM_DECL_INT, 0, ge_mDynType1_StatusColor, 0);
    sts = ccm_create_external_var(
        "mDynType1_HostObject", CCM_DECL_INT, 0, ge_mDynType1_HostObject, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigSound", CCM_DECL_INT, 0, ge_mDynType1_DigSound, 0);
    sts = ccm_create_external_var(
        "mDynType1_XY_Curve", CCM_DECL_INT, 0, ge_mDynType1_XY_Curve, 0);
    sts = ccm_create_external_var(
        "mDynType1_DigCommand", CCM_DECL_INT, 0, ge_mDynType1_DigCommand, 0);
    sts = ccm_create_external_var(
        "mDynType1_Pie", CCM_DECL_INT, 0, ge_mDynType1_Pie, 0);
    sts = ccm_create_external_var(
        "mDynType1_BarChart", CCM_DECL_INT, 0, ge_mDynType1_BarChart, 0);

    sts = ccm_create_external_var(
        "mDynType2_No", CCM_DECL_INT, 0, ge_mDynType2_No, 0);
    sts = ccm_create_external_var(
        "mDynType2_Axis", CCM_DECL_INT, 0, ge_mDynType2_Axis, 0);
    sts = ccm_create_external_var("mDynType2_DigTextColor", CCM_DECL_INT, 0,
        ge_mDynType2_DigTextColor, 0);
    sts = ccm_create_external_var("mDynType2_TimeoutColor", CCM_DECL_INT, 0,
        ge_mDynType2_TimeoutColor, 0);
    sts = ccm_create_external_var("mDynType2_DigFourShift", CCM_DECL_INT, 0,
        ge_mDynType2_DigFourShift, 0);
    sts = ccm_create_external_var("mDynType2_ScrollingText", CCM_DECL_INT, 0,
        ge_mDynType2_ScrollingText, 0);
    sts = ccm_create_external_var("mDynType2_ColorThemeLightness", CCM_DECL_INT,
        0, ge_mDynType2_ColorThemeLightness, 0);
    sts = ccm_create_external_var("mDynType2_DigBackgroundColor", CCM_DECL_INT,
        0, ge_mDynType2_DigBackgroundColor, 0);

    sts = ccm_create_external_var(
        "mActionType1_No", CCM_DECL_INT, 0, ge_mActionType1_No, 0);
    sts = ccm_create_external_var(
        "mActionType1_Inherit", CCM_DECL_INT, 0, ge_mActionType1_Inherit, 0);
    sts = ccm_create_external_var("mActionType1_PopupMenu", CCM_DECL_INT, 0,
        ge_mActionType1_PopupMenu, 0);
    sts = ccm_create_external_var(
        "mActionType1_SetDig", CCM_DECL_INT, 0, ge_mActionType1_SetDig, 0);
    sts = ccm_create_external_var(
        "mActionType1_ResetDig", CCM_DECL_INT, 0, ge_mActionType1_ResetDig, 0);
    sts = ccm_create_external_var("mActionType1_ToggleDig", CCM_DECL_INT, 0,
        ge_mActionType1_ToggleDig, 0);
    sts = ccm_create_external_var(
        "mActionType1_StoDig", CCM_DECL_INT, 0, ge_mActionType1_StoDig, 0);
    sts = ccm_create_external_var(
        "mActionType1_Command", CCM_DECL_INT, 0, ge_mActionType1_Command, 0);
    sts = ccm_create_external_var("mActionType1_CommandDoubleClick",
        CCM_DECL_INT, 0, ge_mActionType1_CommandDoubleClick, 0);
    sts = ccm_create_external_var(
        "mActionType1_Confirm", CCM_DECL_INT, 0, ge_mActionType1_Confirm, 0);
    sts = ccm_create_external_var("mActionType1_IncrAnalog", CCM_DECL_INT, 0,
        ge_mActionType1_IncrAnalog, 0);
    sts = ccm_create_external_var("mActionType1_RadioButton", CCM_DECL_INT, 0,
        ge_mActionType1_RadioButton, 0);
    sts = ccm_create_external_var(
        "mActionType1_Slider", CCM_DECL_INT, 0, ge_mActionType1_Slider, 0);
    sts = ccm_create_external_var("mActionType1_ValueInput", CCM_DECL_INT, 0,
        ge_mActionType1_ValueInput, 0);
    sts = ccm_create_external_var(
        "mActionType1_TipText", CCM_DECL_INT, 0, ge_mActionType1_TipText, 0);
    sts = ccm_create_external_var(
        "mActionType1_Help", CCM_DECL_INT, 0, ge_mActionType1_Help, 0);
    sts = ccm_create_external_var("mActionType1_OpenGraph", CCM_DECL_INT, 0,
        ge_mActionType1_OpenGraph, 0);
    sts = ccm_create_external_var(
        "mActionType1_OpenURL", CCM_DECL_INT, 0, ge_mActionType1_OpenURL, 0);
    sts = ccm_create_external_var("mActionType1_InputFocus", CCM_DECL_INT, 0,
        ge_mActionType1_InputFocus, 0);
    sts = ccm_create_external_var("mActionType1_CloseGraph", CCM_DECL_INT, 0,
        ge_mActionType1_CloseGraph, 0);
    sts = ccm_create_external_var("mActionType1_PulldownMenu", CCM_DECL_INT, 0,
        ge_mActionType1_PulldownMenu, 0);
    sts = ccm_create_external_var("mActionType1_OptionMenu", CCM_DECL_INT, 0,
        ge_mActionType1_OptionMenu, 0);
    sts = ccm_create_external_var(
        "mActionType1_SetValue", CCM_DECL_INT, 0, ge_mActionType1_SetValue, 0);
    sts = ccm_create_external_var("mActionType1_MethodToolbar", CCM_DECL_INT, 0,
        ge_mActionType1_MethodToolbar, 0);
    sts = ccm_create_external_var("mActionType1_MethodPulldownMenu",
        CCM_DECL_INT, 0, ge_mActionType1_MethodPulldownMenu, 0);
    sts = ccm_create_external_var(
        "mActionType1_Script", CCM_DECL_INT, 0, ge_mActionType1_Script, 0);

    char varname[40];
    for (int i = 1; i <= 300; i++) {
      sprintf(varname, "eDrawType_Color%d", i);
      sts = ccm_create_external_var(varname, CCM_DECL_INT, 0, i - 1, 0);
    }
    sts = ccm_create_external_var(
        "eDrawType_LineErase", CCM_DECL_INT, 0, 300, 0);
    for (int i = 1; i <= 90; i++) {
      sprintf(varname, "eDrawType_CustomColor%d", i);
      sts = ccm_create_external_var(
          varname, CCM_DECL_INT, 0, 310 + 4 * (i - 1), 0);
    }
  }

  str_trim(input_str, incommand);
  graph_store_graph(this);
#if LDH
  if (ldhses)
    wccm_store_ldhses(this, ldhses);
  else
    wccm_store_client(this);
#endif
  // Read and execute the command file
  sts = ccm_file_exec(input_str, graph_externcmd_func,
      graph_ccm_deffilename_func, graph_ccm_errormessage_func, &appl_sts,
      verify, 0, NULL, 0, 0, NULL, (void*)this);
  if (EVEN(sts))
    return sts;

  return 1;
}
