/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef glow_draw_gtk_h
#define glow_draw_gtk_h

#include <stdlib.h>
#include <string.h>
#include <fstream>

#include <gtk/gtk.h>

#include "glow_draw.h"

#define DRAW_CLIP_SIZE 10
#define CUSTOMCOLORS_STACK_SIZE 10

class GlowCustomColorsGtk;

class DrawWindGtk : public DrawWind {
public:
  DrawWindGtk()
  {
    zoom_factor_x = zoom_factor_y = base_zoom_factor = 100;
    offset_x = offset_y = 0;
    window_width = window_height = 0;
    subwindow_x = subwindow_y = 0;
    subwindow_scale = 1;
    clip_cnt = 0;
    memset(clip_rectangle, 0, sizeof(clip_rectangle));
  }
  GdkWindow* window = NULL;
  GdkPixmap* buffer = NULL;
  GdkRectangle clip_rectangle[DRAW_CLIP_SIZE];
  GdkPixmap* background_pixmap = NULL;

  DrawWind* copy() {
    DrawWindGtk* tmp = new DrawWindGtk();
    tmp->clip_cnt = this->clip_cnt;
    tmp->window = this->window;
    tmp->buffer = this->buffer;
    memcpy(tmp->clip_rectangle, this->clip_rectangle, sizeof(this->clip_rectangle));
    tmp->background_pixmap = this->background_pixmap;
    return tmp;
  }

  virtual void update_buffer(DrawWind* w) {
    this->buffer = ((DrawWindGtk*)w)->buffer;
  }
};

class GlowDrawGtk : public GlowDraw {
public:
  GlowDrawGtk(GtkWidget* toplevel, void** glow_ctx,
      int (*init_proc)(GtkWidget* w, GlowCtx* ctx, void* client_data),
      void* client_data, glow_eCtxType type);
  ~GlowDrawGtk();

  DrawWindGtk m_wind;
  DrawWindGtk nav_wind;
  DrawWindGtk *w = NULL;
  GdkDisplay* display;
  GdkScreen* screen;
  GdkGC* gc;
  GdkGC* gc_inverse;
  GdkGC* gcs[glow_eDrawType_CustomColor__][DRAW_TYPE_SIZE];
  GdkFont* font[glow_eFont__][glow_eDrawFont__][DRAW_FONT_SIZE];
  GdkCursor* cursors[glow_eDrawCursor__];
  int ef;
  GdkColormap* colormap;
  GdkColor background;
  GdkColor original_background;
  guint timer_id;
  int click_sensitivity;
  GdkColor custom_color_vect[120];
  GdkColor color_vect[400];
  int color_vect_cnt;
  int closing_down;
  GlowCustomColorsGtk* customcolors[CUSTOMCOLORS_STACK_SIZE];
  int customcolors_cnt;
  guint redraw_timer;

  void event_handler(GdkEvent event);
  void enable_event(glow_eEvent event, glow_eEventType event_type,
      int (*event_cb)(GlowCtx* ctx, glow_tEvent event));
  void clear();

  int begin(DrawWind* wind);
  void end(bool flush = true);

  void get_window_size(DrawWind* w, int* width, int* height);
  void set_window_size(DrawWind* w, int width, int height);

  void rect(int x, int y, int width, int height, glow_eDrawType gc_type,
      int fill, int idx, int highlight = 0);
  void arrow(int x1, int y1, int x2, int y2, int x3, int y3,
      glow_eDrawType gc_type, int idx, int highlight = 0);
  void arc(int x, int y, int width, int height, int angle1, int angle2,
      glow_eDrawType gc_type, int fill, int idx, int highlight = 0);
  void line(int x1, int y1, int x2, int y2, glow_eDrawType gc_type, int idx,
      int highlight = 0, glow_eLineType line_type = glow_eLineType_Solid);
  void polyline(glow_sPointX* points, int point_cnt, glow_eDrawType gc_type,
      int fill, int idx, int highlight = 0);
  void text(int x, int y, char* text, int len, glow_eDrawType gc_type,
      glow_eDrawType color, int idx, int highlight, glow_eFont font_idx,
      double size, int rot);
  void text_cursor(int x, int y, char* text, int len, glow_eDrawType gc_type,
      glow_eDrawType color, int idx, int highlight, int pos, glow_eFont font,
      double size);
  void image(int x, int y, int width, int height, glow_tImImage image,
      glow_tPixmap pixmap, glow_tPixmap clip_mask);

  void set_cursor(DrawWind* w, glow_eDrawCursor cursor);
  void get_text_extent(const char* text, int len, glow_eDrawType gc_type,
      int idx, glow_eFont font_idx, int* width, int* height, int* descent,
      double size, int rot);
  void set_background(DrawWind* w, glow_eDrawType drawtype, glow_tPixmap pixmap,
      glow_tImImage image, int pixmap_width, int pixmap_height);
  void reset_background(DrawWind* w);
  int set_clip_rectangle(DrawWind* w, int ll_x, int ll_y, int ur_x, int ur_y);
  void draw_point(int x1, int y1, glow_eDrawType gc_type);
  void draw_points(glow_sPointX* points, int point_num, glow_eDrawType gc_type,
      int idx = 0);
  void set_click_sensitivity(int value);
  void create_buffer(DrawWindGtk* w);
  int print(char* filename, double x0, double x1, int end);
  int export_image(char* filename);
  void set_clip(GdkGC* gc);
  void reset_clip(GdkGC* gc);

  void set_timer(GlowCtx* gctx, int time_ms,
      void (*callback_func)(GlowCtx* ctx), void** id);
  void remove_timer(void* id);
  void init_nav(GtkWidget* nav_widget);
  GdkPoint* points_to_gdk_points(glow_sPointX* points, int point_cnt);
  GdkPoint* points_to_gdk_points_curve(glow_sPointX* points, int point_cnt,
      int* cnt);
  int get_font_type(int gc_type);
  void load_font(glow_eFont font_idx, int font_type, int idx);

  int image_get_width(glow_tImImage image);
  int image_get_height(glow_tImImage image);
  int image_get_rowstride(glow_tImImage image);
  unsigned char* image_get_data(glow_tImImage image);
  void image_copy(glow_tImImage orig_image, glow_tImImage* image);
  void image_rotate(glow_tImImage* image, int to_rotation, int from_rotation);
  void image_flip_vertical(glow_tImImage* image);
  void image_flip_horizontal(glow_tImImage* image);
  int image_scale(int width, int height, glow_tImImage orig_im,
      glow_tImImage* im, glow_tImData* im_data, glow_tPixmap* im_pixmap,
      glow_tPixmap* im_mask);
  int image_load(char* imagefile, glow_tImImage* orig_im, glow_tImImage* im,
      glow_tImData* im_data);
  void image_free(glow_tImImage image);
  void image_pixel_iter(glow_tImImage orig_image, glow_tImImage* image,
      void (*pixel_cb)(void*, unsigned char*), void* userdata);

  void set_cairo_clip(cairo_t* cr);
  void reset_cairo_clip(cairo_t* cr);
  int gradient_create_pattern(int x, int y, int w, int h, glow_eDrawType d0,
      glow_eDrawType d1, glow_eDrawType d2, glow_eGradient gradient,
      cairo_pattern_t** pat);
  void gradient_fill_rect(int x, int y, int w, int h, glow_eDrawType d0,
      glow_eDrawType d1, glow_eDrawType d2, glow_eGradient gradient);
  void gradient_fill_rectrounded(int x, int y, int w, int h, int roundamount,
      glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
      glow_eGradient gradient);
  void gradient_fill_arc(int x, int y, int w, int h, int angle1, int angle2,
      glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
      glow_eGradient gradient);
  void gradient_fill_polyline(glow_sPointX* points, int point_cnt,
      glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
      glow_eGradient gradient);
  void get_text_extent_pango(const char* text, int len, glow_eDrawType gc_type,
      int idx, glow_eFont font_idx, int* width, int* height, int* descent,
      double size, int rot);
  void log_event(GdkEvent* event);
  void event_exec(void* event, unsigned int size);
  int open_color_selection(double* r, double* g, double* b);
  void update_color(glow_eDrawType color);
  void push_customcolors(GlowCustomColors* cc);
  void set_customcolors(GlowCustomColors* cc);
  void pop_customcolors();
  GlowCustomColors* create_customcolors();
  GlowCustomColorsGtk* get_customcolors();
  void reset_customcolors(GlowCustomColors* cc);

private:
  void set_image_clip_mask(glow_tPixmap pixmap, int x, int y);
  void reset_image_clip_mask();
};

class DrawPs {
public:
  DrawPs(char* filename) : fp(filename), x(0), y(0)
  {
  }
  ~DrawPs()
  {
    fp.close();
  }
  std::ofstream fp;
  double x;
  double y;
};

#endif
