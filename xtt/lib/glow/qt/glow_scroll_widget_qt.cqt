/**
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/**
 * WARNING! This file is a mirrored version of flow_scroll_widget_qt.
 * If you modify it, you must modify flow_scroll_widget_qt in the same way!
 */

#include <assert.h>

#include "cow_qt_helpers.h"

#include "glow_scroll_widget_qt.h"

#include <QPainter>
#include <QTimer>

void QtScrollWidgetGlow::createBuffer(QSize size)
{
  this->image = QImage(size, QImage::Format_RGB32);
  QPainter imPainter(&image);
  imPainter.fillRect(image.rect(), palette().color(QPalette::Background));
}

void QtScrollWidgetGlow::init(unsigned int eCtxType,
    int (*init_proc)(GlowCtx* ctx, void* client_data), void* client_data,
    int (*init_proc2)(QWidget* w, GlowCtx* ctx, void* client_data))
{
  createBuffer(size());
  setFocusPolicy(Qt::StrongFocus);
  setMouseTracking(true);
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
  this->scroll_timerid = new QTimer(this);
}

QWidget* QtScrollWidgetGlow::initScroll(unsigned int eCtxType,
    int (*init_proc)(GlowCtx* ctx, void* client_data), void* client_data,
    int (*init_proc2)(QWidget* w, GlowCtx* ctx, void* client_data))
{
  createBuffer(size());
  setFocusPolicy(Qt::StrongFocus);
  setMouseTracking(true);
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
  this->scroll_timerid = new QTimer(this);

  QScrollArea* form = new QScrollArea();
  scroll_h = form->horizontalScrollBar();
  scroll_v = form->verticalScrollBar();
  QObject::connect(
      scroll_h, SIGNAL(valueChanged(int)), this, SLOT(scroll_h_action(int)));
  QObject::connect(
      scroll_v, SIGNAL(valueChanged(int)), this, SLOT(scroll_v_action(int)));

  form->setWidget(this);
  form->setWidgetResizable(true);
  return form;
}

void QtScrollWidgetGlow::init(unsigned int eCtxType, QWidget* main)
{
  createBuffer(size());
  setFocusPolicy(Qt::StrongFocus);
  setMouseTracking(true);
  this->ctxType = eCtxType;
  this->scroll_timerid = new QTimer(this);
  is_navigator = 1;
  main_widget = main;
}

void QtScrollWidgetGlow::scroll_callback_cb()
{
  glow_sScroll* data = &this->scroll_data;
  widget_sScroll* scroll_data = (widget_sScroll*)data->scroll_data;

  scroll_timerid = 0;

  if (data->total_width <= data->window_width) {
    if (data->offset_x == 0) {
      data->total_width = data->window_width;
    }
    if (scroll_data->scroll_h_managed) {
      // Remove horizontal scrollbar
    }
  } else {
    if (!scroll_data->scroll_h_managed) {
      // Insert horizontal scrollbar
    }
  }

  if (data->total_height <= data->window_height) {
    if (data->offset_y == 0) {
      data->total_height = data->window_height;
    }
    if (scroll_data->scroll_v_managed) {
      // Remove vertical scrollbar
    }
  } else {
    if (!scroll_data->scroll_v_managed) {
      // Insert vertical scrollbar
    }
  }
  if (data->offset_x < 0) {
    data->total_width += -data->offset_x;
    data->offset_x = 0;
  }
  if (data->offset_y < 0) {
    data->total_height += -data->offset_y;
    data->offset_y = 0;
  }
  if (data->total_height < data->window_height + data->offset_y) {
    data->total_height = data->window_height + data->offset_y;
  }
  if (data->total_width < data->window_width + data->offset_x) {
    data->total_width = data->window_width + data->offset_x;
  }
  if (data->window_width < 1) {
    data->window_width = 1;
  }
  if (data->window_height < 1) {
    data->window_height = 1;
  }

  if (scroll_data->scroll_h_managed) {
    scroll_h_ignore = 1;
    scroll_h_value = (double)data->offset_x;
    scroll_h_pagesize = data->window_width;
    scroll_h_upper = data->total_width;
    if (data->window_width != scroll_h_pagesize
        || data->total_width != scroll_h_upper || scroll_configure) {
      scroll_data->scroll_h->setMaximum(scroll_h_upper);
      scroll_data->scroll_h->setPageStep(scroll_h_pagesize);
    }
    scroll_data->scroll_h->setSliderPosition(scroll_h_value);
  }

  if (scroll_data->scroll_v_managed) {
    scroll_v_ignore = 1;
    scroll_v_value = (double)data->offset_y;
    scroll_v_pagesize = data->window_height;
    scroll_v_upper = data->total_height;
    if (data->window_height != scroll_v_pagesize
        || data->total_height != scroll_v_upper || scroll_configure) {
      scroll_data->scroll_v->setMaximum(scroll_v_upper);
      scroll_data->scroll_v->setPageStep(scroll_v_pagesize);
    }
    scroll_data->scroll_v->setSliderPosition(scroll_v_value);
  }
  scroll_configure = 0;
}

void QtScrollWidgetGlow::scroll_h_action(int value)
{
  if (scroll_h_ignore) {
    scroll_h_ignore = 0;
    return;
  }

  scroll_h_value = value;
  GlowCtx* ctx = (GlowCtx*)parent_ctx;
  glow_scroll_horizontal(ctx, value, 0);
}

void QtScrollWidgetGlow::scroll_v_action(int value)
{
  if (scroll_v_ignore) {
    scroll_v_ignore = 0;
    return;
  }

  scroll_v_value = value;
  GlowCtx* ctx = (GlowCtx*)parent_ctx;
  glow_scroll_vertical(ctx, value, 0);
}

void QtScrollWidgetGlow::paintEvent(QPaintEvent* event)
{
  QPainter painter(this);
  QRect dirtyRect = event->rect();
  painter.drawImage(dirtyRect, image, dirtyRect);
  QWidget::paintEvent(event);
}

void QtScrollWidgetGlow::closeEvent(QCloseEvent* event)
{
  debug_print("QtScrollWidgetGlow::closeEvent\n");
  if (!destroyed) {
    destroyed = 1;
    if (scroll_timerid) {
      delete scroll_timerid;
    }
    if (is_navigator && parent_ctx) {
      if (!((QtScrollWidgetGlow*)main_widget)->destroyed) {
        ((GlowCtx*)parent_ctx)->no_nav = 1;
      }
    }
  }
  QWidget::closeEvent(event);
}

void QtScrollWidgetGlow::handleEvent(QEvent* event)
{
  if (!destroyed) {
    if (event->type() == QEvent::Resize || event->type() == QEvent::Move) {
      scroll_configure = 1;
    }
    if (parent_ctx) {
      GlowCtx* ctx = (GlowCtx*)parent_ctx;
      GlowDrawQt* drawer = ((GlowDrawQt*)ctx->gdraw);
      if (event->type() == QEvent::MouseMove) {
        drawer->m_wind->window->update();
      }
      drawer->event_handler(event);
    }
  }
}

bool QtScrollWidgetGlow::event(QEvent* event)
{
  if (event->type() == QEvent::Resize) {
    emit resize_signal((QResizeEvent*)event);
    createBuffer(((QResizeEvent*)event)->size());
  }
  if (!is_realized
      && (event->type() == QEvent::Show || event->type() == QEvent::Resize)) {
    realize();
    is_realized = true;
  }
  handleEvent(event);
  return QWidget::event(event);
}

void QtScrollWidgetGlow::realize()
{
  if (!parent_ctx) {
    if (is_navigator) {
      QtScrollWidgetGlow* main
          = dynamic_cast<QtScrollWidgetGlow*>(this->main_widget);

      if (main && !main->is_realized) {
        main->realize();
        main->is_realized = true;
      }

      assert(main->parent_ctx != NULL);
      assert(main->draw_ctx != NULL);

      parent_ctx = main->parent_ctx;
      draw_ctx = main->draw_ctx;
      draw_ctx->init_nav(this);
    } else {
      draw_ctx = new GlowDrawQt(this, &parent_ctx, init_widget_proc,
          client_data, static_cast<glow_eCtxType>(ctxType));
    }
  }
}