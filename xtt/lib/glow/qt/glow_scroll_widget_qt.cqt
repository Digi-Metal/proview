/**
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/**
 * WARNING! This file is a mirrored version of flow_scroll_widget_qt.
 * If you modify it, you must modify flow_scroll_widget_qt in the same way!
 */
#include "glow_scroll_widget_qt.h"

#include <QMainWindow>
#include <QPainter>
#include <QScrollArea>

void QtScrollWidgetGlow::init(
    unsigned int eCtxType, int (*init_proc)(GlowCtx *ctx, void *client_data),
    void *client_data, int (*init_proc2)(QWidget *w, GlowCtx *ctx,
                                         void *client_data))
{
  this->image = QImage(size(), QImage::Format_RGB32);
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;
}

QWidget *QtScrollWidgetGlow::initScroll(
    unsigned int eCtxType, int (*init_proc)(GlowCtx *ctx, void *client_data),
    void *client_data, int (*init_proc2)(QWidget *w, GlowCtx *ctx,
                                         void *client_data))
{
  this->image = QImage(size(), QImage::Format_RGB32);
  this->ctxType = eCtxType;
  this->init_proc = init_proc;
  this->init_widget_proc = init_proc2;
  this->client_data = client_data;

  QMainWindow *window = new QMainWindow();
  window->setAttribute(Qt::WA_DeleteOnClose);
  QScrollArea *form = new QScrollArea();
  scroll_h = form->horizontalScrollBar();
  scroll_v = form->verticalScrollBar();
  QObject::connect(scroll_h, SIGNAL(valueChanged(int)), this,
                   SLOT(scroll_h_action(int)));
  QObject::connect(scroll_v, SIGNAL(valueChanged(int)), this,
                   SLOT(scroll_v_action(int)));

  form->setWidgetResizable(true);
  form->setWidget(this);
  window->setCentralWidget(form);
  return window;
}

void QtScrollWidgetGlow::init(unsigned int eCtxType, QWidget *main)
{
  this->image = QImage(size(), QImage::Format_RGB32);
  this->ctxType = eCtxType;
  is_navigator = 1;
  main_widget = main;
}

void QtScrollWidgetGlow::scroll_callback_cb()
{
  glow_sScroll *data = &this->scroll_data;
  widget_sScroll *scroll_data = (widget_sScroll *) data->scroll_data;

  scroll_timerid = 0;

  if (data->total_width <= data->window_width) {
    if (data->offset_x == 0) {
      data->total_width = data->window_width;
    }
    if (scroll_data->scroll_h_managed) {
      // Remove horizontal scrollbar
    }
  } else {
    if (!scroll_data->scroll_h_managed) {
      // Insert horizontal scrollbar
    }
  }

  if (data->total_height <= data->window_height) {
    if (data->offset_y == 0) {
      data->total_height = data->window_height;
    }
    if (scroll_data->scroll_v_managed) {
      // Remove vertical scrollbar
    }
  } else {
    if (!scroll_data->scroll_v_managed) {
      // Insert vertical scrollbar
    }
  }
  if (data->offset_x < 0) {
    data->total_width += -data->offset_x;
    data->offset_x = 0;
  }
  if (data->offset_y < 0) {
    data->total_height += -data->offset_y;
    data->offset_y = 0;
  }
  if (data->total_height < data->window_height + data->offset_y) {
    data->total_height = data->window_height + data->offset_y;
  }
  if (data->total_width < data->window_width + data->offset_x) {
    data->total_width = data->window_width + data->offset_x;
  }
  if (data->window_width < 1) {
    data->window_width = 1;
  }
  if (data->window_height < 1) {
    data->window_height = 1;
  }

  if (scroll_data->scroll_h_managed) {
    scroll_h_ignore = 1;
    scroll_h_value = (double) data->offset_x;
    scroll_h_pagesize = data->window_width;
    scroll_h_upper = data->total_width;
    if (data->window_width != scroll_h_pagesize ||
        data->total_width != scroll_h_upper || scroll_configure) {
      scroll_data->scroll_h->setMaximum(scroll_h_upper);
      scroll_data->scroll_h->setPageStep(scroll_h_pagesize);
    }
    scroll_data->scroll_h->setSliderPosition(scroll_h_value);
  }

  if (scroll_data->scroll_v_managed) {
    scroll_v_ignore = 1;
    scroll_v_value = (double) data->offset_y;
    scroll_v_pagesize = data->window_height;
    scroll_v_upper = data->total_height;
    if (data->window_height != scroll_v_pagesize ||
        data->total_height != scroll_v_upper || scroll_configure) {
      scroll_data->scroll_v->setMaximum(scroll_v_upper);
      scroll_data->scroll_v->setPageStep(scroll_v_pagesize);
    }
    scroll_data->scroll_v->setSliderPosition(scroll_v_value);
  }
  scroll_configure = 0;
}

void QtScrollWidgetGlow::scroll_h_action(int value)
{
  if (scroll_h_ignore) {
    scroll_h_ignore = 0;
    return;
  }

  scroll_h_value = value;
  GlowCtx *ctx = (GlowCtx *) parent_ctx;
  glow_scroll_horizontal(ctx, value, 0);
}

void QtScrollWidgetGlow::scroll_v_action(int value)
{
  if (scroll_v_ignore) {
    scroll_v_ignore = 0;
    return;
  }

  scroll_v_value = value;
  GlowCtx *ctx = (GlowCtx *) parent_ctx;
  glow_scroll_vertical(ctx, value, 0);
}

void QtScrollWidgetGlow::paintEvent(QPaintEvent *event)
{
  handleEvent(event);
  QWidget::paintEvent(event);
  QPainter painter(this);
  QRect dirtyRect = event->rect();
  painter.drawImage(dirtyRect, image, dirtyRect);
}

void QtScrollWidgetGlow::mouseMoveEvent(
    QMouseEvent *event)
{
  handleEvent(event, false, true);
  QWidget::mouseMoveEvent(event);
}

void QtScrollWidgetGlow::moveEvent(QMoveEvent *event)
{
  handleEvent(event, true);
  QWidget::moveEvent(event);
}

void QtScrollWidgetGlow::resizeEvent(
    QResizeEvent *event)
{
  this->image = QImage(event->size(), QImage::Format_RGB32);
  realize();
  handleEvent(event, true);
  QWidget::resizeEvent(event);
}

void QtScrollWidgetGlow::showEvent(QShowEvent *event)
{
  realize();
  QWidget::showEvent(event);
}

void QtScrollWidgetGlow::closeEvent(QCloseEvent *event)
{
  if (!destroyed) {
    destroyed = 1;
    if (scroll_timerid) {
      delete scroll_timerid;
    }
    if (is_navigator && parent_ctx) {
      if (!((QtScrollWidgetGlow *) main_widget)->destroyed) {
        ((GlowCtx *) parent_ctx)->no_nav = 1;
      }
    }
  }
  QWidget::closeEvent(event);
}

void QtScrollWidgetGlow::handleEvent(QEvent *event, bool conf_scroll,
                                            bool update)
{
  if (!destroyed) {
    if (conf_scroll) {
      scroll_configure = 1;
    }
    if (parent_ctx) {
      GlowCtx *ctx = (GlowCtx *) parent_ctx;
      GlowDrawQt *drawer = ((GlowDrawQt *) ctx->gdraw);
      if (update) {
        drawer->m_wind->window->update();
      }
      drawer->event_handler(event);
    }
  }
}

#include <assert.h>

void QtScrollWidgetGlow::realize()
{
  if (is_realized) {
    return;
  }

  if (!parent_ctx) {
    if (is_navigator) {
      QtScrollWidgetGlow *main = dynamic_cast<QtScrollWidgetGlow *>(
          this->main_widget);

      if (main && !main->is_realized) {
        main->realize();
      }

      assert(main->parent_ctx != NULL);
      assert(main->draw_ctx != NULL);

      parent_ctx = main->parent_ctx;
      draw_ctx = main->draw_ctx;
      draw_ctx->init_nav(this);
    } else {
      draw_ctx = new GlowDrawQt(this, &parent_ctx, init_widget_proc,
                                client_data,
                                static_cast<glow_eCtxType>(ctxType));
    }
  }

  is_realized = true;
}