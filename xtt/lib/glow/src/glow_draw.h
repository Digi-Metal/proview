/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef glow_draw_h
#define glow_draw_h

#include "glow_ctx.h"

#define DRAW_CLIP_SIZE 10

class DrawWind {
public:
  int type;
  int double_buffered = 1;

  double zoom_factor_x; //!< Zoom factor in x direction.
  double zoom_factor_y; //!< Zoom factor in y direction.
  double base_zoom_factor; //!< Original zoom factor.
  int offset_x; //!< Offset in pixel between origo and displayed window in x
  //! direction.
  int offset_y; //!< Offset in pixel between origo and displayde window in y
  //! direction.
  int window_width; //!< Window width in pixel.
  int window_height; //!< Window height in pixel.
  int subwindow_x; //!< Subwindow x coordinate in pixel.
  int subwindow_y; //!< Subwindow y coordinate in pixel.
  double subwindow_scale; //!< Subwindow scale.
  int clip_on = 0;
  int clip_cnt = 0;

  virtual DrawWind* copy() = 0;
  virtual void update_buffer(DrawWind* w) {}
};

class GlowDraw {
public:
  GlowCtx* ctx;
  glow_tImData imlib;

  GlowDraw();
  virtual ~GlowDraw();

  virtual void enable_event(glow_eEvent event, glow_eEventType event_type,
      int (*event_cb)(GlowCtx* ctx, glow_tEvent event)) = 0;
  virtual void clear() = 0;

  virtual void get_window_size(DrawWind* w, int* width, int* height) = 0;
  virtual void set_window_size(DrawWind* w, int width, int height) = 0;

  virtual int begin(DrawWind* wind) = 0;
  virtual void end() = 0;

  virtual void rect(int x, int y, int width, int height, glow_eDrawType gc_type,
      int fill, int idx, int highlight = 0) = 0;
  virtual void arrow(int x1, int y1, int x2, int y2, int x3, int y3,
      glow_eDrawType gc_type, int idx, int highlight = 0) = 0;
  virtual void arc(int x, int y, int width, int height, int angle1, int angle2,
      glow_eDrawType gc_type, int fill, int idx, int highlight = 0) = 0;
  virtual void line(int x1, int y1, int x2, int y2,
      glow_eDrawType gc_type, int idx, int highlight = 0,
      glow_eLineType line_type = glow_eLineType_Solid) = 0;
  virtual void polyline(glow_sPointX* points, int point_cnt,
      glow_eDrawType gc_type, int fill, int idx, int highlight = 0) = 0;
  virtual void text(int x, int y, char* text, int len, glow_eDrawType gc_type,
      glow_eDrawType color, int idx, int highlight, glow_eFont font_idx,
      double size, int rot) = 0;
  virtual void text_cursor(int x, int y, char* text, int len,
      glow_eDrawType gc_type, glow_eDrawType color, int idx, int highlight,
      int pos, glow_eFont font, double size) = 0;
  virtual void image(int x, int y, int width, int height, glow_tImImage image,
      glow_tPixmap pixmap, glow_tPixmap clip_mask) = 0;

  virtual void set_cursor(DrawWind* w, glow_eDrawCursor cursor) = 0;
  virtual void get_text_extent(const char* text, int len, glow_eDrawType gc_type,
      int idx, glow_eFont font_idx, int* width, int* height, int* descent,
      double size, int rot) = 0;
  virtual void set_background(DrawWind* w, glow_eDrawType drawtype,
      glow_tPixmap pixmap, glow_tImImage image, int pixmap_width,
      int pixmap_height) = 0;
  virtual void reset_background(DrawWind* w) = 0;
  virtual int set_clip_rectangle(DrawWind* w, int ll_x, int ll_y, int ur_x,
      int ur_y) = 0;
  virtual void reset_clip_rectangle(DrawWind* w);
  virtual void draw_point(int x1, int y1, glow_eDrawType gc_type) = 0;
  virtual void draw_points(glow_sPointX* points, int point_num,
      glow_eDrawType gc_type, int idx = 0) = 0;
  virtual void set_click_sensitivity(int value) = 0;
  virtual int export_image(char* filename) = 0;
  virtual int print(char* filename, double x0, double x1, int end) = 0;

  virtual void set_timer(GlowCtx* gctx, int time_ms,
      void (*callback_func)(GlowCtx* ctx), void** id) = 0;
  virtual void remove_timer(void* id) = 0;

  virtual int image_get_width(glow_tImImage image) = 0;
  virtual int image_get_height(glow_tImImage image) = 0;
  virtual int image_get_rowstride(glow_tImImage image) = 0;
  virtual unsigned char* image_get_data(glow_tImImage image) = 0;
  virtual void image_copy(glow_tImImage orig_image, glow_tImImage* image) = 0;
  virtual void image_rotate(glow_tImImage* image, int to_rotation,
      int from_rotation) = 0;
  virtual void image_flip_vertical(glow_tImImage* image) = 0;
  virtual void image_flip_horizontal(glow_tImImage* image) = 0;
  virtual int image_scale(int width, int height, glow_tImImage orig_im,
      glow_tImImage* im, glow_tImData* im_data, glow_tPixmap* im_pixmap,
      glow_tPixmap* im_mask) = 0;
  virtual int image_load(char* imagefile, glow_tImImage* orig_im,
      glow_tImImage* im, glow_tImData* im_data) = 0;
  virtual void image_free(glow_tImImage image) = 0;
  virtual void image_pixel_iter(glow_tImImage orig_image, glow_tImImage* image,
      void (*pixel_cb)(void*, unsigned char*), void* userdata) = 0;
  glow_eGradient gradient_rotate(double rot, glow_eGradient gradient);
  virtual void gradient_fill_rect(int x, int y, int w, int h, glow_eDrawType d0,
      glow_eDrawType d1, glow_eDrawType d2, glow_eGradient gradient) = 0;
  virtual void gradient_fill_rectrounded(int x, int y, int w, int h,
      int roundamount, glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
      glow_eGradient gradient) = 0;
  virtual void gradient_fill_arc(int x, int y, int w, int h, int angle1,
      int angle2, glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
      glow_eGradient gradient) = 0;
  virtual void gradient_fill_polyline(glow_sPointX* points, int point_cnt,
      glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
      glow_eGradient gradient) = 0;
  virtual void event_exec(void* event, unsigned int size) = 0;
  virtual int open_color_selection(double* r, double* g, double* b) = 0;
  virtual void update_color(glow_eDrawType color) = 0;
  virtual void push_customcolors(GlowCustomColors* cc) = 0;
  virtual void set_customcolors(GlowCustomColors* cc) = 0;
  virtual void pop_customcolors() = 0;
  virtual GlowCustomColors* create_customcolors() = 0;
  virtual void reset_customcolors(GlowCustomColors* cc) = 0;
};

#endif
