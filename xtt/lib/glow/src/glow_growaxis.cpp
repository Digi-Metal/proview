/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_string.h"
#include "co_time.h"

#include "glow_growaxis.h"
#include "glow_grownode.h"
#include "glow_draw.h"

#if defined OS_OPENBSD
#define nearbyint rint
#endif

typedef struct {
  int lines;
  int longq;
  int vvalq;
  int hvalq;
  char format[10];
} sRange;

GrowAxis::GrowAxis(GrowCtx* glow_ctx, const char* name, double x1, double y1,
    double x2, double y2, glow_eDrawType border_d_type, int line_w, int t_size,
    glow_eDrawType t_drawtype, int nodraw)
    : GrowRect(glow_ctx, name, x1, y1, x2 - x1, y2 - y1, border_d_type, line_w,
          0, glow_mDisplayLevel_1, 0, 1, 0, glow_eDrawType_Line, 1),
      text_size(t_size), text_drawtype(t_drawtype),
      text_color_drawtype(glow_eDrawType_Line), max_value(100), min_value(0),
      lines(11), longquotient(1), valuequotient(1), increment(0)
{
  strcpy(format, "%3.0f");

  configure();
  if (!nodraw)
    ctx->set_dirty();
}

GrowAxis::~GrowAxis()
{
  ctx->set_dirty();
}

void GrowAxis::configure()
{
  if (lines <= 1)
    lines = 2;
  if (longquotient <= 0)
    longquotient = 1;
  if (valuequotient <= 0)
    valuequotient = 1;
  increment = (max_value - min_value) / (lines - 1);
}

void GrowAxis::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowAxis) << '\n';
  fp << int(glow_eSave_GrowAxis_max_value) << FSPACE << max_value << '\n';
  fp << int(glow_eSave_GrowAxis_min_value) << FSPACE << min_value << '\n';
  fp << int(glow_eSave_GrowAxis_rect_part) << '\n';
  GrowRect::save(fp, mode);
  fp << int(glow_eSave_GrowAxis_lines) << FSPACE << lines << '\n';
  fp << int(glow_eSave_GrowAxis_longquotient) << FSPACE << longquotient << '\n';
  fp << int(glow_eSave_GrowAxis_valuequotient) << FSPACE << valuequotient
     << '\n';
  fp << int(glow_eSave_GrowAxis_format) << FSPACE << format << '\n';
  fp << int(glow_eSave_GrowAxis_text_size) << FSPACE << text_size << '\n';
  fp << int(glow_eSave_GrowAxis_text_drawtype) << FSPACE << int(text_drawtype)
     << '\n';
  fp << int(glow_eSave_GrowAxis_text_color_drawtype) << FSPACE
     << int(text_color_drawtype) << '\n';
  if (user_data && ctx->userdata_save_callback) {
    fp << int(glow_eSave_GrowAxis_userdata_cb) << '\n';
    (ctx->userdata_save_callback)(&fp, this, glow_eUserdataCbType_Node);
  }
  fp << int(glow_eSave_End) << '\n';
}

void GrowAxis::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowAxis: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowAxis:
      break;
    case glow_eSave_GrowAxis_max_value:
      fp >> max_value;
      break;
    case glow_eSave_GrowAxis_min_value:
      fp >> min_value;
      break;
    case glow_eSave_GrowAxis_rect_part:
      GrowRect::open(fp);
      break;
    case glow_eSave_GrowAxis_lines:
      fp >> lines;
      break;
    case glow_eSave_GrowAxis_longquotient:
      fp >> longquotient;
      break;
    case glow_eSave_GrowAxis_valuequotient:
      fp >> valuequotient;
      break;
    case glow_eSave_GrowAxis_format:
      fp.get();
      fp.getline(format, sizeof(format));
      break;
    case glow_eSave_GrowAxis_text_size:
      fp >> text_size;
      break;
    case glow_eSave_GrowAxis_text_drawtype:
      fp >> tmp;
      text_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowAxis_text_color_drawtype:
      fp >> tmp;
      text_color_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowAxis_userdata_cb:
      if (ctx->userdata_open_callback)
        (ctx->userdata_open_callback)(&fp, this, glow_eUserdataCbType_Node);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowAxis:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  configure();
}

void GrowAxis::draw(GlowWind* w, int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;

  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * w->zoom_factor_x - w->offset_x >= ll_x
      && x_left * w->zoom_factor_x - w->offset_x <= ur_x
      && y_high * w->zoom_factor_y - w->offset_y >= ll_y
      && y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);
  }
}

void GrowAxis::draw(GlowWind* w, int* ll_x, int* ll_y, int* ur_x, int* ur_y)
{
  int tmp;
  int obj_ur_x = int(x_right * w->zoom_factor_x) - w->offset_x;
  int obj_ll_x = int(x_left * w->zoom_factor_x) - w->offset_x;
  int obj_ur_y = int(y_high * w->zoom_factor_y) - w->offset_y;
  int obj_ll_y = int(y_low * w->zoom_factor_y) - w->offset_y;

  if (*ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if (*ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (obj_ur_x >= *ll_x && obj_ll_x <= *ur_x && obj_ur_y >= *ll_y
      && obj_ll_y <= *ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);

    // Increase the redraw area
    if (obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if (obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if (obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if (obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
}

void GrowAxis::set_highlight(int on)
{
  if (highlight != on) {
    highlight = on;
    ctx->set_dirty();
  }
}

void GrowAxis::draw(GlowWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  hot = (w == &ctx->navw) ? 0 : hot;
  int draw_text = (fabs(increment) > DBL_EPSILON);
  int idx;
  int x, y;
  char text[20];
  int line_length;
  int y_text;
  int z_height = 0, z_width, z_descent = 0;
  int max_z_width = 0;
  int text_idx
      = int(w->zoom_factor_y / w->base_zoom_factor * (text_size + 4) - 4);
  double tsize = w->zoom_factor_y / w->base_zoom_factor * (8 + 2 * text_size);
  text_idx = MIN(text_idx, DRAW_TYPE_SIZE - 1);

  if (fix_line_width) {
    idx = line_width;
    idx += hot;
    if (idx < 0) {
      erase(w, t, hot, node);
      return;
    }
  } else {
    if (node && ((GrowNode*)node)->line_width)
      idx = int(
          w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
          - 1);
    else
      idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
    idx += hot;
  }
  if ((node && ((GrowNode*)node)->invisible) || invisible)
    return;

  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;
  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  double rotation = (tmp.rotation / 360 - floor(tmp.rotation / 360)) * 360;

  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  glow_eDrawType drawtype = ctx->get_drawtype(draw_type, glow_eDrawType_LineHighlight,
      highlight, (GrowNode*)colornode, 0);

  if (45 >= rotation || rotation > 315) {
    // Vertical line to the right and values to the left

    ctx->gdraw->line(ur_x, ll_y, ur_x, ur_y, drawtype, idx, 0);

    // Calculate max value text width
    if (draw_text) {
      for (int i = 0; i < lines; i++) {
        if (i % valuequotient == 0) {
          format_text(text, format, max_value - i * increment);
          ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
              MAX(0, text_idx), glow_eFont_Helvetica, &z_width, &z_height,
              &z_descent, tsize, 0);
          if (max_z_width < z_width)
            max_z_width = z_width;
        }
      }
      line_length = ur_x - ll_x - max_z_width;
      if (line_length < 3)
        line_length = 3;
    } else {
      line_length = ur_x - ll_x;
    }

    for (int i = 0; i < lines; i++) {
      y = int(ll_y + double(ur_y - ll_y) / (lines - 1) * i);
      if (i % longquotient == 0)
        ctx->gdraw->line(ur_x - line_length, y, ur_x, y, drawtype, idx, 0);
      else
        ctx->gdraw->line(ur_x - int(2.0 / 3 * line_length), y, ur_x, y,
            drawtype, idx, 0);
      if (draw_text) {
        format_text(text, format, max_value - i * increment);

        if (text_idx >= 0 && max_z_width < ur_x - ll_x
            && i % valuequotient == 0) {
          if (i == lines - 1)
            y_text = y;
          else if (i == 0)
            y_text = y + z_height - z_descent - 3;
          else
            y_text = y + (z_height - z_descent) / 2;
          ctx->gdraw->text(ll_x, y_text, text, strlen(text), text_drawtype,
              text_color_drawtype, text_idx, highlight, glow_eFont_Helvetica,
              tsize, 0);
        }
      }
    }
  } else if (45 < rotation && rotation <= 135) {
    // Horizontal line at bottom and values to the top

    ctx->gdraw->line(ll_x, ur_y, ur_x, ur_y, drawtype, idx, 0);

    // Calculate max value text height
    if (draw_text) {
      ctx->gdraw->get_text_extent("0", 1, text_drawtype, MAX(0, text_idx),
          glow_eFont_Helvetica, &z_width, &z_height, &z_descent, tsize, 0);

      line_length = ur_y - ll_y - z_height;
      if (line_length < 3)
        line_length = 3;
    } else {
      line_length = ur_y - ll_y;
    }

    for (int i = 0; i < lines; i++) {
      x = int(ll_x + double(ur_x - ll_x) / (lines - 1) * (lines - 1 - i));
      if (i % longquotient == 0)
        ctx->gdraw->line(x, ur_y - line_length, x, ur_y, drawtype, idx, 0);
      else
        ctx->gdraw->line(x, ur_y - int(2.0 / 3 * line_length), x, ur_y,
            drawtype, idx, 0);

      if (draw_text && i % valuequotient == 0) {
        format_text(text, format, max_value - i * increment);
        ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
            MAX(0, text_idx), glow_eFont_Helvetica, &z_width, &z_height,
            &z_descent, tsize, 0);

        if (text_idx >= 0 && z_height < ur_y - ll_y) {
          int x_text;
          if (i == lines - 1)
            x_text = x;
          else if (i == 0)
            x_text = x - z_width;
          else
            x_text = x - (z_width) / 2;
          ctx->gdraw->text(x_text, ll_y + z_height - z_descent, text,
              strlen(text), text_drawtype, text_color_drawtype, text_idx,
              highlight, glow_eFont_Helvetica, tsize, 0);
        }
      }
    }
  } else if (135 < rotation && rotation <= 225) {
    // Vertical line to the left and values to the right

    ctx->gdraw->line(ll_x, ll_y, ll_x, ur_y, drawtype, idx, 0);

    // Calculate max value text width
    int x_text = ur_x;
    if (draw_text) {
      for (int i = 0; i < lines; i++) {
        if (i % valuequotient == 0) {
          format_text(text, format, max_value - i * increment);
          ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
              MAX(0, text_idx), glow_eFont_Helvetica, &z_width, &z_height,
              &z_descent, tsize, 0);
          if (max_z_width < z_width)
            max_z_width = z_width;
        }
      }
      x_text -= max_z_width;
      line_length = ur_x - ll_x - max_z_width;
      if (line_length < 3)
        line_length = 3;
    } else {
      line_length = ur_x - ll_x;
    }

    for (int i = 0; i < lines; i++) {
      y = int(ll_y + double(ur_y - ll_y) / (lines - 1) * (lines - 1 - i));
      if (i % longquotient == 0)
        ctx->gdraw->line(ll_x, y, ll_x + line_length, y, drawtype, idx, 0);
      else
        ctx->gdraw->line(ll_x, y, ll_x + int(2.0 / 3 * line_length), y,
            drawtype, idx, 0);
      format_text(text, format, max_value - i * increment);

      if (draw_text && text_idx >= 0 && max_z_width < ur_x - ll_x
          && i % valuequotient == 0) {
        if (i == lines - 1)
          y_text = y + z_height - z_descent - 3;
        else if (i == 0)
          y_text = y;
        else
          y_text = y + (z_height - z_descent) / 2;
        ctx->gdraw->text(x_text, y_text, text, strlen(text), text_drawtype,
            text_color_drawtype, text_idx, highlight, glow_eFont_Helvetica,
            tsize, 0);
      }
    }
  } else { // if ( 225 < rotation && rotation <= 315)
    // Horizontal line at top and values at the bottom

    ctx->gdraw->line(ll_x, ll_y, ur_x, ll_y, drawtype, idx, 0);

    // Calculate max value text height
    if (draw_text) {
      ctx->gdraw->get_text_extent("0", 1, text_drawtype, MAX(0, text_idx),
          glow_eFont_Helvetica, &z_width, &z_height, &z_descent, tsize, 0);

      line_length = ur_y - ll_y - (z_height - z_descent);
      if (line_length < 3)
        line_length = 3;
    } else {
      line_length = ur_y - ll_y;
    }

    for (int i = 0; i < lines; i++) {
      x = int(ll_x + double(ur_x - ll_x) / (lines - 1) * i);
      if (i % longquotient == 0)
        ctx->gdraw->line(x, ll_y, x, ll_y + line_length, drawtype, idx, 0);
      else
        ctx->gdraw->line(x, ll_y, x, ll_y + int(2.0 / 3 * line_length),
            drawtype, idx, 0);
      if (draw_text && i % valuequotient == 0) {
        format_text(text, format, max_value - i * increment);
        ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
            MAX(0, text_idx), glow_eFont_Helvetica, &z_width, &z_height,
            &z_descent, tsize, 0);

        if (text_idx >= 0 && z_height - z_descent < ur_y - ll_y) {
          int x_text;
          if (i == lines - 1)
            x_text = x - z_width;
          else if (i == 0)
            x_text = x;
          else
            x_text = x - (z_width) / 2;
          ctx->gdraw->text(x_text, ur_y, text, strlen(text), text_drawtype,
              text_color_drawtype, text_idx, highlight, glow_eFont_Helvetica,
              tsize, 0);
        }
      }
    }
  }
}

void GrowAxis::erase(GlowWind* w, GlowTransform* t, int hot, void* node)
{
  int hotw = 2;

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;
  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;

  int ll_x = ROUND(MIN(p1.x, p2.x)) - hotw;
  int ur_x = ROUND(MAX(p1.x, p2.x)) + hotw;
  int ll_y = ROUND(MIN(p1.y, p2.y)) - hotw;
  int ur_y = ROUND(MAX(p1.y, p2.y)) + hotw;

  ctx->gdraw->rect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
      glow_eDrawType_LineErase, 1, 0);
}

void GrowAxis::align(double x, double y, glow_eAlignDirection direction)
{
  double dx, dy;

  switch (direction) {
  case glow_eAlignDirection_CenterVert:
    dx = x - (x_right + x_left) / 2;
    dy = 0;
    break;
  case glow_eAlignDirection_CenterHoriz:
    dx = 0;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_CenterCenter:
    dx = x - (x_right + x_left) / 2;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_Right:
    dx = x - x_right;
    dy = 0;
    break;
  case glow_eAlignDirection_Left:
    dx = x - x_left;
    dy = 0;
    break;
  case glow_eAlignDirection_Up:
    dx = 0;
    dy = y - y_high;
    break;
  case glow_eAlignDirection_Down:
    dx = 0;
    dy = y - y_low;
    break;
  }
  if (!feq(dx, 0.0) || !feq(dy, 0.0)) {
    ctx->set_dirty();
  }
  trf.move(dx, dy);
  x_right += dx;
  x_left += dx;
  y_high += dy;
  y_low += dy;
}

void GrowAxis::set_textsize(int size)
{
  if (text_size != size) {
    text_size = size;
    ctx->set_dirty();
  }
  get_node_borders();
}

void GrowAxis::set_textbold(int bold)
{
  if ((bold && text_drawtype == glow_eDrawType_TextHelveticaBold)
      || (!bold && text_drawtype == glow_eDrawType_TextHelvetica))
    return;

  if (bold)
    text_drawtype = glow_eDrawType_TextHelveticaBold;
  else
    text_drawtype = glow_eDrawType_TextHelvetica;
  get_node_borders();
  ctx->set_dirty();
}

void GrowAxis::set_range(double minval, double maxval, int keep_settings)
{
  static sRange rdata[2][25] = { { { 26, 5, 5, 10, "%3.1f" }, // 1
                                     { 21, 5, 5, 10, "%3.1f" }, // 2
                                     { 31, 5, 10, 10, "%3.1f" }, // 3
                                     { 41, 5, 10, 20, "%3.1f" }, // 4
                                     { 26, 5, 5, 10, "%1.0f" }, // 5
                                     { 31, 5, 10, 10, "%1.0f" }, // 6
                                     { 36, 5, 10, 10, "%1.0f" }, // 7
                                     { 17, 2, 4, 4, "%1.0f" }, // 8
                                     { 19, 2, 4, 4, "%1.0f" }, // 9
                                     { 21, 2, 4, 8, "%2.0f" }, // 10
                                     { 23, 2, 4, 8, "%2.0f" }, // 11
                                     { 13, 4, 4, 4, "%2.0f" }, // 12
                                     { 14, 4, 4, 4, "%2.0f" }, // 13
                                     { 15, 4, 4, 4, "%2.0f" }, // 14
                                     { 16, 5, 5, 5, "%2.0f" }, // 15
                                     { 17, 5, 5, 5, "%2.0f" }, // 16
                                     { 18, 5, 5, 5, "%2.0f" }, // 17
                                     { 19, 5, 5, 5, "%2.0f" }, // 18
                                     { 20, 5, 5, 5, "%2.0f" }, // 19
                                     { 21, 5, 5, 5, "%2.0f" }, // 20
                                     { 22, 5, 5, 5, "%2.0f" }, // 21
                                     { 23, 5, 5, 5, "%2.0f" }, // 22
                                     { 24, 5, 5, 5, "%2.0f" }, // 23
                                     { 25, 5, 5, 5, "%2.0f" }, // 24
                                     { 26, 5, 5, 10, "%2.0f" } }, // 25
    { { 101, 5, 10, 20, "%3.1f" }, // 1
        { 101, 5, 10, 20, "%3.1f" }, // 2
        { 61, 10, 10, 20, "%3.1f" }, // 3
        { 81, 10, 10, 20, "%3.1f" }, // 4
        { 101, 10, 20, 20, "%1.0f" }, // 5
        { 61, 5, 10, 20, "%1.0f" }, // 6
        { 71, 5, 10, 20, "%1.0f" }, // 7
        { 81, 5, 10, 20, "%1.0f" }, // 8
        { 91, 5, 10, 20, "%1.0f" }, // 9
        { 101, 5, 10, 20, "%2.0f" }, // 10
        { 56, 5, 5, 5, "%2.0f" }, // 11
        { 61, 5, 10, 10, "%2.0f" }, // 12
        { 66, 5, 10, 20, "%2.0f" }, // 13
        { 71, 5, 10, 20, "%2.0f" }, // 14
        { 76, 5, 10, 20, "%2.0f" }, // 15
        { 81, 5, 10, 20, "%2.0f" }, // 16
        { 86, 5, 10, 20, "%2.0f" }, // 17
        { 91, 5, 10, 20, "%2.0f" }, // 18
        { 96, 5, 10, 20, "%2.0f" }, // 19
        { 101, 5, 10, 25, "%2.0f" }, // 20
        { 43, 2, 6, 6, "%2.0f" }, // 21
        { 45, 2, 4, 8, "%2.0f" }, // 22
        { 47, 2, 4, 8, "%2.0f" }, // 23
        { 49, 2, 4, 8, "%2.0f" }, // 24
        { 26, 5, 5, 5, "%2.0f" } } }; // 25

  max_value = maxval;
  min_value = minval;

  GlowWind* w = &ctx->mw;
  // double tsize = w->zoom_factor_y / w->base_zoom_factor * (8+2*text_size);
  glow_sPoint p1 = trf * ll;
  glow_sPoint p2 = trf * ur;
  p1.x = int(p1.x * ctx->mw.zoom_factor_x) - w->offset_x;
  p1.y = int(p1.y * ctx->mw.zoom_factor_y) - w->offset_y;
  p2.x = int(p2.x * ctx->mw.zoom_factor_x) - w->offset_x;
  p2.y = int(p2.y * ctx->mw.zoom_factor_y) - w->offset_y;
  double rotation = (trf.rotation / 360 - floor(trf.rotation / 360)) * 360;

  if (!keep_settings) {
    int horizontal = !(rotation < 45 || (rotation > 135 && rotation < 225)
                         || rotation > 315);
    int len = horizontal ? int(ABS(p2.x - p1.x)) : int(ABS(p2.y - p1.y));
    int lix = (len >= 150);

    double d = fabs(maxval - minval);
    if (d < 5)
      d = 1000 * d;

    int di = ROUND(d);
    while (di >= 25)
      di /= 10;

    if (di > 0 && di <= 25) {
      lines = rdata[lix][di - 1].lines;
      longquotient = rdata[lix][di - 1].longq;
      if (horizontal)
        valuequotient = rdata[lix][di - 1].hvalq;
      else
        valuequotient = rdata[lix][di - 1].vvalq;
    }

    double m = MAX(fabs(maxval), fabs(minval));

    if (m < 0.01)
      strcpy(format, "%g");
    else if (m < 0.1)
      strcpy(format, "%5.3f");
    else if (m < 1)
      strcpy(format, "%4.2f");
    else if (!lix && m < 3)
      strcpy(format, "%3.1f");
    else if (lix && m <= 4)
      strcpy(format, "%3.1f");
    else if (m <= 20)
      strcpy(format, "%2.0f");
    else if (m <= 200)
      strcpy(format, "%3.0f");
    else if (m < 2000)
      strcpy(format, "%4.0f");
    else if (m < 20000)
      strcpy(format, "%5.0f");
    else
      strcpy(format, "%g");
  }
  configure();
  ctx->set_dirty();
}

void GrowAxis::export_javabean(GlowTransform* t, void* node,
    glow_eExportPass pass, int* shape_cnt, int node_cnt, int in_nc,
    std::ofstream& fp)
{
  int draw_text = (fabs(increment) > DBL_EPSILON);
  int bold;
  char text[20];
  int line_length;
  int z_height, z_width, z_descent;
  int max_z_width = 0;
  int idx = int(
      ctx->mw.zoom_factor_y / ctx->mw.base_zoom_factor * (text_size + 4) - 4);
  double tsize
      = ctx->mw.zoom_factor_y / ctx->mw.base_zoom_factor * (8 + 2 * text_size);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  bold = (text_drawtype == glow_eDrawType_TextHelveticaBold);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;
  p1.x = p1.x * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
  p1.y = p1.y * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
  p2.x = p2.x * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
  p2.y = p2.y * ctx->mw.zoom_factor_y - ctx->mw.offset_y;

  double ll_x = MIN(p1.x, p2.x);
  double ur_x = MAX(p1.x, p2.x);
  double ll_y = MIN(p1.y, p2.y);
  double ur_y = MAX(p1.y, p2.y);

  double rotation = (tmp.rotation / 360 - floor(tmp.rotation / 360)) * 360;

  // Calculate max value line width
  if (45 >= rotation || rotation > 315) {
    if (draw_text) {
      for (int i = 0; i < lines; i++) {
        if (i % valuequotient == 0) {
          format_text(text, format, max_value - i * increment);
          ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
              MAX(0, idx), glow_eFont_Helvetica, &z_width, &z_height,
              &z_descent, tsize, 0);
          if (max_z_width < z_width)
            max_z_width = z_width;
        }
      }
      line_length = int(ur_x - ll_x) - max_z_width;
    } else
      line_length = int(ur_x - ll_x);
  } else if (45 < rotation && rotation <= 135) {
    if (draw_text) {
      ctx->gdraw->get_text_extent("0", 1, text_drawtype, MAX(0, idx),
          glow_eFont_Helvetica, &z_width, &z_height, &z_descent, tsize, 0);

      line_length = int(ur_y - ll_y) - (z_height - z_descent);
    } else
      line_length = int(ur_y - ll_y);
  } else if (135 < rotation && rotation <= 225) {
    if (draw_text) {
      for (int i = 0; i < lines; i++) {
        if (i % valuequotient == 0) {
          format_text(text, format, max_value - i * increment);
          ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
              MAX(0, idx), glow_eFont_Helvetica, &z_width, &z_height,
              &z_descent, tsize, 0);
          if (max_z_width < z_width)
            max_z_width = z_width;
        }
      }
      line_length = int(ur_x - ll_x) - max_z_width;
    } else
      line_length = int(ur_x - ll_x);
  } else // if ( 225 < rotation && rotation <= 315)
  {
    if (draw_text) {
      ctx->gdraw->get_text_extent("0", 1, text_drawtype, MAX(0, idx),
          glow_eFont_Helvetica, &z_width, &z_height, &z_descent, tsize, 0);

      line_length = int(ur_y - ll_y) - (z_height - z_descent);
    } else
      line_length = int(ur_y - ll_y);
  }
  if (line_length < 3)
    line_length = 3;

  ctx->export_jbean->axis(ll_x, ll_y, ur_x, ur_y, draw_type,
      text_color_drawtype, min_value, max_value, lines, longquotient,
      valuequotient, line_length, line_width, rotation, bold, idx, format,
      pass, shape_cnt, node_cnt, fp);
}

int GrowAxis::trace_scan()
{
  if (!trace.p)
    return 1;

  if (ctx->trace_scan_func)
    ctx->trace_scan_func((void*)this, trace.p);
  return 1;
}

int GrowAxis::trace_init()
{
  int sts;

  sts = ctx->trace_connect_func((void*)this, &trace);
  return sts;
}

void GrowAxis::trace_close()
{
  if (trace.p)
    ctx->trace_disconnect_func((void*)this);
}

void GrowAxis::set_conf(double max_val, double min_val, int no_of_lines,
    int long_quot, int value_quot, double rot, const char* value_format)
{
  max_value = max_val;
  min_value = min_val;
  lines = no_of_lines;
  longquotient = long_quot;
  valuequotient = value_quot;
  trf.rotation = rot;
  if (format)
    strcpy(format, value_format);

  configure();
  ctx->set_dirty();
}

void GrowAxis::set_format(const char* f)
{
  strncpy(format, f, sizeof(format));
}

void GrowAxis::get_format(char* f)
{
  strcpy(f, format);
}

void GrowAxis::set_axis_info(glow_sAxisInfo* info)
{
  max_value = info->max_value;
  min_value = info->min_value;
  if (info->lines)
    lines = info->lines;
  if (info->longquotient)
    longquotient = info->longquotient;
  if (info->valuequotient)
    valuequotient = info->valuequotient;
  if (!streq(info->format, ""))
    strcpy(format, info->format);
}

void GrowAxis::get_axis_info(glow_sAxisInfo* info)
{
  info->max_value = max_value;
  info->min_value = min_value;
  info->lines = lines;
  info->longquotient = longquotient;
  info->valuequotient = valuequotient;
  strcpy(info->format, format);
}

void GrowAxis::format_text(char* text, char* fmt, double value)
{
  if (streq(fmt, "%1t")) {
    // Hours, minutes and seconds, value in seconds
    int val = (int)nearbyint(value);
    int hours = val / 3600;
    int minutes = (val - hours * 3600) / 60;
    int seconds = (val - hours * 3600 - minutes * 60);
    sprintf(text, "%d:%02d:%02d", hours, minutes, seconds);
  } else if (streq(fmt, "%2t")) {
    // Hours and minutes, value in seconds
    int val = (int)nearbyint(value);
    int hours = val / 3600;
    int minutes = (val - hours * 3600) / 60;
    sprintf(text, "%d:%02d", hours, minutes);
  } else if (streq(fmt, "%3t")) {
    // Days, hours and minues, value in seconds
    int val = (int)nearbyint(value);
    int days = val / (24 * 3600);
    int hours = (val - days * 24 * 3600) / 3600;
    int minutes = (val - days * 24 * 3600 - hours * 3600) / 60;
    sprintf(text, "%d %02d:%02d", days, hours, minutes);
  } else if (streq(fmt, "%10t")) {
    // Date
    char timstr[40];
    pwr_tTime t;
    t.tv_sec = (int)nearbyint(value);
    t.tv_nsec = 0;

    time_AtoAscii(&t, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
    timstr[19] = 0;
    strcpy(text, timstr);
  } else if (streq(fmt, "%11t")) {
    // Date, no seconds
    char timstr[40];
    pwr_tTime t;
    t.tv_sec = (int)nearbyint(value);
    t.tv_nsec = 0;

    time_AtoAscii(&t, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
    timstr[16] = 0;
    strcpy(text, timstr);
  } else {
    if (fabs(value) < FLT_EPSILON)
      value = 0;
    sprintf(text, fmt, value);
  }
}

void GrowAxis::convert(glow_eConvert version)
{
  switch (version) {
  case glow_eConvert_V34: {
    // Conversion of colors
    GrowRect::convert(version);
    text_drawtype = GlowColor::convert(version, text_drawtype);

    break;
  }
  }
}

glow_eVis GrowAxis::get_visibility()
{
  if (invisible)
    return glow_eVis_Invisible;
  return glow_eVis_Visible;
}

void GrowAxis::set_visibility(glow_eVis visibility)
{
  if ((!invisible && visibility == glow_eVis_Visible) ||
      (invisible && visibility == glow_eVis_Invisible) ||
      visibility == glow_eVis_Dimmed) {
    return;
  }

  invisible = (visibility == glow_eVis_Invisible);
  ctx->set_dirty();
}
