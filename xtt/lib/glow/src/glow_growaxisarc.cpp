/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_string.h"
#include "co_time.h"

#include "glow_growaxisarc.h"
#include "glow_grownode.h"
#include "glow_draw.h"

#if defined OS_OPENBSD
#define nearbyint rint
#endif

typedef struct {
  int lines;
  int longq;
  int vvalq;
  int hvalq;
  char format[10];
} sRange;

GrowAxisArc::GrowAxisArc(GrowCtx* glow_ctx, const char* name, double x1,
    double y1, double x2, double y2, int ang1, int ang2,
    glow_eDrawType border_d_type, int line_w, int t_size,
    glow_eDrawType t_drawtype, int nodraw)
    : GrowArc(glow_ctx, name, x1, y1, x2, y2, ang1, ang2, border_d_type, line_w,
          0, 0, 0, glow_eDrawType_Line, 1),
      text_size(t_size), text_drawtype(t_drawtype),
      text_color_drawtype(glow_eDrawType_Line), max_value(100), min_value(0),
      lines(11), linelength(0.15), longquotient(1), valuequotient(1),
      increment(0)
{
  strcpy(format, "%3.0f");

  configure();
  if (!nodraw)
    ctx->set_dirty();
}

GrowAxisArc::~GrowAxisArc()
{
  ctx->set_dirty();
}

void GrowAxisArc::configure()
{
  if (lines <= 1)
    lines = 2;
  if (longquotient <= 0)
    longquotient = 1;
  if (valuequotient <= 0)
    valuequotient = 1;
  increment = (max_value - min_value) / (lines - 1);
}

void GrowAxisArc::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowAxisArc) << '\n';
  fp << int(glow_eSave_GrowAxisArc_max_value) << FSPACE << max_value << '\n';
  fp << int(glow_eSave_GrowAxisArc_min_value) << FSPACE << min_value << '\n';
  fp << int(glow_eSave_GrowAxisArc_arc_part) << '\n';
  GrowArc::save(fp, mode);
  fp << int(glow_eSave_GrowAxisArc_lines) << FSPACE << lines << '\n';
  fp << int(glow_eSave_GrowAxisArc_linelength) << FSPACE << linelength << '\n';
  fp << int(glow_eSave_GrowAxisArc_longquotient) << FSPACE << longquotient
     << '\n';
  fp << int(glow_eSave_GrowAxisArc_valuequotient) << FSPACE << valuequotient
     << '\n';
  fp << int(glow_eSave_GrowAxisArc_format) << FSPACE << format << '\n';
  fp << int(glow_eSave_GrowAxisArc_text_size) << FSPACE << text_size << '\n';
  fp << int(glow_eSave_GrowAxisArc_text_drawtype) << FSPACE
     << int(text_drawtype) << '\n';
  fp << int(glow_eSave_GrowAxisArc_text_color_drawtype) << FSPACE
     << int(text_color_drawtype) << '\n';
  if (user_data && ctx->userdata_save_callback) {
    fp << int(glow_eSave_GrowAxisArc_userdata_cb) << '\n';
    (ctx->userdata_save_callback)(&fp, this, glow_eUserdataCbType_Node);
  }
  fp << int(glow_eSave_End) << '\n';
}

void GrowAxisArc::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowAxisArc: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowAxisArc:
      break;
    case glow_eSave_GrowAxisArc_max_value:
      fp >> max_value;
      break;
    case glow_eSave_GrowAxisArc_min_value:
      fp >> min_value;
      break;
    case glow_eSave_GrowAxisArc_arc_part:
      GrowArc::open(fp);
      break;
    case glow_eSave_GrowAxisArc_lines:
      fp >> lines;
      break;
    case glow_eSave_GrowAxisArc_linelength:
      fp >> linelength;
      break;
    case glow_eSave_GrowAxisArc_longquotient:
      fp >> longquotient;
      break;
    case glow_eSave_GrowAxisArc_valuequotient:
      fp >> valuequotient;
      break;
    case glow_eSave_GrowAxisArc_format:
      fp.get();
      fp.getline(format, sizeof(format));
      break;
    case glow_eSave_GrowAxisArc_text_size:
      fp >> text_size;
      break;
    case glow_eSave_GrowAxisArc_text_drawtype:
      fp >> tmp;
      text_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowAxisArc_text_color_drawtype:
      fp >> tmp;
      text_color_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowAxisArc_userdata_cb:
      if (ctx->userdata_open_callback)
        (ctx->userdata_open_callback)(&fp, this, glow_eUserdataCbType_Node);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowAxisArc:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  configure();
}

void GrowAxisArc::draw(GlowWind* w, int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;

  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * w->zoom_factor_x - w->offset_x >= ll_x
      && x_left * w->zoom_factor_x - w->offset_x <= ur_x
      && y_high * w->zoom_factor_y - w->offset_y >= ll_y
      && y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);
  }
}

void GrowAxisArc::draw(GlowWind* w, int* ll_x, int* ll_y, int* ur_x, int* ur_y)
{
  int tmp;
  int obj_ur_x = int(x_right * w->zoom_factor_x) - w->offset_x;
  int obj_ll_x = int(x_left * w->zoom_factor_x) - w->offset_x;
  int obj_ur_y = int(y_high * w->zoom_factor_y) - w->offset_y;
  int obj_ll_y = int(y_low * w->zoom_factor_y) - w->offset_y;

  if (*ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if (*ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (obj_ur_x >= *ll_x && obj_ll_x <= *ur_x && obj_ur_y >= *ll_y
      && obj_ll_y <= *ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);

    // Increase the redraw area
    if (obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if (obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if (obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if (obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
}

void GrowAxisArc::set_highlight(int on)
{
  if (highlight != on) {
    highlight = on;
    ctx->set_dirty();
  }
}

void GrowAxisArc::draw(GlowWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  hot = (w == &ctx->navw) ? 0 : hot;
  int draw_text = (fabs(increment) > DBL_EPSILON);
  int idx;
  char text[20];
  int z_height, z_width, z_descent;
  int text_idx
      = int(w->zoom_factor_y / w->base_zoom_factor * (text_size + 4) - 4);
  double tsize = w->zoom_factor_y / w->base_zoom_factor * (8 + 2 * text_size);
  text_idx = MIN(text_idx, DRAW_TYPE_SIZE - 1);

  if (node && ((GrowNode*)node)->line_width)
    idx = int(
        w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
        - 1);
  else
    idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;

  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;
  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  double rotation = (tmp.rotation / 360 - floor(tmp.rotation / 360)) * 360;

  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  glow_eDrawType drawtype = ctx->get_drawtype(draw_type, glow_eDrawType_LineHighlight,
      highlight, (GrowNode*)colornode, 0);

  // Lines inwards
  ctx->gdraw->arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
      angle1 - (int)rotation, angle2, drawtype, 0, idx);

  if (lines == 1)
    return;

  if (increment > 0)
    format_text(text, format, min_value + (lines - 2) * increment);
  else
    format_text(text, format, min_value + increment);
  ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
      MAX(0, text_idx), glow_eFont_Helvetica, &z_width, &z_height, &z_descent,
      tsize, 0);

  // z_descent=0;
  double line_angle = (double)angle2 / (lines - 1);
  for (int i = 0; i < lines; i++) {
    double sin1 = sin(((double)angle1 + i * line_angle) / 180 * M_PI);
    double cos1 = cos(((double)angle1 + i * line_angle) / 180 * M_PI);
    p1.y = int(((double)ur_y - ll_y) / 2 * (-sin1 + 1) + ll_y);
    p1.x = int(((double)ur_x - ll_x) / 2 * (cos1 + 1) + ll_x);
    if (i % longquotient == 0) {
      p2.y = int(((double)ur_y - ll_y) / 2 * (-sin1 * (1.0 - linelength) + 1)
               + ll_y);
      p2.x = int(
          ((double)ur_x - ll_x) / 2 * (cos1 * (1.0 - linelength) + 1) + ll_x);
    } else {
      p2.y = int(
          ((double)ur_y - ll_y) / 2 * (-sin1 * (1.0 - linelength / 2) + 1)
          + ll_y);
      p2.x = int(((double)ur_x - ll_x) / 2 * (cos1 * (1.0 - linelength / 2) + 1)
          + ll_x);
    }
    int yt = int(((double)ur_y - ll_y) / 2 * (-sin1 * (1.0 - linelength) + 1)
        + ll_y + sin1 * (z_height - z_descent) / 2);
    int xt = int(((double)ur_x - ll_x) / 2 * (cos1 * (1.0 - linelength) + 1)
        + ll_x - cos1 * z_width / 2);

    ctx->gdraw->line((int)p1.x, (int)p1.y, (int)p2.x, (int)p2.y, drawtype, idx, 0);
    if (draw_text) {
      if (text_idx >= 0 && i % valuequotient == 0
          && !(angle2 == 360 && ((increment > 0 && i == lines - 1)
                                    || (increment < 0 && i == 0)))) {
        format_text(text, format, min_value + i * increment);
        ctx->gdraw->get_text_extent(text, strlen(text), text_drawtype,
            MAX(0, text_idx), glow_eFont_Helvetica, &z_width, &z_height,
            &z_descent, tsize, 0);

        if (i == lines - 1 && angle1 == 0 && angle2 == 180) {
          // yt = yt - (z_height-z_descent)/2;
          xt = xt - z_width / 2;
        } else if (i == 0 && angle1 == 0 && angle2 != 360) {
          // yt = yt - (z_height-z_descent)/2;
          xt = xt - z_width / 2;
        } else {
          yt = yt + (z_height - z_descent) / 2;
          xt = xt - z_width / 2;
        }
        ctx->gdraw->text(xt, yt, text, strlen(text), text_drawtype,
            text_color_drawtype, text_idx, highlight, glow_eFont_Helvetica,
            tsize, 0);
      }
    }
  }
}

void GrowAxisArc::erase(GlowWind* w, GlowTransform* t, int hot, void* node)
{
  hot = (w == &ctx->navw) ? 0 : hot;
  int idx;
  if (hot && ctx->environment != glow_eEnv_Development
      && ctx->hot_indication != glow_eHotIndication_LineWidth)
    hot = 0;

  if (node && ((GrowNode*)node)->line_width)
    idx = int(
        w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
        - 1);
  else
    idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;
  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;
  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;

  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  ctx->gdraw->arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
      angle1 - (int)tmp.rotation, angle2, glow_eDrawType_LineErase, 0, idx);
  ctx->gdraw->rect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
      glow_eDrawType_LineErase, 1, 0);
}

void GrowAxisArc::align(double x, double y, glow_eAlignDirection direction)
{
  double dx, dy;

  switch (direction) {
  case glow_eAlignDirection_CenterVert:
    dx = x - (x_right + x_left) / 2;
    dy = 0;
    break;
  case glow_eAlignDirection_CenterHoriz:
    dx = 0;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_CenterCenter:
    dx = x - (x_right + x_left) / 2;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_Right:
    dx = x - x_right;
    dy = 0;
    break;
  case glow_eAlignDirection_Left:
    dx = x - x_left;
    dy = 0;
    break;
  case glow_eAlignDirection_Up:
    dx = 0;
    dy = y - y_high;
    break;
  case glow_eAlignDirection_Down:
    dx = 0;
    dy = y - y_low;
    break;
  }
  if (!feq(dx, 0.0) || !feq(dy, 0.0)) {
    ctx->set_dirty();
  }
  trf.move(dx, dy);
  x_right += dx;
  x_left += dx;
  y_high += dy;
  y_low += dy;
}

void GrowAxisArc::set_textsize(int size)
{
  if (text_size != size) {
    text_size = size;
    ctx->set_dirty();
  }
  get_node_borders();
}

void GrowAxisArc::set_textbold(int bold)
{
  if ((bold && text_drawtype == glow_eDrawType_TextHelveticaBold)
      || (!bold && text_drawtype == glow_eDrawType_TextHelvetica))
    return;

  if (bold)
    text_drawtype = glow_eDrawType_TextHelveticaBold;
  else
    text_drawtype = glow_eDrawType_TextHelvetica;
  get_node_borders();
  ctx->set_dirty();
}

void GrowAxisArc::set_range(double minval, double maxval, int keep_settings)
{
  static sRange rdata[2][25] = { { { 26, 5, 5, 10, "%3.1f" }, // 1
                                     { 21, 5, 5, 10, "%3.1f" }, // 2
                                     { 31, 5, 10, 10, "%3.1f" }, // 3
                                     { 41, 5, 10, 20, "%3.1f" }, // 4
                                     { 26, 5, 5, 10, "%1.0f" }, // 5
                                     { 31, 5, 10, 10, "%1.0f" }, // 6
                                     { 36, 5, 10, 10, "%1.0f" }, // 7
                                     { 17, 2, 4, 4, "%1.0f" }, // 8
                                     { 19, 2, 4, 4, "%1.0f" }, // 9
                                     { 21, 2, 4, 8, "%2.0f" }, // 10
                                     { 23, 2, 4, 8, "%2.0f" }, // 11
                                     { 13, 4, 4, 4, "%2.0f" }, // 12
                                     { 14, 4, 4, 4, "%2.0f" }, // 13
                                     { 15, 4, 4, 4, "%2.0f" }, // 14
                                     { 16, 5, 5, 5, "%2.0f" }, // 15
                                     { 17, 5, 5, 5, "%2.0f" }, // 16
                                     { 18, 5, 5, 5, "%2.0f" }, // 17
                                     { 19, 5, 5, 5, "%2.0f" }, // 18
                                     { 20, 5, 5, 5, "%2.0f" }, // 19
                                     { 21, 5, 5, 5, "%2.0f" }, // 20
                                     { 22, 5, 5, 5, "%2.0f" }, // 21
                                     { 23, 5, 5, 5, "%2.0f" }, // 22
                                     { 24, 5, 5, 5, "%2.0f" }, // 23
                                     { 25, 5, 5, 5, "%2.0f" }, // 24
                                     { 26, 5, 5, 10, "%2.0f" } }, // 25
    { { 101, 5, 10, 20, "%3.1f" }, // 1
        { 101, 5, 10, 20, "%3.1f" }, // 2
        { 61, 10, 10, 20, "%3.1f" }, // 3
        { 81, 10, 10, 20, "%3.1f" }, // 4
        { 101, 10, 20, 20, "%1.0f" }, // 5
        { 61, 5, 10, 20, "%1.0f" }, // 6
        { 71, 5, 10, 20, "%1.0f" }, // 7
        { 81, 5, 10, 20, "%1.0f" }, // 8
        { 91, 5, 10, 20, "%1.0f" }, // 9
        { 101, 5, 10, 20, "%2.0f" }, // 10
        { 56, 5, 5, 5, "%2.0f" }, // 11
        { 61, 5, 10, 10, "%2.0f" }, // 12
        { 66, 5, 10, 20, "%2.0f" }, // 13
        { 71, 5, 10, 20, "%2.0f" }, // 14
        { 76, 5, 10, 20, "%2.0f" }, // 15
        { 81, 5, 10, 20, "%2.0f" }, // 16
        { 86, 5, 10, 20, "%2.0f" }, // 17
        { 91, 5, 10, 20, "%2.0f" }, // 18
        { 96, 5, 10, 20, "%2.0f" }, // 19
        { 101, 5, 10, 25, "%2.0f" }, // 20
        { 43, 2, 6, 6, "%2.0f" }, // 21
        { 45, 2, 4, 8, "%2.0f" }, // 22
        { 47, 2, 4, 8, "%2.0f" }, // 23
        { 49, 2, 4, 8, "%2.0f" }, // 24
        { 26, 5, 5, 5, "%2.0f" } } }; // 25

  max_value = maxval;
  min_value = minval;

  GlowWind* w = &ctx->mw;
  // double tsize = w->zoom_factor_y / w->base_zoom_factor * (8+2*text_size);
  glow_sPoint p1 = trf * ll;
  glow_sPoint p2 = trf * ur;
  p1.x = p1.x * ctx->mw.zoom_factor_x - w->offset_x;
  p1.y = p1.y * ctx->mw.zoom_factor_y - w->offset_y;
  p2.x = p2.x * ctx->mw.zoom_factor_x - w->offset_x;
  p2.y = p2.y * ctx->mw.zoom_factor_y - w->offset_y;
  double rotation = (trf.rotation / 360 - floor(trf.rotation / 360)) * 360;

  if (!keep_settings) {
    int horizontal = !(rotation < 45 || (rotation > 135 && rotation < 225)
                         || rotation > 315);
    int len = horizontal ? int(ABS(p2.x - p1.x)) : int(ABS(p2.y - p1.y));

    int lix = (len >= 150);

    double d = fabs(maxval - minval);
    if (d < 5)
      d = 1000 * d;

    int di = ROUND(d);
    while (di >= 25)
      di /= 10;

    if (di > 0 && di <= 25) {
      lines = rdata[lix][di - 1].lines;
      longquotient = rdata[lix][di - 1].longq;
      if (horizontal)
        valuequotient = rdata[lix][di - 1].hvalq;
      else
        valuequotient = rdata[lix][di - 1].vvalq;
    }

    double m = MAX(fabs(maxval), fabs(minval));
    if (m < 0.01)
      strcpy(format, "%g");
    else if (m < 0.1)
      strcpy(format, "%5.3f");
    else if (m < 1)
      strcpy(format, "%4.2f");
    else if (!lix && m < 3)
      strcpy(format, "%3.1f");
    else if (lix && m <= 4)
      strcpy(format, "%3.1f");
    else if (m <= 20)
      strcpy(format, "%2.0f");
    else if (m <= 200)
      strcpy(format, "%3.0f");
    else if (m < 2000)
      strcpy(format, "%4.0f");
    else if (m < 20000)
      strcpy(format, "%5.0f");
    else
      strcpy(format, "%g");
  }

  configure();
  ctx->set_dirty();
}

void GrowAxisArc::export_javabean(GlowTransform* t, void* node,
    glow_eExportPass pass, int* shape_cnt, int node_cnt, int in_nc,
    std::ofstream& fp)
{
  int bold;
  int idx = int(
      ctx->mw.zoom_factor_y / ctx->mw.base_zoom_factor * (text_size + 4) - 4);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  bold = (text_drawtype == glow_eDrawType_TextHelveticaBold);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;
  p1.x = p1.x * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
  p1.y = p1.y * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
  p2.x = p2.x * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
  p2.y = p2.y * ctx->mw.zoom_factor_y - ctx->mw.offset_y;

  double ll_x = MIN(p1.x, p2.x);
  double ur_x = MAX(p1.x, p2.x);
  double ll_y = MIN(p1.y, p2.y);
  double ur_y = MAX(p1.y, p2.y);

  double rotation = (tmp.rotation / 360 - floor(tmp.rotation / 360)) * 360;

  ctx->export_jbean->axisarc(ll_x, ll_y, ur_x, ur_y, angle1, angle2, draw_type,
      text_color_drawtype, min_value, max_value, lines, longquotient,
      valuequotient, linelength, line_width, rotation, bold, idx, format, pass,
      shape_cnt, node_cnt, fp);
}

int GrowAxisArc::trace_scan()
{
  if (!trace.p)
    return 1;

  if (ctx->trace_scan_func)
    ctx->trace_scan_func((void*)this, trace.p);
  return 1;
}

int GrowAxisArc::trace_init()
{
  int sts;

  sts = ctx->trace_connect_func((void*)this, &trace);
  return sts;
}

void GrowAxisArc::trace_close()
{
  if (trace.p)
    ctx->trace_disconnect_func((void*)this);
}

void GrowAxisArc::set_conf(double max_val, double min_val, int no_of_lines,
    int long_quot, int value_quot, double rot, const char* value_format)
{
  max_value = max_val;
  min_value = min_val;
  lines = no_of_lines;
  longquotient = long_quot;
  valuequotient = value_quot;
  trf.rotation = rot;
  if (format)
    strcpy(format, value_format);

  configure();
  ctx->set_dirty();
}

void GrowAxisArc::set_axis_info(glow_sAxisInfo* info)
{
  max_value = info->max_value;
  min_value = info->min_value;
  lines = info->lines;
  longquotient = info->longquotient;
  valuequotient = info->valuequotient;
  strcpy(format, info->format);
}

void GrowAxisArc::get_axis_info(glow_sAxisInfo* info)
{
  info->max_value = max_value;
  info->min_value = min_value;
  info->lines = lines;
  info->longquotient = longquotient;
  info->valuequotient = valuequotient;
  strcpy(info->format, format);
}

void GrowAxisArc::format_text(char* text, char* fmt, double value)
{
  if (streq(fmt, "%1t")) {
    // Hours, minutes and seconds, value in seconds
    int val = (int)nearbyint(value);
    int hours = val / 3600;
    int minutes = (val - hours * 3600) / 60;
    int seconds = (val - hours * 3600 - minutes * 60);
    sprintf(text, "%d:%02d:%02d", hours, minutes, seconds);
  } else if (streq(fmt, "%2t")) {
    // Hours and minutes, value in seconds
    int val = (int)nearbyint(value);
    int hours = val / 3600;
    int minutes = (val - hours * 3600) / 60;
    sprintf(text, "%d:%02d", hours, minutes);
  } else if (streq(fmt, "%3t")) {
    // Days, hours and minues, value in seconds
    int val = (int)nearbyint(value);
    int days = val / (24 * 3600);
    int hours = (val - days * 24 * 3600) / 3600;
    int minutes = (val - days * 24 * 3600 - hours * 3600) / 60;
    sprintf(text, "%d %02d:%02d", days, hours, minutes);
  } else if (streq(fmt, "%10t")) {
    // Date
    char timstr[40];
    pwr_tTime t;
    t.tv_sec = (int)nearbyint(value);
    t.tv_nsec = 0;

    time_AtoAscii(&t, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
    timstr[19] = 0;
    strcpy(text, timstr);
  } else if (streq(fmt, "%11t")) {
    // Date, no seconds
    char timstr[40];
    pwr_tTime t;
    t.tv_sec = (int)nearbyint(value);
    t.tv_nsec = 0;

    time_AtoAscii(&t, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
    timstr[16] = 0;
    strcpy(text, timstr);
  } else {
    if (fabs(value) < FLT_EPSILON)
      value = 0;
    sprintf(text, fmt, value);
  }
}

void GrowAxisArc::convert(glow_eConvert version)
{
}
