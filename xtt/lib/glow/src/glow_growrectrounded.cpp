/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_string.h"

#include "glow_growrectrounded.h"
#include "glow_grownode.h"
#include "glow_draw.h"

GrowRectRounded::GrowRectRounded(GrowCtx* glow_ctx, const char* name, double x,
    double y, double w, double h, glow_eDrawType border_d_type, int line_w,
    int fix_line_w, glow_mDisplayLevel display_lev, int fill_rect,
    int display_border, int display_shadow, glow_eDrawType fill_d_type,
    int nodraw)
    : GlowRect(glow_ctx, x, y, w, h, border_d_type, line_w, fix_line_w,
          display_lev, fill_rect),
      hot(0), pzero(ctx), highlight(0), inverse(0), user_data(NULL),
      original_border_drawtype(border_d_type),
      original_fill_drawtype(fill_d_type), fill_drawtype(fill_d_type),
      border(display_border), dynamic(0), dynamicsize(0), round_amount(15),
      shadow(display_shadow), shadow_width(5), relief(glow_eRelief_Up),
      shadow_contrast(2), disable_shadow(0), gradient(glow_eGradient_No),
      gradient_contrast(4), disable_gradient(0), fixposition(0)
{
  strcpy(n_name, name);
  pzero.nav_zoom();
  strcpy(last_group, "");

  if (ctx->grid_on) {
    double x_grid, y_grid;

    ctx->find_grid(ll.x, ll.y, &x_grid, &y_grid);
    ll.posit(x_grid, y_grid);
    ctx->find_grid(ur.x, ur.y, &x_grid, &y_grid);
    ur.posit(x_grid, y_grid);
  }
  if (!nodraw)
    ctx->set_dirty();
  get_node_borders();
}

GrowRectRounded::~GrowRectRounded()
{
  ctx->object_deleted(this);
  ctx->set_dirty();
  if (hot)
    ctx->gdraw->set_cursor(ctx->mw.window, glow_eDrawCursor_Normal);
}

void GrowRectRounded::move(double delta_x, double delta_y, int grid)
{
  if (fixposition)
    return;

  if (grid) {
    double x_grid, y_grid;

    /* Move to closest grid point */
    ctx->find_grid(x_left + delta_x / ctx->mw.zoom_factor_x,
        y_low + delta_y / ctx->mw.zoom_factor_y, &x_grid, &y_grid);
    trf.move(x_grid - x_left, y_grid - y_low);
    get_node_borders();
  } else {
    double dx = delta_x / ctx->mw.zoom_factor_x;
    double dy = delta_y / ctx->mw.zoom_factor_y;
    trf.move(dx, dy);
    x_right += dx;
    x_left += dx;
    y_high += dy;
    y_low += dy;
  }
  ctx->set_dirty();
}

int GrowRectRounded::event_handler(glow_eEvent event, double fx, double fy)
{
  // Convert from global to local coordinates
  glow_sPoint p = trf.reverse(fx, fy);
  return (MIN(ll.x, ur.x) <= p.x && p.x <= MAX(ll.x, ur.x)
      && MIN(ll.y, ur.y) <= p.y && p.y <= MAX(ll.y, ur.y));
}

int GrowRectRounded::event_handler(glow_eEvent event, int x, int y, double fx, double fy)
{
  int sts = 0;
  if (event == ctx->event_move_node) {
    sts = event_handler(event, fx, fy);
    if (sts) {
      /* Register node for potential movement */
      ctx->move_insert(this);
    }
    return sts;
  }
  switch (event) {
  case glow_eEvent_CursorMotion: {
    if (ctx->hot_mode == glow_eHotMode_TraceAction)
      sts = 0;
    else if (ctx->hot_found)
      sts = 0;
    else {
      sts = event_handler(event, fx, fy);
      if (sts)
        ctx->hot_found = 1;
    }
    if (sts && !hot
        && !(ctx->node_movement_active || ctx->node_movement_paste_active)) {
      ctx->gdraw->set_cursor(ctx->mw.window, glow_eDrawCursor_CrossHair);
      set_hot(1);
    }
    if (!sts && hot) {
      if (!ctx->hot_found)
        ctx->gdraw->set_cursor(ctx->mw.window, glow_eDrawCursor_Normal);
      set_hot(0);
    }
    break;
  }
  default:
    sts = event_handler(event, fx, fy);
  }
  if (sts)
    ctx->register_callback_object(glow_eObjectType_Node, this);
  return sts;
}

void GrowRectRounded::save(std::ofstream& fp, glow_eSaveMode mode)
{
  char* s;

  fp << int(glow_eSave_GrowRectRounded) << '\n';
  fp << int(glow_eSave_GrowRectRounded_n_name) << FSPACE << n_name << '\n';
  fp << int(glow_eSave_GrowRectRounded_x_right) << FSPACE << x_right << '\n';
  fp << int(glow_eSave_GrowRectRounded_x_left) << FSPACE << x_left << '\n';
  fp << int(glow_eSave_GrowRectRounded_y_high) << FSPACE << y_high << '\n';
  fp << int(glow_eSave_GrowRectRounded_y_low) << FSPACE << y_low << '\n';
  fp << int(glow_eSave_GrowRectRounded_original_border_drawtype) << FSPACE
     << int(original_border_drawtype) << '\n';
  fp << int(glow_eSave_GrowRectRounded_original_fill_drawtype) << FSPACE
     << int(original_fill_drawtype) << '\n';
  fp << int(glow_eSave_GrowRectRounded_fill_drawtype) << FSPACE
     << int(fill_drawtype) << '\n';
  fp << int(glow_eSave_GrowRectRounded_border) << FSPACE << border << '\n';
  fp << int(glow_eSave_GrowRectRounded_round_amount) << FSPACE << round_amount
     << '\n';
  fp << int(glow_eSave_GrowRectRounded_shadow_width) << FSPACE << shadow_width
     << '\n';
  fp << int(glow_eSave_GrowRectRounded_shadow) << FSPACE << shadow << '\n';
  fp << int(glow_eSave_GrowRectRounded_shadow_contrast) << FSPACE
     << shadow_contrast << '\n';
  fp << int(glow_eSave_GrowRectRounded_relief) << FSPACE << int(relief) << '\n';
  fp << int(glow_eSave_GrowRectRounded_disable_shadow) << FSPACE
     << disable_shadow << '\n';
  fp << int(glow_eSave_GrowRectRounded_gradient) << FSPACE << int(gradient)
     << '\n';
  fp << int(glow_eSave_GrowRectRounded_gradient_contrast) << FSPACE
     << gradient_contrast << '\n';
  fp << int(glow_eSave_GrowRectRounded_disable_gradient) << FSPACE
     << disable_gradient << '\n';
  fp << int(glow_eSave_GrowRectRounded_fixposition) << FSPACE << fixposition
     << '\n';
  fp << int(glow_eSave_GrowRectRounded_dynamicsize) << FSPACE << dynamicsize
     << '\n';
  fp << int(glow_eSave_GrowRectRounded_dynamic) << '\n';
  if (dynamic) {
    fp << "\"";
    for (s = dynamic; *s; s++) {
      if (*s == '"')
        fp << "\\";
      fp << *s;
    }
    fp << "\"\n";
  }
  fp << int(glow_eSave_GrowRectRounded_rect_part) << '\n';
  GlowRect::save(fp, mode);
  fp << int(glow_eSave_GrowRectRounded_trf) << '\n';
  trf.save(fp, mode);
  fp << int(glow_eSave_End) << '\n';
}

void GrowRectRounded::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowRectRounded: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowRectRounded:
      break;
    case glow_eSave_GrowRectRounded_n_name:
      fp.get();
      fp.getline(n_name, sizeof(n_name));
      break;
    case glow_eSave_GrowRectRounded_x_right:
      fp >> x_right;
      break;
    case glow_eSave_GrowRectRounded_x_left:
      fp >> x_left;
      break;
    case glow_eSave_GrowRectRounded_y_high:
      fp >> y_high;
      break;
    case glow_eSave_GrowRectRounded_y_low:
      fp >> y_low;
      break;
    case glow_eSave_GrowRectRounded_original_border_drawtype:
      fp >> tmp;
      original_border_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowRectRounded_original_fill_drawtype:
      fp >> tmp;
      original_fill_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowRectRounded_fill_drawtype:
      fp >> tmp;
      fill_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowRectRounded_border:
      fp >> border;
      break;
    case glow_eSave_GrowRectRounded_round_amount:
      fp >> round_amount;
      break;
    case glow_eSave_GrowRectRounded_shadow:
      fp >> shadow;
      break;
    case glow_eSave_GrowRectRounded_shadow_width:
      fp >> shadow_width;
      break;
    case glow_eSave_GrowRectRounded_shadow_contrast:
      fp >> shadow_contrast;
      break;
    case glow_eSave_GrowRectRounded_relief:
      fp >> tmp;
      relief = (glow_eRelief)tmp;
      break;
    case glow_eSave_GrowRectRounded_disable_shadow:
      fp >> disable_shadow;
      break;
    case glow_eSave_GrowRectRounded_gradient:
      fp >> tmp;
      gradient = (glow_eGradient)tmp;
      break;
    case glow_eSave_GrowRectRounded_gradient_contrast:
      fp >> gradient_contrast;
      break;
    case glow_eSave_GrowRectRounded_fixposition:
      fp >> fixposition;
      break;
    case glow_eSave_GrowRectRounded_disable_gradient:
      fp >> disable_gradient;
      break;
    case glow_eSave_GrowRectRounded_dynamicsize:
      fp >> dynamicsize;
      break;
    case glow_eSave_GrowRectRounded_dynamic:
      fp.getline(dummy, sizeof(dummy));
      if (dynamicsize) {
        dynamic = (char*)calloc(1, dynamicsize);
        fp.get();
        for (int j = 0; j < dynamicsize; j++) {
          char c;
          if ((c = fp.get()) == '"') {
            if (dynamic[j - 1] == '\\')
              j--;
            else {
              dynamic[j] = 0;
              break;
            }
          }
          dynamic[j] = c;
        }
        fp.getline(dummy, sizeof(dummy));
      }
      break;
    case glow_eSave_GrowRectRounded_rect_part:
      GlowRect::open(fp);
      break;
    case glow_eSave_GrowRectRounded_trf:
      trf.open(fp);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowRectRounded:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

void GrowRectRounded::draw(GlowWind* w, int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;

  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * w->zoom_factor_x - w->offset_x + 1 >= ll_x
      && x_left * w->zoom_factor_x - w->offset_x <= ur_x
      && y_high * w->zoom_factor_y - w->offset_y + 1 >= ll_y
      && y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);
  }
}

void GrowRectRounded::draw(
    GlowWind* w, int* ll_x, int* ll_y, int* ur_x, int* ur_y)
{
  int tmp;
  int obj_ur_x = int(x_right * w->zoom_factor_x) - w->offset_x;
  int obj_ll_x = int(x_left * w->zoom_factor_x) - w->offset_x;
  int obj_ur_y = int(y_high * w->zoom_factor_y) - w->offset_y;
  int obj_ll_y = int(y_low * w->zoom_factor_y) - w->offset_y;

  if (*ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if (*ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (obj_ur_x >= *ll_x && obj_ll_x <= *ur_x && obj_ur_y >= *ll_y
      && obj_ll_y <= *ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);

    // Increase the redraw area
    if (obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if (obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if (obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if (obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
}

void GrowRectRounded::set_highlight(int on)
{
  if (highlight != on) {
    highlight = on;
    ctx->set_dirty();
  }
}

void GrowRectRounded::select_region_insert(double ll_x, double ll_y,
    double ur_x, double ur_y, glow_eSelectPolicy select_policy)
{
  if (select_policy == glow_eSelectPolicy_Surround) {
    if (x_left > ll_x && x_right < ur_x && y_high < ur_y && y_low > ll_y)
      ctx->select_insert(this);
  } else {
    if (x_right > ll_x && x_left < ur_x && y_low < ur_y && y_high > ll_y)
      ctx->select_insert(this);
  }
}

void GrowRectRounded::set_dynamic(char* code, int size)
{
  if (!dynamic) {
    dynamic = (char*)calloc(1, size + 1);
    dynamicsize = size + 1;
  } else if (dynamicsize < size + 1) {
    free(dynamic);
    dynamic = (char*)calloc(1, size + 1);
    dynamicsize = size + 1;
  }
  strncpy(dynamic, code, size + 1);
}

void GrowRectRounded::exec_dynamic()
{
  if (dynamicsize && !streq(dynamic, ""))
    ctx->dynamic_cb(this, dynamic, glow_eDynamicType_Object);
}

void GrowRectRounded::set_position(double x, double y)
{
  if (feq(trf.a13, x) && feq(trf.a23, y))
    return;

  trf.posit(x, y);
  get_node_borders();
  ctx->set_dirty();
}

void GrowRectRounded::set_scale(
    double scale_x, double scale_y, double x0, double y0, glow_eScaleType type)
{
  if (trf.s.a11 && trf.s.a22
      && fabs(scale_x - trf.a11 / trf.s.a11) < FLT_EPSILON
      && fabs(scale_y - trf.a22 / trf.s.a22) < FLT_EPSILON)
    return;

  switch (type) {
  case glow_eScaleType_LowerLeft:
    x0 = x_left;
    y0 = y_low;
    break;
  case glow_eScaleType_LowerRight:
    x0 = x_right;
    y0 = y_low;
    break;
  case glow_eScaleType_UpperRight:
    x0 = x_right;
    y0 = y_high;
    break;
  case glow_eScaleType_UpperLeft:
    x0 = x_left;
    y0 = y_high;
    break;
  case glow_eScaleType_FixPoint:
    break;
  case glow_eScaleType_Center:
    x0 = (x_left + x_right) / 2;
    y0 = (y_low + y_high) / 2;
    break;
  default:;
  }

  double old_x_left = x_left;
  double old_x_right = x_right;
  double old_y_low = y_low;
  double old_y_high = y_high;
  trf.scale_from_stored(scale_x, scale_y, x0, y0);
  get_node_borders();

  switch (type) {
  case glow_eScaleType_LowerLeft:
    x_left = old_x_left;
    y_low = old_y_low;
    break;
  case glow_eScaleType_LowerRight:
    x_right = old_x_right;
    y_low = old_y_low;
    break;
  case glow_eScaleType_UpperRight:
    x_right = old_x_right;
    y_high = old_y_high;
    break;
  case glow_eScaleType_UpperLeft:
    x_left = old_x_left;
    y_high = old_y_high;
    break;
  case glow_eScaleType_FixPoint:
    break;
  case glow_eScaleType_Center:
    x0 = (x_left + x_right) / 2;
    y0 = (y_low + y_high) / 2;
    break;
  default:;
  }
  ctx->set_dirty();
}

void GrowRectRounded::set_rotation(
    double angle, double x0, double y0, glow_eRotationPoint type)
{
  if (fabs(angle - trf.rotation + trf.s.rotation) < FLT_EPSILON)
    return;

  switch (type) {
  case glow_eRotationPoint_LowerLeft:
    x0 = x_left;
    y0 = y_low;
    break;
  case glow_eRotationPoint_LowerRight:
    x0 = x_right;
    y0 = y_low;
    break;
  case glow_eRotationPoint_UpperRight:
    x0 = x_right;
    y0 = y_high;
    break;
  case glow_eRotationPoint_UpperLeft:
    x0 = x_left;
    y0 = y_high;
    break;
  case glow_eRotationPoint_Center:
    x0 = (x_left + x_right) / 2;
    y0 = (y_high + y_low) / 2;
    break;
  default:;
  }

  trf.rotate_from_stored(angle, x0, y0);
  get_node_borders();
  ctx->set_dirty();
}

void GrowRectRounded::draw(GlowWind* w, GlowTransform* t, int highlight,
    int hot, void* node, void* colornode)
{
  if (!(display_level & ctx->display_level))
    return;
  hot = (w == &ctx->navw) ? 0 : hot;
  int chot = 0;
  if (hot && ctx->environment != glow_eEnv_Development) {
    if (ctx->hot_indication == glow_eHotIndication_No)
      hot = 0;
    else if (ctx->hot_indication == glow_eHotIndication_DarkColor) {
      chot = hot;
      hot = 0;
    } else if (ctx->hot_indication == glow_eHotIndication_LightColor) {
      chot = -hot;
      hot = 0;
    }
  }
  int idx;
  glow_eDrawType drawtype;

  if (fix_line_width) {
    idx = line_width;
    idx += hot;
    if (idx < 0) {
      erase(w, t, hot, node);
      return;
    }
  } else {
    if (node && ((GrowNode*)node)->line_width)
      idx = int(
          w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
          - 1);
    else
      idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
    idx += hot;
  }
  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  int amount = ROUND(round_amount / 100 * MIN(ur_x - ll_x, ur_y - ll_y));
  if (fill) {
    int ish = ROUND(shadow_width / 100 * MIN(ur_x - ll_x, ur_y - ll_y));
    int display_shadow
        = ((node && ((GrowNode*)node)->shadow) || shadow) && !disable_shadow;
    glow_eDrawType fillcolor = ctx->get_drawtype(fill_drawtype,
        glow_eDrawType_FillHighlight, highlight, (GrowNode*)colornode, 1);
    glow_eGradient grad = gradient;
    if (gradient == glow_eGradient_No
        && (node && ((GrowNode*)node)->gradient != glow_eGradient_No)
        && !disable_gradient)
      grad = ((GrowNode*)node)->gradient;

    if (!display_shadow || ish == 0) {
      if (grad == glow_eGradient_No) {
        if (chot)
          drawtype = GlowColor::shift_drawtype(fillcolor, chot, 0);
        else
          drawtype = fillcolor;

        ctx->gdraw->rect(ll_x, ll_y + amount, ur_x - ll_x,
            ur_y - ll_y - 2 * amount, drawtype, 1, 0);
        ctx->gdraw->rect(ll_x + amount, ll_y, ur_x - ll_x - 2 * amount, amount,
            drawtype, 1, 0);
        ctx->gdraw->rect(ll_x + amount, ur_y - amount, ur_x - ll_x - 2 * amount,
            amount, drawtype, 1, 0);
        ctx->gdraw->arc(ll_x, ll_y, 2 * amount, 2 * amount, 90, 90, drawtype,
            1, 0);
        ctx->gdraw->arc(ll_x, ur_y - 2 * amount, 2 * amount, 2 * amount, 180,
            90, drawtype, 1, 0);
        ctx->gdraw->arc(ur_x - 2 * amount, ur_y - 2 * amount, 2 * amount,
            2 * amount, 270, 90, drawtype, 1, 0);
        ctx->gdraw->arc(ur_x - 2 * amount, ll_y, 2 * amount, 2 * amount, 0, 90,
            drawtype, 1, 0);
      } else {
        glow_eDrawType f1, f2;
        if (gradient_contrast >= 0) {
          f2 = GlowColor::shift_drawtype(
              fillcolor, -gradient_contrast / 2 + chot, 0);
          f1 = GlowColor::shift_drawtype(
              fillcolor, int(float(gradient_contrast) / 2 + 0.6) + chot, 0);
        } else {
          f2 = GlowColor::shift_drawtype(
              fillcolor, -int(float(gradient_contrast) / 2 - 0.6) + chot, 0);
          f1 = GlowColor::shift_drawtype(
              fillcolor, gradient_contrast / 2 + chot, 0);
        }

        ctx->gdraw->gradient_fill_rectrounded(ll_x, ll_y, ur_x - ll_x,
            ur_y - ll_y, amount, fillcolor, f1, f2,
            ctx->gdraw->gradient_rotate(tmp.rotation, grad));
      }
    } else {
      int drawtype_incr = shadow_contrast;
      if (relief == glow_eRelief_Down)
        drawtype_incr = -shadow_contrast;

      // Draw light shadow
      drawtype = ctx->shift_drawtype(
          fillcolor, -drawtype_incr + chot, (GrowNode*)colornode);
      ctx->gdraw->rect(
          ll_x + amount, ll_y, ur_x - ll_x - 2 * amount, ish, drawtype, 1, 0);
      ctx->gdraw->rect(
          ll_x, ll_y + amount, ish, ur_y - ll_y - 2 * amount, drawtype, 1, 0);
      ctx->gdraw->arc(
          ll_x, ll_y, 2 * amount, 2 * amount, 90, 90, drawtype, 1, 0);
      ctx->gdraw->arc(ll_x, ur_y - 2 * amount, 2 * amount, 2 * amount, 180, 45,
          drawtype, 1, 0);
      ctx->gdraw->arc(ur_x - 2 * amount, ll_y, 2 * amount, 2 * amount, 45, 45,
          drawtype, 1, 0);
      // Draw dark shadow
      drawtype = ctx->shift_drawtype(
          fillcolor, drawtype_incr + chot, (GrowNode*)colornode);
      ctx->gdraw->rect(ll_x + amount, ur_y - ish, ur_x - ll_x - 2 * amount,
          ish, drawtype, 1, 0);
      ctx->gdraw->rect(ur_x - ish, ll_y + amount, ish,
          ur_y - ll_y - 2 * amount, drawtype, 1, 0);
      ctx->gdraw->arc(ll_x, ur_y - 2 * amount, 2 * amount, 2 * amount, 225, 45,
          drawtype, 1, 0);
      ctx->gdraw->arc(ur_x - 2 * amount, ll_y, 2 * amount, 2 * amount, 0, 45,
          drawtype, 1, 0);
      ctx->gdraw->arc(ur_x - 2 * amount, ur_y - 2 * amount, 2 * amount,
          2 * amount, 270, 90, drawtype, 1, 0);

      if (grad == glow_eGradient_No) {
        if (chot)
          drawtype = GlowColor::shift_drawtype(fillcolor, chot, 0);
        else
          drawtype = fillcolor;

        if (amount > ish) {
          ctx->gdraw->rect(ll_x + ish, ll_y + amount,
              ur_x - ll_x - 2 * ish, ur_y - ll_y - 2 * amount, drawtype, 1, 0);
          ctx->gdraw->rect(ll_x + amount, ll_y + ish,
              ur_x - ll_x - 2 * amount, amount - ish, drawtype, 1, 0);
          ctx->gdraw->rect(ll_x + amount, ur_y - amount,
              ur_x - ll_x - 2 * amount, amount - ish, drawtype, 1, 0);
          ctx->gdraw->arc(ll_x + ish, ll_y + ish, 2 * amount - 2 * ish,
              2 * amount - 2 * ish, 90, 90, drawtype, 1, 0);
          ctx->gdraw->arc(ll_x + ish, ur_y - 2 * amount + ish,
              2 * amount - 2 * ish, 2 * amount - 2 * ish, 180, 90, drawtype, 1,
              0);
          ctx->gdraw->arc(ur_x - 2 * amount + ish, ur_y - 2 * amount + ish,
              2 * amount - 2 * ish, 2 * amount - 2 * ish, 270, 90, drawtype, 1,
              0);
          ctx->gdraw->arc(ur_x - 2 * amount + ish, ll_y + ish,
              2 * amount - 2 * ish, 2 * amount - 2 * ish, 0, 90, drawtype, 1,
              0);
        } else {
          ctx->gdraw->rect(ll_x + amount, ll_y + amount,
              ur_x - ll_x - 2 * amount, ur_y - ll_y - 2 * amount, drawtype, 1, 0);
        }
      } else {
        glow_eDrawType f1, f2;
        if (gradient_contrast >= 0) {
          f2 = GlowColor::shift_drawtype(
              fillcolor, -gradient_contrast / 2 + chot, 0);
          f1 = GlowColor::shift_drawtype(
              fillcolor, int(float(gradient_contrast) / 2 + 0.6) + chot, 0);
        } else {
          f2 = GlowColor::shift_drawtype(
              fillcolor, -int(float(gradient_contrast) / 2 - 0.6) + chot, 0);
          f1 = GlowColor::shift_drawtype(
              fillcolor, gradient_contrast / 2 + chot, 0);
        }

        ctx->gdraw->gradient_fill_rectrounded(ll_x + ish, ll_y + ish,
            ur_x - ll_x - 2 * ish, ur_y - ll_y - 2 * ish, amount - ish,
            fillcolor, f1, f2, ctx->gdraw->gradient_rotate(tmp.rotation, grad));
      }
    }
  }
  if (border || !fill) {
    drawtype = ctx->get_drawtype(draw_type, glow_eDrawType_LineHighlight,
        highlight, (GrowNode*)colornode, 0);
    int c = 0;
    ctx->gdraw->line(
        ll_x + amount, ll_y, ur_x - amount, ll_y, drawtype, idx, 0);
    ctx->gdraw->line(
        ll_x, ll_y - c + amount, ll_x, ur_y - c - amount, drawtype, idx, 0);
    ctx->gdraw->line(
        ll_x + amount, ur_y, ur_x - amount, ur_y, drawtype, idx, 0);
    ctx->gdraw->line(
        ur_x - c, ll_y + amount, ur_x - c, ur_y - amount, drawtype, idx, 0);
    ctx->gdraw->arc(
        ll_x, ll_y, 2 * amount, 2 * amount, 90, 90, drawtype, 0, idx);
    ctx->gdraw->arc(ll_x, ur_y - 2 * amount, 2 * amount, 2 * amount, 180, 90,
        drawtype, 0, idx);
    ctx->gdraw->arc(ur_x - 2 * amount, ur_y - 2 * amount, 2 * amount,
        2 * amount, 270, 90, drawtype, 0, idx);
    ctx->gdraw->arc(ur_x - 2 * amount, ll_y, 2 * amount, 2 * amount, 0, 90,
        drawtype, 0, idx);
  }
}

void GrowRectRounded::erase(GlowWind* w, GlowTransform* t, int hot, void* node)
{
  if (!(display_level & ctx->display_level))
    return;
  hot = (w == &ctx->navw) ? 0 : hot;
  if (hot && ctx->environment != glow_eEnv_Development
      && ctx->hot_indication != glow_eHotIndication_LineWidth)
    hot = 0;

  int idx;
  if (fix_line_width) {
    idx = line_width;
    idx += hot;
    if (idx < 0)
      return;
  } else {
    if (node && ((GrowNode*)node)->line_width)
      idx = int(
          w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
          - 1);
    else
      idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
    idx += hot;
  }
  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  int amount = ROUND(round_amount / 100 * MIN(ur_x - ll_x, ur_y - ll_y));
  if (border || !fill) {
    ctx->gdraw->line(ll_x + amount, ll_y, ur_x - amount, ll_y,
        glow_eDrawType_LineErase, idx);
    ctx->gdraw->line(ll_x, ll_y + amount, ll_x, ur_y - amount,
        glow_eDrawType_LineErase, idx);
    ctx->gdraw->line(ll_x + amount, ur_y, ur_x - amount, ur_y,
        glow_eDrawType_LineErase, idx);
    ctx->gdraw->line(ur_x, ll_y + amount, ur_x, ur_y - amount,
        glow_eDrawType_LineErase, idx);
    ctx->gdraw->arc(ll_x, ll_y, 2 * amount, 2 * amount, 90, 90,
        glow_eDrawType_LineErase, 0, idx);
    ctx->gdraw->arc(ll_x, ur_y - 2 * amount, 2 * amount, 2 * amount, 180, 90,
        glow_eDrawType_LineErase, 0, idx);
    ctx->gdraw->arc(ur_x - 2 * amount, ur_y - 2 * amount, 2 * amount,
        2 * amount, 270, 90, glow_eDrawType_LineErase, 0, idx);
    ctx->gdraw->arc(ur_x - 2 * amount, ll_y, 2 * amount, 2 * amount, 0, 90,
        glow_eDrawType_LineErase, 0, idx);
  }
  if (fill)
    ctx->gdraw->rect(
        ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, glow_eDrawType_LineErase, 1, 0);
}

void GrowRectRounded::get_borders(GlowTransform* t, double* x_right,
    double* x_left, double* y_high, double* y_low)
{
  if (display_level != glow_mDisplayLevel_1)
    return;

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  *x_left = MIN(*x_left, MIN(p1.x, p2.x));
  *x_right = MAX(*x_right, MAX(p1.x, p2.x));
  *y_low = MIN(*y_low, MIN(p1.y, p2.y));
  *y_high = MAX(*y_high, MAX(p1.y, p2.y));
}

void GrowRectRounded::set_transform(GlowTransform* t)
{
  trf.set(*t * trf);
  get_node_borders();
}

void GrowRectRounded::set_border(int borderval)
{
  if (border != borderval) {
    border = borderval;
    ctx->set_dirty();
  }
}

int GrowRectRounded::draw_annot_background(
    GlowTransform* t, void* node, double x, double y)
{
  if (fill) {
    draw(&ctx->mw, t, 0, 0, node, node);
    return 1;
  }
  return 0;
}

int GrowRectRounded::get_annot_background(
    GlowTransform* t, void* node, glow_eDrawType* background)
{
  if (fill) {
    *background = ctx->get_drawtype(
        fill_drawtype, glow_eDrawType_FillHighlight, 0, (GrowNode*)node, 1);
    return 1;
  }
  return 0;
}

void GrowRectRounded::align(double x, double y, glow_eAlignDirection direction)
{
  if (fixposition)
    return;

  double dx, dy;
  switch (direction) {
  case glow_eAlignDirection_CenterVert:
    dx = x - (x_right + x_left) / 2;
    dy = 0;
    break;
  case glow_eAlignDirection_CenterHoriz:
    dx = 0;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_CenterCenter:
    dx = x - (x_right + x_left) / 2;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_Right:
    dx = x - x_right;
    dy = 0;
    break;
  case glow_eAlignDirection_Left:
    dx = x - x_left;
    dy = 0;
    break;
  case glow_eAlignDirection_Up:
    dx = 0;
    dy = y - y_high;
    break;
  case glow_eAlignDirection_Down:
    dx = 0;
    dy = y - y_low;
    break;
  }
  trf.move(dx, dy);
  x_right += dx;
  x_left += dx;
  y_high += dy;
  y_low += dy;
  ctx->set_dirty();
}

void GrowRectRounded::export_javabean(GlowTransform* t, void* node,
    glow_eExportPass pass, int* shape_cnt, int node_cnt, int in_nc,
    std::ofstream& fp)
{
  if (!(display_level & ctx->display_level))
    return;
  int idx;
  int gc1, gc2;

  if (fix_line_width) {
    idx = line_width;
    idx += hot;
    if (idx < 0) {
      erase(&ctx->mw, t, hot, node);
      return;
    }
  } else {
    if (node && ((GrowNode*)node)->line_width)
      idx = int(ctx->mw.zoom_factor_y / ctx->mw.base_zoom_factor
              * ((GrowNode*)node)->line_width
          - 1);
    else
      idx = int(
          ctx->mw.zoom_factor_y / ctx->mw.base_zoom_factor * line_width - 1);
    idx += hot;
  }
  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
  p1.y = p1.y * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
  p2.x = p2.x * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
  p2.y = p2.y * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
  double ll_x = MIN(p1.x, p2.x);
  double ur_x = MAX(p1.x, p2.x);
  double ll_y = MIN(p1.y, p2.y);
  double ur_y = MAX(p1.y, p2.y);

  double amount = round_amount / 100 * MIN(ur_x - ll_x, ur_y - ll_y);
  double ish;
  if (!disable_shadow)
    ish = shadow_width / 100 * MIN(ur_x - ll_x, ur_y - ll_y);
  else
    ish = 0;

  int drawtype_incr = shadow_contrast;
  if (relief == glow_eRelief_Down)
    drawtype_incr = -shadow_contrast;

  if (gradient_contrast >= 0) {
    gc1 = gradient_contrast / 2;
    gc2 = -int(float(gradient_contrast) / 2 + 0.6);
  } else {
    gc1 = int(float(gradient_contrast) / 2 - 0.6);
    gc2 = -gradient_contrast / 2;
  }

  ctx->export_jbean->rectrounded(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, fill,
      border || !fill, fill_drawtype, draw_type, idx, amount, ish, shadow,
      drawtype_incr, gradient, gc1, gc2, pass, shape_cnt, node_cnt, fp);
}

void GrowRectRounded::flip(double x0, double y0, glow_eFlipDirection dir)
{
  switch (dir) {
  case glow_eFlipDirection_Horizontal:
    trf.store();
    set_scale(1, -1, x0, y0, glow_eScaleType_FixPoint);
    break;
  case glow_eFlipDirection_Vertical:
    trf.store();
    set_scale(-1, 1, x0, y0, glow_eScaleType_FixPoint);
    break;
  }
}

void GrowRectRounded::convert(glow_eConvert version)
{
  switch (version) {
  case glow_eConvert_V34: {
    // Conversion of colors
    draw_type = GlowColor::convert(version, draw_type);
    original_border_drawtype
        = GlowColor::convert(version, original_border_drawtype);
    original_fill_drawtype
        = GlowColor::convert(version, original_fill_drawtype);
    fill_drawtype = GlowColor::convert(version, fill_drawtype);

    break;
  }
  }
}
