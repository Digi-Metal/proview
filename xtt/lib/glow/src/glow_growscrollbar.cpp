/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "glow_growscrollbar.h"
#include "glow_grownode.h"
#include "glow_draw.h"

GrowScrollBar::GrowScrollBar(GrowCtx* glow_ctx, const char* name, double x,
    double y, double w, double h, glow_eDir dir, glow_eDrawType border_d_type,
    int line_w, glow_mDisplayLevel display_lev, glow_eDrawType fill_d_type,
    glow_eDrawType bar_d_type, int nodraw)
    : GrowRect(glow_ctx, name, x, y, w, h, border_d_type, line_w, 0,
          display_lev, 1, 0, 0, fill_d_type, nodraw),
      max_value(100), min_value(0), bar_value(35), bar_length(10), user_data(0),
      direction(dir), movement_active(0), start_pos(0), start_value(0),
      callback_userdata(0), value_changed_cb(0), bar_color(bar_d_type)
{
  if (!nodraw)
    ctx->set_dirty();
}

GrowScrollBar::~GrowScrollBar()
{
  ctx->set_dirty();
}

void GrowScrollBar::save(std::ofstream& fp, glow_eSaveMode mode)
{
}

void GrowScrollBar::open(std::ifstream& fp)
{
}

void GrowScrollBar::set_highlight(int on)
{
  if (highlight != on) {
    highlight = on;
    ctx->set_dirty();
  }
}

void GrowScrollBar::draw(GlowWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  if (!(display_level & ctx->display_level))
    return;
  hot = (w == &ctx->navw) ? 0 : hot;
  int idx;

  idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;

  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  glow_eDrawType fdrawtype = ctx->get_drawtype(fill_drawtype,
      glow_eDrawType_FillHighlight, highlight, (GrowNode*)colornode, 1);
  glow_eDrawType bdrawtype = ctx->get_drawtype(draw_type,
      glow_eDrawType_LineHighlight, highlight, (GrowNode*)colornode, 0);
  glow_eDrawType shift_drawtype;

  ctx->gdraw->rect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, fdrawtype, 1, 0);
  if (shadow) {
    shift_drawtype = ctx->shift_drawtype(fill_drawtype, 2, 0); // Dark
    ctx->gdraw->line(
        ll_x + 1, ll_y + 1, ll_x + 1, ur_y - 1, shift_drawtype, 0, 0);
    ctx->gdraw->line(
        ll_x + 1, ll_y + 1, ur_x - 1, ll_y + 1, shift_drawtype, 0, 0);
    shift_drawtype = ctx->shift_drawtype(fill_drawtype, -2, 0); // Light
    ctx->gdraw->line(
        ll_x + 1, ur_y - 1, ur_x - 1, ur_y - 1, shift_drawtype, 0, 0);
    ctx->gdraw->line(
        ur_x - 1, ll_y + 1, ur_x - 1, ur_y - 1, shift_drawtype, 0, 0);
  }

  if (!feq(max_value, min_value)) {
    int x0, y0, width, height;

    switch (direction) {
    case glow_eDir_Vertical:
      height = int(bar_length / (max_value - min_value) * (ur_y - ll_y));
      height = MAX(0, MIN(height, ur_y - ll_y));
      width = ur_x - ll_x;
      x0 = ll_x;
      y0 = ll_y + int((bar_value - min_value) / (max_value - min_value)
                      * (ur_y - ll_y));
      break;
    case glow_eDir_Horizontal:
      width = int(bar_length / (max_value - min_value) * (ur_x - ll_x));
      width = MAX(0, MIN(width, ur_x - ll_x));
      height = ur_y - ll_y;
      x0 = ll_x + int((bar_value - min_value) / (max_value - min_value)
                      * (ur_x - ll_x));
      y0 = ll_y;
      break;
    }

    ctx->gdraw->rect(x0, y0, width, height, bar_color, 1, 0);
    if (shadow) {
      shift_drawtype = ctx->shift_drawtype(bar_color, -2, 0); // Light
      ctx->gdraw->line(
          x0 + 1, y0 + 1, x0 + 1, y0 + height - 1, shift_drawtype, 0, 0);
      ctx->gdraw->line(
          x0 + 1, y0 + 1, x0 + width - 1, y0 + 1, shift_drawtype, 0, 0);
      shift_drawtype = ctx->shift_drawtype(bar_color, 2, 0); // Dark
      ctx->gdraw->line(x0 + 1, y0 + height - 1, x0 + width - 1,
          y0 + height - 1, shift_drawtype, 0, 0);
      ctx->gdraw->line(x0 + width - 1, y0 + 1, x0 + width - 1,
          y0 + height - 1, shift_drawtype, 0, 0);
    }
    ctx->gdraw->rect(x0, y0, width, height, bdrawtype, 0, idx);
  }

  ctx->gdraw->rect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, bdrawtype, 0, idx);
}

void GrowScrollBar::erase(GlowWind* w, GlowTransform* t, int hot, void* node)
{
  if (!(display_level & ctx->display_level))
    return;
  hot = (w == &ctx->navw) ? 0 : hot;
  int idx;

  idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;

  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  int ll_x = ROUND(MIN(p1.x, p2.x));
  int ur_x = ROUND(MAX(p1.x, p2.x));
  int ll_y = ROUND(MIN(p1.y, p2.y));
  int ur_y = ROUND(MAX(p1.y, p2.y));

  ctx->gdraw->rect(
      ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, glow_eDrawType_LineErase, 0, idx);
  ctx->gdraw->rect(
      ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, glow_eDrawType_LineErase, 1, 0);
}

double GrowScrollBar::set_value(double value, double length)
{
  bar_value = value;
  if (!feq(length, 0.0))
    bar_length = length;

  bar_value = CLAMP(bar_value, min_value, max_value - bar_length);
  ctx->set_dirty();
  return bar_value;
}

void GrowScrollBar::set_range(double min, double max)
{
  max_value = max;
  min_value = min;
  ctx->set_dirty();
}

void GrowScrollBar::export_javabean(GlowTransform* t, void* node,
    glow_eExportPass pass, int* shape_cnt, int node_cnt, int in_nc,
    std::ofstream& fp)
{
}

void GrowScrollBar::convert(glow_eConvert version)
{
  switch (version) {
  case glow_eConvert_V34: {
    break;
  }
  }
}

int GrowScrollBar::event_handler(glow_eEvent event, int x, int y, double fx, double fy)
{
  double ll_x, ur_x, ll_y, ur_y;

  ll_x = MIN(ll.x, ur.x);
  ur_x = MAX(ll.x, ur.x);
  ll_y = MIN(ll.y, ur.y);
  ur_y = MAX(ll.y, ur.y);

  if (!movement_active
      && !(ll_x <= fx && fx <= ur_x && ll_y <= fy && fy <= ur_y))
    return 0;

  if (event == glow_eEvent_ButtonMotion && !movement_active)
    return 0;

  if (feq(min_value, max_value))
    return 1;

  switch (event) {
  case glow_eEvent_MB1Down:
    switch (direction) {
    case glow_eDir_Vertical:
      if (ll_y
                  + (bar_value - min_value) / (max_value - min_value)
                      * (ur_y - ll_y)
              <= fy
          && fy <= ll_y
                  + (bar_value - min_value + bar_length)
                      / (max_value - min_value) * (ur_y - ll_y)) {
        start_pos = fy;
        start_value = bar_value;
        movement_active = 1;
        ctx->gdraw->set_click_sensitivity(glow_mSensitivity_MB1Press);
      }
      break;
    case glow_eDir_Horizontal:
      if (ll_x
                  + (bar_value - min_value) / (max_value - min_value)
                      * (ur_x - ll_x)
              <= fx
          && fx <= ll_x
                  + (bar_value - min_value + bar_length)
                      / (max_value - min_value) * (ur_x - ll_x)) {
        start_pos = fx;
        start_value = bar_value;
        movement_active = 1;
        ctx->gdraw->set_click_sensitivity(glow_mSensitivity_MB1Press);
      }
      break;
    }
    break;
  case glow_eEvent_MB1Up:
    movement_active = 0;
    break;
  case glow_eEvent_ButtonMotion:
    if (movement_active) {
      if (bar_length >= max_value - min_value)
        break;
      switch (direction) {
      case glow_eDir_Vertical:
        bar_value = start_value
            + (fy - start_pos) / (ur_y - ll_y) * (max_value - min_value);
        break;
      case glow_eDir_Horizontal:
        bar_value = start_value
            + (fx - start_pos) / (ur_x - ll_x) * (max_value - min_value);
        break;
      }
      if (bar_value < min_value)
        bar_value = min_value;
      if (bar_value > max_value - bar_length)
        bar_value = max_value - bar_length;
      (value_changed_cb)(callback_userdata, bar_value);
    }
    break;
  default:;
  }
  return 1;
}
