/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>

#include <iostream>

#include "glow_transform.h"

Matrix& Matrix::set(const Matrix& m) {
  a11 = m.a11;
  a12 = m.a12;
  a13 = m.a13;
  a21 = m.a21;
  a22 = m.a22;
  a23 = m.a23;
  rotation = m.rotation;
  return *this;
}

double Matrix::vertical_scale() {
  return sqrt(a12 * a12 + a22 * a22);
}

Matrix operator*(const Matrix &a, const Matrix &b)
{
  Matrix tmp;
  tmp.a11 = a.a11 * b.a11 + a.a12 * b.a21;
  tmp.a12 = a.a11 * b.a12 + a.a12 * b.a22;
  tmp.a13 = a.a11 * b.a13 + a.a12 * b.a23 + a.a13;
  tmp.a21 = a.a21 * b.a11 + a.a22 * b.a21;
  tmp.a22 = a.a21 * b.a12 + a.a22 * b.a22;
  tmp.a23 = a.a21 * b.a13 + a.a22 * b.a23 + a.a23;
  tmp.rotation = a.rotation + b.rotation;
  return tmp;
}

glow_sPoint operator*(const Matrix &m, const glow_sPoint &p)
{
  return {
      p.x * m.a11 + p.y * m.a12 + m.a13,
      p.x * m.a21 + p.y * m.a22 + m.a23
  };
}

void GlowTransform::scale(double sx, double sy, double x0, double y0)
{
  Matrix s;
  s.a11 = sx;
  s.a22 = sy;
  set(s * *this);

  // In order to scale at a point (x0, y0), we need to
  // 1. Translate the object (-x0, -y0) such that origo is located at (x0, y0)
  // 2. Apply the scaling
  // 3. Translate it back (x0, y0)
  // The lines below is the result of multiplying the matrices inv(t) * s * t
  a13 += x0 * (1 - sx);
  a23 += y0 * (1 - sy);
}

void GlowTransform::rotate(double angle, double x0, double y0)
{
  double sin_a = -1;
  double cos_a = 0;
  if (!(-90.01 < angle && angle < -89.99)) {
    sin_a = sin(angle / 180 * 3.14159);
    cos_a = cos(angle / 180 * 3.14159);
  }

  Matrix r;
  r.a11 = cos_a;
  r.a12 = -sin_a;
  r.a21 = sin_a;
  r.a22 = cos_a;
  r.rotation = angle;
  set(r * *this);

  // In order to rotate around a point (x0, y0), we need to
  // 1. Translate the object (-x0, -y0) such that origo is located at (x0, y0)
  // 2. Apply the rotation
  // 3. Translate it back (x0, y0)
  // The lines below is the result of multiplying the matrices inv(t) * r * t
  a13 += x0 * (1 - cos_a) + y0 * sin_a;
  a23 += y0 * (1 - cos_a) - x0 * sin_a;
}

void GlowTransform::move(double x0, double y0)
{
  a13 += x0;
  a23 += y0;
}

void GlowTransform::move_from_stored(double x0, double y0)
{
  a13 = s.a13 + x0;
  a23 = s.a23 + y0;
}

void GlowTransform::posit(double x0, double y0)
{
  a13 = x0;
  a23 = y0;
}

glow_sPoint GlowTransform::reverse(double x, double y)
{
  if (feq(a11, 0.0) || feq(a12 * a21 - a11 * a22, 0.0)) {
    if (feq(a11, 0.0) && feq(a22, 0.0) && !feq(a12, 0.0) && !feq(a21, 0.0)) {
      return {(x - a13) / a12, (y - a23) / a21};
    } else {
      return {0, 0};
    }
  }
  glow_sPoint r;
  r.y = (a11 * (a23 - y) - a21 * (a13 - x)) / (a12 * a21 - a11 * a22);
  r.x = (x - a12 * r.y - a13) / a11;
  return r;
}

void GlowTransform::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_Transform) << '\n';
  fp << int(glow_eSave_Transform_a11) << FSPACE << a11 << '\n';
  fp << int(glow_eSave_Transform_a12) << FSPACE << a12 << '\n';
  fp << int(glow_eSave_Transform_a13) << FSPACE << a13 << '\n';
  fp << int(glow_eSave_Transform_a21) << FSPACE << a21 << '\n';
  fp << int(glow_eSave_Transform_a22) << FSPACE << a22 << '\n';
  fp << int(glow_eSave_Transform_a23) << FSPACE << a23 << '\n';
  fp << int(glow_eSave_Transform_rotation) << FSPACE << rotation << '\n';
  fp << int(glow_eSave_End) << '\n';
}

void GlowTransform::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GlowTransform: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_Transform:
      break;
    case glow_eSave_Transform_a11:
      fp >> a11;
      break;
    case glow_eSave_Transform_a12:
      fp >> a12;
      break;
    case glow_eSave_Transform_a13:
      fp >> a13;
      break;
    case glow_eSave_Transform_a21:
      fp >> a21;
      break;
    case glow_eSave_Transform_a22:
      fp >> a22;
      break;
    case glow_eSave_Transform_a23:
      fp >> a23;
      break;
    case glow_eSave_Transform_rotation:
      fp >> rotation;
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GlowTransform:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  store();
  stored = false;
}
