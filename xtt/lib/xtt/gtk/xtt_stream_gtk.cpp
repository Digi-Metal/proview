/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#define PWRE_CONF_GST 1

#if defined PWRE_CONF_GST

#include <string.h>
#include "xtt_xnav.h"
  
#include <gtk/gtk.h>
#include <gst/gst.h>
#include <gst/interfaces/xoverlay.h>
  
#include <gdk/gdk.h>
#include <gdk/gdkx.h>

#include "pwr.h"
#include "co_dcli.h"
#include "xtt_stream_gtk.h"  
#include "rt_xnav_msg.h"
#include "cow_wow_gtk.h"

int XttStreamGtk::gst_initialized = 0;
  
/* This function is called when the GUI toolkit creates the physical window that will hold the video.
 * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)
 * and pass it to GStreamer through the XOverlay interface. */
void XttStreamGtk::realize_cb( GtkWidget *widget, void *data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  GdkWindow *window = gtk_widget_get_window( widget);
  guintptr window_handle;
  
  if (!gdk_window_ensure_native (window))
    g_error ("Couldn't create native window needed for GstXOverlay!");
  
  /* Retrieve window handler from GDK */
  window_handle = GDK_WINDOW_XID( window);
  /* Pass it to playbin2, which implements XOverlay and will forward it to the video sink */
  //gst_x_overlay_set_window_handle( GST_X_OVERLAY (strm->playbin2), window_handle);
  gst_x_overlay_set_xwindow_id( GST_X_OVERLAY (strm->playbin2), window_handle);
}
  
/* This function is called when the PLAY button is clicked */
void XttStreamGtk::play_cb( GtkButton *button, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gst_element_set_state( strm->playbin2, GST_STATE_PLAYING);
}
  
/* This function is called when the PAUSE button is clicked */
void XttStreamGtk::pause_cb( GtkButton *button, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gst_element_set_state( strm->playbin2, GST_STATE_PAUSED);
}
  
/* This function is called when the STOP button is clicked */
void XttStreamGtk::stop_cb( GtkButton *button, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gst_element_set_state( strm->playbin2, GST_STATE_READY);
}
  
/* This function is called when the main window is closed */
void XttStreamGtk::delete_event_cb (GtkWidget *widget, GdkEvent *event, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  stop_cb( NULL, strm);

  if ( strm->close_cb)
    (strm->close_cb)( strm->parent_ctx, strm);
  delete strm;  
}
  
/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,
 * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,
 * we simply draw a black rectangle to avoid garbage showing up. */
gboolean XttStreamGtk::expose_cb( GtkWidget *widget, GdkEventExpose *event, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  if (strm->state < GST_STATE_PAUSED) {
    GtkAllocation allocation;
    GdkWindow *window = gtk_widget_get_window( widget);
    cairo_t *cr;
    
    /* Cairo is a 2D graphics library which we use here to clean the video window.
     * It is used by GStreamer for other reasons, so it will always be available to us. */
    gtk_widget_get_allocation( widget, &allocation);
    cr = gdk_cairo_create (window);
    cairo_set_source_rgb( cr, 0, 0, 0);
    cairo_rectangle( cr, 0, 0, allocation.width, allocation.height);
    cairo_fill( cr);
    cairo_destroy( cr);
  }
  
  return FALSE;
}
  
/* This function is called when the slider changes its position. We perform a seek to the
 * new position here. */
void XttStreamGtk::slider_cb( GtkRange *range, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gdouble value = gtk_range_get_value( GTK_RANGE( strm->slider));
  gst_element_seek_simple( strm->playbin2, GST_FORMAT_TIME, GstSeekFlags(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
      (gint64)(value * GST_SECOND));
}
  
/* This function is called periodically to refresh the GUI */
void XttStreamGtk::refresh_ui( XttStreamGtk *strm) 
{
  GstFormat fmt = GST_FORMAT_TIME;
  gint64 current = -1;
  
  if ( !(strm->options & pwr_mVideoOptionsMask_ControlPanel && 
	 strm->options & pwr_mVideoOptionsMask_ProgressBar))
    return;

  /* We do not want to update anything unless we are in the PAUSED or PLAYING states */
  if (strm->state < GST_STATE_PAUSED)
    return;
  
  /* If we didn't know it yet, query the stream duration */
  if (!GST_CLOCK_TIME_IS_VALID( strm->duration)) {
    if (!gst_element_query_duration( strm->playbin2, &fmt, &strm->duration)) {
      g_printerr( "Could not query current duration.\n");
    } else {
      /* Set the range of the slider to the clip duration, in SECONDS */
      if (GST_CLOCK_TIME_IS_VALID( strm->duration))
	gtk_range_set_range( GTK_RANGE( strm->slider), 0, (gdouble)strm->duration / GST_SECOND);
    }
  }
  
  if (gst_element_query_position( strm->playbin2, &fmt, &current)) {
    /* Block the "value-changed" signal, so the slider_cb function is not called
     * (which would trigger a seek the user has not requested) */
    g_signal_handler_block( strm->slider, strm->slider_update_signal_id);
    /* Set the position of the slider to the current pipeline positoin, in SECONDS */
    gtk_range_set_value( GTK_RANGE( strm->slider), (gdouble)current / GST_SECOND);
    /* Re-enable the signal */
    g_signal_handler_unblock( strm->slider, strm->slider_update_signal_id);
  }

}
  
void XttStreamGtk::refresh( void *data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  refresh_ui( strm);

  strm->timerid->add( strm->scan_time, strm->refresh, data);
}

/* This function is called when new metadata is discovered in the stream */
void XttStreamGtk::tags_cb( GstElement *playbin2, gint stream, void *data) 
{

  /* We are possibly in a GStreamer working thread, so we notify the main
   * thread of this event through a message in the bus */
  gst_element_post_message( playbin2,
    gst_message_new_application( GST_OBJECT( playbin2),
      gst_structure_new( "tags-changed", NULL)));
}
  
/* This function is called when an error message is posted on the bus */
void XttStreamGtk::error_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;
  GError *err;
  gchar *debug_info;
  
  /* Print error details on the screen */
  gst_message_parse_error( msg, &err, &debug_info);
  printf( "Error received from element %s: %s\n", GST_OBJECT_NAME( msg->src), err->message);
  printf( "Debugging information: %s\n", debug_info ? debug_info : "none");
  g_clear_error( &err);
  g_free( debug_info);
  
  /* Set the pipeline to READY (which stops playback) */
  gst_element_set_state( strm->playbin2, GST_STATE_READY);
}
  
/* This function is called when an End-Of-Stream message is posted on the bus.
 * We just set the pipeline to READY (which stops playback) */
void XttStreamGtk::eos_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  g_print( "End-Of-Stream reached.\n");
  gst_element_set_state( strm->playbin2, GST_STATE_READY);
}
  
/* This function is called when the pipeline changes states. We use it to
 * keep track of the current state. */
void XttStreamGtk::state_changed_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  GstState old_state, new_state, pending_state;
  gst_message_parse_state_changed( msg, &old_state, &new_state, &pending_state);
  if (GST_MESSAGE_SRC( msg) == GST_OBJECT( strm->playbin2)) {
    strm->state = new_state;
    // g_print( "State set to %s\n", gst_element_state_get_name( new_state));
    if (old_state == GST_STATE_READY && new_state == GST_STATE_PAUSED) {
      /* For extra responsiveness, we refresh the GUI as soon as we reach the PAUSED state */
      strm->refresh_ui( strm);
    }
  }
}
  
/* Extract metadata from all the streams and write it to the text widget in the GUI */
static void analyze_streams( void *data) {
#if 0
  XttStreamGtk *strm = (XttStreamGtk *)data;
  gint i;
  GstTagList *tags;
  gchar *str, *total_str;
  guint rate;
  gint n_video, n_audio, n_text;
  GtkTextBuffer *text;
  
  /* Clean current contents of the widget */
  text = gtk_text_view_get_buffer( GTK_TEXT_VIEW( strm->streams_list));
  gtk_text_buffer_set_text( text, "", -1);
  
  /* Read some properties */
  g_object_get( strm->playbin2, "n-video", &n_video, NULL);
  g_object_get( strm->playbin2, "n-audio", &n_audio, NULL);
  g_object_get( strm->playbin2, "n-text", &n_text, NULL);
  
  for (i = 0; i < n_video; i++) {
    tags = NULL;
    /* Retrieve the stream's video tags */
    g_signal_emit_by_name( strm->playbin2, "get-video-tags", i, &tags);
    if (tags) {
      total_str = g_strdup_printf( "video stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      gst_tag_list_get_string( tags, GST_TAG_VIDEO_CODEC, &str);
      str = 0;
      total_str = g_strdup_printf( "  codec: %s\n", str ? str : "unknown");
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      g_free( str);
      gst_tag_list_free( tags);
    }
  }
  
  for (i = 0; i < n_audio; i++) {
    tags = NULL;
    /* Retrieve the stream's audio tags */
    g_signal_emit_by_name( strm->playbin2, "get-audio-tags", i, &tags);
    if (tags) {
      total_str = g_strdup_printf( "\naudio stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      if (gst_tag_list_get_string( tags, GST_TAG_AUDIO_CODEC, &str)) {
        total_str = g_strdup_printf( "  codec: %s\n", str);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
        g_free( str);
      }
      if (gst_tag_list_get_string( tags, GST_TAG_LANGUAGE_CODE, &str)) {
        total_str = g_strdup_printf( "  language: %s\n", str);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
        g_free( str);
      }
      if (gst_tag_list_get_uint( tags, GST_TAG_BITRATE, &rate)) {
        total_str = g_strdup_printf( "  bitrate: %d\n", rate);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
      }
      gst_tag_list_free( tags);
    }
  }
  
  for (i = 0; i < n_text; i++) {
    tags = NULL;
    /* Retrieve the stream's subtitle tags */
    g_signal_emit_by_name( strm->playbin2, "get-text-tags", i, &tags);
    if (tags) {
      total_str = g_strdup_printf( "\nsubtitle stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      if (gst_tag_list_get_string( tags, GST_TAG_LANGUAGE_CODE, &str)) {
        total_str = g_strdup_printf( "  language: %s\n", str);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
        g_free( str);
      }
      gst_tag_list_free( tags);
    }
  }
#endif
}
  
/* This function is called when an "application" message is posted on the bus.
 * Here we retrieve the message posted by the tags_cb callback */
void XttStreamGtk::application_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  if (g_strcmp0( gst_structure_get_name( msg->structure), "tags-changed") == 0) {
    /* If the message is the "tags-changed" (only one we are currently issuing), update
     * the stream info GUI */
    analyze_streams( data);
  }
}

XttStreamGtk::XttStreamGtk( GtkWidget *st_parent_wid, void *st_parent_ctx, const char *name, const char *st_uri,
			    int width, int height, int x, int y, double scan_time, 
			    unsigned int st_options, int st_embedded, pwr_tStatus *sts) :
  XttStream( st_parent_ctx, name, st_uri, width, height, x, y, scan_time, st_options, st_embedded),
  parent_wid(st_parent_wid)
{
  GstStateChangeReturn ret;
  GstBus *bus;
  pwr_tFileName fname;
  
  if ( !gst_initialized) {
    // Initialize gstreamer
    int argc = 0;
    char **argv;

    gst_init( &argc, &argv);
    gst_initialized = 1;
  }

  if( width == 0 || height == 0) {
    width = 640;
    height = 480;
  }

  duration = GST_CLOCK_TIME_NONE;
  
  /* Create the elements */
  playbin2 = gst_element_factory_make( "playbin2", "playbin2");
   
  if (!playbin2) {
    g_printerr( "Not all elements could be created.\n");
    *sts = 0;
    return;
  }
  
  /* Set the URI to play, eg "http://192.168.67.248/mjpg/video.mjpg" */
  g_object_set( playbin2, "uri", uri,  NULL);
  
  /* Connect to interesting signals in playbin2 */
  g_signal_connect( G_OBJECT( playbin2), "video-tags-changed",( GCallback) tags_cb, this);
  g_signal_connect( G_OBJECT( playbin2), "audio-tags-changed",( GCallback) tags_cb, this);
  g_signal_connect( G_OBJECT( playbin2), "text-tags-changed",( GCallback) tags_cb, this);

  if ( !embedded) {
    toplevel = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    g_signal_connect( G_OBJECT(toplevel), "delete-event", G_CALLBACK(delete_event_cb), this);

    char *titleutf8 = g_convert( name, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    gtk_window_set_title( GTK_WINDOW(toplevel), titleutf8);
    g_free( titleutf8);

    CoWowGtk::SetWindowIcon( toplevel);
  }
  else
    toplevel = parent_wid;

  video_form = gtk_drawing_area_new();
  gtk_widget_set_double_buffered( video_form, FALSE);
  g_signal_connect( video_form, "realize", G_CALLBACK( realize_cb), this);
  g_signal_connect( video_form, "expose_event", G_CALLBACK( expose_cb), this);
  
  // GtkWidget *controls;
  GtkWidget *hbox = gtk_hbox_new( FALSE, 0);
  if ( options & pwr_mVideoOptionsMask_ControlPanel) {
    GtkToolbar *controlbuttons;
    controlbuttons = (GtkToolbar *) g_object_new(GTK_TYPE_TOOLBAR, NULL);

    GtkWidget *play_button = gtk_button_new();
    dcli_translate_filename( fname, "$pwr_exe/xtt_play.png");
    gtk_container_add( GTK_CONTAINER(play_button), 
		       gtk_image_new_from_file( fname));
    g_signal_connect( G_OBJECT( play_button), "clicked", G_CALLBACK( play_cb), this);
    gtk_toolbar_append_widget( controlbuttons, play_button,CoWowGtk::translate_utf8("Play"), "");
  
    GtkWidget *pause_button = gtk_button_new();
    dcli_translate_filename( fname, "$pwr_exe/xtt_pause.png");
    gtk_container_add( GTK_CONTAINER(pause_button), 
		       gtk_image_new_from_file( fname));
    g_signal_connect( G_OBJECT( pause_button), "clicked", G_CALLBACK( pause_cb), this);
    gtk_toolbar_append_widget( controlbuttons, pause_button,CoWowGtk::translate_utf8("Pause"), "");
  
    GtkWidget *stop_button = gtk_button_new();
    dcli_translate_filename( fname, "$pwr_exe/xtt_stop.png");
    gtk_container_add( GTK_CONTAINER(stop_button), 
		       gtk_image_new_from_file( fname));
    g_signal_connect( G_OBJECT( stop_button), "clicked", G_CALLBACK( stop_cb), this);
    gtk_toolbar_append_widget( controlbuttons, stop_button,CoWowGtk::translate_utf8("Stop"), "");
  

    gtk_box_pack_start( GTK_BOX( hbox), GTK_WIDGET(controlbuttons), FALSE, FALSE, 2);

    if ( options & pwr_mVideoOptionsMask_ProgressBar) {
      slider = gtk_hscale_new_with_range( 0, 100, 1);
      gtk_scale_set_draw_value( GTK_SCALE( slider), 0);
      slider_update_signal_id = g_signal_connect( G_OBJECT( slider), "value-changed", G_CALLBACK( slider_cb), this);
      gtk_box_pack_start( GTK_BOX( hbox), slider, TRUE, TRUE, 2);
    }
  }
  
  main_box = gtk_vbox_new( FALSE, 0);
  gtk_box_pack_start( GTK_BOX( main_box), video_form, TRUE, TRUE, 0);
  if ( options & pwr_mVideoOptionsMask_ControlPanel)
    gtk_box_pack_start( GTK_BOX( main_box), GTK_WIDGET(hbox), FALSE, FALSE, 0);

  if ( !embedded) {
    gtk_container_add( GTK_CONTAINER( toplevel), main_box);
    gtk_window_set_default_size( GTK_WINDOW( toplevel), width, height);
  
    gtk_widget_show_all( toplevel);

    if ( options & pwr_mVideoOptionsMask_FullScreen)
      gtk_window_fullscreen( GTK_WINDOW(toplevel));
    else if ( options & pwr_mVideoOptionsMask_Maximize)
      gtk_window_maximize( GTK_WINDOW(toplevel)); // TODO
    else if ( options & pwr_mVideoOptionsMask_FullMaximize)
      gtk_window_maximize( GTK_WINDOW(toplevel));
    else if ( options & pwr_mVideoOptionsMask_Iconify)
      gtk_window_iconify( GTK_WINDOW(toplevel));
  }
  else {
    gtk_widget_set_size_request( main_box, width, height);
  }

  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus( playbin2);
  gst_bus_add_signal_watch( bus);
  g_signal_connect( G_OBJECT( bus), "message::error", (GCallback)error_cb, this);
  g_signal_connect( G_OBJECT( bus), "message::eos", (GCallback)eos_cb, this);
  g_signal_connect( G_OBJECT( bus), "message::state-changed", (GCallback)state_changed_cb, this);
  g_signal_connect( G_OBJECT( bus), "message::application", (GCallback)application_cb, this);
  gst_object_unref( bus);
  
  /* Start playing */
  ret = gst_element_set_state( playbin2, GST_STATE_PLAYING);
  if (ret == GST_STATE_CHANGE_FAILURE) {
    g_printerr( "Unable to set the pipeline to the playing state.\n");
    gst_object_unref( playbin2);
    *sts = 0;
    return;
  }
  
  wow = new CoWowGtk( toplevel);
  timerid = wow->timer_new();
  timerid->add( scan_time, refresh, this);

  *sts = XNAV__SUCCESS;
}
  
XttStreamGtk::~XttStreamGtk()
{
  timerid->remove();

  gst_element_set_state( playbin2, GST_STATE_NULL);
  gst_object_unref( playbin2);

  if ( !embedded)
    gtk_widget_destroy( toplevel);
}

void XttStreamGtk::pop()
{
  gtk_window_present( GTK_WINDOW(toplevel));
}

void XttStreamGtk::set_size( int width, int height)
{
  gtk_window_resize( GTK_WINDOW(toplevel), width, height);
}

  
#if 0
int main(int argc, char *argv[]) {
  pwr_tStatus sts;

  /* Initialize GTK */
  gtk_init( &argc, &argv);
  
  /* Initialize GStreamer */
  gst_init( &argc, &argv);
  
  XttStreamGtk *strm = new XttStreamGtk( 0, 0, "Some video", "http://192.168.67.248/mjpg/video.mjpg", 1, 0, 0, 0, 0, 1, 0, &sts);
 
  /* Start the GTK main loop. We will not regain control until gtk_main_quit is called. */
  gtk_main();
  
  delete strm;

  /* Free resources */
  return 0;
}
#endif

#else
// gstreamer not installed
#include <gtk/gtk.h>
#include "xtt_stream_gtk.h"  

XttStreamGtk::XttStreamGtk( GtkWidget *parent_wid, void *parent_ctx, const char *name, const char *uri,
		int width, int height,
		int x, int y, double scan_time, unsigned int options) {}
XttStreamGtk::~XttStreamGtk() {}

#endif
