/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_block_qt.cpp -- Alarm blocking window in xtt. */

#include "pwr_privilege.h"

#include "co_msg.h"

#include "rt_gdh.h"
#include "rt_mh_outunit.h"

#include "cow_qt_helpers.h"
#include "cow_wow_qt.h"

#include "xtt_block_qt.h"

#include <QButtonGroup>
#include <QDialogButtonBox>
#include <QPushButton>
#include <QVBoxLayout>

int BlockQt::execute()
{
  mh_eEventPrio prio;
  pwr_tStatus sts;

  if (toggleA->isChecked()) {
    prio = mh_eEventPrio_A;
  } else if (toggleB->isChecked()) {
    prio = mh_eEventPrio_B;
  } else if (toggleC->isChecked()) {
    prio = mh_eEventPrio_C;
  } else if (toggleD->isChecked()) {
    prio = mh_eEventPrio_D;
  } else {
    prio = (mh_eEventPrio)0;
  }

  sts = mh_OutunitBlock(oar.Objid, prio);
  if (EVEN(sts)) {
    char msg[80];

    msg_GetMsg(sts, msg, sizeof(msg));
    wow->DisplayError("Block Error", msg);
  }
  return sts;
}

void BlockQt::update()
{
  pwr_tStatus sts;
  mh_uEventInfo block_level;

  sts = gdh_GetAlarmInfo(
      oar.Objid, NULL, NULL, (pwr_tUInt32*)&block_level, NULL, NULL);
  switch (block_level.Event.Prio) {
  case mh_eEventPrio_A:
    toggleA->setChecked(true);
    break;
  case mh_eEventPrio_B:
    toggleB->setChecked(true);
    break;
  case mh_eEventPrio_C:
    toggleC->setChecked(true);
    break;
  case mh_eEventPrio_D:
    toggleD->setChecked(true);
    break;
  case 0:
    toggleNo->setChecked(true);
    break;
  default:
    break;
  }
}

void BlockQtWidget::activate_apply()
{
  block->execute();
}

void BlockQtWidget::activate_ok()
{
  pwr_tStatus sts;

  sts = block->execute();
  if (ODD(sts)) {
    close();
  }
}

void BlockQtWidget::closeEvent(QCloseEvent* event)
{
  debug_print("BlockQtWidget::closeEvent\n");
  delete block;
  QWidget::closeEvent(event);
}

BlockQt::BlockQt(void* b_parent_ctx, QWidget* b_parent_wid, pwr_sAttrRef* b_oar,
    char* name, unsigned int priv, pwr_tStatus* sts)
    : Block(b_parent_ctx, b_oar, name, priv, sts)
{
  char title[400];
  pwr_tAName aname;

  *sts = gdh_AttrrefToName(&oar, aname, sizeof(aname), cdh_mNName);
  if (EVEN(*sts)) {
    return;
  }

  toplevel = new BlockQtWidget(this, b_parent_wid);
  strcpy(title, name);
  strcat(title, "    ");
  strcat(title, aname);

  toplevel->setToolTip(fl("xtt_block widget"));
  toplevel->setMinimumSize(500, 300);
  toplevel->setWindowTitle(fl(title));
  toplevel->setAttribute(Qt::WA_DeleteOnClose);

  CoWowQt::SetWindowIcon(toplevel);

  QButtonGroup* bl_group = new QButtonGroup();
  toggleA = new QRadioButton("A Alarm");
  bl_group->addButton(toggleA);
  toggleB = new QRadioButton("B Alarm");
  bl_group->addButton(toggleB);
  toggleC = new QRadioButton("C Alarm");
  bl_group->addButton(toggleC);
  toggleD = new QRadioButton("D Alarm");
  bl_group->addButton(toggleD);
  toggleNo = new QRadioButton("No Blocking");
  bl_group->addButton(toggleNo);

  QVBoxLayout* toggle_vbox = new QVBoxLayout();
  toggle_vbox->addWidget(toggleA);
  toggle_vbox->addWidget(toggleB);
  toggle_vbox->addWidget(toggleC);
  toggle_vbox->addWidget(toggleD);
  toggle_vbox->addWidget(toggleNo);

  QDialogButtonBox* buttons = new QDialogButtonBox();
  buttons->addButton(QDialogButtonBox::Ok);
  buttons->addButton(QDialogButtonBox::Apply);
  buttons->addButton(QDialogButtonBox::Cancel);
  QObject::connect(buttons->button(QDialogButtonBox::Ok), SIGNAL(clicked()),
      toplevel, SLOT(activate_ok()));
  QObject::connect(buttons->button(QDialogButtonBox::Apply), SIGNAL(clicked()),
      toplevel, SLOT(activate_apply()));
  QObject::connect(buttons->button(QDialogButtonBox::Cancel), SIGNAL(clicked()),
      toplevel, SLOT(close()));

  QVBoxLayout* vbox = new QVBoxLayout(toplevel);
  vbox->addLayout(toggle_vbox);
  vbox->addWidget(separator(QFrame::HLine));
  vbox->addWidget(buttons);

  toplevel->setLayout(vbox);
  toplevel->show();

  if (!(priv & pwr_mPrv_RtEventsBlock || priv & pwr_mPrv_System)) {
    buttonOk->setEnabled(false);
    buttonApply->setEnabled(false);
    toggleA->setEnabled(false);
    toggleB->setEnabled(false);
    toggleC->setEnabled(false);
    toggleD->setEnabled(false);
    toggleNo->setEnabled(false);
  }

  wow = new CoWowQt(b_parent_wid);

  update();
}