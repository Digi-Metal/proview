/*
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "pwr.h"
#include "rt_gdh.h"
#include "cow_wow_qt.h"
#include "co_lng.h"
#include "xtt_fileview_qt.h"
#include "xtt_xnav.h"

void XttFileviewQt::execute(char *file)
{
  pwr_tStatus sts;
  pwr_tFileName fname;

  strcpy(fname, dir);
  strcat(fname, "/");
  strcat(fname, file);

  sts = gdh_SetObjectInfo(target_attr, fname, 80);
  if (EVEN(sts)) {
    printf("** Fileview: unable to set target %s\n", target_attr);
    return;
  }

  pwr_tBoolean b = 1;
  sts = gdh_SetObjectInfo(trigger_attr, &b, sizeof(b));
  if (EVEN(sts)) {
    printf("** Fileview: unable to set trigger %s\n", trigger_attr);
    return;
  }
}

void XttFileviewQtWidget::list_ok_cb(const QString &file)
{
  if (fileview->type == fileview_eType_Open) {
    char selected_text[80];

    QByteArray textiso = file.toLatin1();
    strcpy(selected_text, textiso.data());

    fileview->execute(selected_text);
  } else {
    bool file_exist = false;
    char input_text[200];

    QByteArray text = file.toLatin1();
    strncpy(input_text, text.data(), sizeof(input_text));

    /*
    if (strcmp(filetype, "") != 0) {
      if (file.indexOf('.') == 0) {
        strcat(input_text, filetype);
      }
    }
    */

    for (int i = 0; i < fileview->filecnt; i++) {
      if (strcmp(fileview->filelist[i], input_text) == 0) {
        file_exist = true;
        break;
      }
    }
    if (file_exist) {
      char msg[200];

      strcpy(fileview->selected_file, input_text);
      sprintf(msg, "%s %s\n", input_text, Lng::translate("already exists"));
      sprintf(&msg[strlen(msg)], "%s",
              Lng::translate("Do you want to replace it"));
      ((XNav *) fileview->parent_ctx)->wow->DisplayQuestion(
          this, Lng::translate("File already exists"), msg,
          XttFileviewQt::list_save_cb, 0, 0);
      return;
    }
    fileview->execute(input_text);
  }
  close();
}

void XttFileviewQtWidget::closeEvent(QCloseEvent *event)
{
  free(fileview->filelist);
  delete fileview;
  QWidget::closeEvent(event);
}

void XttFileviewQt::list_save_cb(void *ctx, void *data)
{
  XttFileviewQt *fileview = (XttFileviewQt *) ctx;

  fileview->execute(fileview->selected_file);

  fileview->toplevel->close();
}

XttFileviewQt::XttFileviewQt(void *xn_parent_ctx, QWidget *xn_parent_wid,
                             pwr_tOid xn_oid, char *xn_title, char *xn_dir,
                             char *xn_pattern, int xn_type,
                             char *xn_target_attr, char *xn_trigger_attr,
                             char *xn_filetype) : filelist(0),
                                                  parent_ctx(xn_parent_ctx),
                                                  oid(xn_oid), type(xn_type)
{
  pwr_tStatus sts;

  strncpy(dir, xn_dir, sizeof(dir));
  strncpy(pattern, xn_pattern, sizeof(pattern));
  strncpy(target_attr, xn_target_attr, sizeof(target_attr));
  strncpy(trigger_attr, xn_trigger_attr, sizeof(trigger_attr));
  if (xn_filetype) {
    strcpy(filetype, ".");
    strncat(filetype, xn_filetype, sizeof(filetype) - 1);
  } else {
    strcpy(filetype, "");
  }
  strcpy(selected_file, "");

  sts = gdh_SearchFile(oid, dir, pattern, &filelist, &filecnt);
  if (type == fileview_eType_Open && (EVEN(sts) || filecnt == 0)) {
    return;
  }

  toplevel = new XttFileviewQtWidget(this, xn_parent_wid);
  toplevel->setToolTip(fl("xtt_fileview widget"));
  toplevel->setMinimumSize(500, 500);
  toplevel->setWindowTitle(translate_utf8(xn_title));
  toplevel->setAttribute(Qt::WA_DeleteOnClose);

  QStringList store;
  for (int i = 0; i < filecnt; i++) {
    store << QString::fromLatin1(filelist[i]);
  }
  toplevel->setNameFilters(store);

  if (type == fileview_eType_Save) {
    toplevel->setAcceptMode(QFileDialog::AcceptSave);
  } else {
    toplevel->setAcceptMode(QFileDialog::AcceptOpen);
  }

  QObject::connect(toplevel, SIGNAL(fileSelected(const QString &)), toplevel,
                   SLOT(list_ok_cb(const QString &)));

  toplevel->exec();
}