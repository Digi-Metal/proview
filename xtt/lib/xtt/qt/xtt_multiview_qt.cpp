/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "co_cdh.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_qt_helpers.h"

#include "glow_growctx.h"
#include "glow_growapi.h"
#include "glow_msg.h"

#include "xtt_ev.h"
#include "xtt_evala_qt.h"
#include "xtt_eveve_qt.h"
#include "xtt_ge_qt.h"
#include "xtt_multiview_qt.h"
#include "xtt_otree.h"
#include "xtt_trend_qt.h"
#include "xtt_sevhist_qt.h"
#include "xtt_stream_qt.h"
#include "xtt_xnav.h"

QWidget* XttMultiViewQt::error_msg(const char* msg, pwr_tStatus sts)
{
  char str1[200];
  char str2[400];

  msg_GetMsg(sts, str1, sizeof(str1));
  strcpy(str2, msg);
  strcat(str2, "\n");
  strcat(str2, str1);

  return new QLabel(fl(str2));
}

void XttMultiViewQtWidget::focusInEvent(QFocusEvent* event)
{
  if (!multiview->focustimer.disabled()) {
    multiview->focustimer.disable(400);
  }
  QWidget::focusInEvent(event);
}

void XttMultiViewQtWidget::resize(int width, int height)
{
  int default_width;
  int default_height;
  float rd = 0.05;
  ;

  default_width = width + 20;
  default_height = height + 20;
  if (width < 300 || height < 300) {
    rd = 0.2;
  }
  default_height = MIN(default_height, width);
  default_height = MAX(default_height, width * 1.02);

  QWidget::resize(default_width, default_height);
}

void XttMultiViewQt::set_size(int width, int height)
{
  toplevel->resize(width, height);
}

XttMultiViewQt::~XttMultiViewQt()
{
  debug_print("XttMultiViewQt::~XttMultiViewQt\n");
  if (close_cb) {
    (close_cb)(parent_ctx, this);
  }
}

void XttMultiViewQt::pop()
{
  ::pop(toplevel);
}

void XttMultiViewQtWidget::closeEvent(QCloseEvent* event)
{
  debug_print("XttMultiViewQtWidget::closeEvent\n");
  if (multiview->options & ge_mOptions_IsMain) {
    (multiview->close_cb)(multiview->parent_ctx, multiview);
  } else {
    delete multiview;
  }
  QWidget::closeEvent(event);
}

XttMultiViewQt::XttMultiViewQt(QWidget* mv_parent_wid, void* mv_parent_ctx,
    const char* mv_name, pwr_tAttrRef* mv_aref, int mv_width, int mv_height,
    int mv_x, int mv_y, unsigned int mv_options, void* basewidget,
    int mv_color_theme, pwr_tStatus* sts,
    int (*mv_command_cb)(void*, char*, char*, void*),
    int (*mv_get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*mv_is_authorized_cb)(void*, unsigned int),
    void (*mv_keyboard_cb)(void*, void*, int, int))
    : XttMultiView(mv_parent_ctx, mv_name, mv_aref, mv_width, mv_height, mv_x,
          mv_y, mv_options, mv_color_theme, mv_command_cb,
          mv_get_current_objects_cb, mv_is_authorized_cb, mv_keyboard_cb)
{
  int window_width = 600;
  int window_height = 500;
  pwr_tStatus lsts;
  XNav* xnav = get_xnav();
  pwr_sClass_XttMultiView mv;

  memset(gectx, 0, sizeof(gectx));
  memset(mvctx, 0, sizeof(mvctx));
  memset(sala, 0, sizeof(sala));
  memset(seve, 0, sizeof(seve));
  memset(trend, 0, sizeof(trend));
  memset(sevhist, 0, sizeof(sevhist));
  memset(strmctx, 0, sizeof(strmctx));
  memset(comp_widget, 0, sizeof(comp_widget));
  memset(exchange_widget, 0, sizeof(exchange_widget));
  memset(comp_width, 0, sizeof(comp_width));
  memset(comp_height, 0, sizeof(comp_height));
  memset(comp_x, 0, sizeof(comp_x));
  memset(comp_y, 0, sizeof(comp_y));

  *sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(*sts)) {
    return;
  }

  if (mv_width != 0 && mv_height != 0) {
    window_width = mv_width;
    window_height = mv_height;
  } else if (mv.Width != 0 && mv.Height != 0) {
    window_width = mv.Width;
    window_height = mv.Height;
  } else {
    window_width = 600;
    window_height = 500;
  }

  // Qt
  if (!(options & ge_mOptions_Embedded)) {
    toplevel = new XttMultiViewQtWidget(this, mv_parent_wid);
    toplevel->setToolTip(fl("xtt_multiview widget"));
    toplevel->setMinimumSize(window_width, window_height);
    toplevel->setWindowTitle(QString::fromLatin1(mv.Title));
    toplevel->setAttribute(Qt::WA_DeleteOnClose);

    if (mv.Options & pwr_mMultiViewOptionsMask_HideDecorations) {
      toplevel->setWindowFlags(Qt::CustomizeWindowHint);
    }

    if (mv.Layout == pwr_eMultiViewLayoutEnum_Fix
        || mv.Layout == pwr_eMultiViewLayoutEnum_Table) {
      toplevel->setMinimumSize(window_width, window_height);
    }

    if (mv.Options & pwr_mMultiViewOptionsMask_Dialog) {
      toplevel->setWindowFlags(Qt::Dialog);
      toplevel->setMinimumSize(window_width, window_height);
    }

    CoWowQt::SetWindowIcon(toplevel);
  } else {
    box_widget = layout_to_widget(new QHBoxLayout());
  }

  {
    rows = mv.Rows;
    cols = mv.Columns;

    QHBoxLayout* col_widget_box = NULL;
    QSplitter* col_widget_pane = NULL;
    QGridLayout* col_widget_table = NULL;

    switch (mv.Layout) {
    case pwr_eMultiViewLayoutEnum_Box:
      col_widget_box = new QHBoxLayout();
      break;
    case pwr_eMultiViewLayoutEnum_Pane:
      col_widget_pane = new QSplitter();
      break;
    case pwr_eMultiViewLayoutEnum_Table:
      col_widget_table = new QGridLayout(); //(rows, cols);
      break;
    default:
      return;
    }

    bool escape = false;
    for (int i = 0; i < cols; i++) {
      QVBoxLayout* row_widget_box = NULL;
      QSplitter* row_widget_pane = NULL;

      if (mv.Layout == pwr_eMultiViewLayoutEnum_Pane && i > 1) {
        break;
      }

      switch (mv.Layout) {
      case pwr_eMultiViewLayoutEnum_Box:
        row_widget_box = new QVBoxLayout();
        break;
      case pwr_eMultiViewLayoutEnum_Pane:
        row_widget_pane = new QSplitter(Qt::Vertical);
        break;
      default:
        break;
      }

      for (int j = 0; j < rows; j++) {
        pwr_tFileName graph_name;
        int w, h, scrollbar, menu, type;

        if (i * rows + j >= MV_SIZE) {
          escape = true;
          break;
        }
        if (mv.Layout == pwr_eMultiViewLayoutEnum_Pane && j > 1) {
          break;
        }

        w = comp_width[i * rows + j] = mv.Action[i * rows + j].Width;
        h = comp_height[i * rows + j] = mv.Action[i * rows + j].Height;
        comp_x[i * rows + j] = mv.Action[i * rows + j].X;
        comp_y[i * rows + j] = mv.Action[i * rows + j].Y;
        scrollbar = (mv.Action[i * rows + j].Options
                        & pwr_mMultiViewElemOptionsMask_Scrollbars)
            ? 1
            : 0;
        menu = (mv.Action[i * rows + j].Options
                   & pwr_mMultiViewElemOptionsMask_Menu)
            ? 1
            : 0;
        strcpy(graph_name, mv.Action[i * rows + j].Action);
        type = mv.Action[i * rows + j].Type;

        switch (type) {
        case pwr_eMultiViewContentEnum_AlarmList: {
          if (xnav->ev) {
            sala[i * rows + j]
                = (EvAlaQt*)xnav->ev->open_alarmlist_satellite("No title",
                    &lsts, w, h, 0, 0, mv.Action[i * rows + j].Object[0].Objid,
                    ev_mAlaOptions_Embedded, toplevel);
            if (!sala[i * rows + j]) {
              continue;
            }
            comp_widget[i * rows + j] = sala[i * rows + j]->get_widget();
          }
          break;
        }
        case pwr_eMultiViewContentEnum_EventList: {
          if (xnav->ev) {
            seve[i * rows + j]
                = (EvEveQt*)xnav->ev->open_eventlist_satellite("No title",
                    &lsts, w, h, 0, 0, mv.Action[i * rows + j].Object[0].Objid,
                    ev_mAlaOptions_Embedded, toplevel);
            if (!seve[i * rows + j]) {
              continue;
            }
            comp_widget[i * rows + j] = seve[i * rows + j]->get_widget();
          }
          break;
        }
        case pwr_eMultiViewContentEnum_Graph:
        case pwr_eMultiViewContentEnum_ObjectGraph: {
          char* objectname_p = 0;
          char objectname[800];
          double borders[4];
          double* bordersp = 0;
          char* s;

          for (int k = 0; k < 4; k++) {
            pwr_tAName oname;

            if (cdh_ObjidIsNull(mv.Action[i * rows + j].Object[k].Objid)) {
              break;
            }
            lsts = gdh_AttrrefToName(&mv.Action[i * rows + j].Object[k], oname,
                sizeof(oname), cdh_mName_volumeStrict);
            if (EVEN(lsts)) {
              break;
            }

            if (k == 0) {
              strncpy(objectname, oname, sizeof(objectname));
            } else {
              strncat(objectname, ",", sizeof(objectname) - strlen(objectname) - 1);
              strncat(objectname, oname, sizeof(objectname) - strlen(objectname) - 1);
            }
            objectname_p = objectname;
          }

          if (!feqf(mv.Action[i * rows + j].Borders[0], 0.0f)
              || !feqf(mv.Action[i * rows + j].Borders[1], 0.0f)
              || !feqf(mv.Action[i * rows + j].Borders[2], 0.0f)
              || !feqf(mv.Action[i * rows + j].Borders[3], 0.0f)) {
            for (int k = 0; k < 4; k++) {
              borders[k] = mv.Action[i * rows + j].Borders[k];
            }
            bordersp = borders;
          }

          gectx[i * rows + j]
              = new XttGeQt(toplevel, toplevel, "No title", graph_name,
                  scrollbar, menu, 0, w, h, mv_x, mv_y, 1.0, objectname_p, 0, 0,
                  ge_mOptions_Embedded, 0, bordersp, color_theme,
                  multiview_ge_command_cb, multiview_ge_get_current_objects_cb,
                  multiview_ge_is_authorized_cb, multiview_keyboard_cb);

          gectx[i * rows + j]->close_cb = multiview_ge_close_cb;
          gectx[i * rows + j]->help_cb = multiview_ge_help_cb;
          gectx[i * rows + j]->display_in_xnav_cb
              = multiview_ge_display_in_xnav_cb;
          gectx[i * rows + j]->popup_menu_cb = multiview_ge_popup_menu_cb;
          gectx[i * rows + j]->call_method_cb = multiview_ge_call_method_cb;
          gectx[i * rows + j]->sound_cb = multiview_ge_sound_cb;
          gectx[i * rows + j]->eventlog_cb = multiview_ge_eventlog_cb;

          comp_widget[i * rows + j] = gectx[i * rows + j]->get_graph_widget();

          recall_buffer[i * rows + j].insert(graph_name, objectname_p);

          if ((s = strchr(graph_name, '.'))) {
            *s = 0;
          }
          appl.insert(applist_eType_Graph, (void*)gectx[i * rows + j],
              pwr_cNObjid, graph_name, objectname_p);

          break;
        }
        case pwr_eMultiViewContentEnum_MultiView: {
          pwr_tAttrRef graph_aref;

          lsts = gdh_NameToAttrref(pwr_cNObjid, graph_name, &graph_aref);
          if (EVEN(lsts)) {
            break;
          }

          mvctx[i * rows + j]
              = new XttMultiViewQt(toplevel, this, "No title", &graph_aref, w,
                  h, mv_x, mv_y, ge_mOptions_Embedded, 0, color_theme, &lsts,
                  multiview_ge_command_cb, multiview_ge_get_current_objects_cb,
                  multiview_ge_is_authorized_cb, multiview_keyboard_cb);

          mvctx[i * rows + j]->close_cb = multiview_ge_close_cb;
          mvctx[i * rows + j]->help_cb = multiview_ge_help_cb;
          mvctx[i * rows + j]->display_in_xnav_cb
              = multiview_ge_display_in_xnav_cb;
          mvctx[i * rows + j]->popup_menu_cb = multiview_ge_popup_menu_cb;
          mvctx[i * rows + j]->call_method_cb = multiview_ge_call_method_cb;
          mvctx[i * rows + j]->sound_cb = multiview_ge_sound_cb;
          mvctx[i * rows + j]->eventlog_cb = multiview_ge_eventlog_cb;

          comp_widget[i * rows + j]
              = (QWidget*)mvctx[i * rows + j]->get_widget();

          recall_buffer[i * rows + j].insert(graph_name, 0);

          appl.insert(applist_eType_MultiView, (void*)mvctx[i * rows + j],
              &aref, "", NULL);

          break;
        }
        case pwr_eMultiViewContentEnum_TrendCurve: {
          int plotgroup_found = 0;
          pwr_tAttrRef plotgroup;
          pwr_tCid classid;
          QWidget* widget;
          pwr_tAttrRef arefv[2];
          int skip = 0;

          lsts
              = gdh_GetAttrRefTid(&mv.Action[i * rows + j].Object[0], &classid);
          if (EVEN(lsts)) {
            break;
          }

          switch (classid) {
          case pwr_cClass_DsTrend:
          case pwr_cClass_DsTrendCurve:
            break;
          case pwr_cClass_PlotGroup:
            plotgroup_found = 1;
            plotgroup = mv.Action[i * rows + j].Object[0];
            arefv[0] = plotgroup;
            break;
          default:
            skip = 1;
          }

          if (skip) {
            break;
          }

          if (plotgroup_found) {
            trend[i * rows + j] = new XttTrendQt(this, toplevel,
                (char*)"No title", &widget, 0, &plotgroup, w, h,
                (unsigned int)curve_mOptions_Embedded, color_theme, 0, sts);
          } else {
            arefv[0] = mv.Action[i * rows + j].Object[0];
            memset(&arefv[1], 0, sizeof(arefv[0]));
            trend[i * rows + j] = new XttTrendQt(this, toplevel,
                (char*)"No title", &widget, arefv, 0, w, h,
                (unsigned int)curve_mOptions_Embedded, color_theme, 0, sts);
          }
          if (EVEN(*sts)) {
            break;
          }

          trend[i * rows + j]->close_cb = multiview_trend_close_cb;
          trend[i * rows + j]->command_cb = multiview_trend_command_cb;
          trend[i * rows + j]->help_cb = multiview_trend_help_cb;

          comp_widget[i * rows + j] = widget;

          appl.insert(applist_eType_Trend, (void*)trend[i * rows + j],
              &arefv[0], "", NULL);

          break;
        }
        case pwr_eMultiViewContentEnum_SevHistory: {
          pwr_tOid oidv[11];
          pwr_tOName anamev[11];
          pwr_tOName onamev[11];
          bool sevhistobjectv[11];
          pwr_tAttrRef attr_aref, sevhist_aref, histthread_aref;
          pwr_tOid histthread_oid;
          char server_node[40];
          char* s;
          pwr_tAName aname;
          int plotgroup_found = 0;
          int sevHistObjectFound = 0;
          int oid_cnt = 0;
          pwr_tCid classid;
          int skip = 0;

          if (cdh_ObjidIsNull(mv.Action[i * rows + j].Object[0].Objid)) {
            break;
          }

          pwr_tAttrRef arefv[2];
          pwr_tAttrRef plotgroup;
          arefv[0] = mv.Action[i * rows + j].Object[0];
          memset(&arefv[1], 0, sizeof(arefv[0]));

          lsts = gdh_GetAttrRefTid(&arefv[0], &classid);
          if (EVEN(lsts)) {
            break;
          };

          switch (classid) {
          case pwr_cClass_SevHist:
            break;
          case pwr_cClass_SevHistObject:
            sevHistObjectFound = true;
            break;
          case pwr_cClass_PlotGroup:
            plotgroup = mv.Action[i * rows + j].Object[0];
            plotgroup_found = 1;
            break;
          default:
            skip = 1;
          }

          if (skip) {
            break;
          }

          if (plotgroup_found) {
            pwr_sClass_PlotGroup plot;
            pwr_tCid cid;
            int j;

            lsts = gdh_GetObjectInfoAttrref(&plotgroup, &plot, sizeof(plot));
            if (EVEN(lsts)) {
              break;
            }

            for (j = 0; j < 20; j++) {
              if (cdh_ObjidIsNull(plot.YObjectName[j].Objid)) {
                break;
              }

              sevhist_aref = plot.YObjectName[j];
              lsts = gdh_GetAttrRefTid(&sevhist_aref, &cid);
              if (EVEN(lsts)) {
                break;
              }

              if (cid == pwr_cClass_SevHist) {
                lsts = gdh_ArefANameToAref(
                    &sevhist_aref, "Attribute", &attr_aref);
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_GetObjectInfoAttrref(
                    &attr_aref, &attr_aref, sizeof(attr_aref));
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_AttrrefToName(
                    &attr_aref, aname, sizeof(aname), cdh_mNName);
                if (EVEN(lsts)) {
                  break;
                }

                s = strchr(aname, '.');
                if (!s) {
                  break;
                }

                *s = 0;
                strcpy(onamev[oid_cnt], aname);
                strcpy(anamev[oid_cnt], s + 1);
                oidv[oid_cnt] = attr_aref.Objid;
                sevhistobjectv[oid_cnt] = false;
                oid_cnt++;
              } else if (cid == pwr_cClass_SevHistObject) {
                lsts = gdh_ArefANameToAref(&sevhist_aref, "Object", &attr_aref);
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_GetObjectInfoAttrref(
                    &attr_aref, &attr_aref, sizeof(attr_aref));
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_AttrrefToName(
                    &attr_aref, aname, sizeof(aname), cdh_mNName);
                if (EVEN(lsts)) {
                  break;
                }

                s = strchr(aname, '.');
                if (!s) {
                  // It is a complete object
                  anamev[oid_cnt][0] = '\0';
                } else {
                  strcpy(anamev[oid_cnt], s + 1);
                  *s = 0;
                }
                strcpy(onamev[oid_cnt], aname);
                oidv[oid_cnt] = attr_aref.Objid;
                sevhistobjectv[oid_cnt] = true;
                oid_cnt++;
              }
            }
          } else if (sevHistObjectFound) {
            lsts = gdh_ArefANameToAref(
                &mv.Action[i * rows + j].Object[0], "Object", &attr_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetObjectInfoAttrref(
                &attr_aref, &attr_aref, sizeof(attr_aref));
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_AttrrefToName(
                &attr_aref, aname, sizeof(aname), cdh_mNName);
            if (EVEN(lsts)) {
              break;
            }

            s = strchr(aname, '.');
            if (!s) {
              // It is a complete object
              anamev[oid_cnt][0] = '\0';
            } else {
              strcpy(anamev[oid_cnt], s + 1);
            }
            oidv[oid_cnt] = attr_aref.Objid;
            sevhistobjectv[oid_cnt] = true;
            strcpy(onamev[oid_cnt], "");
            sevhist_aref = mv.Action[i * rows + j].Object[0];
            oid_cnt = 1;
          } else {
            lsts = gdh_ArefANameToAref(
                &mv.Action[i * rows + j].Object[0], "Attribute", &attr_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetObjectInfoAttrref(
                &attr_aref, &attr_aref, sizeof(attr_aref));
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_AttrrefToName(
                &attr_aref, aname, sizeof(aname), cdh_mNName);
            if (EVEN(lsts)) {
              break;
            }

            s = strchr(aname, '.');
            if (!s) {
              break;
            }
            *s = 0;

            strcpy(onamev[0], aname);
            strcpy(anamev[0], s + 1);
            oidv[0] = attr_aref.Objid;
            sevhistobjectv[0] = false;
            oid_cnt = 1;
            sevhist_aref = mv.Action[i * rows + j].Object[0];
          }

          oidv[oid_cnt] = pwr_cNOid;

          // Get server and connect to server
          lsts = gdh_ArefANameToAref(&sevhist_aref, "ThreadObject", &attr_aref);
          if (EVEN(lsts)) {
            break;
          }

          lsts = gdh_GetObjectInfoAttrref(
              &attr_aref, &histthread_oid, sizeof(histthread_oid));
          if (EVEN(lsts)) {
            break;
          }

          histthread_aref = cdh_ObjidToAref(histthread_oid);
          lsts
              = gdh_ArefANameToAref(&histthread_aref, "ServerNode", &attr_aref);
          if (EVEN(lsts)) {
            break;
          }

          lsts = gdh_GetObjectInfoAttrref(
              &attr_aref, server_node, sizeof(server_node));
          if (EVEN(lsts)) {
            break;
          }

          if (!xnav->scctx) {
            sevcli_init(&lsts, &xnav->scctx);
            if (EVEN(lsts)) {
              break;
            }
          }
          sevcli_set_servernode(&lsts, xnav->scctx, server_node);
          if (EVEN(lsts)) {
            break;
          }

          QWidget* widget;
          sevhist[i * rows + j] = new XttSevHistQt(this, toplevel,
              (char*)"No title", &widget, oidv, anamev, onamev, sevhistobjectv,
              xnav->scctx, w, h, (unsigned int)curve_mOptions_Embedded,
              color_theme, time_ePeriod_, 0, sts);
          if (EVEN(*sts)) {
            comp_widget[i * rows + j]
                = error_msg("Unable to load history data", *sts);
            break;
          }

          sevhist[i * rows + j]->help_cb = multiview_trend_help_cb;
          sevhist[i * rows + j]->get_select_cb
              = multiview_sevhist_get_select_cb;

          comp_widget[i * rows + j] = widget;

          break;
        }
        case pwr_eMultiViewContentEnum_Camera: {
          pwr_sClass_XttCamera xttcamera;
          pwr_tObjid objid;
          pwr_tCid cid;

          objid = mv.Action[i * rows + j].Object[0].Objid;
          if (cdh_ObjidIsNull(objid)) {
            break;
          }

          lsts = gdh_GetObjectClass(objid, &cid);
          if (EVEN(lsts)) {
            break;
          }

          if (cid != pwr_cClass_XttCamera) {
            break;
          }

          pwr_tAttrRef aref = cdh_ObjidToAref(objid);

          lsts = gdh_GetObjectInfoAttrref(
              &aref, (pwr_tAddress)&xttcamera, sizeof(xttcamera));
          if (EVEN(lsts)) {
            break;
          }

          unsigned int options = 0;
          if (xttcamera.Options & pwr_mCameraOptionsMask_FullScreen) {
            options |= strm_mOptions_FullScreen;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_Maximize) {
            options |= strm_mOptions_Maximize;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_FullMaximize) {
            options |= strm_mOptions_FullMaximize;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_Iconify) {
            options |= strm_mOptions_Iconify;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_CameraControlPanel) {
            options |= strm_mOptions_CameraControlPanel;
          }
          if (xttcamera.Options
              & pwr_mCameraOptionsMask_HttpBasicAuthentication) {
            options |= strm_mOptions_HttpBasicAuthentication;
          }
          if (xttcamera.Options
              & pwr_mCameraOptionsMask_CgiParameterAuthentication) {
            options |= strm_mOptions_CgiParameterAuthentication;
          }

          strmctx[i * rows + j] = new XttStreamQt(toplevel, this, "No title",
              xttcamera.URL, mv.Action[i * rows + j].Width,
              mv.Action[i * rows + j].Height, 0, 0, 0, options, 1, &aref, sts);

          strmctx[i * rows + j]->close_cb = multiview_strm_close_cb;

          comp_widget[i * rows + j]
              = (QWidget*)strmctx[i * rows + j]->get_widget();

          appl.insert(applist_eType_Stream, (void*)strmctx[i * rows + j], objid,
              xttcamera.Title, xttcamera.URL);

          break;
        }
        default:;
        }

        if (mv.Action[i * rows + j].Options
            & pwr_mMultiViewElemOptionsMask_Exchangeable) {
          exchange_widget_layout[i * rows + j] = new QHBoxLayout();
          exchange_widget[i * rows + j]
              = layout_to_widget(exchange_widget_layout[i * rows + j]);
          if (comp_widget[i * rows + j]) {
            add_expanding(exchange_widget_layout[i * rows + j],
                comp_widget[i * rows + j]);
          }
          switch (mv.Layout) {
          case pwr_eMultiViewLayoutEnum_Box:
            add_expanding(row_widget_box, exchange_widget[i * rows + j]);
            break;
          case pwr_eMultiViewLayoutEnum_Fix:
            comp_widget[i * rows + j]->setMinimumSize(
                mv.Action[i * rows + j].Width, mv.Action[i * rows + j].Height);
            fixed_put(toplevel, exchange_widget[i * rows + j],
                mv.Action[i * rows + j].X, mv.Action[i * rows + j].Y);
            break;
          case pwr_eMultiViewLayoutEnum_Pane:
            if (j == 0) {
              if (row_widget_pane->widget(0) && row_widget_pane->count() == 2) {
                row_widget_pane->widget(0)->setParent(NULL);
              }
              row_widget_pane->insertWidget(0, exchange_widget[i * rows + j]);
            } else {
              if (row_widget_pane->widget(1)) {
                row_widget_pane->widget(1)->setParent(NULL);
              }
              row_widget_pane->insertWidget(1, exchange_widget[i * rows + j]);
            }
            break;
          case pwr_eMultiViewLayoutEnum_Table:
            col_widget_table->addWidget(
                exchange_widget[i * rows + j], i, j, i + 1, j + 1);
            break;
          default:;
          }
        } else {
          if (comp_widget[i * rows + j]) {
            switch (mv.Layout) {
            case pwr_eMultiViewLayoutEnum_Box:
              add_expanding(row_widget_box, comp_widget[i * rows + j]);
              break;
            case pwr_eMultiViewLayoutEnum_Fix:
              comp_widget[i * rows + j]->setMinimumSize(
                  mv.Action[i * rows + j].Width,
                  mv.Action[i * rows + j].Height);
              fixed_put(toplevel, comp_widget[i * rows + j],
                  mv.Action[i * rows + j].X, mv.Action[i * rows + j].Y);
              break;
            case pwr_eMultiViewLayoutEnum_Pane:
              if (j == 0) {
                if (row_widget_pane->widget(0)
                    && row_widget_pane->count() == 2) {
                  row_widget_pane->widget(0)->setParent(NULL);
                }
                row_widget_pane->insertWidget(0, comp_widget[i * rows + j]);
              } else {
                if (row_widget_pane->widget(1)) {
                  row_widget_pane->widget(1)->setParent(NULL);
                }
                row_widget_pane->insertWidget(1, comp_widget[i * rows + j]);
              }
              break;
            case pwr_eMultiViewLayoutEnum_Table:
              col_widget_table->addWidget(
                  comp_widget[i * rows + j], i, j, i + 1, j + 1);
            default:;
            }
          }
        }
        if (mv.Layout == pwr_eMultiViewLayoutEnum_Box
            && ((j + 1) % rows != 0
                   && mv.Options & pwr_mMultiViewOptionsMask_RowSeparators)) {
          row_widget_box->addWidget(separator(QFrame::HLine));
        }
      }

      switch (mv.Layout) {
      case pwr_eMultiViewLayoutEnum_Box: {
        add_expanding(col_widget_box, row_widget_box);
        break;
      }
      case pwr_eMultiViewLayoutEnum_Fix:
        break;
      case pwr_eMultiViewLayoutEnum_Pane: {
        if (i == 0) {
          if (col_widget_pane->widget(0) && col_widget_pane->count() == 2) {
            col_widget_pane->widget(0)->setParent(NULL);
          }
          col_widget_pane->insertWidget(0, row_widget_pane);
        } else {
          if (col_widget_pane->widget(1)) {
            col_widget_pane->widget(1)->setParent(NULL);
          }
          col_widget_pane->insertWidget(1, row_widget_pane);
        }
        break;
      }
      default:;
      }

      if (mv.Layout == pwr_eMultiViewLayoutEnum_Box
          && (i != cols - 1
                 && mv.Options & pwr_mMultiViewOptionsMask_ColumnSeparators)) {
        col_widget_box->addWidget(separator(QFrame::VLine));
      }

      if (escape) {
        break;
      }
    }

    switch (mv.Layout) {
    case pwr_eMultiViewLayoutEnum_Box:
      col_widget = layout_to_widget(col_widget_box);
      break;
    case pwr_eMultiViewLayoutEnum_Pane:
      col_widget = col_widget_pane;
      break;
    case pwr_eMultiViewLayoutEnum_Table:
      col_widget = layout_to_widget(col_widget_table);
      break;
    default:
      return;
    }

    if (!(options & ge_mOptions_Embedded)) {
      // setLayout(col_widget);
      col_widget->setParent(toplevel);
    } else {
      box_widget->layout()->addWidget(col_widget);
    }
  }

  if (!(options & ge_mOptions_Embedded)) {
    toplevel->show();

    if (!(mv_x == 0 && mv_y == 0)) {
      // Set position
      toplevel->move(mv_x, mv_y);
    } else if (!(mv.X == 0 && mv.Y == 0)) {
      // Set position from object
      toplevel->move(mv.X, mv.Y);
    }

    for (int i = 0; i < MV_SIZE; i++) {
      if (trend[i]) {
        trend[i]->setup();
      }
    }
    for (int i = 0; i < MV_SIZE; i++) {
      if (sevhist[i]) {
        sevhist[i]->setup();
      }
    }
    for (int i = 0; i < MV_SIZE; i++) {
      if (strmctx[i]) {
        strmctx[i]->setup();
      }
    }

    if (options & ge_mOptions_FullScreen
        || mv.Options & pwr_mMultiViewOptionsMask_FullScreen) {
      toplevel->showFullScreen();
    } else if (options & ge_mOptions_Maximize
        || mv.Options & pwr_mMultiViewOptionsMask_Maximize) {
      toplevel->showMaximized();
    } else if (options & ge_mOptions_FullMaximize
        || mv.Options & pwr_mMultiViewOptionsMask_FullMaximize) {
      toplevel->showMaximized();
    } else if (options & ge_mOptions_Iconify
        || mv.Options & pwr_mMultiViewOptionsMask_Iconify) {
      toplevel->showMinimized();
    } else if (options & ge_mOptions_Invisible) {
      toplevel->setVisible(false);
    }

    if (basewidget) {
      toplevel->setModal(true);
    }
  } else {
    box_widget->setMinimumSize(window_width, window_height);
  }

  *sts = XNAV__SUCCESS;
}

void* XttMultiViewQt::get_widget()
{
  if (!(options & ge_mOptions_Embedded)) {
    return toplevel;
  } else {
    return box_widget;
  }
}

int XttMultiViewQt::set_subwindow_source(const char* name, char* source,
    char* object, double* borders, int insert, int cont)
{
  pwr_sClass_XttMultiView mv;
  pwr_tStatus sts;
  int x, y, w, h;
  int scrollbar;
  int menu;
  int type;
  char comp_name[80];
  char* sub_name;

  sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(sts)) {
    return sts;
  }

  strncpy(comp_name, name, sizeof(comp_name));
  if ((sub_name = strchr(comp_name, '.'))) {
    *sub_name = 0;
    sub_name++;
  } else {
    sub_name = 0;
  }

  for (int i = 0; i < cols; i++) {
    for (int j = 0; j < rows; j++) {
      if (str_NoCaseStrcmp(comp_name, mv.Action[i * rows + j].Name) == 0) {
        if (!sub_name) {
          // Replace component
          x = 0;
          y = 0;
          w = mv.Action[i * rows + j].Width;
          h = mv.Action[i * rows + j].Height;
          scrollbar = (mv.Action[i * rows + j].Options
                          & pwr_mMultiViewElemOptionsMask_Scrollbars)
              ? 1
              : 0;
          menu = (mv.Action[i * rows + j].Options
                     & pwr_mMultiViewElemOptionsMask_Menu)
              ? 1
              : 0;
          type = mv.Action[i * rows + j].Type;

          if (!(mv.Action[i * rows + j].Options
                  & pwr_mMultiViewElemOptionsMask_Exchangeable)) {
            return 0;
          }

          switch (type) {
          case pwr_eMultiViewContentEnum_Graph:
          case pwr_eMultiViewContentEnum_ObjectGraph: {
            XttGeQt* ctx = new XttGeQt(toplevel, toplevel, "No title", source,
                scrollbar, menu, 0, w, h, x, y, 1.0, object, 0, 0,
                ge_mOptions_Embedded, 0, borders, color_theme,
                multiview_ge_command_cb, multiview_ge_get_current_objects_cb,
                multiview_ge_is_authorized_cb, multiview_keyboard_cb);

            ctx->close_cb = multiview_ge_close_cb;
            ctx->help_cb = multiview_ge_help_cb;
            ctx->display_in_xnav_cb = multiview_ge_display_in_xnav_cb;
            ctx->popup_menu_cb = multiview_ge_popup_menu_cb;
            ctx->call_method_cb = multiview_ge_call_method_cb;
            ctx->sound_cb = multiview_ge_sound_cb;
            ctx->eventlog_cb = multiview_ge_eventlog_cb;

            QWidget* comp_w = ctx->get_graph_widget();

            appl.remove((void*)gectx[i * rows + j]);

            exchange_widget_layout[i * rows + j]->removeWidget(
                comp_widget[i * rows + j]);
            comp_w->setSizePolicy(
                QSizePolicy::Expanding, QSizePolicy::Expanding);
            exchange_widget_layout[i * rows + j]->insertWidget(0, comp_w);
            exchange_widget[i * rows + j]->show();

            comp_widget[i * rows + j] = comp_w;
            gectx[i * rows + j] = ctx;
            if (insert) {
              recall_buffer[i * rows + j].insert(source, object);
            }
            appl.insert(applist_eType_Graph, (void*)gectx[i * rows + j],
                pwr_cNObjid, source, object);
            break;
          }
          case pwr_eMultiViewContentEnum_MultiView: {
            pwr_tAttrRef source_aref;

            sts = gdh_NameToAttrref(pwr_cNObjid, source, &source_aref);
            if (EVEN(sts)) {
              break;
            }

            XttMultiViewQt* ctx = new XttMultiViewQt(toplevel, this, "No title",
                &source_aref, w, h, x, y, ge_mOptions_Embedded, 0, color_theme,
                &sts, multiview_ge_command_cb,
                multiview_ge_get_current_objects_cb,
                multiview_ge_is_authorized_cb, multiview_keyboard_cb);

            ctx->close_cb = multiview_ge_close_cb;
            ctx->help_cb = multiview_ge_help_cb;
            ctx->display_in_xnav_cb = multiview_ge_display_in_xnav_cb;
            ctx->popup_menu_cb = multiview_ge_popup_menu_cb;
            ctx->call_method_cb = multiview_ge_call_method_cb;
            ctx->sound_cb = multiview_ge_sound_cb;
            ctx->eventlog_cb = multiview_ge_eventlog_cb;

            QWidget* comp_w = (QWidget*)ctx->get_widget();

            appl.remove((void*)mvctx[i * rows + j]);

            exchange_widget_layout[i * rows + j]->removeWidget(
                comp_widget[i * rows + j]);
            comp_w->setSizePolicy(
                QSizePolicy::Expanding, QSizePolicy::Expanding);
            exchange_widget_layout[i * rows + j]->insertWidget(0, comp_w);
            exchange_widget[i * rows + j]->show();

            comp_widget[i * rows + j] = comp_w;
            mvctx[i * rows + j] = ctx;

            if (insert) {
              recall_buffer[i * rows + j].insert(source, object);
            }
            appl.insert(applist_eType_MultiView, (void*)mvctx[i * rows + j],
                &source_aref, "", NULL);
            break;
          }
          case pwr_eMultiViewContentEnum_TrendCurve: {
            int plotgroup_found = 0;
            pwr_tAttrRef plotgroup;
            pwr_tCid classid;
            QWidget* comp_w;
            pwr_tAttrRef arefv[2];
            int skip = 0;
            pwr_tStatus lsts;
            pwr_tAttrRef object_aref;

            lsts = gdh_NameToAttrref(pwr_cNObjid, object, &object_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetAttrRefTid(&object_aref, &classid);
            if (EVEN(lsts)) {
              break;
            }

            switch (classid) {
            case pwr_cClass_DsTrend:
            case pwr_cClass_DsTrendCurve:
              break;
            case pwr_cClass_PlotGroup:
              plotgroup_found = 1;
              plotgroup = object_aref;
              arefv[0] = plotgroup;
              break;
            default:
              skip = 1;
            }

            if (skip) {
              break;
            }

            XttTrendQt* ctx;
            if (plotgroup_found) {
              ctx = new XttTrendQt(this, toplevel, (char*)"No title", &comp_w,
                  0, &plotgroup, w, h, (unsigned int)curve_mOptions_Embedded,
                  color_theme, 0, &lsts);
            } else {
              arefv[0] = object_aref;
              memset(&arefv[1], 0, sizeof(arefv[0]));
              ctx = new XttTrendQt(this, toplevel, (char*)"No title", &comp_w,
                  arefv, 0, w, h, (unsigned int)curve_mOptions_Embedded,
                  color_theme, 0, &lsts);
            }
            if (EVEN(lsts)) {
              break;
            }

            ctx->close_cb = multiview_trend_close_cb;
            ctx->command_cb = multiview_trend_command_cb;
            ctx->help_cb = multiview_trend_help_cb;

            appl.remove((void*)trend[i * rows + j]);

            exchange_widget_layout[i * rows + j]->removeWidget(
                comp_widget[i * rows + j]);
            comp_w->setSizePolicy(
                QSizePolicy::Expanding, QSizePolicy::Expanding);
            exchange_widget_layout[i * rows + j]->insertWidget(0, comp_w);
            exchange_widget[i * rows + j]->show();
            ctx->setup();

            comp_widget[i * rows + j] = comp_w;
            trend[i * rows + j] = ctx;

            if (insert) {
              recall_buffer[i * rows + j].insert(source, object);
            }
            appl.insert(applist_eType_Trend, (void*)trend[i * rows + j],
                &arefv[0], "", NULL);

            mv.Action[i * rows + j].Object[0] = object_aref;
            break;
          }

          case pwr_eMultiViewContentEnum_SevHistory: {
            pwr_tOid oidv[11];
            pwr_tOName anamev[11];
            pwr_tOName onamev[11];
            bool sevhistobjectv[11];
            pwr_tAttrRef attr_aref, sevhist_aref;
            char* s;
            pwr_tAName aname;
            int plotgroup_found = 0;
            int sevHistObjectFound = 0;
            int oid_cnt = 0;
            pwr_tCid classid;
            int skip = 0;
            pwr_tStatus lsts;
            QWidget* comp_w;
            pwr_tAttrRef arefv[2];
            pwr_tAttrRef plotgroup;
            pwr_tAttrRef object_aref;

            lsts = gdh_NameToAttrref(pwr_cNObjid, object, &object_aref);
            if (EVEN(lsts)) {
              break;
            }

            arefv[0] = object_aref;
            memset(&arefv[1], 0, sizeof(arefv[0]));

            lsts = gdh_GetAttrRefTid(&arefv[0], &classid);
            if (EVEN(lsts)) {
              break;
            };

            switch (classid) {
            case pwr_cClass_SevHist:
              break;
            case pwr_cClass_SevHistObject:
              sevHistObjectFound = true;
              break;
            case pwr_cClass_PlotGroup:
              plotgroup = object_aref;
              plotgroup_found = 1;
              break;
            default:
              skip = 1;
            }

            if (skip) {
              break;
            }

            if (plotgroup_found) {
              pwr_sClass_PlotGroup plot;
              pwr_tCid cid;
              int j;

              lsts = gdh_GetObjectInfoAttrref(&plotgroup, &plot, sizeof(plot));
              if (EVEN(lsts)) {
                break;
              }

              for (j = 0; j < 20; j++) {
                if (cdh_ObjidIsNull(plot.YObjectName[j].Objid)) {
                  break;
                }

                sevhist_aref = plot.YObjectName[j];
                lsts = gdh_GetAttrRefTid(&sevhist_aref, &cid);
                if (EVEN(lsts)) {
                  break;
                }

                if (cid == pwr_cClass_SevHist) {
                  lsts = gdh_ArefANameToAref(
                      &sevhist_aref, "Attribute", &attr_aref);
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_GetObjectInfoAttrref(
                      &attr_aref, &attr_aref, sizeof(attr_aref));
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_AttrrefToName(
                      &attr_aref, aname, sizeof(aname), cdh_mNName);
                  if (EVEN(lsts)) {
                    break;
                  }

                  s = strchr(aname, '.');
                  if (!s) {
                    break;
                  }

                  *s = 0;
                  strcpy(onamev[oid_cnt], aname);
                  strcpy(anamev[oid_cnt], s + 1);
                  oidv[oid_cnt] = attr_aref.Objid;
                  sevhistobjectv[oid_cnt] = false;
                  oid_cnt++;
                } else if (cid == pwr_cClass_SevHistObject) {
                  lsts = gdh_ArefANameToAref(
                      &sevhist_aref, "Object", &attr_aref);
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_GetObjectInfoAttrref(
                      &attr_aref, &attr_aref, sizeof(attr_aref));
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_AttrrefToName(
                      &attr_aref, aname, sizeof(aname), cdh_mNName);
                  if (EVEN(lsts)) {
                    break;
                  }

                  s = strchr(aname, '.');
                  if (!s) {
                    // It is a complete object
                    anamev[oid_cnt][0] = '\0';
                  } else {
                    strcpy(anamev[oid_cnt], s + 1);
                    *s = 0;
                  }
                  strcpy(onamev[oid_cnt], aname);
                  oidv[oid_cnt] = attr_aref.Objid;
                  sevhistobjectv[oid_cnt] = true;
                  oid_cnt++;
                }
              }
            } else if (sevHistObjectFound) {
              lsts = gdh_ArefANameToAref(&object_aref, "Object", &attr_aref);
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_GetObjectInfoAttrref(
                  &attr_aref, &attr_aref, sizeof(attr_aref));
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_AttrrefToName(
                  &attr_aref, aname, sizeof(aname), cdh_mNName);
              if (EVEN(lsts)) {
                break;
              }

              s = strchr(aname, '.');
              if (!s) {
                // It is a complete object
                anamev[oid_cnt][0] = '\0';
              } else {
                strcpy(anamev[oid_cnt], s + 1);
              }
              oidv[oid_cnt] = attr_aref.Objid;
              sevhistobjectv[oid_cnt] = true;
              strcpy(onamev[oid_cnt], "");
              sevhist_aref = object_aref;
              oid_cnt = 1;
            } else {
              lsts = gdh_ArefANameToAref(&object_aref, "Attribute", &attr_aref);
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_GetObjectInfoAttrref(
                  &attr_aref, &attr_aref, sizeof(attr_aref));
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_AttrrefToName(
                  &attr_aref, aname, sizeof(aname), cdh_mNName);
              if (EVEN(lsts)) {
                break;
              }

              s = strchr(aname, '.');
              if (!s) {
                break;
              }
              *s = 0;

              strcpy(onamev[0], aname);
              strcpy(anamev[0], s + 1);
              oidv[0] = attr_aref.Objid;
              sevhistobjectv[0] = false;
              oid_cnt = 1;
              sevhist_aref = object_aref;
            }

            oidv[oid_cnt] = pwr_cNOid;

            XNav* xnav = get_xnav();
            XttSevHistQt* ctx;

            if (!xnav->scctx) {
              break;
            }

            ctx = new XttSevHistQt(this, toplevel, (char*)"No title", &comp_w,
                oidv, anamev, onamev, sevhistobjectv, xnav->scctx, w, h,
                (unsigned int)curve_mOptions_Embedded, color_theme,
                time_ePeriod_, 0, &lsts);
            if (EVEN(lsts)) {
              break;
            }

            ctx->help_cb = multiview_trend_help_cb;
            ctx->get_select_cb = multiview_sevhist_get_select_cb;

            appl.remove((void*)trend[i * rows + j]);

            exchange_widget_layout[i * rows + j]->removeWidget(
                comp_widget[i * rows + j]);
            comp_w->setSizePolicy(
                QSizePolicy::Expanding, QSizePolicy::Expanding);
            exchange_widget_layout[i * rows + j]->insertWidget(0, comp_w);
            exchange_widget[i * rows + j]->show();
            ctx->setup();

            comp_widget[i * rows + j] = comp_w;
            sevhist[i * rows + j] = ctx;

            mv.Action[i * rows + j].Object[0] = object_aref;
          }
          case pwr_eMultiViewContentEnum_Camera: {
            pwr_sClass_XttCamera xttcamera;
            pwr_tStatus lsts;
            pwr_tAttrRef object_aref;

            lsts = gdh_NameToAttrref(pwr_cNObjid, object, &object_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetObjectInfoAttrref(
                &object_aref, (pwr_tAddress)&xttcamera, sizeof(xttcamera));
            if (EVEN(lsts)) {
              break;
            }

            XttStreamQt* ctx
                = new XttStreamQt(toplevel, this, "No title", xttcamera.URL, w,
                    h, 0, 0, 0, xttcamera.Options, 1, &object_aref, &lsts);

            QWidget* comp_w = (QWidget*)ctx->get_widget();

            appl.remove((void*)strmctx[i * rows + j]);

            exchange_widget_layout[i * rows + j]->removeWidget(
                comp_widget[i * rows + j]);
            comp_w->setSizePolicy(
                QSizePolicy::Expanding, QSizePolicy::Expanding);
            exchange_widget_layout[i * rows + j]->insertWidget(0, comp_w);
            exchange_widget[i * rows + j]->show();

            comp_widget[i * rows + j] = comp_w;
            strmctx[i * rows + j] = ctx;
            if (insert) {
              recall_buffer[i * rows + j].insert(source, object);
            }

            appl.insert(applist_eType_Stream, (void*)strmctx[i * rows + j],
                object_aref.Objid, xttcamera.Title, xttcamera.URL);
            break;
          }
          default:;
          }
        } else {
          // Call set_window in component
          type = mv.Action[i * rows + j].Type;

          switch (type) {
          case pwr_eMultiViewContentEnum_Graph:
          case pwr_eMultiViewContentEnum_ObjectGraph: {
            gectx[i * rows + j]->set_subwindow_source(sub_name, source, object);
            break;
          }
          case pwr_eMultiViewContentEnum_MultiView: {
            mvctx[i * rows + j]->set_subwindow_source(
                sub_name, source, object, borders, insert);
          }
          default:;
          }
        }
      }
    }
  }
  if (cont) {
    return 1;
  } else {
    return GLOW__TERMINATED;
  }
}

int XttMultiViewQt::key_pressed(int key)
{
  int sts;

  for (int i = 0; i < cols * rows; i++) {
    if (gectx[i] != 0) {
      sts = gectx[i]->key_pressed(key);
      if (ODD(sts)) {
        return sts;
      }
    } else if (mvctx[i] != 0) {
      sts = mvctx[i]->key_pressed(key);
      if (ODD(sts)) {
        return sts;
      }
    }
  }
  return 0;
}

void XttMultiViewQt::close_input_all()
{
  for (int i = 0; i < cols * rows; i++) {
    if (gectx[i] != 0) {
      gectx[i]->close_input_all();
    } else if (mvctx[i] != 0) {
      mvctx[i]->close_input_all();
    }
  }
}

void XttMultiViewQt::signal_send(char* signalname)
{
  pwr_sClass_XttMultiView mv;
  pwr_tStatus sts;

  sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(sts)) {
    return;
  }

  for (int i = 0; i < cols; i++) {
    for (int j = 0; j < rows; j++) {
      // Call signal_send in component

      switch (mv.Action[i * rows + j].Type) {
      case pwr_eMultiViewContentEnum_Graph:
      case pwr_eMultiViewContentEnum_ObjectGraph:
        gectx[i * rows + j]->signal_send(signalname);
        break;
      case pwr_eMultiViewContentEnum_MultiView: {
        mvctx[i * rows + j]->signal_send(signalname);
        break;
      }
      default:;
      }
    }
  }
}