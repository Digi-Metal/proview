/*
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "pwr_baseclasses.h"

#include "co_dcli.h"
#include "co_math.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_qt_helpers.h"

#include "xtt_stream_qt.h"

#include <QHBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QPainter>

#include <phonon/MediaObject>
#include <phonon/MediaSource>

/* This function is called when the main window is closed */
void XttStreamQtWidget::closeEvent(QCloseEvent* event)
{
  debug_print("XttStreamQtWidget::closeEvent\n");
  stream->playbin2->stop();

  if (stream->close_cb) {
    (stream->close_cb)(stream->parent_ctx, stream);
  }
  delete stream;

  QWidget::closeEvent(event);
}

/* This function is called when the slider changes its position. We perform a
 * seek to the
 * new position here. */
void XttStreamQtWidget::slider_cb(int value)
{
  stream->playbin2->seek(value * 1000);
}

static void refresh_ui(XttStreamQt* strm)
{
  if (!(strm->options & strm_mOptions_VideoControlPanel
          && strm->options & strm_mOptions_VideoProgressBar)) {
    return;
  }

  /* We do not want to update anything unless we are in the PAUSED or PLAYING
   * states */
  if (strm->state != Phonon::PausedState) {
    return;
  }

  qint64 current = strm->playbin2->totalTime();
  strm->slider->setRange(0, current / 1000);
}

void XttStreamQt::erase_window()
{
  QWidget* window = video_form->window();
  QPainter painter(window);
  painter.eraseRect(0, 0, toplevel->width(), toplevel->height());
}

void XttStreamQt::reconnect(void* data)
{
  XttStreamQt* strm = (XttStreamQt*)data;

  printf("Try to reconnect %d\n", strm->playbin2->mediaObject()->state());

  if (strm->playbin2->mediaObject()->state() == Phonon::PlayingState) {
    return;
  }

  printf("Adding reconnect\n");
  strm->reconnect_timerid->remove();
  strm->reconnect_timerid->add(
      int(strm->reconnect_time * 1000), reconnect, strm);

  if (strm->no_uri) {
    printf("Reconnect no URI\n");
    strm->no_uri = 0;
    pwr_tURL luri;
    char* s;
    if (strm->options & strm_mOptions_HttpBasicAuthentication) {
      if (!streq(strm->user, "") && !streq(strm->password, "")
          && (s = strstr(strm->uri, "://"))) {
        unsigned long int offs = s - (char*)strm->uri + 3;
        strncpy(luri, strm->uri, offs);
        luri[offs] = 0;
        strcat(luri, strm->user);
        strcat(luri, ":");
        strcat(luri, strm->password);
        strcat(luri, "@");
        strcat(luri, &strm->uri[offs]);
      } else {
        strcpy(luri, strm->uri);
      }
    } else if (strm->options & strm_mOptions_CgiParameterAuthentication) {
      snprintf(luri, sizeof(luri), "%s?user=%s&pwd=%s", strm->uri, strm->user,
          strm->password);
    } else {
      strcpy(luri, strm->uri);
    }

    strm->playbin2->load(Phonon::MediaSource(QUrl(fl(luri))));
  } else {
    strm->playbin2->play();
  }
}

static void refresh(void* data)
{
  XttStreamQt* strm = (XttStreamQt*)data;

  refresh_ui(strm);

  strm->timerid->add(strm->scan_time, refresh, data);
}

/* This function is called when an error message is posted on the bus */
void XttStreamQtWidget::error_cb(Phonon::ErrorType error)
{
  printf("Message %d\n", error);
  /* Print error details on the screen */
  printf("Error received from element: %s\n",
      qPrintable(stream->playbin2->mediaObject()->errorString()));

  if (error == Phonon::FatalError) {
    stream->no_uri = 1;
  }

  stream->playbin2->stop();

  // Erase window
  stream->erase_window();

  // Try to reconnect
  stream->reconnect_timerid->remove();
  stream->reconnect_timerid->add(
      int(stream->reconnect_time * 1000), stream->reconnect, stream);
}

/* This function is called when the pipeline changes states. We use it to
 * keep track of the current state. */
void XttStreamQtWidget::state_changed_cb(Phonon::State new_state)
{
  if (stream->state == Phonon::StoppedState
      && new_state == Phonon::PausedState) {
    /* For extra responsiveness, we refresh the GUI as soon as we reach the
     * PAUSED state */
    update();
  }
  stream->state = new_state;
}

void XttStreamQtWidget::resizeEvent(QResizeEvent* event)
{
  if (event->size().width() > event->size().height() * stream->stream_ratio) {
    stream->x_offset = (event->size().width()
                           - event->size().height() * stream->stream_ratio)
        / 2;
    stream->y_offset = 0;
  } else {
    stream->x_offset = 0;
    stream->y_offset
        = (event->size().height()
              - ((float)event->size().width()) / stream->stream_ratio)
        / 2;
  }
}

void XttStreamQt::togglePtzBoxVisible()
{
  if (ptz_box_displayed) {
    ptz_box->setVisible(false);
    ptz_box_displayed = 0;
  }
}

void XttStreamQtWidget::mousePressEvent(QMouseEvent* event)
{
  switch (event->button()) {
  case Qt::LeftButton:
    time_GetTime(&stream->mb_press_time);
    stream->mb_press_x = event->pos().x();
    stream->mb_press_y = event->pos().y();
    break;
  case Qt::RightButton: {
    int x1, y1;
    int x = event->pos().x() + 8;
    int y = event->pos().y();
    CoWowQt::PopupPosition(stream->video_form, x, y, &x1, &y1);
    stream->action_mb3click(x1, y1);
    stream->togglePtzBoxVisible();
    break;
  }
  default:
    break;
  }

  QWidget::mousePressEvent(event);
}

void XttStreamQtWidget::mouseReleaseEvent(QMouseEvent* event)
{
  // Calculate offset for video image
  if (width() == 0 || height() == 0 || stream->width == 0
      || stream->height == 0) {
    QWidget::mouseReleaseEvent(event);
    return;
  }

  int offset_x, offset_y;

  if ((double)width() / height() > (double)stream->width / stream->height) {
    offset_x
        = (width() - (double)stream->width / stream->height * height()) / 2;
    offset_y = 0;
  } else {
    offset_x = 0;
    offset_y
        = (height() - (double)stream->height / stream->width * width()) / 2;
  }

  switch (event->button()) {
  case Qt::LeftButton: {
    pwr_tTime now;
    pwr_tDeltaTime dt;
    pwr_tFloat32 dft;

    time_GetTime(&now);
    time_Adiff(&dt, &now, &stream->mb_press_time);
    dft = time_DToFloat(&dft, &dt);
    if (dft < 0.5 && ABS(event->pos().x() - stream->mb_press_x) < 10
        && ABS(event->pos().y() - stream->mb_press_y) < 10) {
      stream->action_click(
          event->pos().x() - offset_x, event->pos().y() - offset_y);
      stream->togglePtzBoxVisible();
    } else if (ABS(event->pos().x() - stream->mb_press_x) > 20
        && abs(event->pos().y() - stream->mb_press_y) > 20) {
      int x = MIN(event->pos().x(), stream->mb_press_x) - offset_x;
      int y = MIN(event->pos().y(), stream->mb_press_y) - offset_y;
      int w = ABS(event->pos().x() - stream->mb_press_x);
      int h = ABS(event->pos().y() - stream->mb_press_y);
      printf("Mb zoom (%d,%d) rect %d,%d\n", x, y, w, h);
      stream->action_areaselect(x, y, w, h);
      stream->togglePtzBoxVisible();
    }
    break;
  }
  case Qt::MidButton: {
    int x = MIN(event->pos().x(), stream->mb_press_x) - offset_x;
    int y = MIN(event->pos().y(), stream->mb_press_y) - offset_y;
    stream->action_mb2click(x, y);
    break;
  }
  default:
    break;
  }

  QWidget::mouseReleaseEvent(event);
}

void XttStreamQtWidget::wheelEvent(QWheelEvent* event)
{
  // Calculate offset for video image
  if (width() == 0 || height() == 0 || stream->width == 0
      || stream->height == 0) {
    QWidget::wheelEvent(event);
    return;
  }

  int offset_x, offset_y;

  if ((double)width() / height() > (double)stream->width / stream->height) {
    offset_x
        = (width() - (double)stream->width / stream->height * height()) / 2;
    offset_y = 0;
  } else {
    offset_x = 0;
    offset_y
        = (height() - (double)stream->height / stream->width * width()) / 2;
  }

  stream->scroll_timerid->remove();
  stream->scroll_timerid->add(600, stream->scroll_cb, stream);
  stream->scroll_direction = event->delta() > 0 ? 1 : 0;
  stream->scroll_x = event->pos().x() - offset_x;
  stream->scroll_y = event->pos().y() - offset_y;
  stream->scroll_cnt++;

  QWidget::wheelEvent(event);
}

void XttStreamQt::scroll_cb(void* data)
{
  XttStreamQt* strm = (XttStreamQt*)data;

  strm->action_scroll(
      strm->scroll_direction, strm->scroll_x, strm->scroll_y, strm->scroll_cnt);
  strm->scroll_cnt = 0;
  strm->togglePtzBoxVisible();
}

static QAction* addToolItemSpecial(QObject* parent, QToolBar* tools,
    QString& tooltip, const char* callback, const char* iconName)
{
  QIcon icon = QIcon::fromTheme(fl(iconName));
  if (icon.isNull()) { // iconName is a path to a local icon
    pwr_tFileName fname;
    dcli_translate_filename(fname, iconName);
    icon = QIcon(fl(fname));
  }
  QAction* action = new QAction(icon, "", parent);

  action->setToolTip(tooltip);

  QObject::connect(action, SIGNAL(triggered()), parent, callback);

  tools->addAction(action);

  return action;
}

QAction* XttStreamQt::addToolItemSpecial(QToolBar* tools, const char* objName,
    const char* tooltip, const char* callback, const char* iconName)
{
  pwr_tAttrRef aaref;
  pwr_tStatus lsts;
  lsts = gdh_ArefANameToAref(&aref, objName, &aaref);
  char tooltiptext[80];
  if (ODD(lsts)) {
    lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
  }

  QString text;
  if (ODD(lsts) && !streq(tooltiptext, "")) {
    text = convert_utf8(tooltiptext);
  } else {
    text = translate_utf8(tooltip);
  }
  return ::addToolItemSpecial(toplevel, tools, text, callback, iconName);
}

XttStreamQt::XttStreamQt(QWidget* st_parent_wid, void* st_parent_ctx,
    const char* name, const char* st_uri, int width, int height, int x, int y,
    double scan_time, unsigned int st_options, int st_embedded,
    pwr_tAttrRef* st_arp, pwr_tStatus* sts)
    : XttStream(st_parent_ctx, name, st_uri, width, height, x, y, scan_time,
          st_options, st_embedded, st_arp),
      scroll_cnt(0), ptz_box_displayed(0), is_live(0), buftime(pwr_cNTime),
      ptz_box(0), reconnect_timerid(0), no_uri(0)
{
  if (width == 0 || height == 0) {
    width = 640;
    height = 480;
  }

  toplevel = new XttStreamQtWidget(this, st_parent_wid);

  /* Create the elements */
  playbin2 = new Phonon::VideoPlayer(toplevel);

  /* Set the URI to play, eg "http://192.168.67.248/mjpg/video.mjpg" */
  pwr_tURL luri;
  char* s;
  if (options & strm_mOptions_HttpBasicAuthentication) {
    if (!streq(user, "") && !streq(password, "")
        && (s = strstr(uri, "://"))) {
      unsigned long int offs = s - (char*)uri + 3;
      strncpy(luri, uri, offs);
      luri[offs] = 0;
      strcat(luri, user);
      strcat(luri, ":");
      strcat(luri, password);
      strcat(luri, "@");
      strcat(luri, &uri[offs]);
    } else {
      strcpy(luri, uri);
    }
  } else if (options & strm_mOptions_CgiParameterAuthentication) {
    snprintf(luri, sizeof(luri), "%s?user=%s&pwd=%s", uri, user, password);
  } else {
    strcpy(luri, uri);
  }

  playbin2->load(Phonon::MediaSource(QUrl(fl(luri))));

  // Set timeout for connection
  /*
  int tmo = (int) (connection_timeout + 0.5);

  QNetworkConfiguration *source = playbin2->currentNetworkConfiguration();
  source->setConnectTimeout(tmo);
  */

  if (!embedded) {
    toplevel->setToolTip(fl("xtt_stream widget"));
    toplevel->setWindowTitle(QString::fromLatin1(name));
    toplevel->setAttribute(Qt::WA_DeleteOnClose);

    CoWowQt::SetWindowIcon(toplevel);
  }

  video_form = new Phonon::VideoWidget(toplevel);

  QHBoxLayout* hbox = new QHBoxLayout();
  if (options & strm_mOptions_VideoControlPanel) {
    QToolBar* controlbuttons = new QToolBar();

    addToolItem(playbin2, controlbuttons, "Play",
        SLOT(Phonon::VideoPlayer::play()), "$pwr_exe/xtt_play.png");
    addToolItem(playbin2, controlbuttons, "Pause",
        SLOT(Phonon::VideoPlayer::pause()), "$pwr_exe/xtt_pause.png");
    addToolItem(playbin2, controlbuttons, "Stop",
        SLOT(Phonon::VideoPlayer::stop()), "$pwr_exe/xtt_stop.png");

    hbox->addWidget(controlbuttons);

    if (options & strm_mOptions_VideoProgressBar) {
      slider = new QSlider(Qt::Horizontal);
      slider->setRange(0, 100);
      slider->setSliderPosition(0);
      QObject::connect(
          slider, SIGNAL(sliderMoved(int)), toplevel, SLOT(slider_cb(int)));
      add_expanding(hbox, slider);
    }
  }

  tools = new QToolBar();

  QHBoxLayout* tools_box = new QHBoxLayout();
  if (control_protocol != pwr_eCameraControlEnum_No) {
    addToolItem(toplevel, tools, "Zoom in", SLOT(activate_zoomin()),
        "$pwr_exe/xtt_zoom_in.png");
    addToolItem(toplevel, tools, "Zoom out", SLOT(activate_zoomout()),
        "$pwr_exe/xtt_zoom_out.png");
    addToolItem(toplevel, tools, "Zoom reset", SLOT(activate_zoomreset()),
        "$pwr_exe/xtt_zoom_reset.png");

    tools->addSeparator();

    addToolItem(toplevel, tools, "Page left", SLOT(activate_page_left()),
        "$pwr_exe/ge_page_left.png");
    addToolItem(toplevel, tools, "Left", SLOT(activate_scroll_left()),
        "$pwr_exe/ge_scroll_left.png");
    addToolItem(toplevel, tools, "Right", SLOT(activate_scroll_right()),
        "$pwr_exe/ge_scroll_right.png");
    addToolItem(toplevel, tools, "Page right", SLOT(activate_page_right()),
        "$pwr_exe/ge_page_right.png");

    tools->addSeparator();

    addToolItem(toplevel, tools, "Page down", SLOT(activate_page_down()),
        "$pwr_exe/ge_page_down.png");
    addToolItem(toplevel, tools, "Down", SLOT(activate_scroll_down()),
        "$pwr_exe/ge_scroll_down.png");
    addToolItem(toplevel, tools, "Up", SLOT(activate_scroll_up()),
        "$pwr_exe/ge_scroll_up.png");
    addToolItem(toplevel, tools, "Page up", SLOT(activate_page_up()),
        "$pwr_exe/ge_page_up.png");

    tools->addSeparator();

    for (int i = 0; i < 10; i++) {
      QString text1, text2, text3;
      text1 = "PresetPosition[";
      text1 += QString::number(i);
      text1 += "].Description";
      text2 = "Preset position ";
      text2 += QString::number(i + 1);
      text3 = "$pwr_exe/xtt_pos";
      text3 += QString::number(i + 1);
      text3 += ".png";
      QAction* a
          = addToolItemSpecial(tools, qPrintable(text1), qPrintable(text2),
              SLOT(activate_preset_position()), qPrintable(text3));
      a->setData(i);
    }

    tools->addSeparator();

    QString txt = translate_utf8("Get position");
    ::addToolItemSpecial(toplevel, tools, txt, SLOT(activate_get_position()),
        "$pwr_exe/xtt_get_pos.png");

    QWidget* ptz_pan_label = new QLabel("Pan");
    ptz_pan = new QLabel("0");
    QWidget* ptz_tilt_label = new QLabel("Tilt");
    ptz_tilt = new QLabel("0");
    QWidget* ptz_zoom_label = new QLabel("Zoom");
    ptz_zoom = new QLabel("0");

    QHBoxLayout* ptz_box_layout = new QHBoxLayout();
    ptz_box_layout->addWidget(ptz_pan_label);
    ptz_box_layout->addWidget(ptz_pan);
    ptz_box_layout->addWidget(separator(QFrame::VLine));
    ptz_box_layout->addWidget(ptz_tilt_label);
    ptz_box_layout->addWidget(ptz_tilt);
    ptz_box_layout->addWidget(separator(QFrame::VLine));
    ptz_box_layout->addWidget(ptz_zoom_label);
    ptz_box_layout->addWidget(ptz_zoom);

    ptz_box = layout_to_widget(ptz_box_layout);

    add_expanding(tools_box, tools);
    tools_box->addWidget(ptz_box);
  } else {
    // Empty toolbar
    tools->setFixedHeight(32);
    add_expanding(tools_box, tools);
  }

  QVBoxLayout* main_box_layout = new QVBoxLayout(toplevel);
  main_box_layout->addLayout(tools_box);
  add_expanding(main_box_layout, video_form);
  if (options & strm_mOptions_VideoControlPanel) {
    main_box_layout->addLayout(hbox);
  }

  if (!embedded) {
    toplevel->setLayout(main_box_layout);
    toplevel->setMinimumSize(width, height);
    toplevel->show();

    setup();

    if (options & strm_mOptions_FullScreen) {
      toplevel->showFullScreen();
    } else if (options & strm_mOptions_Maximize) {
      toplevel->showMaximized();
    } else if (options & strm_mOptions_FullMaximize) {
      toplevel->showMaximized();
    } else if (options & strm_mOptions_Iconify) {
      toplevel->showMinimized();
    }
  } else {
    main_box = layout_to_widget(main_box_layout);
    main_box->setMinimumSize(width, height);
    setup();
  }

  /* Connect to the interesting signals */
  QObject::connect(playbin2, SIGNAL(error(QMediaPlayer::Error)), toplevel,
      SLOT(error_cb(QMediaPlayer::Error)));
  QObject::connect(playbin2, SIGNAL(stateChanged(QMediaPlayer::State)),
      toplevel, SLOT(state_changed_cb(QMediaPlayer::State)));

  /* Start playing */
  playbin2->play();
  if (playbin2->mediaObject()->state() != Phonon::PlayingState) {
    fprintf(stderr, "Unable to set the pipeline to the playing state.\n");
    *sts = 0;
    return;
  } else {
    is_live = 1;
  }

  wow = new CoWowQt(toplevel);
  timerid = wow->timer_new();
  scroll_timerid = wow->timer_new();
  reconnect_timerid = wow->timer_new();
  timerid->add(scan_time, refresh, this);

  *sts = XNAV__SUCCESS;
}

XttStreamQt::~XttStreamQt()
{
  debug_print("XttStreamQt::~XttStreamQt\n");
  if (timerid) {
    timerid->remove();
  }
  if (scroll_timerid) {
    scroll_timerid->remove();
  }
  if (reconnect_timerid) {
    reconnect_timerid->remove();
  }
}

void XttStreamQt::pop()
{
  ::pop(toplevel);
}

void XttStreamQt::set_size(int width, int height)
{
  toplevel->resize(width, height);
}

void XttStreamQt::setup()
{
  if (ptz_box) {
    ptz_box->setVisible(false);
  }
  if (!(options & strm_mOptions_CameraControlPanel)) {
    tools->setVisible(false);
  }
}

void XttStreamQt::create_popup_menu(int x, int y)
{
  QMenu* menu = new QMenu(toplevel);

  addMenuItem(toplevel, menu, "Zoom in", SLOT(activate_zoomin()));
  addMenuItem(toplevel, menu, "Zoom out", SLOT(activate_zoomout()));
  addMenuItem(toplevel, menu, "Zoom reset", SLOT(activate_zoomreset()));

  QMenu* menu_preset_store = menu->addMenu("Preset store");
  for (int i = 0; i < 10; i++) {
    QString text;
    text += "Position ";
    text += QString::number(i + 1);
    QAction* a = addMenuItem(toplevel, menu_preset_store, qPrintable(text),
        SLOT(activate_preset_store_pos()));
    a->setData(i);
  }

  popupmenu_x = x + 5;
  popupmenu_y = y;
  menu->popup(toplevel->mapToGlobal(
      QPoint(toplevel->width() / 2, toplevel->height() / 2)));
}

void XttStreamQtWidget::zoom_helper(int value)
{
  if (!stream->camera_control) {
    return;
  }

  if (value == 0) {
    stream->camera_control->zoom_absolute(value);
  } else {
    stream->camera_control->zoom_relative(value);
  }
  stream->togglePtzBoxVisible();
}

void XttStreamQtWidget::activate_zoomreset()
{
  zoom_helper(0);
}

void XttStreamQtWidget::activate_zoomin()
{
  zoom_helper(5);
}

void XttStreamQtWidget::activate_zoomout()
{
  zoom_helper(-5);
}

void XttStreamQtWidget::pan_helper(int value)
{
  if (!stream->camera_control) {
    return;
  }

  stream->camera_control->pan_relative(value);
  stream->togglePtzBoxVisible();
}

void XttStreamQtWidget::activate_scroll_left()
{
  pan_helper(-3);
}

void XttStreamQtWidget::activate_scroll_right()
{
  pan_helper(3);
}

void XttStreamQtWidget::activate_page_left()
{
  pan_helper(-15);
}

void XttStreamQtWidget::activate_page_right()
{
  pan_helper(15);
}

void XttStreamQtWidget::tilt_helper(int value)
{
  if (!stream->camera_control) {
    return;
  }

  stream->camera_control->tilt_relative(value);
  stream->togglePtzBoxVisible();
}

void XttStreamQtWidget::activate_scroll_down()
{
  tilt_helper(-3);
}

void XttStreamQtWidget::activate_scroll_up()
{
  tilt_helper(3);
}

void XttStreamQtWidget::activate_page_down()
{
  tilt_helper(-15);
}

void XttStreamQtWidget::activate_page_up()
{
  tilt_helper(15);
}

void XttStreamQtWidget::activate_preset_position()
{
  int idx = ((QAction*)sender())->data().toInt();
  stream->activate_preset_position(idx);
  stream->togglePtzBoxVisible();
}

void XttStreamQtWidget::activate_preset_store_pos()
{
  int idx = ((QAction*)sender())->data().toInt();
  stream->activate_preset_store_pos(idx);
  stream->togglePtzBoxVisible();
}

void XttStreamQtWidget::activate_get_position()
{
  double pan, tilt, zoom;
  int sts;
  char pan_str[20], tilt_str[20], zoom_str[20];

  if (!stream->camera_control) {
    return;
  }

  sts = stream->camera_control->get_position(&pan, &tilt, &zoom);
  if (EVEN(sts)) {
    return;
  }

  sprintf(pan_str, "%6.2f", pan);
  sprintf(tilt_str, "%6.2f", tilt);
  sprintf(zoom_str, "%6.2f", zoom);
  stream->ptz_pan->setText(pan_str);
  stream->ptz_tilt->setText(tilt_str);
  stream->ptz_zoom->setText(zoom_str);

  stream->togglePtzBoxVisible();
}