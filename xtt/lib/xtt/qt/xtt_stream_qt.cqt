/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "pwr_baseclasses.h"

#include "co_dcli.h"
#include "co_math.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_qt_helpers.h"

#include "xtt_stream_qt.h"

#include <QHBoxLayout>
#include <QLabel>
#include <QMenu>
#include <QPainter>

#include <phonon/MediaObject>
#include <phonon/MediaSource>

/* This function is called when the main window is closed */
void XttStreamQtWidget::closeEvent(QCloseEvent* event)
{
  stream->playbin2->stop();

  if (stream->close_cb) {
    (stream->close_cb)(stream->parent_ctx, stream);
  }
  delete stream;

  QWidget::closeEvent(event);
}

/* This function is called when the slider changes its position. We perform a
 * seek to the
 * new position here. */
void XttStreamQtWidget::slider_cb(int value)
{
  stream->playbin2->seek(value * 1000);
}

static void refresh_ui(XttStreamQt* strm)
{
  if (!(strm->options & strm_mOptions_VideoControlPanel
          && strm->options & strm_mOptions_VideoProgressBar)) {
    return;
  }

  /* We do not want to update anything unless we are in the PAUSED or PLAYING
   * states */
  if (!(strm->state == Phonon::PausedState || strm->state == Phonon::PlayingState)) {
    return;
  }

  qint64 current = strm->playbin2->totalTime();
  strm->slider->setRange(0, current / 1000);
  strm->toplevel->update();
}

void XttStreamQt::erase_window()
{
  QPainter painter(toplevel->window());
  painter.eraseRect(0, 0, toplevel->window()->width(), toplevel->window()->height());
}

void XttStreamQt::reconnect(void* data)
{
  XttStreamQt* strm = (XttStreamQt*)data;

  printf("Try to reconnect %d 1\n", strm->playbin2->mediaObject()->state());

  if (strm->playbin2->mediaObject()->state() == Phonon::PlayingState) {
    return;
  }

  printf("Adding reconnect\n");
  strm->reconnect_timerid->remove();
  strm->reconnect_timerid->add(
      int(strm->reconnect_time * 1000), reconnect, strm);

  if (strm->no_uri) {
    printf("Reconnect no URI\n");
    strm->no_uri = 0;
    pwr_tURL luri;
    char* s;
    if (strm->options & strm_mOptions_HttpBasicAuthentication) {
      if (!streq(strm->user, "") && !streq(strm->password, "")
          && (s = strstr(strm->uri, "://"))) {
        unsigned long int offs = s - (char*)strm->uri + 3;
        strncpy(luri, strm->uri, offs);
        luri[offs] = 0;
        strcat(luri, strm->user);
        strcat(luri, ":");
        strcat(luri, strm->password);
        strcat(luri, "@");
        strcat(luri, &strm->uri[offs]);
      } else {
        strcpy(luri, strm->uri);
      }
    } else if (strm->options & strm_mOptions_CgiParameterAuthentication) {
      snprintf(luri, sizeof(luri), "%s?user=%s&pwd=%s", strm->uri, strm->user,
          strm->password);
    } else {
      strcpy(luri, strm->uri);
    }

    strm->playbin2->load(Phonon::MediaSource(QUrl(fl(luri))));
  } else {
    strm->playbin2->play();
  }
}

static void refresh(void* data)
{
  XttStreamQt* strm = (XttStreamQt*)data;

  refresh_ui(strm);

  strm->timerid->add(strm->scan_time, refresh, data);
}

/* This function is called when the pipeline changes states. We use it to
 * keep track of the current state. */
void XttStreamQtWidget::state_changed_cb(Phonon::State new_state, Phonon::State old_state)
{
  if (new_state == Phonon::ErrorState) {
    printf("Error: %s\n", qPrintable(stream->playbin2->mediaObject()->errorString()));

    if (stream->playbin2->mediaObject()->errorType() == Phonon::FatalError) {
      stream->no_uri = 1;
    }

    stream->playbin2->stop();

    // Erase window
    stream->erase_window();

    // Try to reconnect
    stream->reconnect_timerid->remove();
    stream->reconnect_timerid->add(
        int(stream->reconnect_time * 1000), stream->reconnect, stream);
  }
  if (stream->state == Phonon::StoppedState
      && new_state == Phonon::PausedState) {
    /* For extra responsiveness, we refresh the GUI as soon as we reach the
     * PAUSED state */
    refresh_ui(stream);
  }
  stream->state = new_state;
}

void XttStreamQtWidget::resizeEvent(QResizeEvent* event)
{
  if (event->size().width() > event->size().height() * stream->stream_ratio) {
    stream->x_offset = (event->size().width()
                           - event->size().height() * stream->stream_ratio)
        / 2;
    stream->y_offset = 0;
  } else {
    stream->x_offset = 0;
    stream->y_offset
        = (event->size().height()
              - ((float)event->size().width()) / stream->stream_ratio)
        / 2;
  }
}

void XttStreamQt::hidePtz()
{
  if (ptz_box != NULL) {
    ptz_box->setVisible(false);
  }
}

void XttStreamQtWidget::mousePressEvent(QMouseEvent* event)
{
  switch (event->button()) {
  case Qt::LeftButton:
    time_GetTime(&stream->mb_press_time);
    stream->mb_press_x = event->pos().x();
    stream->mb_press_y = event->pos().y();
    break;
  case Qt::RightButton: {
    int x = event->globalPos().x() + 8;
    int y = event->globalPos().y();
    stream->action_mb3click(x, y);
    stream->hidePtz();
    break;
  }
  default:
    break;
  }

  QWidget::mousePressEvent(event);
}

void XttStreamQtWidget::mouseReleaseEvent(QMouseEvent* event)
{
  // Calculate offset for video image
  if (width() == 0 || height() == 0 || stream->width == 0
      || stream->height == 0) {
    QWidget::mouseReleaseEvent(event);
    return;
  }

  int offset_x, offset_y;

  if ((double)width() / height() > (double)stream->width / stream->height) {
    offset_x
        = (width() - (double)stream->width / stream->height * height()) / 2;
    offset_y = 0;
  } else {
    offset_x = 0;
    offset_y
        = (height() - (double)stream->height / stream->width * width()) / 2;
  }

  switch (event->button()) {
  case Qt::LeftButton: {
    pwr_tTime now;
    pwr_tDeltaTime dt;
    pwr_tFloat32 dft;

    time_GetTime(&now);
    time_Adiff(&dt, &now, &stream->mb_press_time);
    dft = time_DToFloat(&dft, &dt);
    if (dft < 0.5 && ABS(event->pos().x() - stream->mb_press_x) < 10
        && ABS(event->pos().y() - stream->mb_press_y) < 10) {
      stream->action_click(
          event->pos().x() - offset_x, event->pos().y() - offset_y);
      stream->hidePtz();
    } else if (ABS(event->pos().x() - stream->mb_press_x) > 20
        && abs(event->pos().y() - stream->mb_press_y) > 20) {
      int x = MIN(event->pos().x(), stream->mb_press_x) - offset_x;
      int y = MIN(event->pos().y(), stream->mb_press_y) - offset_y;
      int w = ABS(event->pos().x() - stream->mb_press_x);
      int h = ABS(event->pos().y() - stream->mb_press_y);
      printf("Mb zoom (%d,%d) rect %d,%d\n", x, y, w, h);
      stream->action_areaselect(x, y, w, h);
      stream->hidePtz();
    }
    break;
  }
  case Qt::MidButton: {
    int x = MIN(event->pos().x(), stream->mb_press_x) - offset_x;
    int y = MIN(event->pos().y(), stream->mb_press_y) - offset_y;
    stream->action_mb2click(x, y);
    break;
  }
  default:
    break;
  }

  QWidget::mouseReleaseEvent(event);
}

void XttStreamQtWidget::wheelEvent(QWheelEvent* event)
{
  // Calculate offset for video image
  if (width() == 0 || height() == 0 || stream->width == 0
      || stream->height == 0) {
    QWidget::wheelEvent(event);
    return;
  }

  int offset_x, offset_y;

  if ((double)width() / height() > (double)stream->width / stream->height) {
    offset_x
        = (width() - (double)stream->width / stream->height * height()) / 2;
    offset_y = 0;
  } else {
    offset_x = 0;
    offset_y
        = (height() - (double)stream->height / stream->width * width()) / 2;
  }

  stream->scroll_timerid->remove();
  stream->scroll_timerid->add(600, stream->scroll_cb, stream);
  stream->scroll_direction = event->delta() > 0 ? 1 : 0;
  stream->scroll_x = event->pos().x() - offset_x;
  stream->scroll_y = event->pos().y() - offset_y;
  stream->scroll_cnt++;

  QWidget::wheelEvent(event);
}

void XttStreamQt::scroll_cb(void* data)
{
  XttStreamQt* stream = (XttStreamQt*)data;

  stream->action_scroll(
      stream->scroll_direction, stream->scroll_x, stream->scroll_y, stream->scroll_cnt);
  stream->scroll_cnt = 0;
  stream->hidePtz();
}

XttStreamQt::XttStreamQt(void* st_parent_ctx, const char* name,
    const char* st_uri, int width, int height, int x, int y, double scan_time,
    unsigned int st_options, int st_embedded, pwr_tAttrRef* st_arp,
    pwr_tStatus* sts) : XttStream(st_parent_ctx, name, st_uri, width, height,
    x, y, scan_time, st_options, st_embedded, st_arp), scroll_cnt(0), no_uri(0)
{
  if (width == 0 || height == 0) {
    width = 640;
    height = 480;
  }

  toplevel = new XttStreamQtWidget(this);

  /* Create the elements */
  playbin2 = new Phonon::VideoPlayer(toplevel);
  QObject::connect(playbin2->mediaObject(), SIGNAL(stateChanged(Phonon::State, Phonon::State)),
      toplevel, SLOT(state_changed_cb(Phonon::State, Phonon::State)));

  /* Set the URI to play, eg "http://192.168.67.248/mjpg/video.mjpg" */
  pwr_tURL luri;
  char* s;
  if (options & strm_mOptions_HttpBasicAuthentication) {
    if (!streq(user, "") && !streq(password, "")
        && (s = strstr(uri, "://"))) {
      unsigned long int offs = s - (char*)uri + 3;
      strncpy(luri, uri, offs);
      luri[offs] = 0;
      strcat(luri, user);
      strcat(luri, ":");
      strcat(luri, password);
      strcat(luri, "@");
      strcat(luri, &uri[offs]);
    } else {
      strcpy(luri, uri);
    }
  } else if (options & strm_mOptions_CgiParameterAuthentication) {
    snprintf(luri, sizeof(luri), "%s?user=%s&pwd=%s", uri, user, password);
  } else {
    strcpy(luri, uri);
  }

  playbin2->load(Phonon::MediaSource(QUrl(fl(luri))));

  if (!embedded) {
    toplevel->setWindowTitle(QString::fromLatin1(name));
    toplevel->setAttribute(Qt::WA_DeleteOnClose);

    CoWowQt::SetWindowIcon(toplevel);
  }

  QVBoxLayout* main_layout = new QVBoxLayout(toplevel);
  if (control_protocol != pwr_eCameraControlEnum_No) {
    QToolBar* tools = new QToolBar();
    QAction* a = addToolItem(toplevel, tools, "Zoom in", SLOT(zoom_helper()),
        "$pwr_exe/xtt_zoom_in.png");
    a->setData(5);
    a = addToolItem(toplevel, tools, "Zoom out", SLOT(zoom_helper()),
        "$pwr_exe/xtt_zoom_out.png");
    a->setData(-5);
    a = addToolItem(toplevel, tools, "Zoom reset", SLOT(zoom_helper()),
        "$pwr_exe/xtt_zoom_reset.png");
    a->setData(0);

    tools->addSeparator();

    a = addToolItem(toplevel, tools, "Page left", SLOT(pan_helper()),
        "$pwr_exe/ge_page_left.png");
    a->setData(-15);
    a = addToolItem(toplevel, tools, "Left", SLOT(pan_helper()),
        "$pwr_exe/ge_scroll_left.png");
    a->setData(-3);
    a = addToolItem(toplevel, tools, "Right", SLOT(pan_helper()),
        "$pwr_exe/ge_scroll_right.png");
    a->setData(3);
    a = addToolItem(toplevel, tools, "Page right", SLOT(pan_helper()),
        "$pwr_exe/ge_page_right.png");
    a->setData(15);

    tools->addSeparator();

    a = addToolItem(toplevel, tools, "Page down", SLOT(tilt_helper()),
        "$pwr_exe/ge_page_down.png");
    a->setData(-15);
    a = addToolItem(toplevel, tools, "Down", SLOT(tilt_helper()),
        "$pwr_exe/ge_scroll_down.png");
    a->setData(-3);
    a = addToolItem(toplevel, tools, "Up", SLOT(tilt_helper()),
        "$pwr_exe/ge_scroll_up.png");
    a->setData(3);
    a = addToolItem(toplevel, tools, "Page up", SLOT(tilt_helper()),
        "$pwr_exe/ge_page_up.png");
    a->setData(15);

    tools->addSeparator();

    for (int i = 0; i < 10; i++) {
      QString text1 = "PresetPosition[" + QString::number(i) + "].Description";
      pwr_tAttrRef aaref;
      pwr_tStatus lsts = gdh_ArefANameToAref(&aref, qPrintable(text1), &aaref);
      char tooltiptext[80];
      if (ODD(lsts)) {
        lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
      }

      QString text3 = "$pwr_exe/xtt_pos" + QString::number(i + 1) + ".png";
      QAction* a
          = addToolItem(toplevel, tools, "", SLOT(activate_preset_position()), qPrintable(text3));
      a->setData(i);

      if (ODD(lsts) && !streq(tooltiptext, "")) {
        a->setToolTip(convert_utf8(tooltiptext));
      } else {
        QString text2 = "Preset position " + QString::number(i + 1);
        a->setToolTip(text2);
      }
    }

    tools->addSeparator();

    QString txt = translate_utf8("Get position");
    a = addToolItem(toplevel, tools, "", SLOT(activate_get_position()),
        "$pwr_exe/xtt_get_pos.png");
    a->setToolTip(txt);

    QWidget* ptz_pan_label = new QLabel("Pan");
    ptz_pan = new QLabel("0");
    QWidget* ptz_tilt_label = new QLabel("Tilt");
    ptz_tilt = new QLabel("0");
    QWidget* ptz_zoom_label = new QLabel("Zoom");
    ptz_zoom = new QLabel("0");

    QHBoxLayout* ptz_box_layout = new QHBoxLayout();
    ptz_box_layout->addWidget(ptz_pan_label);
    ptz_box_layout->addWidget(ptz_pan);
    ptz_box_layout->addWidget(separator(QFrame::VLine));
    ptz_box_layout->addWidget(ptz_tilt_label);
    ptz_box_layout->addWidget(ptz_tilt);
    ptz_box_layout->addWidget(separator(QFrame::VLine));
    ptz_box_layout->addWidget(ptz_zoom_label);
    ptz_box_layout->addWidget(ptz_zoom);

    ptz_box = layout_to_widget(ptz_box_layout);

    QHBoxLayout* tools_box = new QHBoxLayout();
    tools_box->addWidget(tools);
    tools_box->addWidget(ptz_box);
    main_layout->addLayout(tools_box);

    ptz_box->setVisible(false);
    if (!(options & strm_mOptions_CameraControlPanel)) {
      tools->setVisible(false);
    }
  } else {
    // Empty toolbar
    QToolBar* tools = new QToolBar();
    tools->setFixedHeight(32);
    main_layout->addWidget(tools);

    if (!(options & strm_mOptions_CameraControlPanel)) {
      tools->setVisible(false);
    }
  }

  add_expanding(main_layout, playbin2);

  if (options & strm_mOptions_VideoControlPanel) {
    QToolBar* controlbuttons = new QToolBar();

    addToolItem(playbin2, controlbuttons, "Play",
        SLOT(Phonon::VideoPlayer::play()), "$pwr_exe/xtt_play.png");
    addToolItem(playbin2, controlbuttons, "Pause",
        SLOT(Phonon::VideoPlayer::pause()), "$pwr_exe/xtt_pause.png");
    addToolItem(playbin2, controlbuttons, "Stop",
        SLOT(Phonon::VideoPlayer::stop()), "$pwr_exe/xtt_stop.png");

    if (options & strm_mOptions_VideoProgressBar) {
      slider = new QSlider(Qt::Horizontal);
      slider->setRange(0, 100);
      slider->setSliderPosition(0);
      QObject::connect(
          slider, SIGNAL(sliderMoved(int)), toplevel, SLOT(slider_cb(int)));
      QHBoxLayout* hbox = new QHBoxLayout();
      hbox->addWidget(controlbuttons);
      add_expanding(hbox, slider);
      main_layout->addLayout(hbox);
    } else {
      main_layout->addWidget(controlbuttons);
    }
  }

  toplevel->setLayout(main_layout);
  if (!embedded) {
    toplevel->setMinimumSize(width, height);
    toplevel->show();

    if (options & strm_mOptions_FullScreen) {
      toplevel->showFullScreen();
    } else if (options & strm_mOptions_Maximize) {
      toplevel->showMaximized();
    } else if (options & strm_mOptions_FullMaximize) {
      toplevel->showMaximized();
    } else if (options & strm_mOptions_Iconify) {
      toplevel->showMinimized();
    }
  }

  /* Start playing */
  playbin2->play();

  wow = new CoWowQt(toplevel);
  timerid = wow->timer_new();
  scroll_timerid = wow->timer_new();
  reconnect_timerid = wow->timer_new();
  timerid->add(scan_time, refresh, this);

  *sts = XNAV__SUCCESS;
}

XttStreamQt::~XttStreamQt()
{
  if (timerid) {
    timerid->remove();
  }
  if (scroll_timerid) {
    scroll_timerid->remove();
  }
  if (reconnect_timerid) {
    reconnect_timerid->remove();
  }
}

void XttStreamQt::pop()
{
  ::pop(toplevel);
}

void XttStreamQt::set_size(int width, int height)
{
  toplevel->resize(width, height);
}

void XttStreamQt::create_popup_menu(int x, int y)
{
  QMenu* menu = new QMenu(toplevel);

  QAction* a = addMenuItem(toplevel, menu, "Zoom in", SLOT(zoom_helper()));
  a->setData(5);
  a = addMenuItem(toplevel, menu, "Zoom out", SLOT(zoom_helper()));
  a->setData(-5);
  a = addMenuItem(toplevel, menu, "Zoom reset", SLOT(zoom_helper()));
  a->setData(0);

  QMenu* menu_preset_store = menu->addMenu("Preset store");
  for (int i = 0; i < 10; i++) {
    QString text = "Position " + QString::number(i + 1);
    QAction* a = addMenuItem(toplevel, menu_preset_store, qPrintable(text),
        SLOT(activate_preset_store_pos()));
    a->setData(i);
  }

  menu->popup(QPoint(x, y));
}

void XttStreamQtWidget::zoom_helper()
{
  if (!stream->camera_control) {
    return;
  }

  int value = ((QAction *) sender())->data().toInt();

  if (value == 0) {
    stream->camera_control->zoom_absolute(value);
  } else {
    stream->camera_control->zoom_relative(value);
  }
  stream->hidePtz();
}

void XttStreamQtWidget::pan_helper()
{
  if (!stream->camera_control) {
    return;
  }

  int value = ((QAction *) sender())->data().toInt();

  stream->camera_control->pan_relative(value);
  stream->hidePtz();
}

void XttStreamQtWidget::tilt_helper()
{
  if (!stream->camera_control) {
    return;
  }

  int value = ((QAction *) sender())->data().toInt();

  stream->camera_control->tilt_relative(value);
  stream->hidePtz();
}

void XttStreamQtWidget::activate_preset_position()
{
  int idx = ((QAction*)sender())->data().toInt();
  stream->activate_preset_position(idx);
  stream->hidePtz();
}

void XttStreamQtWidget::activate_preset_store_pos()
{
  int idx = ((QAction*)sender())->data().toInt();
  stream->activate_preset_store_pos(idx);
  stream->hidePtz();
}

void XttStreamQtWidget::activate_get_position()
{
  if (!stream->camera_control) {
    return;
  }

  double pan, tilt, zoom;
  int sts = stream->camera_control->get_position(&pan, &tilt, &zoom);
  if (EVEN(sts)) {
    return;
  }

  char pan_str[20], tilt_str[20], zoom_str[20];
  sprintf(pan_str, "%6.2f", pan);
  sprintf(tilt_str, "%6.2f", tilt);
  sprintf(zoom_str, "%6.2f", zoom);
  stream->ptz_pan->setText(pan_str);
  stream->ptz_tilt->setText(tilt_str);
  stream->ptz_zoom->setText(zoom_str);
  stream->hidePtz();
}