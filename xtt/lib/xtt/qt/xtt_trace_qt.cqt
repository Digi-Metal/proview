/*
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_trace_qt.cpp -- trace in runtime environment */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#if defined OS_LINUX
#include <sys/stat.h>
#endif

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "pwr_privilege.h"

#include "flow_ctx.h"
#include "flow_api.h"
#include "co_cdh.h"
#include "co_time.h"
#include "co_api.h"
#include "co_dcli.h"
#include "rt_gdh.h"
#include "flow_widget_qt.h"
#include "xtt_trace_qt.h"
#include "cow_wow_qt.h"

#include <QAction>
#include <QMenu>
#include <QMenuBar>
#include <QSplitter>
#include <QToolBar>
#include <QVBoxLayout>

void RtTraceQtWidget::activate_print()
{
  pwr_tStatus sts;

  CoWowQt::CreateFlowPrintDialogQt("Trace", rt->flow_ctx,
                                   flow_eOrientation_Landscape, 1.0, this,
                                   &sts);
}

void RtTraceQtWidget::activate_zoom_in()
{
  flow_Zoom(rt->flow_ctx, 1.0 / 0.7);
}

void RtTraceQtWidget::activate_zoom_out()
{
  flow_Zoom(rt->flow_ctx, 0.7);
}

void RtTraceQtWidget::activate_zoom_reset()
{
  flow_UnZoom(rt->flow_ctx);
}

void RtTraceQtWidget::activate_scantime1()
{
  rt->scan_time = 0.5;
}

void RtTraceQtWidget::activate_scantime2()
{
  rt->scan_time = 0.2;
}

void RtTraceQtWidget::activate_scantime3()
{
  rt->scan_time = 0.1;
}

void RtTraceQtWidget::activate_scantime4()
{
  rt->scan_time = 0.05;
}

void RtTraceQtWidget::activate_scantime5()
{
  rt->scan_time = 0.02;
}

RtTraceQt::~RtTraceQt()
{
  trace_tNode *node, *fnode;

  trace_stop();

  /* Delete all trace children windows */
  for (node = trace_list; node;) {
    delete node->tractx;
    fnode = node->Next;
    free((char *) node);
    node = fnode;
  }
  if (nav_shell) {
    nav_shell->close();
  }

  if (trace_timerid) {
    delete trace_timerid;
  }
}

void RtTraceQt::pop()
{
  ::pop(toplevel);
}

void RtTraceQt::popup_menu_position(int event_x, int event_y, int *x, int *y)
{
  CoWowQt::PopupPosition(flow_widget, event_x, event_y, x, y);
}

RtTrace *RtTraceQt::subwindow_new(void *ctx, pwr_tObjid oid, pwr_tStatus *sts)
{
  return new RtTraceQt(ctx, flow_widget, oid, sts);
}

void RtTraceQtWidget::closeEvent(QCloseEvent *event)
{
  rt->activate_close();
  QWidget::closeEvent(event);
}

RtTraceQt::RtTraceQt(void *tr_parent_ctx, QWidget *tr_parent_wid,
                     pwr_tObjid tr_objid, pwr_tStatus *status)
    : RtTrace(tr_parent_ctx, tr_objid, status), nav_shell(0)
{
  const int window_width = 900;
  const int window_height = 800;
  const int nav_width = 180;
  pwr_tStatus sts;
  pwr_tObjid window_objid;
  pwr_tClassId cid;
  char title[220];
  pwr_tAName hostname;
  pwr_tOName plcconnect;

  sts = gdh_ObjidToName(tr_objid, name, sizeof(name), cdh_mNName);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }
  strcpy(title, "Trace ");
  strcat(title, name);

  /* Find plcwindow */
  sts = gdh_GetObjectClass(tr_objid, &cid);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  if (!(cid == pwr_cClass_windowplc || cid == pwr_cClass_windowcond ||
        cid == pwr_cClass_windoworderact || cid == pwr_cClass_windowsubstep)) {
    sts = gdh_GetChild(tr_objid, &window_objid);
    if (EVEN(sts)) {
      *status = sts;
      return;
    }
  } else {
    window_objid = tr_objid;
  }

  sts = gdh_GetObjectClass(window_objid, &cid);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  if (!(cid == pwr_cClass_windowplc || cid == pwr_cClass_windowcond ||
        cid == pwr_cClass_windoworderact || cid == pwr_cClass_windowsubstep)) {
    *status = 0;
    return;
  }

  sts = get_filename(window_objid, filename, &m_has_host, hostname, plcconnect);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  /* Create object context */
  objid = window_objid;
  if (m_has_host) {
    strcpy(m_hostname, hostname);
    strcpy(m_plcconnect, plcconnect);
  }

  // Qt
  toplevel = new RtTraceQtWidget(this, tr_parent_wid);
  toplevel->setMinimumSize(window_width, window_height);
  toplevel->setWindowTitle(QString::fromLatin1(title));
  toplevel->setAttribute(Qt::WA_DeleteOnClose);

  CoWowQt::SetWindowIcon(toplevel);

  QMenuBar *menu_bar = new QMenuBar(toplevel);

  // File Entry
  QMenu *file = menu_bar->addMenu(translate_utf8("&File"));
  addMenuItem(toplevel, file, "&Print", SLOT(activate_print()));
  addMenuItem(toplevel, file, "Print &Selected Documents",
              SLOT(activate_printselect()));
  addMenuItem(toplevel, file, "Save &Trace", SLOT(activate_savetrace()));
  addMenuItem(toplevel, file, "&Restore Trace", SLOT(activate_restoretrace()));
  addMenuItem(toplevel, file, "C&lear Trace", SLOT(activate_cleartrace()));
  addMenuItem(toplevel, file, "&Close", SLOT(close()), "CTRL+W", "window-close");

  // Functions Entry
  QMenu *functions = menu_bar->addMenu(translate_utf8("&Functions"));
  addMenuItem(toplevel, functions, "&Open Object", SLOT(activate_open_object()),
              "CTRL+A");
  addMenuItem(toplevel, functions, "Open S&ubwindow",
              SLOT(activate_open_subwindow()), "CTRL+L");
  addMenuItem(toplevel, functions, "&Display object in Navigator",
              SLOT(activate_display_object()), "CTRL+D");
  addMenuItem(toplevel, functions, "&Show Crossreferences",
              SLOT(activate_show_cross()), "CTRL+R");
  addMenuItem(toplevel, functions, "&Open ObjectGraph",
              SLOT(activate_open_classgraph()), "CTRL+G");
  addMenuItem(toplevel, functions, "&Collect Insert",
              SLOT(activate_collect_insert()), "CTRL+V");

  // View Entry
  QMenu *view = menu_bar->addMenu(translate_utf8("&View"));
  addMenuItem(toplevel, view, "Zoom &In", SLOT(activate_zoom_in()), "CTRL+I",
              "zoom-in");
  addMenuItem(toplevel, view, "Zoom &Out", SLOT(activate_zoom_out()), "CTRL+O",
              "zoom-out");
  addMenuItem(toplevel, view, "Zoom &Reset", SLOT(activate_zoom_reset()), "CTRL+B",
              "zoom-original");

  // Submenu ScanTime
  QMenu *view_sc = view->addMenu(translate_utf8("&ScanTime"));
  QActionGroup *view_sc_group = new QActionGroup(toplevel);
  QAction *view_scantime1 =
      addMenuRadioItem(toplevel, view_sc, "0.50 s", SLOT(activate_scantime1()),
                       view_sc_group);
  view_scantime1->setChecked(true);
  addMenuRadioItem(toplevel, view_sc, "0.20 s", SLOT(activate_scantime2()),
                   view_sc_group);
  addMenuRadioItem(toplevel, view_sc, "0.10 s", SLOT(activate_scantime3()),
                   view_sc_group);
  addMenuRadioItem(toplevel, view_sc, "0.05 s", SLOT(activate_scantime4()),
                   view_sc_group);
  addMenuRadioItem(toplevel, view_sc, "0.02 s", SLOT(activate_scantime5()),
                   view_sc_group);
  // End submenu
  // End View entry

  // Mode entry
  QMenu *mode = menu_bar->addMenu(translate_utf8("&Mode"));
  QActionGroup *mode_group = new QActionGroup(toplevel);
  addMenuRadioItem(toplevel, mode, "V&iew", SLOT(activate_view()), mode_group);
  QAction *mode_trace =
      addMenuRadioItem(toplevel, mode, "&Trace", SLOT(activate_trace()),
                       mode_group);
  mode_trace->setChecked(true);
  addMenuRadioItem(toplevel, mode, "&Simulate", SLOT(activate_simulate()),
                   mode_group);

  // Menu Help
  QMenu *help = menu_bar->addMenu(translate_utf8("&Help"));
  addMenuItem(toplevel, help, "On &Trace", SLOT(activate_help()), "CTRL+H",
              "system-help");
  addMenuItem(toplevel, help, "On &PlcPgm", SLOT(activate_helpplc()));
  addMenuItem(toplevel, help, "P&lcPgm Overview", SLOT(activate_helpplclist()));

  // Toolbar
  QToolBar *tools = new QToolBar(toplevel);

  pwr_tObjid parent;
  pwr_tCid parent_cid;
  sts = gdh_GetParent(objid, &parent);
  if (ODD(sts)) {
    sts = gdh_GetObjectClass(parent, &parent_cid);
    if (ODD(sts) && parent_cid != pwr_cClass_plc) {
      addToolItem(toplevel, tools, "Open parent window",
                  SLOT(activate_parent_window()), "$pwr_exe/xtt_up.png");
    }
  }

  addToolItem(toplevel, tools, "Display object in Navigator",
              SLOT(activate_display_object()), "$pwr_exe/xtt_navigator.png");
  addToolItem(toplevel, tools, "Show Crossreferences", SLOT(activate_show_cross()),
              "$pwr_exe/xtt_crossref.png");
  addToolItem(toplevel, tools, "Zoom in", SLOT(activate_zoom_in()),
              "$pwr_exe/xtt_zoom_in.png");
  addToolItem(toplevel, tools, "Zoom out", SLOT(activate_zoom_out()),
              "$pwr_exe/xtt_zoom_out.png");
  addToolItem(toplevel, tools, "Zoom reset", SLOT(activate_zoom_reset()),
              "$pwr_exe/xtt_zoom_reset.png");

  // Flow widget
  QWidget
      *flow_scrolled = scrolledflowwidgetqt_new(init_flow, this, &flow_widget);
  showNow(flow_widget);

  nav_widget = flownavwidgetqt_new(flow_widget);

  QSplitter *paned = new QSplitter(toplevel);
  add_expanding(paned, flow_scrolled);
  paned->addWidget(nav_widget);

  QVBoxLayout *vbox = new QVBoxLayout();
  vbox->setMenuBar(menu_bar);
  vbox->addWidget(tools);
  add_expanding(vbox, paned);

  toplevel->setLayout(vbox);
  toplevel->show();

  QList<int> sizes;
  sizes << window_width - nav_width << nav_width;
  paned->setSizes(sizes);

  wow = new CoWowQt(toplevel);
  trace_timerid = wow->timer_new();

  viewsetup();
  flow_Open(flow_ctx, filename);

#if defined OS_LINUX
  {
    struct stat info;

    if ( stat( filename, &info) != -1)
      version = info.st_ctime;
  }
#endif

  // Check version
  unsigned int flow_version;
  pwr_tUInt32 window_version;
  pwr_tAName aname;

  flow_GetCtxUserVersion(flow_ctx, &flow_version);

  strcpy(aname, name);
  strcat(aname, ".Version");

  sts = gdh_GetObjectInfo(aname, &window_version, sizeof(window_version));
  if (EVEN(sts)) { return; }

  if (flow_version != window_version) {
    char msg[200];
    char flow_version_str[30];
    char window_version_str[30];
    pwr_tTime t;

    t.tv_sec = flow_version;
    t.tv_nsec = 0;
    time_AtoAscii(&t, time_eFormat_DateAndTime, flow_version_str,
                  sizeof(flow_version_str));
    t.tv_sec = window_version;
    t.tv_nsec = 0;
    time_AtoAscii(&t, time_eFormat_DateAndTime, window_version_str,
                  sizeof(window_version_str));

    if (flow_version > window_version) {
      sprintf(msg, "Trace file is newer than database version\n(%s > %s)",
              flow_version_str, window_version_str);
    } else if (flow_version < window_version) {
      sprintf(msg, "Trace file is older than database version\n(%s < %s)",
              flow_version_str, window_version_str);
    }
    wow->DisplayError("Version mismatch", msg);
  }
}