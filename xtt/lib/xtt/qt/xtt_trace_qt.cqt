/*
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of Proview (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_trace_qt.cpp -- trace in runtime environment */

#include <stdio.h>
#include <string.h>

#if defined OS_LINUX
#include <sys/stat.h>
#endif

//#include "pwr_baseclasses.h"

#include "co_cdh.h"
#include "co_time.h"

#include "rt_gdh.h"

#include "cow_wow_qt.h"

#include "flow_widget_qt.h"

#include "xtt_trace_qt.h"

#include <QAction>
#include <QMenu>
#include <QMenuBar>
#include <QSplitter>
#include <QToolBar>
#include <QVBoxLayout>

void RtTraceQtWidget::activate_print()
{
  pwr_tStatus sts;

  CoWowQt::CreateFlowPrintDialogQt(
      "Trace", rt->flow_ctx, flow_eOrientation_Landscape, 1.0, this, &sts);
}

void RtTraceQtWidget::activate_printselect()
{
  rt->activate_printselect();
}

void RtTraceQtWidget::activate_savetrace()
{
  rt->activate_savetrace();
}

void RtTraceQtWidget::activate_restoretrace()
{
  rt->activate_restoretrace();
}

void RtTraceQtWidget::activate_cleartrace()
{
  rt->activate_cleartrace();
}

void RtTraceQtWidget::activate_display_object()
{
  rt->activate_display_object();
}

void RtTraceQtWidget::activate_parent_window()
{
  rt->activate_parent_window();
}

void RtTraceQtWidget::activate_collect_insert()
{
  rt->activate_collect_insert();
}

void RtTraceQtWidget::activate_open_object()
{
  rt->activate_open_object();
}

void RtTraceQtWidget::activate_open_subwindow()
{
  rt->activate_open_subwindow();
}

void RtTraceQtWidget::activate_show_cross()
{
  rt->activate_show_cross();
}

void RtTraceQtWidget::activate_open_classgraph()
{
  rt->activate_open_classgraph();
}

void RtTraceQtWidget::activate_trace()
{
  rt->activate_trace();
}

void RtTraceQtWidget::activate_simulate()
{
  rt->activate_simulate();
}

void RtTraceQtWidget::activate_view()
{
  rt->activate_view();
}

void RtTraceQtWidget::activate_zoomin()
{
  flow_Zoom(rt->flow_ctx, 1.0 / 0.7);
}

void RtTraceQtWidget::activate_zoomout()
{
  flow_Zoom(rt->flow_ctx, 0.7);
}

void RtTraceQtWidget::activate_zoomreset()
{
  flow_UnZoom(rt->flow_ctx);
}

void RtTraceQtWidget::activate_scantime()
{
  rt->scan_time = ((QAction*)sender())->data().toInt();
}

void RtTraceQtWidget::activate_help()
{
  rt->activate_help();
}

void RtTraceQtWidget::activate_helpplc()
{
  rt->activate_helpplc();
}

void RtTraceQtWidget::activate_helpplclist()
{
  rt->activate_helpplclist();
}

RtTraceQt::~RtTraceQt()
{
  debug_print("RtTraceQt::~RtTraceQt\n");
  trace_tNode *node, *fnode;

  trace_stop();

  /* Delete all trace children windows */
  for (node = trace_list; node;) {
    delete node->tractx;
    fnode = node->Next;
    free((char*)node);
    node = fnode;
  }
  if (nav_shell) {
    nav_shell->close();
  }

  if (trace_timerid) {
    delete trace_timerid;
  }
}

void RtTraceQt::pop()
{
  ::pop(toplevel);
}

void RtTraceQt::popup_menu_position(int event_x, int event_y, int* x, int* y)
{
  CoWowQt::PopupPosition(flow_widget, event_x, event_y, x, y);
}

RtTrace* RtTraceQt::subwindow_new(void* ctx, pwr_tObjid oid, pwr_tStatus* sts)
{
  return new RtTraceQt(ctx, flow_widget, oid, sts);
}

void RtTraceQtWidget::closeEvent(QCloseEvent* event)
{
  debug_print("RtTraceQtWidget::closeEvent\n");
  rt->activate_close();
  QWidget::closeEvent(event);
}

RtTraceQt::RtTraceQt(void* tr_parent_ctx, QWidget* tr_parent_wid,
    pwr_tObjid tr_objid, pwr_tStatus* status)
    : RtTrace(tr_parent_ctx, tr_objid, status), nav_shell(0)
{
  const int window_width = 900;
  const int window_height = 800;
  const int nav_width = 180;
  pwr_tStatus sts;
  pwr_tObjid window_objid;
  pwr_tClassId cid;
  char title[220];
  pwr_tAName hostname;
  pwr_tOName plcconnect;

  sts = gdh_ObjidToName(tr_objid, name, sizeof(name), cdh_mNName);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }
  strcpy(title, "Trace ");
  strcat(title, name);

  /* Find plcwindow */
  sts = gdh_GetObjectClass(tr_objid, &cid);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  if (!(cid == pwr_cClass_windowplc || cid == pwr_cClass_windowcond
          || cid == pwr_cClass_windoworderact
          || cid == pwr_cClass_windowsubstep)) {
    sts = gdh_GetChild(tr_objid, &window_objid);
    if (EVEN(sts)) {
      *status = sts;
      return;
    }
  } else {
    window_objid = tr_objid;
  }

  sts = gdh_GetObjectClass(window_objid, &cid);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  if (!(cid == pwr_cClass_windowplc || cid == pwr_cClass_windowcond
          || cid == pwr_cClass_windoworderact
          || cid == pwr_cClass_windowsubstep)) {
    *status = 0;
    return;
  }

  sts = get_filename(window_objid, filename, &m_has_host, hostname, plcconnect);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  /* Create object context */
  objid = window_objid;
  if (m_has_host) {
    strcpy(m_hostname, hostname);
    strcpy(m_plcconnect, plcconnect);
  }

  // Qt
  toplevel = new RtTraceQtWidget(this, tr_parent_wid);
  toplevel->setToolTip(fl("xtt_trace widget"));
  toplevel->setMinimumSize(window_width, window_height);
  toplevel->setWindowTitle(QString::fromLatin1(title));
  toplevel->setAttribute(Qt::WA_DeleteOnClose);

  CoWowQt::SetWindowIcon(toplevel);

  QMenuBar* menu_bar = new QMenuBar(toplevel);

  // File Entry
  QMenu* file = menu_bar->addMenu(translate_utf8("&File"));
  addMenuItem(toplevel, file, "&Print", SLOT(activate_print()));
  addMenuItem(toplevel, file, "Print &Selected Documents",
      SLOT(activate_printselect()));
  addMenuItem(toplevel, file, "Save &Trace", SLOT(activate_savetrace()));
  addMenuItem(toplevel, file, "&Restore Trace", SLOT(activate_restoretrace()));
  addMenuItem(toplevel, file, "C&lear Trace", SLOT(activate_cleartrace()));
  addMenuItem(
      toplevel, file, "&Close", SLOT(close()), "CTRL+W", "window-close");

  // Functions Entry
  QMenu* functions = menu_bar->addMenu(translate_utf8("&Functions"));
  addMenuItem(toplevel, functions, "&Open Object", SLOT(activate_open_object()),
      "CTRL+A");
  addMenuItem(toplevel, functions, "Open S&ubwindow",
      SLOT(activate_open_subwindow()), "CTRL+L");
  addMenuItem(toplevel, functions, "&Display object in Navigator",
      SLOT(activate_display_object()), "CTRL+D");
  addMenuItem(toplevel, functions, "&Show Crossreferences",
      SLOT(activate_show_cross()), "CTRL+R");
  addMenuItem(toplevel, functions, "&Open ObjectGraph",
      SLOT(activate_open_classgraph()), "CTRL+G");
  addMenuItem(toplevel, functions, "&Collect Insert",
      SLOT(activate_collect_insert()), "CTRL+V");

  // View Entry
  QMenu* view = menu_bar->addMenu(translate_utf8("&View"));
  addMenuItem(
      toplevel, view, "Zoom &In", SLOT(activate_zoomin()), "CTRL+I", "zoom-in");
  addMenuItem(toplevel, view, "Zoom &Out", SLOT(activate_zoomout()), "CTRL+O",
      "zoom-out");
  addMenuItem(toplevel, view, "Zoom &Reset", SLOT(activate_zoomreset()),
      "CTRL+B", "zoom-original");

  // Submenu ScanTime
  QMenu* view_sc = view->addMenu(translate_utf8("&ScanTime"));
  QActionGroup* view_sc_group = new QActionGroup(toplevel);
  QAction* a = addMenuRadioItem(
      toplevel, view_sc, "0.50 s", SLOT(activate_scantime()), view_sc_group);
  a->setData(500);
  a->setChecked(true);
  a = addMenuRadioItem(
      toplevel, view_sc, "0.20 s", SLOT(activate_scantime()), view_sc_group);
  a->setData(200);
  a = addMenuRadioItem(
      toplevel, view_sc, "0.10 s", SLOT(activate_scantime()), view_sc_group);
  a->setData(100);
  a = addMenuRadioItem(
      toplevel, view_sc, "0.05 s", SLOT(activate_scantime()), view_sc_group);
  a->setData(50);
  a = addMenuRadioItem(
      toplevel, view_sc, "0.02 s", SLOT(activate_scantime()), view_sc_group);
  a->setData(20);
  // End submenu
  // End View entry

  // Mode entry
  QMenu* mode = menu_bar->addMenu(translate_utf8("&Mode"));
  QActionGroup* mode_group = new QActionGroup(toplevel);
  addMenuRadioItem(toplevel, mode, "V&iew", SLOT(activate_view()), mode_group);
  QAction* mode_trace = addMenuRadioItem(
      toplevel, mode, "&Trace", SLOT(activate_trace()), mode_group);
  mode_trace->setChecked(true);
  addMenuRadioItem(
      toplevel, mode, "&Simulate", SLOT(activate_simulate()), mode_group);

  // Menu Help
  QMenu* help = menu_bar->addMenu(translate_utf8("&Help"));
  addMenuItem(toplevel, help, "On &Trace", SLOT(activate_help()), "CTRL+H",
      "system-help");
  addMenuItem(toplevel, help, "On &PlcPgm", SLOT(activate_helpplc()));
  addMenuItem(toplevel, help, "P&lcPgm Overview", SLOT(activate_helpplclist()));

  // Toolbar
  QToolBar* tools = new QToolBar(toplevel);

  pwr_tObjid parent;
  pwr_tCid parent_cid;
  sts = gdh_GetParent(objid, &parent);
  if (ODD(sts)) {
    sts = gdh_GetObjectClass(parent, &parent_cid);
    if (ODD(sts) && parent_cid != pwr_cClass_plc) {
      addToolItem(toplevel, tools, "Open parent window",
          SLOT(activate_parent_window()), "$pwr_exe/xtt_up.png");
    }
  }

  addToolItem(toplevel, tools, "Display object in Navigator",
      SLOT(activate_display_object()), "$pwr_exe/xtt_navigator.png");
  addToolItem(toplevel, tools, "Show Crossreferences",
      SLOT(activate_show_cross()), "$pwr_exe/xtt_crossref.png");
  addToolItem(toplevel, tools, "Zoom in", SLOT(activate_zoomin()),
      "$pwr_exe/xtt_zoom_in.png");
  addToolItem(toplevel, tools, "Zoom out", SLOT(activate_zoomout()),
      "$pwr_exe/xtt_zoom_out.png");
  addToolItem(toplevel, tools, "Zoom reset", SLOT(activate_zoomreset()),
      "$pwr_exe/xtt_zoom_reset.png");

  // Flow widget
  debug_print("creating a scrolledflowwidgetqt\n");
  QWidget* flow_scrolled
      = scrolledflowwidgetqt_new(init_flow, this, &flow_widget);
  showNow(flow_widget);
  debug_print("creating a flownavwidgetqt\n");
  nav_widget = flownavwidgetqt_new(flow_widget);

  QSplitter* paned = new QSplitter(toplevel);
  add_expanding(paned, flow_scrolled);
  paned->addWidget(nav_widget);

  QVBoxLayout* vbox = new QVBoxLayout();
  vbox->setMenuBar(menu_bar);
  vbox->addWidget(tools);
  add_expanding(vbox, paned);

  toplevel->setLayout(vbox);
  toplevel->show();

  QList<int> sizes;
  sizes << window_width - nav_width << nav_width;
  paned->setSizes(sizes);

  wow = new CoWowQt(toplevel);
  trace_timerid = wow->timer_new();

  viewsetup();
  flow_Open(flow_ctx, filename);

#if defined OS_LINUX
  {
    struct stat info;

    if (stat(filename, &info) != -1)
      version = info.st_ctime;
  }
#endif

  // Check version
  unsigned int flow_version;
  pwr_tUInt32 window_version;
  pwr_tAName aname;

  flow_GetCtxUserVersion(flow_ctx, &flow_version);

  strcpy(aname, name);
  strcat(aname, ".Version");

  sts = gdh_GetObjectInfo(aname, &window_version, sizeof(window_version));
  if (EVEN(sts)) {
    return;
  }

  if (flow_version != window_version) {
    char msg[200];
    char flow_version_str[30];
    char window_version_str[30];
    pwr_tTime t;

    t.tv_sec = flow_version;
    t.tv_nsec = 0;
    time_AtoAscii(&t, time_eFormat_DateAndTime, flow_version_str,
        sizeof(flow_version_str));
    t.tv_sec = window_version;
    t.tv_nsec = 0;
    time_AtoAscii(&t, time_eFormat_DateAndTime, window_version_str,
        sizeof(window_version_str));

    if (flow_version > window_version) {
      sprintf(msg, "Trace file is newer than database version\n(%s > %s)",
          flow_version_str, window_version_str);
    } else if (flow_version < window_version) {
      sprintf(msg, "Trace file is older than database version\n(%s < %s)",
          flow_version_str, window_version_str);
    }
    wow->DisplayError("Version mismatch", msg);
  }
}