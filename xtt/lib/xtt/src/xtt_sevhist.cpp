/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include "flow_std.h"

#include <stdio.h>
#include <stdlib.h>
#include <vector>

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "co_cdh.h"
#include "co_time.h"
#include "co_dcli.h"
#include "cow_wow.h"
#include "rt_sev_msg.h"

#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "glow_growctx.h"
#include "glow_growapi.h"
#include "glow_curvectx.h"
#include "glow_curveapi.h"

#include "xtt_xnav.h"
#include "xtt_sevhist.h"
#include "ge_curve.h"


XttSevHist::XttSevHist( void *parent_ctx,
			const char *name,
			pwr_tOid *xn_oidv,
			pwr_tOName *xn_anamev,
			pwr_tOName *xn_onamev,
			bool *xn_sevhistobjectv,
			sevcli_tCtx xn_scctx,
			int *sts) :
  xnav(parent_ctx), gcd(0), curve(0), rows(0), vsize(0), timerid(0), close_cb(0), help_cb(0), 
  get_select_cb(0), first_scan(1), scctx(xn_scctx), time_low_old(0), time_high_old(0)
{
  pwr_tTime from, to;

  if ( xn_oidv == 0 || xn_oidv[0].vid == 0) {
    oid_cnt = 0;
    gcd = new GeCurveData( curve_eDataType_DsTrend);
    return;
  }

  // Count number of curves
  for ( oid_cnt = 0; xn_oidv[oid_cnt].vid != 0; oid_cnt++) ;

  if ( oid_cnt > XTT_SEVHIST_MAX)
    oid_cnt = XTT_SEVHIST_MAX;

  memcpy( oidv, xn_oidv, oid_cnt * sizeof(oidv[0]));
  memcpy( anamev, xn_anamev, oid_cnt * sizeof(anamev[0]));
  memcpy( onamev, xn_onamev, oid_cnt * sizeof(onamev[0]));
  memcpy( sevhistobjectv, xn_sevhistobjectv, oid_cnt * sizeof(sevhistobjectv[0]));

  time_Period( time_ePeriod_OneHour, &from, &to, 0, 0);
  if ( oid_cnt == 1) {
    get_data( sts, from, to);
    if ( EVEN(*sts)) return;
  }
  else {
    get_multidata( sts, from, to);
    if ( EVEN(*sts)) return;
  }
  cdh_StrncpyCutOff( title, name, sizeof(title), 1);
}

XttSevHist::XttSevHist( void *parent_ctx,
			const char *name,
			char *filename,
			int *sts) :
  xnav(parent_ctx), gcd(0), curve(0), rows(0), vsize(0), timerid(0), close_cb(0), help_cb(0), 
  get_select_cb(0), first_scan(1), scctx(0), time_low_old(0), time_high_old(0)
{
  strncpy( title, filename, sizeof(title));

  *sts = read_export( filename);
}

XttSevHist::~XttSevHist()
{
}



int XttSevHist::get_data( pwr_tStatus *sts, pwr_tTime from, pwr_tTime to)
{
  if( sevhistobjectv[0]) {
    return get_objectdata(sts, from, to);
  }
  pwr_tTime *tbuf;
  void *vbuf;
  pwr_tDeltaTime trange;

  if ( curve)
    curve->set_clock_cursor();
  sevcli_get_itemdata( sts, scctx, oidv[0], anamev[0], from, to, 1000, &tbuf, &vbuf,
  		       &rows, &vtype, &vsize);
  if ( curve)
    curve->reset_cursor();
  if ( EVEN(*sts))
    return 0;

  if( rows == 0 ) {
    *sts = SEV__NODATATIME;
    return 0;
  }

  // Create data for time axis
  gcd = new GeCurveData( curve_eDataType_DsTrend);

  gcd->x_data[0] = (double *) calloc( 1, 8 * rows);
  for ( int i = 0; i < rows; i++)
    gcd->x_data[0][i] = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

  strcpy( gcd->x_name, "Time");
  gcd->x_axis_type[0] = curve_eAxis_x;
  strcpy( gcd->x_format[0], "%10t");

  strcpy( gcd->y_name[0], onamev[0]);
  if ( strcmp( onamev[0], "") != 0)
    strcat( gcd->y_name[0], ".");
  strcat( gcd->y_name[0], anamev[0]);
  gcd->y_data[0] = (double *) calloc( 1, 8 * rows);

  for ( int i = 0; i < rows; i++) {
    switch ( vtype) {
    case pwr_eType_Int64:
      gcd->y_data[0][i] = ((pwr_tInt32 *)vbuf)[i];
      break;
    case pwr_eType_Int32:
      gcd->y_data[0][i] = ((pwr_tInt32 *)vbuf)[i];
      break;
    case pwr_eType_Int16:
      gcd->y_data[0][i] = ((pwr_tInt32 *)vbuf)[i];
      break;
    case pwr_eType_Int8:
      gcd->y_data[0][i] = ((pwr_tInt32 *)vbuf)[i];
      break;
    case pwr_eType_UInt64:
      gcd->y_data[0][i] = ((pwr_tUInt32 *)vbuf)[i];
      break;
    case pwr_eType_UInt32:
      gcd->y_data[0][i] = ((pwr_tUInt32 *)vbuf)[i];
      break;
    case pwr_eType_UInt16:
      gcd->y_data[0][i] = ((pwr_tUInt32 *)vbuf)[i];
      break;
    case pwr_eType_UInt8:
      gcd->y_data[0][i] = ((pwr_tUInt32 *)vbuf)[i];
      break;
    case pwr_eType_Float32:
      gcd->y_data[0][i] = ((pwr_tFloat32 *)vbuf)[i];
      break;
    case pwr_eType_Float64:
      gcd->y_data[0][i] = ((pwr_tFloat64 *)vbuf)[i];
      break;
    case pwr_eType_Boolean:
      gcd->y_data[0][i] = ((pwr_tBoolean *)vbuf)[i];
      break;
    default: 
      *sts = SEV__CURVETYPE;
      return 0;
    }
  }
  free( tbuf);
  free( vbuf);

  gcd->y_axis_type[0] = curve_eAxis_y;

  gcd->cols = 1;
  gcd->rows[0] = rows;

  gcd->get_borders();
  gcd->get_default_axis();

  if ( to.tv_sec != 0 && from.tv_sec != 0) {
    time_Adiff( &trange, &to, &from);
    if ( time_DToFloat( 0, &trange) < 600)
      strcpy( gcd->x_format[0], "%10t");
    else
      strcpy( gcd->x_format[0], "%11t");
  }
  else
    strcpy( gcd->x_format[0], "%11t");
    

  gcd->select_color( 0);

  if ( curve) {
    curve->set_curvedata( gcd);  // This will free the old gcd 
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int XttSevHist::get_objectdata( pwr_tStatus *sts, pwr_tTime from, pwr_tTime to)
{
  pwr_tTime *tbuf;
  void *vbuf;
  sevcli_sHistAttr *histattrbuf;
  int numAttributes;

  pwr_tDeltaTime trange;

  if ( curve)
    curve->set_clock_cursor();
  sevcli_get_objectitemdata( sts, scctx, oidv[0], anamev[0], from, to, 1000, &tbuf, &vbuf,
  		       &rows, &histattrbuf, &numAttributes);
  if ( curve)
    curve->reset_cursor();
  if ( EVEN(*sts))
    return 0;

  if( rows == 0 ) {
    *sts = SEV__NODATATIME;
    return 0;
  }

  // Create data for time axis
  gcd = new GeCurveData( curve_eDataType_DsTrend);

  gcd->x_data[0] = (double *) calloc( 1, 8 * rows);
  for ( int i = 0; i < rows; i++)
    gcd->x_data[0][i] = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

  strcpy( gcd->x_name, "Time");
  gcd->x_axis_type[0] = curve_eAxis_x;
  strcpy( gcd->x_format[0], "%10t");

  //todo linesize bör vi kunna få från sevcli_get_objectitemdata
  int linesize = 0;
  for( int i = 0; i < numAttributes; i++) {
    linesize += histattrbuf[i].size;
  }
  void *dataptr = vbuf;
  int tmp = 0;
  gcd->cols = 0;
  for( int i = 0; i < numAttributes; i++) {

    switch ( histattrbuf[i].type ) {
    case pwr_eType_Int64:
    case pwr_eType_Int32:
    case pwr_eType_Int16:
    case pwr_eType_Int8:
    case pwr_eType_UInt64:
    case pwr_eType_UInt32:
    case pwr_eType_UInt16:
    case pwr_eType_UInt8:
    case pwr_eType_Float32:
    case pwr_eType_Float64:
    case pwr_eType_Boolean:
      break;
    default: 
      tmp += histattrbuf[i].size;
      continue;
    }

    if( gcd->cols >= CURVE_MAX_COLS) {
      printf("To many columns for curve class max:%d\n", CURVE_MAX_COLS);
      break;
    }

    gcd->cols++;

    strcpy( gcd->y_name[gcd->cols-1], onamev[0]);
    if ( strcmp( onamev[0], "") != 0)
      strcat( gcd->y_name[gcd->cols-1], ".");
    strcat( gcd->y_name[gcd->cols-1], histattrbuf[i].aname);
    gcd->y_data[gcd->cols-1] = (double *) calloc( 1, 8 * rows);
    gcd->y_axis_type[gcd->cols-1] = curve_eAxis_y;

    dataptr = (char *)vbuf + tmp;
    //tmp += histattrbuf[i].size;
    for ( int j = 0; j < rows; j++) {
      //dataptr = (char *)dataptr + linesize*j;
      dataptr = ((char *)vbuf)+ j * linesize + tmp;
      switch ( histattrbuf[i].type ) {
      case pwr_eType_Int64:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tInt64 *)dataptr;
        break;
      case pwr_eType_Int32:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tInt32 *)dataptr;
        break;
      case pwr_eType_Int16:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tInt16 *)dataptr;
        break;
      case pwr_eType_Int8:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tInt8 *)dataptr;
        break;
      case pwr_eType_UInt64:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tUInt64 *)dataptr;
        break;
      case pwr_eType_UInt32:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tUInt32 *)dataptr;
        break;
      case pwr_eType_UInt16:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tUInt16 *)dataptr;
        break;
      case pwr_eType_UInt8:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tUInt8 *)dataptr;
        break;
      case pwr_eType_Float32:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tFloat32 *)dataptr;
        break;
      case pwr_eType_Float64:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tFloat64 *)dataptr;
        break;
      case pwr_eType_Boolean:
        gcd->y_data[gcd->cols-1][j] = *(pwr_tBoolean *)dataptr;
        break;
      default: 
        *sts = SEV__CURVETYPE;
        return 0;
      }
    }
    tmp += histattrbuf[i].size;
  }
  free( tbuf);
  free( vbuf);
  free( histattrbuf);


  
  for ( int i = 0; i < gcd->cols; i++)
    gcd->rows[i] = rows;

  gcd->get_borders();
  gcd->get_default_axis();

  if ( to.tv_sec != 0 && from.tv_sec != 0) {
    time_Adiff( &trange, &to, &from);
    if ( time_DToFloat( 0, &trange) < 600)
      strcpy( gcd->x_format[0], "%10t");
    else
      strcpy( gcd->x_format[0], "%11t");
  }
  else
    strcpy( gcd->x_format[0], "%11t");
    

  gcd->select_color( 0);

  if ( curve) {
    curve->set_curvedata( gcd);  // This will free the old gcd 
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int XttSevHist::get_multidata( pwr_tStatus *sts, pwr_tTime from, pwr_tTime to)
{
  pwr_tTime *tbuf;
  void *vbuf;
  pwr_tDeltaTime trange;
  int curve_cnt = 0;

  // Create data for time axis
  gcd = new GeCurveData( curve_eDataType_MultiTrend);
  strcpy( gcd->x_name, "Time");

  for ( int k = 0; k < oid_cnt; k++) {

    if ( curve_cnt >= CURVE_MAX_COLS) {
      printf("To many columns for curve class max: %d\n", CURVE_MAX_COLS);
      break;
    }
      
    if ( !sevhistobjectv[k]) {
      if ( curve)
	curve->set_clock_cursor();
      sevcli_get_itemdata( sts, scctx, oidv[k], anamev[k], from, to, 1000, &tbuf, &vbuf,
			 &rows, &vtype, &vsize);
      if ( curve)
	curve->reset_cursor();
      if ( EVEN(*sts))
	return 0;

      if ( rows == 0)
	continue;


      gcd->x_data[curve_cnt] = (double *) calloc( 1, 8 * rows);
      for ( int i = 0; i < rows; i++)
	gcd->x_data[curve_cnt][i] = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

      gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
      strcpy( gcd->x_format[curve_cnt], "%10t");

      strcpy( gcd->y_name[curve_cnt], onamev[k]);
      if ( strcmp( onamev[k], "") != 0)
	strcat( gcd->y_name[curve_cnt], ".");
      strcat( gcd->y_name[curve_cnt], anamev[k]);
      gcd->y_data[curve_cnt] = (double *) calloc( 1, 8 * rows);

      for ( int i = 0; i < rows; i++) {
	switch ( vtype) {
	case pwr_eType_Int64:
	  gcd->y_data[curve_cnt][i] = ((pwr_tInt32 *)vbuf)[i];
	  break;
	case pwr_eType_Int32:
	  gcd->y_data[curve_cnt][i] = ((pwr_tInt32 *)vbuf)[i];
	  break;
	case pwr_eType_Int16:
	  gcd->y_data[curve_cnt][i] = ((pwr_tInt32 *)vbuf)[i];
	  break;
	case pwr_eType_Int8:
	  gcd->y_data[curve_cnt][i] = ((pwr_tInt32 *)vbuf)[i];
	  break;
	case pwr_eType_UInt64:
	  gcd->y_data[curve_cnt][i] = ((pwr_tUInt32 *)vbuf)[i];
	  break;
	case pwr_eType_UInt32:
	  gcd->y_data[curve_cnt][i] = ((pwr_tUInt32 *)vbuf)[i];
	  break;
	case pwr_eType_UInt16:
	  gcd->y_data[curve_cnt][i] = ((pwr_tUInt32 *)vbuf)[i];
	  break;
	case pwr_eType_UInt8:
	  gcd->y_data[curve_cnt][i] = ((pwr_tUInt32 *)vbuf)[i];
	  break;
	case pwr_eType_Float32:
	  gcd->y_data[curve_cnt][i] = ((pwr_tFloat32 *)vbuf)[i];
	  break;
	case pwr_eType_Float64:
	  gcd->y_data[curve_cnt][i] = ((pwr_tFloat64 *)vbuf)[i];
	  break;
	case pwr_eType_Boolean:
	  gcd->y_data[curve_cnt][i] = ((pwr_tBoolean *)vbuf)[i];
	  break;
	default: 
	  *sts = SEV__CURVETYPE;
	  return 0;
	}
      }
      free( tbuf);
      free( vbuf);

      gcd->y_axis_type[curve_cnt] = curve_eAxis_y;

      gcd->rows[curve_cnt] = rows;
      curve_cnt++;
    }
    else {
      // SevHistObject object
      sevcli_sHistAttr *histattrbuf;
      int numAttributes;

      sevcli_get_objectitemdata( sts, scctx, oidv[k], anamev[k], from, to, 1000, &tbuf, &vbuf,
			       &rows, &histattrbuf, &numAttributes);
      if ( EVEN(*sts))
	return 0;
      
      if ( rows == 0)
	continue;

      gcd->x_data[curve_cnt] = (double *) calloc( 1, 8 * rows);
      for ( int i = 0; i < rows; i++)
	gcd->x_data[curve_cnt][i] = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;
      
      strcpy( gcd->x_name, "Time");
      gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
      strcpy( gcd->x_format[0], "%10t");
      
      //todo linesize bör vi kunna få från sevcli_get_objectitemdata
      int linesize = 0;
      for ( int i = 0; i < numAttributes; i++) {
	linesize += histattrbuf[i].size;
      }
      void *dataptr = vbuf;
      int tmp = 0;
      for ( int i = 0; i < numAttributes; i++) {
	gcd->x_data[curve_cnt] = (double *) calloc( 1, 8 * rows);
	for ( int j = 0; j < rows; j++)
	  gcd->x_data[curve_cnt][j] = (double)tbuf[j].tv_sec + (double)1e-9 * tbuf[j].tv_nsec;
	
	strcpy( gcd->x_name, "Time");
	gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
	strcpy( gcd->x_format[curve_cnt], "%10t");
	
	switch ( histattrbuf[i].type ) {
	case pwr_eType_Int64:
	case pwr_eType_Int32:
	case pwr_eType_Int16:
	case pwr_eType_Int8:
	case pwr_eType_UInt64:
	case pwr_eType_UInt32:
	case pwr_eType_UInt16:
	case pwr_eType_UInt8:
	case pwr_eType_Float32:
	case pwr_eType_Float64:
	case pwr_eType_Boolean:
	  break;
	default: 
	  tmp += histattrbuf[i].size;
	  continue;
	}
	
	if ( curve_cnt >= CURVE_MAX_COLS) {
	  printf("To many columns for curve class max:%d\n", CURVE_MAX_COLS);
	  break;
	}
	
	strcpy( gcd->y_name[curve_cnt], onamev[k]);
	if ( strcmp( onamev[k], "") != 0)
	  strcat( gcd->y_name[curve_cnt], ".");
	strcat( gcd->y_name[curve_cnt], histattrbuf[i].aname);
	gcd->y_data[curve_cnt] = (double *) calloc( 1, 8 * rows);
	gcd->y_axis_type[curve_cnt] = curve_eAxis_y;
	
	dataptr = (char *)vbuf + tmp;
	for ( int j = 0; j < rows; j++) {
	  dataptr = ((char *)vbuf)+ j * linesize + tmp;
	  switch ( histattrbuf[i].type ) {
	  case pwr_eType_Int64:
	    gcd->y_data[curve_cnt][j] = *(pwr_tInt64 *)dataptr;
	    break;
	  case pwr_eType_Int32:
	    gcd->y_data[curve_cnt][j] = *(pwr_tInt32 *)dataptr;
	    break;
	  case pwr_eType_Int16:
	    gcd->y_data[curve_cnt][j] = *(pwr_tInt16 *)dataptr;
	    break;
	  case pwr_eType_Int8:
	    gcd->y_data[curve_cnt][j] = *(pwr_tInt8 *)dataptr;
	    break;
	  case pwr_eType_UInt64:
	    gcd->y_data[curve_cnt][j] = *(pwr_tUInt64 *)dataptr;
	    break;
	  case pwr_eType_UInt32:
	    gcd->y_data[curve_cnt][j] = *(pwr_tUInt32 *)dataptr;
	    break;
	  case pwr_eType_UInt16:
	    gcd->y_data[curve_cnt][j] = *(pwr_tUInt16 *)dataptr;
	    break;
	  case pwr_eType_UInt8:
	    gcd->y_data[curve_cnt][j] = *(pwr_tUInt8 *)dataptr;
	    break;
	  case pwr_eType_Float32:
	    gcd->y_data[curve_cnt][j] = *(pwr_tFloat32 *)dataptr;
	    break;
	  case pwr_eType_Float64:
	    gcd->y_data[curve_cnt][j] = *(pwr_tFloat64 *)dataptr;
	    break;
	  case pwr_eType_Boolean:
	    gcd->y_data[curve_cnt][j] = *(pwr_tBoolean *)dataptr;
	    break;
	  default: 
	    *sts = SEV__CURVETYPE;
	    return 0;
	  }
	}
	tmp += histattrbuf[i].size;
	gcd->y_axis_type[curve_cnt] = curve_eAxis_y;

	gcd->rows[curve_cnt] = rows;
	curve_cnt++;
      }
      free( tbuf);
      free( vbuf);
      free( histattrbuf);
    }
  }

  if( curve_cnt == 0 ) {
    delete gcd;
    *sts = SEV__NODATATIME;
    return 0;
  }

  gcd->cols = curve_cnt;

  gcd->get_borders();
  gcd->get_default_axis();

  if ( to.tv_sec != 0 && from.tv_sec != 0) {
    time_Adiff( &trange, &to, &from);
    if ( time_DToFloat( 0, &trange) < 600)
      strcpy( gcd->x_format[0], "%10t");
    else
      strcpy( gcd->x_format[0], "%11t");
  }
  else
    strcpy( gcd->x_format[0], "%11t");
    

  gcd->select_color( 0);

  if ( curve) {
    curve->set_curvedata( gcd);  // This will free the old gcd 
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }
  *sts = SEV__SUCCESS;
  return 1;
}

void XttSevHist::curve_add( pwr_tOid oid, pwr_tOName aname, pwr_tOName oname,
			    bool sevhistobject)
{
  if ( oid_cnt == XTT_SEVHIST_MAX)
    return;

  if ( gcd->type != curve_eDataType_MultiTrend) {
    // Convert to multidata

    for ( int i = 1; i < gcd->cols; i++) {
      gcd->rows[i] = gcd->rows[0];
      gcd->x_data[i] = (double *) calloc( 1, 8 * gcd->rows[i]);
      memcpy( gcd->x_data[i], gcd->x_data[0], 8 * gcd->rows[i]);

      gcd->x_axis_type[i] = curve_eAxis_x;
      strcpy( gcd->x_format[i], "%10t");

    }
    gcd->type = curve_eDataType_MultiTrend;
  }
  
  oidv[oid_cnt] = oid;
  strncpy( anamev[oid_cnt], aname, sizeof(anamev[0]));
  strncpy( onamev[oid_cnt], oname, sizeof(onamev[0]));
  oid_cnt++;

  int curve_cnt = gcd->cols;
  rows = 0;

  gcd->x_data[curve_cnt] = (double *) calloc( 1, 8 * rows);
  
  gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
  strcpy( gcd->x_format[curve_cnt], "%10t");

  strcpy( gcd->y_name[curve_cnt], oname);
  if ( strcmp( oname, "") != 0)
    strcat( gcd->y_name[curve_cnt], ".");
  strcat( gcd->y_name[curve_cnt], aname);
  gcd->y_data[curve_cnt] = (double *) calloc( 1, 8 * rows);
  
  gcd->cols++;

  gcd->select_color( 0);
  curve->config_names();
}


void XttSevHist::pop()
{
  curve->pop();
}

void XttSevHist::setup()
{
  curve->setup( curve_mEnable_Timebox | curve_mEnable_Export | curve_mEnable_ExportTime);
}

void XttSevHist::sevhist_close_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;

  if ( sevhist->close_cb)
    (sevhist->close_cb)( sevhist->xnav, sevhist);
  else
    delete sevhist;
}

void XttSevHist::sevhist_decrease_period_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  time_ePeriod period;
  pwr_tStatus sts;
  int changed;

  sts = sevhist->curve->get_period( &period);

  changed = time_PeriodZoomIn( &period);
  if ( changed)
    sevhist->curve->set_period( period, 0);

}

void XttSevHist::sevhist_increase_period_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  time_ePeriod period;
  pwr_tStatus sts;
  int changed;

  sts = sevhist->curve->get_period( &period);

  changed = time_PeriodZoomOut( &period);
  if ( changed)
    sevhist->curve->set_period( period, 0);

}

void XttSevHist::sevhist_reload_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  pwr_tTime t_low, t_high;
  pwr_tStatus sts;

  sts = sevhist->curve->get_times( &t_low, &t_high);
  if ( EVEN(sts)) {
    sevhist->wow->DisplayError( "Time", "Time syntax error");
    return;
  }

  if ( time_Acomp( &t_high, &t_low) != 1) {
    sevhist->wow->DisplayError( "Time", "Start time later than end time");
    return;
  }

  if ( t_low.tv_sec < 0)
    t_low.tv_sec = 0;

  if ( sevhist->oid_cnt == 1)
    sevhist->get_data( &sts, t_low, t_high);
  else
    sevhist->get_multidata( &sts, t_low, t_high);

  sevhist->time_low_old = 0;
  sevhist->time_high_old = 0;
  sevhist->curve->set_center_from_window( 1);
}

void XttSevHist::sevhist_prev_period_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  pwr_tTime from, to, prev_from, prev_to;
  pwr_tStatus sts;
  time_ePeriod period;

  sts = sevhist->curve->get_times( &prev_from, &prev_to);
  if ( EVEN(sts)) {
    sevhist->wow->DisplayError( "Time", "Time syntax error");
    return;
  }

  sts = sevhist->curve->get_period( &period);

  if ( time_Acomp( &prev_to, &prev_from) != 1) {
    sevhist->wow->DisplayError( "Time", "Start time later than end time");
    return;
  }

  time_PreviousPeriod( period, &prev_from, &prev_to, &from, &to);

  sevhist->curve->set_times( &from, &to);

  int change_period = 1;
  switch( period) {
  case time_ePeriod_LastMinute:
    period = time_ePeriod_OneMinute;
    break;
  case time_ePeriod_Last10Minutes:
    period = time_ePeriod_10Minutes;
    break;
  case time_ePeriod_LastHour:
    period = time_ePeriod_OneHour;
    break;
  case time_ePeriod_Today:
    period = time_ePeriod_Yesterday;
    break;
  case time_ePeriod_Yesterday:
    period = time_ePeriod_OneDay;
    break;
  case time_ePeriod_ThisWeek:
    period = time_ePeriod_LastWeek;
    break;
  case time_ePeriod_LastWeek:
    period = time_ePeriod_OneWeek;
    break;
  case time_ePeriod_ThisMonth:
    period = time_ePeriod_LastMonth;
    break;
  case time_ePeriod_LastMonth:
    period = time_ePeriod_OneMonth;
    break;
  case time_ePeriod_ThisYear:
    period = time_ePeriod_OneYear;
    break;
  default:
    change_period = 0;
  }
  if ( change_period)
    sevhist->curve->set_period( period, 1);
    
}

void XttSevHist::sevhist_next_period_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  pwr_tTime from, to, prev_from, prev_to;
  pwr_tStatus sts;
  time_ePeriod period;

  sts = sevhist->curve->get_times( &prev_from, &prev_to);
  if ( EVEN(sts)) {
    sevhist->wow->DisplayError( "Time", "Time syntax error");
    return;
  }

  sts = sevhist->curve->get_period( &period);

  if ( time_Acomp( &prev_to, &prev_from) != 1) {
    sevhist->wow->DisplayError( "Time", "Start time later than end time");
    return;
  }
 
  time_NextPeriod( period, &prev_from, &prev_to, &from, &to);

  sevhist->curve->set_times( &from, &to);

}

void XttSevHist::sevhist_add_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  pwr_tOid oid;
  pwr_tOName aname, oname;
  int sts;

  if ( !sevhist->get_select_cb)
    return;

  sts = sevhist->get_select_cb( sevhist->xnav, &oid, aname, oname);
  if ( EVEN(sts)) return;

  sevhist->curve_add( oid, aname, oname, false);
}

void XttSevHist::sevhist_remove_cb( void *ctx)
{
  // Do do
}

int XttSevHist::sevhist_export_cb( void *ctx, pwr_tTime *from, pwr_tTime *to, int rows, int idx, 
				   char *filename)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;
  pwr_tFileName fname;
  pwr_tTime *tbuf;
  void *vbuf;
  pwr_eType	vtype;
  unsigned int  vsize;
  pwr_tStatus sts;
  int rrows;
  char timestr[40];
  FILE *fp;
  pwr_tOName oname;

  // Replace $date with date
  strncpy( fname, filename, sizeof(fname));
  char *s1 = strstr( fname, "$date");
  if ( s1) {
    char timstr[40];
    pwr_tFileName str;

    sts = time_AtoAscii( 0, time_eFormat_FileDateAndTime,
			 timstr, sizeof(timstr));

    strncpy( str, s1 + strlen("$date"), sizeof(str));
    *s1 = 0;
    strncat( fname, timstr, sizeof(fname));
    strncat( fname, str, sizeof(fname));
  }

  dcli_translate_filename( fname, fname);

  if ( idx == -1) {
    // Export all attributes
    fp = fopen( fname, "w");
    if ( !fp)
      return SEV__EXPORTFILE;

    for ( int j = 0; j < sevhist->oid_cnt; j++) {
      sts = gdh_ObjidToName ( sevhist->oidv[j], oname, sizeof(oname),
			      cdh_mName_volumeStrict);
      if ( EVEN(sts)) continue;

      fprintf( fp, "# Attribute %s.%s\n", oname, sevhist->anamev[j]);

      sevhist->curve->set_clock_cursor();
      sevcli_get_itemdata( &sts, sevhist->scctx, sevhist->oidv[j], sevhist->anamev[j], *from, *to, 
			   rows, &tbuf, &vbuf, &rrows, &vtype, &vsize);
      sevhist->curve->reset_cursor();
      if ( EVEN(sts))
	return sts;
    
      if( rrows == 0 )
	continue;

      fprintf( fp, "# Rows %d\n", rrows);

      for ( int i = 0; i < rrows; i++) {
	time_AtoAscii( &tbuf[i], time_eFormat_DateAndTime, timestr, sizeof(timestr));
	fprintf( fp, "%s, ", timestr);
	switch ( vtype) {
	case pwr_eType_Int32:
	case pwr_eType_Int64:
	case pwr_eType_Int16:
	case pwr_eType_Int8:
	  fprintf( fp, "%d", ((pwr_tInt32 *)vbuf)[i]);
	  break;
	case pwr_eType_UInt64:
	case pwr_eType_UInt32:
	case pwr_eType_UInt16:
	case pwr_eType_UInt8:
	  fprintf( fp, "%u", ((pwr_tUInt32 *)vbuf)[i]);
	  break;
	case pwr_eType_Float32:
	  fprintf( fp, "%g", ((pwr_tFloat32 *)vbuf)[i]);
	  break;
	case pwr_eType_Float64:
	  fprintf( fp, "%g", ((pwr_tFloat64 *)vbuf)[i]);
	  break;
	case pwr_eType_Boolean:
	  fprintf( fp, "%d", ((pwr_tBoolean *)vbuf)[i]);
	  break;
	default: 
	  sts = SEV__CURVETYPE;
	}
	fprintf( fp, "\n");
      }
      free( tbuf);
      free( vbuf);
    }
    fclose( fp);
  }
  else {
    sevhist->curve->set_clock_cursor();
    sevcli_get_itemdata( &sts, sevhist->scctx, sevhist->oidv[idx], sevhist->anamev[idx], *from, *to, 
			 rows, &tbuf, &vbuf, &rrows, &vtype, &vsize);
    sevhist->curve->reset_cursor();
    if ( EVEN(sts))
      return sts;
    
    if( rrows == 0 ) {
      return SEV__NODATATIME;
    }

    fp = fopen( fname, "w");
    if ( !fp)
      return SEV__EXPORTFILE;

    for ( int i = 0; i < rrows; i++) {
      time_AtoAscii( &tbuf[i], time_eFormat_DateAndTime, timestr, sizeof(timestr));
      fprintf( fp, "%s, ", timestr);
      switch ( vtype) {
      case pwr_eType_Int32:
      case pwr_eType_Int64:
      case pwr_eType_Int16:
      case pwr_eType_Int8:
	fprintf( fp, "%d", ((pwr_tInt32 *)vbuf)[i]);
	break;
      case pwr_eType_UInt64:
      case pwr_eType_UInt32:
      case pwr_eType_UInt16:
      case pwr_eType_UInt8:
	fprintf( fp, "%u", ((pwr_tUInt32 *)vbuf)[i]);
	break;
      case pwr_eType_Float32:
	fprintf( fp, "%g", ((pwr_tFloat32 *)vbuf)[i]);
	break;
      case pwr_eType_Float64:
	fprintf( fp, "%g", ((pwr_tFloat64 *)vbuf)[i]);
	break;
      case pwr_eType_Boolean:
	fprintf( fp, "%d", ((pwr_tBoolean *)vbuf)[i]);
	break;
      default: 
	sts = SEV__CURVETYPE;
      }
      fprintf( fp, "\n");
    }
    free( tbuf);
    free( vbuf);
    fclose( fp);

    printf( "Exported %d rows to file \"%s\" (%d)\n", rrows, fname, idx);

    if ( EVEN(sts))
      return sts;
  }
  return SEV__SUCCESS;
}

int XttSevHist::read_export( char *filename)
{
  pwr_tFileName fname;
  FILE *fp;
  char line[200];
  int idx = -1;
  int rowcnt = 0;
  int rows;
  char timstr[40];
  double y;
  char *s;
  pwr_tStatus sts;
  pwr_tTime t;

  dcli_translate_filename( fname, filename);

  fp = fopen( fname, "r");
  if ( !fp)
    return 0;

  gcd = new GeCurveData( curve_eDataType_DsTrend);

  while( 1) {
    sts = dcli_read_line( line, sizeof(line), fp);
    if ( !sts)
      break;

    if ( line[0] == '#') {
      if ( strncmp( &line[2], "Attribute", 9) == 0) {
	// New attribute
	idx++;
	strncpy( onamev[idx], &line[12], sizeof(onamev[0]));
	s = strchr( onamev[idx], '.');
	if ( s) {
	  *s = 0;
	  strncpy( anamev[idx], s+1, sizeof(anamev[0]));
	}		
	rowcnt = 0;

	gcd->y_axis_type[idx] = curve_eAxis_y;
	gcd->x_axis_type[idx] = curve_eAxis_x;
	strcpy( gcd->x_format[idx], "%11t");

	strcpy( gcd->y_name[idx], onamev[idx]);
	strcat( gcd->y_name[idx], ".");
	strcat( gcd->y_name[idx], anamev[idx]);
      }
      else if ( strncmp( &line[2], "Rows", 4) == 0) {
	if ( idx < 0)
	  continue;

	sscanf( &line[7], "%d", &rows);
	gcd->rows[idx] = rows;
	gcd->x_data[idx] = (double *) calloc( 1, 8 * rows);
	gcd->y_data[idx] = (double *) calloc( 1, 8 * rows);
      }
    }
    else {
      if ( idx < 0)
	continue;

      strncpy( timstr, line, 23);
      timstr[23] = 0;
      sscanf( &line[25], "%lf", &y);
      if ( rowcnt > gcd->rows[idx])
	continue;

      time_AsciiToA( timstr, &t);
      
      gcd->x_data[idx][rowcnt] = (double)t.tv_sec + (double)1e-9 * t.tv_nsec;
      gcd->y_data[idx][rowcnt] = y;
      rowcnt++;
    }
  }
  if ( idx > 0)
    gcd->rows[idx-1] = rowcnt;
  gcd->cols = idx + 1;

  fclose(fp);

  gcd->get_borders();
  gcd->get_default_axis();
  gcd->select_color( 0);
  strcpy( gcd->x_format[0], "%11t");

  if ( curve) {
    curve->set_curvedata( gcd);  // This will free the old gcd 
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }

  return 1;
}

void XttSevHist::sevhist_help_cb( void *ctx)
{
  XttSevHist *sevhist = (XttSevHist *) ctx;

  if ( sevhist->help_cb)
    (sevhist->help_cb)( sevhist->xnav, "opg_history");
}

void XttSevHist::sevhist_scan( void *data)
{
  XttSevHist *sevhist = (XttSevHist *) data;

  if ( sevhist->timerid)
    sevhist->timerid->add( 1000, sevhist_scan, sevhist);
}







